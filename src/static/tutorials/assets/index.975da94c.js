var wo = Object.defineProperty;
var ko = (_, et, tt) =>
	et in _ ? wo(_, et, { enumerable: !0, configurable: !0, writable: !0, value: tt }) : (_[et] = tt);
var fn = (_, et, tt) => (ko(_, typeof et != "symbol" ? et + "" : et, tt), tt);
function _mergeNamespaces(_, et) {
	for (var tt = 0; tt < et.length; tt++) {
		const nt = et[tt];
		if (typeof nt != "string" && !Array.isArray(nt)) {
			for (const rt in nt)
				if (rt !== "default" && !(rt in _)) {
					const it = Object.getOwnPropertyDescriptor(nt, rt);
					it && Object.defineProperty(_, rt, it.get ? it : { enumerable: !0, get: () => nt[rt] });
				}
		}
	}
	return Object.freeze(Object.defineProperty(_, Symbol.toStringTag, { value: "Module" }));
}
(function () {
	const et = document.createElement("link").relList;
	if (et && et.supports && et.supports("modulepreload")) return;
	for (const rt of document.querySelectorAll('link[rel="modulepreload"]')) nt(rt);
	new MutationObserver((rt) => {
		for (const it of rt)
			if (it.type === "childList")
				for (const ot of it.addedNodes) ot.tagName === "LINK" && ot.rel === "modulepreload" && nt(ot);
	}).observe(document, { childList: !0, subtree: !0 });
	function tt(rt) {
		const it = {};
		return (
			rt.integrity && (it.integrity = rt.integrity),
			rt.referrerpolicy && (it.referrerPolicy = rt.referrerpolicy),
			rt.crossorigin === "use-credentials"
				? (it.credentials = "include")
				: rt.crossorigin === "anonymous"
				? (it.credentials = "omit")
				: (it.credentials = "same-origin"),
			it
		);
	}
	function nt(rt) {
		if (rt.ep) return;
		rt.ep = !0;
		const it = tt(rt);
		fetch(rt.href, it);
	}
})();
var commonjsGlobal =
	typeof globalThis < "u"
		? globalThis
		: typeof window < "u"
		? window
		: typeof global < "u"
		? global
		: typeof self < "u"
		? self
		: {};
function getDefaultExportFromCjs(_) {
	return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _;
}
var react = { exports: {} },
	react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var l$4 = Symbol.for("react.element"),
	n$3 = Symbol.for("react.portal"),
	p$6 = Symbol.for("react.fragment"),
	q$4 = Symbol.for("react.strict_mode"),
	r$4 = Symbol.for("react.profiler"),
	t$3 = Symbol.for("react.provider"),
	u$5 = Symbol.for("react.context"),
	v$3 = Symbol.for("react.forward_ref"),
	w$2 = Symbol.for("react.suspense"),
	x$2 = Symbol.for("react.memo"),
	y$3 = Symbol.for("react.lazy"),
	z$2 = Symbol.iterator;
function A$2(_) {
	return _ === null || typeof _ != "object"
		? null
		: ((_ = (z$2 && _[z$2]) || _["@@iterator"]), typeof _ == "function" ? _ : null);
}
var B$2 = {
		isMounted: function () {
			return !1;
		},
		enqueueForceUpdate: function () {},
		enqueueReplaceState: function () {},
		enqueueSetState: function () {},
	},
	C$3 = Object.assign,
	D$1 = {};
function E$1(_, et, tt) {
	(this.props = _), (this.context = et), (this.refs = D$1), (this.updater = tt || B$2);
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function (_, et) {
	if (typeof _ != "object" && typeof _ != "function" && _ != null)
		throw Error(
			"setState(...): takes an object of state variables to update or a function which returns an object of state variables."
		);
	this.updater.enqueueSetState(this, _, et, "setState");
};
E$1.prototype.forceUpdate = function (_) {
	this.updater.enqueueForceUpdate(this, _, "forceUpdate");
};
function F$1() {}
F$1.prototype = E$1.prototype;
function G$1(_, et, tt) {
	(this.props = _), (this.context = et), (this.refs = D$1), (this.updater = tt || B$2);
}
var H$2 = (G$1.prototype = new F$1());
H$2.constructor = G$1;
C$3(H$2, E$1.prototype);
H$2.isPureReactComponent = !0;
var I$2 = Array.isArray,
	J = Object.prototype.hasOwnProperty,
	K$1 = { current: null },
	L$1 = { key: !0, ref: !0, __self: !0, __source: !0 };
function M$1(_, et, tt) {
	var nt,
		rt = {},
		it = null,
		ot = null;
	if (et != null)
		for (nt in (et.ref !== void 0 && (ot = et.ref), et.key !== void 0 && (it = "" + et.key), et))
			J.call(et, nt) && !L$1.hasOwnProperty(nt) && (rt[nt] = et[nt]);
	var at = arguments.length - 2;
	if (at === 1) rt.children = tt;
	else if (1 < at) {
		for (var st = Array(at), lt = 0; lt < at; lt++) st[lt] = arguments[lt + 2];
		rt.children = st;
	}
	if (_ && _.defaultProps) for (nt in ((at = _.defaultProps), at)) rt[nt] === void 0 && (rt[nt] = at[nt]);
	return { $$typeof: l$4, type: _, key: it, ref: ot, props: rt, _owner: K$1.current };
}
function N$1(_, et) {
	return { $$typeof: l$4, type: _.type, key: et, ref: _.ref, props: _.props, _owner: _._owner };
}
function O$1(_) {
	return typeof _ == "object" && _ !== null && _.$$typeof === l$4;
}
function escape$2(_) {
	var et = { "=": "=0", ":": "=2" };
	return (
		"$" +
		_.replace(/[=:]/g, function (tt) {
			return et[tt];
		})
	);
}
var P$1 = /\/+/g;
function Q$2(_, et) {
	return typeof _ == "object" && _ !== null && _.key != null ? escape$2("" + _.key) : et.toString(36);
}
function R$1(_, et, tt, nt, rt) {
	var it = typeof _;
	(it === "undefined" || it === "boolean") && (_ = null);
	var ot = !1;
	if (_ === null) ot = !0;
	else
		switch (it) {
			case "string":
			case "number":
				ot = !0;
				break;
			case "object":
				switch (_.$$typeof) {
					case l$4:
					case n$3:
						ot = !0;
				}
		}
	if (ot)
		return (
			(ot = _),
			(rt = rt(ot)),
			(_ = nt === "" ? "." + Q$2(ot, 0) : nt),
			I$2(rt)
				? ((tt = ""),
				  _ != null && (tt = _.replace(P$1, "$&/") + "/"),
				  R$1(rt, et, tt, "", function (lt) {
						return lt;
				  }))
				: rt != null &&
				  (O$1(rt) &&
						(rt = N$1(
							rt,
							tt + (!rt.key || (ot && ot.key === rt.key) ? "" : ("" + rt.key).replace(P$1, "$&/") + "/") + _
						)),
				  et.push(rt)),
			1
		);
	if (((ot = 0), (nt = nt === "" ? "." : nt + ":"), I$2(_)))
		for (var at = 0; at < _.length; at++) {
			it = _[at];
			var st = nt + Q$2(it, at);
			ot += R$1(it, et, tt, st, rt);
		}
	else if (((st = A$2(_)), typeof st == "function"))
		for (_ = st.call(_), at = 0; !(it = _.next()).done; )
			(it = it.value), (st = nt + Q$2(it, at++)), (ot += R$1(it, et, tt, st, rt));
	else if (it === "object")
		throw (
			((et = String(_)),
			Error(
				"Objects are not valid as a React child (found: " +
					(et === "[object Object]" ? "object with keys {" + Object.keys(_).join(", ") + "}" : et) +
					"). If you meant to render a collection of children, use an array instead."
			))
		);
	return ot;
}
function S$2(_, et, tt) {
	if (_ == null) return _;
	var nt = [],
		rt = 0;
	return (
		R$1(_, nt, "", "", function (it) {
			return et.call(tt, it, rt++);
		}),
		nt
	);
}
function T$3(_) {
	if (_._status === -1) {
		var et = _._result;
		(et = et()),
			et.then(
				function (tt) {
					(_._status === 0 || _._status === -1) && ((_._status = 1), (_._result = tt));
				},
				function (tt) {
					(_._status === 0 || _._status === -1) && ((_._status = 2), (_._result = tt));
				}
			),
			_._status === -1 && ((_._status = 0), (_._result = et));
	}
	if (_._status === 1) return _._result.default;
	throw _._result;
}
var U$2 = { current: null },
	V$2 = { transition: null },
	W$1 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$1 };
react_production_min.Children = {
	map: S$2,
	forEach: function (_, et, tt) {
		S$2(
			_,
			function () {
				et.apply(this, arguments);
			},
			tt
		);
	},
	count: function (_) {
		var et = 0;
		return (
			S$2(_, function () {
				et++;
			}),
			et
		);
	},
	toArray: function (_) {
		return (
			S$2(_, function (et) {
				return et;
			}) || []
		);
	},
	only: function (_) {
		if (!O$1(_)) throw Error("React.Children.only expected to receive a single React element child.");
		return _;
	},
};
react_production_min.Component = E$1;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$4;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function (_, et, tt) {
	if (_ == null)
		throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + _ + ".");
	var nt = C$3({}, _.props),
		rt = _.key,
		it = _.ref,
		ot = _._owner;
	if (et != null) {
		if (
			(et.ref !== void 0 && ((it = et.ref), (ot = K$1.current)),
			et.key !== void 0 && (rt = "" + et.key),
			_.type && _.type.defaultProps)
		)
			var at = _.type.defaultProps;
		for (st in et)
			J.call(et, st) && !L$1.hasOwnProperty(st) && (nt[st] = et[st] === void 0 && at !== void 0 ? at[st] : et[st]);
	}
	var st = arguments.length - 2;
	if (st === 1) nt.children = tt;
	else if (1 < st) {
		at = Array(st);
		for (var lt = 0; lt < st; lt++) at[lt] = arguments[lt + 2];
		nt.children = at;
	}
	return { $$typeof: l$4, type: _.type, key: rt, ref: it, props: nt, _owner: ot };
};
react_production_min.createContext = function (_) {
	return (
		(_ = {
			$$typeof: u$5,
			_currentValue: _,
			_currentValue2: _,
			_threadCount: 0,
			Provider: null,
			Consumer: null,
			_defaultValue: null,
			_globalName: null,
		}),
		(_.Provider = { $$typeof: t$3, _context: _ }),
		(_.Consumer = _)
	);
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function (_) {
	var et = M$1.bind(null, _);
	return (et.type = _), et;
};
react_production_min.createRef = function () {
	return { current: null };
};
react_production_min.forwardRef = function (_) {
	return { $$typeof: v$3, render: _ };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function (_) {
	return { $$typeof: y$3, _payload: { _status: -1, _result: _ }, _init: T$3 };
};
react_production_min.memo = function (_, et) {
	return { $$typeof: x$2, type: _, compare: et === void 0 ? null : et };
};
react_production_min.startTransition = function (_) {
	var et = V$2.transition;
	V$2.transition = {};
	try {
		_();
	} finally {
		V$2.transition = et;
	}
};
react_production_min.unstable_act = function () {
	throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function (_, et) {
	return U$2.current.useCallback(_, et);
};
react_production_min.useContext = function (_) {
	return U$2.current.useContext(_);
};
react_production_min.useDebugValue = function () {};
react_production_min.useDeferredValue = function (_) {
	return U$2.current.useDeferredValue(_);
};
react_production_min.useEffect = function (_, et) {
	return U$2.current.useEffect(_, et);
};
react_production_min.useId = function () {
	return U$2.current.useId();
};
react_production_min.useImperativeHandle = function (_, et, tt) {
	return U$2.current.useImperativeHandle(_, et, tt);
};
react_production_min.useInsertionEffect = function (_, et) {
	return U$2.current.useInsertionEffect(_, et);
};
react_production_min.useLayoutEffect = function (_, et) {
	return U$2.current.useLayoutEffect(_, et);
};
react_production_min.useMemo = function (_, et) {
	return U$2.current.useMemo(_, et);
};
react_production_min.useReducer = function (_, et, tt) {
	return U$2.current.useReducer(_, et, tt);
};
react_production_min.useRef = function (_) {
	return U$2.current.useRef(_);
};
react_production_min.useState = function (_) {
	return U$2.current.useState(_);
};
react_production_min.useSyncExternalStore = function (_, et, tt) {
	return U$2.current.useSyncExternalStore(_, et, tt);
};
react_production_min.useTransition = function () {
	return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
(function (_) {
	_.exports = react_production_min;
})(react);
const React$1 = getDefaultExportFromCjs(react.exports),
	React$2 = _mergeNamespaces({ __proto__: null, default: React$1 }, [react.exports]);
var useSafeLayoutEffect$2 = Boolean(globalThis == null ? void 0 : globalThis.document)
		? react.exports.useLayoutEffect
		: react.exports.useEffect,
	jsxRuntime = { exports: {} },
	reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var f$2 = react.exports,
	k$3 = Symbol.for("react.element"),
	l$3 = Symbol.for("react.fragment"),
	m$4 = Object.prototype.hasOwnProperty,
	n$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
	p$5 = { key: !0, ref: !0, __self: !0, __source: !0 };
function q$3(_, et, tt) {
	var nt,
		rt = {},
		it = null,
		ot = null;
	tt !== void 0 && (it = "" + tt), et.key !== void 0 && (it = "" + et.key), et.ref !== void 0 && (ot = et.ref);
	for (nt in et) m$4.call(et, nt) && !p$5.hasOwnProperty(nt) && (rt[nt] = et[nt]);
	if (_ && _.defaultProps) for (nt in ((et = _.defaultProps), et)) rt[nt] === void 0 && (rt[nt] = et[nt]);
	return { $$typeof: k$3, type: _, key: it, ref: ot, props: rt, _owner: n$2.current };
}
reactJsxRuntime_production_min.Fragment = l$3;
reactJsxRuntime_production_min.jsx = q$3;
reactJsxRuntime_production_min.jsxs = q$3;
(function (_) {
	_.exports = reactJsxRuntime_production_min;
})(jsxRuntime);
const Fragment = jsxRuntime.exports.Fragment,
	jsx = jsxRuntime.exports.jsx,
	jsxs = jsxRuntime.exports.jsxs;
var ColorModeContext = react.exports.createContext({});
ColorModeContext.displayName = "ColorModeContext";
function useColorMode() {
	const _ = react.exports.useContext(ColorModeContext);
	if (_ === void 0) throw new Error("useColorMode must be used within a ColorModeProvider");
	return _;
}
function useColorModeValue(_, et) {
	const { colorMode: tt } = useColorMode();
	return tt === "dark" ? et : _;
}
var classNames = { light: "chakra-ui-light", dark: "chakra-ui-dark" };
function getColorModeUtils(_ = {}) {
	const { preventTransition: et = !0 } = _,
		tt = {
			setDataset: (nt) => {
				const rt = et ? tt.preventTransition() : void 0;
				(document.documentElement.dataset.theme = nt),
					(document.documentElement.style.colorScheme = nt),
					rt == null || rt();
			},
			setClassName(nt) {
				document.body.classList.add(nt ? classNames.dark : classNames.light),
					document.body.classList.remove(nt ? classNames.light : classNames.dark);
			},
			query() {
				return window.matchMedia("(prefers-color-scheme: dark)");
			},
			getSystemTheme(nt) {
				var it;
				return ((it = tt.query().matches) != null ? it : nt === "dark") ? "dark" : "light";
			},
			addListener(nt) {
				const rt = tt.query(),
					it = (ot) => {
						nt(ot.matches ? "dark" : "light");
					};
				return (
					typeof rt.addListener == "function" ? rt.addListener(it) : rt.addEventListener("change", it),
					() => {
						typeof rt.removeListener == "function" ? rt.removeListener(it) : rt.removeEventListener("change", it);
					}
				);
			},
			preventTransition() {
				const nt = document.createElement("style");
				return (
					nt.appendChild(
						document.createTextNode(
							"*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}"
						)
					),
					document.head.appendChild(nt),
					() => {
						window.getComputedStyle(document.body),
							requestAnimationFrame(() => {
								requestAnimationFrame(() => {
									document.head.removeChild(nt);
								});
							});
					}
				);
			},
		};
	return tt;
}
var STORAGE_KEY = "chakra-ui-color-mode";
function createLocalStorageManager(_) {
	return {
		ssr: !1,
		type: "localStorage",
		get(et) {
			if (!(globalThis != null && globalThis.document)) return et;
			let tt;
			try {
				tt = localStorage.getItem(_) || et;
			} catch {}
			return tt || et;
		},
		set(et) {
			try {
				localStorage.setItem(_, et);
			} catch {}
		},
	};
}
var localStorageManager = createLocalStorageManager(STORAGE_KEY),
	noop$4 = () => {};
function getTheme$1(_, et) {
	return _.type === "cookie" && _.ssr ? _.get(et) : et;
}
function ColorModeProvider(_) {
	const {
			value: et,
			children: tt,
			options: { useSystemColorMode: nt, initialColorMode: rt, disableTransitionOnChange: it } = {},
			colorModeManager: ot = localStorageManager,
		} = _,
		at = rt === "dark" ? "dark" : "light",
		[st, lt] = react.exports.useState(() => getTheme$1(ot, at)),
		[ut, dt] = react.exports.useState(() => getTheme$1(ot)),
		{
			getSystemTheme: ct,
			setClassName: ft,
			setDataset: mt,
			addListener: pt,
		} = react.exports.useMemo(() => getColorModeUtils({ preventTransition: it }), [it]),
		vt = rt === "system" && !st ? ut : st,
		ht = react.exports.useCallback(
			(xt) => {
				const St = xt === "system" ? ct() : xt;
				lt(St), ft(St === "dark"), mt(St), ot.set(St);
			},
			[ot, ct, ft, mt]
		);
	useSafeLayoutEffect$2(() => {
		rt === "system" && dt(ct());
	}, []),
		react.exports.useEffect(() => {
			const xt = ot.get();
			if (xt) {
				ht(xt);
				return;
			}
			if (rt === "system") {
				ht("system");
				return;
			}
			ht(at);
		}, [ot, at, rt, ht]);
	const gt = react.exports.useCallback(() => {
		ht(vt === "dark" ? "light" : "dark");
	}, [vt, ht]);
	react.exports.useEffect(() => {
		if (!!nt) return pt(ht);
	}, [nt, pt, ht]);
	const yt = react.exports.useMemo(
		() => ({ colorMode: et != null ? et : vt, toggleColorMode: et ? noop$4 : gt, setColorMode: et ? noop$4 : ht }),
		[vt, gt, ht, et]
	);
	return jsx(ColorModeContext.Provider, { value: yt, children: tt });
}
ColorModeProvider.displayName = "ColorModeProvider";
function DarkMode(_) {
	const et = react.exports.useMemo(() => ({ colorMode: "dark", toggleColorMode: noop$4, setColorMode: noop$4 }), []);
	return jsx(ColorModeContext.Provider, { value: et, ..._ });
}
DarkMode.displayName = "DarkMode";
var lodash_mergewith = { exports: {} };
(function (_, et) {
	var tt = 200,
		nt = "__lodash_hash_undefined__",
		rt = 800,
		it = 16,
		ot = 9007199254740991,
		at = "[object Arguments]",
		st = "[object Array]",
		lt = "[object AsyncFunction]",
		ut = "[object Boolean]",
		dt = "[object Date]",
		ct = "[object Error]",
		ft = "[object Function]",
		mt = "[object GeneratorFunction]",
		pt = "[object Map]",
		vt = "[object Number]",
		ht = "[object Null]",
		gt = "[object Object]",
		yt = "[object Proxy]",
		xt = "[object RegExp]",
		St = "[object Set]",
		wt = "[object String]",
		Ct = "[object Undefined]",
		Et = "[object WeakMap]",
		_t = "[object ArrayBuffer]",
		$t = "[object DataView]",
		At = "[object Float32Array]",
		Lt = "[object Float64Array]",
		Nt = "[object Int8Array]",
		Ft = "[object Int16Array]",
		Gt = "[object Int32Array]",
		Bt = "[object Uint8Array]",
		jt = "[object Uint8ClampedArray]",
		It = "[object Uint16Array]",
		Dt = "[object Uint32Array]",
		Rt = /[\\^$.*+?()[\]{}|]/g,
		bt = /^\[object .+?Constructor\]$/,
		kt = /^(?:0|[1-9]\d*)$/,
		zt = {};
	(zt[At] = zt[Lt] = zt[Nt] = zt[Ft] = zt[Gt] = zt[Bt] = zt[jt] = zt[It] = zt[Dt] = !0),
		(zt[at] =
			zt[st] =
			zt[_t] =
			zt[ut] =
			zt[$t] =
			zt[dt] =
			zt[ct] =
			zt[ft] =
			zt[pt] =
			zt[vt] =
			zt[gt] =
			zt[xt] =
			zt[St] =
			zt[wt] =
			zt[Et] =
				!1);
	var Vt = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal,
		Yt = typeof self == "object" && self && self.Object === Object && self,
		Ut = Vt || Yt || Function("return this")(),
		qt = et && !et.nodeType && et,
		Wt = qt && !0 && _ && !_.nodeType && _,
		Xt = Wt && Wt.exports === qt,
		Zt = Xt && Vt.process,
		pn = (function () {
			try {
				var Tt = Wt && Wt.require && Wt.require("util").types;
				return Tt || (Zt && Zt.binding && Zt.binding("util"));
			} catch {}
		})(),
		Sn = pn && pn.isTypedArray;
	function yn(Tt, Pt, Mt) {
		switch (Mt.length) {
			case 0:
				return Tt.call(Pt);
			case 1:
				return Tt.call(Pt, Mt[0]);
			case 2:
				return Tt.call(Pt, Mt[0], Mt[1]);
			case 3:
				return Tt.call(Pt, Mt[0], Mt[1], Mt[2]);
		}
		return Tt.apply(Pt, Mt);
	}
	function Qt(Tt, Pt) {
		for (var Mt = -1, Kt = Array(Tt); ++Mt < Tt; ) Kt[Mt] = Pt(Mt);
		return Kt;
	}
	function Jt(Tt) {
		return function (Pt) {
			return Tt(Pt);
		};
	}
	function tn(Tt, Pt) {
		return Tt == null ? void 0 : Tt[Pt];
	}
	function an(Tt, Pt) {
		return function (Mt) {
			return Tt(Pt(Mt));
		};
	}
	var mn = Array.prototype,
		xn = Function.prototype,
		gn = Object.prototype,
		vn = Ut["__core-js_shared__"],
		kn = xn.toString,
		Cn = gn.hasOwnProperty,
		Rn = (function () {
			var Tt = /[^.]+$/.exec((vn && vn.keys && vn.keys.IE_PROTO) || "");
			return Tt ? "Symbol(src)_1." + Tt : "";
		})(),
		Mn = gn.toString,
		Nn = kn.call(Object),
		Dn = RegExp(
			"^" +
				kn
					.call(Cn)
					.replace(Rt, "\\$&")
					.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
				"$"
		),
		Ot = Xt ? Ut.Buffer : void 0,
		Ht = Ut.Symbol,
		en = Ut.Uint8Array,
		sn = Ot ? Ot.allocUnsafe : void 0,
		wn = an(Object.getPrototypeOf, Object),
		In = Object.create,
		ln = gn.propertyIsEnumerable,
		bn = mn.splice,
		Tn = Ht ? Ht.toStringTag : void 0,
		_n = (function () {
			try {
				var Tt = Xn(Object, "defineProperty");
				return Tt({}, "", {}), Tt;
			} catch {}
		})(),
		hn = Ot ? Ot.isBuffer : void 0,
		jn = Math.max,
		Pn = Date.now,
		ir = Xn(Ut, "Map"),
		zn = Xn(Object, "create"),
		Sr = (function () {
			function Tt() {}
			return function (Pt) {
				if (!Ln(Pt)) return {};
				if (In) return In(Pt);
				Tt.prototype = Pt;
				var Mt = new Tt();
				return (Tt.prototype = void 0), Mt;
			};
		})();
	function On(Tt) {
		var Pt = -1,
			Mt = Tt == null ? 0 : Tt.length;
		for (this.clear(); ++Pt < Mt; ) {
			var Kt = Tt[Pt];
			this.set(Kt[0], Kt[1]);
		}
	}
	function wr() {
		(this.__data__ = zn ? zn(null) : {}), (this.size = 0);
	}
	function kr(Tt) {
		var Pt = this.has(Tt) && delete this.__data__[Tt];
		return (this.size -= Pt ? 1 : 0), Pt;
	}
	function Cr(Tt) {
		var Pt = this.__data__;
		if (zn) {
			var Mt = Pt[Tt];
			return Mt === nt ? void 0 : Mt;
		}
		return Cn.call(Pt, Tt) ? Pt[Tt] : void 0;
	}
	function Er(Tt) {
		var Pt = this.__data__;
		return zn ? Pt[Tt] !== void 0 : Cn.call(Pt, Tt);
	}
	function $r(Tt, Pt) {
		var Mt = this.__data__;
		return (this.size += this.has(Tt) ? 0 : 1), (Mt[Tt] = zn && Pt === void 0 ? nt : Pt), this;
	}
	(On.prototype.clear = wr),
		(On.prototype.delete = kr),
		(On.prototype.get = Cr),
		(On.prototype.has = Er),
		(On.prototype.set = $r);
	function An(Tt) {
		var Pt = -1,
			Mt = Tt == null ? 0 : Tt.length;
		for (this.clear(); ++Pt < Mt; ) {
			var Kt = Tt[Pt];
			this.set(Kt[0], Kt[1]);
		}
	}
	function Pr() {
		(this.__data__ = []), (this.size = 0);
	}
	function _r(Tt) {
		var Pt = this.__data__,
			Mt = Un(Pt, Tt);
		if (Mt < 0) return !1;
		var Kt = Pt.length - 1;
		return Mt == Kt ? Pt.pop() : bn.call(Pt, Mt, 1), --this.size, !0;
	}
	function Ar(Tt) {
		var Pt = this.__data__,
			Mt = Un(Pt, Tt);
		return Mt < 0 ? void 0 : Pt[Mt][1];
	}
	function Rr(Tt) {
		return Un(this.__data__, Tt) > -1;
	}
	function Ir(Tt, Pt) {
		var Mt = this.__data__,
			Kt = Un(Mt, Tt);
		return Kt < 0 ? (++this.size, Mt.push([Tt, Pt])) : (Mt[Kt][1] = Pt), this;
	}
	(An.prototype.clear = Pr),
		(An.prototype.delete = _r),
		(An.prototype.get = Ar),
		(An.prototype.has = Rr),
		(An.prototype.set = Ir);
	function Fn(Tt) {
		var Pt = -1,
			Mt = Tt == null ? 0 : Tt.length;
		for (this.clear(); ++Pt < Mt; ) {
			var Kt = Tt[Pt];
			this.set(Kt[0], Kt[1]);
		}
	}
	function Mr() {
		(this.size = 0), (this.__data__ = { hash: new On(), map: new (ir || An)(), string: new On() });
	}
	function Or(Tt) {
		var Pt = qn(this, Tt).delete(Tt);
		return (this.size -= Pt ? 1 : 0), Pt;
	}
	function Lr(Tt) {
		return qn(this, Tt).get(Tt);
	}
	function Nr(Tt) {
		return qn(this, Tt).has(Tt);
	}
	function Dr(Tt, Pt) {
		var Mt = qn(this, Tt),
			Kt = Mt.size;
		return Mt.set(Tt, Pt), (this.size += Mt.size == Kt ? 0 : 1), this;
	}
	(Fn.prototype.clear = Mr),
		(Fn.prototype.delete = Or),
		(Fn.prototype.get = Lr),
		(Fn.prototype.has = Nr),
		(Fn.prototype.set = Dr);
	function Bn(Tt) {
		var Pt = (this.__data__ = new An(Tt));
		this.size = Pt.size;
	}
	function jr() {
		(this.__data__ = new An()), (this.size = 0);
	}
	function Fr(Tt) {
		var Pt = this.__data__,
			Mt = Pt.delete(Tt);
		return (this.size = Pt.size), Mt;
	}
	function Br(Tt) {
		return this.__data__.get(Tt);
	}
	function zr(Tt) {
		return this.__data__.has(Tt);
	}
	function Vr(Tt, Pt) {
		var Mt = this.__data__;
		if (Mt instanceof An) {
			var Kt = Mt.__data__;
			if (!ir || Kt.length < tt - 1) return Kt.push([Tt, Pt]), (this.size = ++Mt.size), this;
			Mt = this.__data__ = new Fn(Kt);
		}
		return Mt.set(Tt, Pt), (this.size = Mt.size), this;
	}
	(Bn.prototype.clear = jr),
		(Bn.prototype.delete = Fr),
		(Bn.prototype.get = Br),
		(Bn.prototype.has = zr),
		(Bn.prototype.set = Vr);
	function Hr(Tt, Pt) {
		var Mt = Jn(Tt),
			Kt = !Mt && Zn(Tt),
			rn = !Mt && !Kt && ur(Tt),
			un = !Mt && !Kt && !rn && dr(Tt),
			cn = Mt || Kt || rn || un,
			nn = cn ? Qt(Tt.length, String) : [],
			dn = nn.length;
		for (var $n in Tt)
			(Pt || Cn.call(Tt, $n)) &&
				!(
					cn &&
					($n == "length" ||
						(rn && ($n == "offset" || $n == "parent")) ||
						(un && ($n == "buffer" || $n == "byteLength" || $n == "byteOffset")) ||
						sr($n, dn))
				) &&
				nn.push($n);
		return nn;
	}
	function Yn(Tt, Pt, Mt) {
		((Mt !== void 0 && !Gn(Tt[Pt], Mt)) || (Mt === void 0 && !(Pt in Tt))) && Kn(Tt, Pt, Mt);
	}
	function Ur(Tt, Pt, Mt) {
		var Kt = Tt[Pt];
		(!(Cn.call(Tt, Pt) && Gn(Kt, Mt)) || (Mt === void 0 && !(Pt in Tt))) && Kn(Tt, Pt, Mt);
	}
	function Un(Tt, Pt) {
		for (var Mt = Tt.length; Mt--; ) if (Gn(Tt[Mt][0], Pt)) return Mt;
		return -1;
	}
	function Kn(Tt, Pt, Mt) {
		Pt == "__proto__" && _n ? _n(Tt, Pt, { configurable: !0, enumerable: !0, value: Mt, writable: !0 }) : (Tt[Pt] = Mt);
	}
	var Wr = ro();
	function Wn(Tt) {
		return Tt == null ? (Tt === void 0 ? Ct : ht) : Tn && Tn in Object(Tt) ? io(Tt) : co(Tt);
	}
	function or(Tt) {
		return Vn(Tt) && Wn(Tt) == at;
	}
	function qr(Tt) {
		if (!Ln(Tt) || lo(Tt)) return !1;
		var Pt = tr(Tt) ? Dn : bt;
		return Pt.test(mo(Tt));
	}
	function Gr(Tt) {
		return Vn(Tt) && cr(Tt.length) && !!zt[Wn(Tt)];
	}
	function Yr(Tt) {
		if (!Ln(Tt)) return uo(Tt);
		var Pt = lr(Tt),
			Mt = [];
		for (var Kt in Tt) (Kt == "constructor" && (Pt || !Cn.call(Tt, Kt))) || Mt.push(Kt);
		return Mt;
	}
	function ar(Tt, Pt, Mt, Kt, rn) {
		Tt !== Pt &&
			Wr(
				Pt,
				function (un, cn) {
					if ((rn || (rn = new Bn()), Ln(un))) Kr(Tt, Pt, cn, Mt, ar, Kt, rn);
					else {
						var nn = Kt ? Kt(Qn(Tt, cn), un, cn + "", Tt, Pt, rn) : void 0;
						nn === void 0 && (nn = un), Yn(Tt, cn, nn);
					}
				},
				fr
			);
	}
	function Kr(Tt, Pt, Mt, Kt, rn, un, cn) {
		var nn = Qn(Tt, Mt),
			dn = Qn(Pt, Mt),
			$n = cn.get(dn);
		if ($n) {
			Yn(Tt, Mt, $n);
			return;
		}
		var En = un ? un(nn, dn, Mt + "", Tt, Pt, cn) : void 0,
			Hn = En === void 0;
		if (Hn) {
			var nr = Jn(dn),
				rr = !nr && ur(dn),
				hr = !nr && !rr && dr(dn);
			(En = dn),
				nr || rr || hr
					? Jn(nn)
						? (En = nn)
						: go(nn)
						? (En = eo(nn))
						: rr
						? ((Hn = !1), (En = Zr(dn, !0)))
						: hr
						? ((Hn = !1), (En = _i(dn, !0)))
						: (En = [])
					: yo(dn) || Zn(dn)
					? ((En = nn), Zn(nn) ? (En = vo(nn)) : (!Ln(nn) || tr(nn)) && (En = oo(dn)))
					: (Hn = !1);
		}
		Hn && (cn.set(dn, En), rn(En, dn, Kt, un, cn), cn.delete(dn)), Yn(Tt, Mt, En);
	}
	function Xr(Tt, Pt) {
		return po(fo(Tt, Pt, pr), Tt + "");
	}
	var Qr = _n
		? function (Tt, Pt) {
				return _n(Tt, "toString", { configurable: !0, enumerable: !1, value: xo(Pt), writable: !0 });
		  }
		: pr;
	function Zr(Tt, Pt) {
		if (Pt) return Tt.slice();
		var Mt = Tt.length,
			Kt = sn ? sn(Mt) : new Tt.constructor(Mt);
		return Tt.copy(Kt), Kt;
	}
	function Jr(Tt) {
		var Pt = new Tt.constructor(Tt.byteLength);
		return new en(Pt).set(new en(Tt)), Pt;
	}
	function _i(Tt, Pt) {
		var Mt = Pt ? Jr(Tt.buffer) : Tt.buffer;
		return new Tt.constructor(Mt, Tt.byteOffset, Tt.length);
	}
	function eo(Tt, Pt) {
		var Mt = -1,
			Kt = Tt.length;
		for (Pt || (Pt = Array(Kt)); ++Mt < Kt; ) Pt[Mt] = Tt[Mt];
		return Pt;
	}
	function to(Tt, Pt, Mt, Kt) {
		var rn = !Mt;
		Mt || (Mt = {});
		for (var un = -1, cn = Pt.length; ++un < cn; ) {
			var nn = Pt[un],
				dn = Kt ? Kt(Mt[nn], Tt[nn], nn, Mt, Tt) : void 0;
			dn === void 0 && (dn = Tt[nn]), rn ? Kn(Mt, nn, dn) : Ur(Mt, nn, dn);
		}
		return Mt;
	}
	function no(Tt) {
		return Xr(function (Pt, Mt) {
			var Kt = -1,
				rn = Mt.length,
				un = rn > 1 ? Mt[rn - 1] : void 0,
				cn = rn > 2 ? Mt[2] : void 0;
			for (
				un = Tt.length > 3 && typeof un == "function" ? (rn--, un) : void 0,
					cn && ao(Mt[0], Mt[1], cn) && ((un = rn < 3 ? void 0 : un), (rn = 1)),
					Pt = Object(Pt);
				++Kt < rn;

			) {
				var nn = Mt[Kt];
				nn && Tt(Pt, nn, Kt, un);
			}
			return Pt;
		});
	}
	function ro(Tt) {
		return function (Pt, Mt, Kt) {
			for (var rn = -1, un = Object(Pt), cn = Kt(Pt), nn = cn.length; nn--; ) {
				var dn = cn[Tt ? nn : ++rn];
				if (Mt(un[dn], dn, un) === !1) break;
			}
			return Pt;
		};
	}
	function qn(Tt, Pt) {
		var Mt = Tt.__data__;
		return so(Pt) ? Mt[typeof Pt == "string" ? "string" : "hash"] : Mt.map;
	}
	function Xn(Tt, Pt) {
		var Mt = tn(Tt, Pt);
		return qr(Mt) ? Mt : void 0;
	}
	function io(Tt) {
		var Pt = Cn.call(Tt, Tn),
			Mt = Tt[Tn];
		try {
			Tt[Tn] = void 0;
			var Kt = !0;
		} catch {}
		var rn = Mn.call(Tt);
		return Kt && (Pt ? (Tt[Tn] = Mt) : delete Tt[Tn]), rn;
	}
	function oo(Tt) {
		return typeof Tt.constructor == "function" && !lr(Tt) ? Sr(wn(Tt)) : {};
	}
	function sr(Tt, Pt) {
		var Mt = typeof Tt;
		return (
			(Pt = Pt == null ? ot : Pt),
			!!Pt && (Mt == "number" || (Mt != "symbol" && kt.test(Tt))) && Tt > -1 && Tt % 1 == 0 && Tt < Pt
		);
	}
	function ao(Tt, Pt, Mt) {
		if (!Ln(Mt)) return !1;
		var Kt = typeof Pt;
		return (Kt == "number" ? er(Mt) && sr(Pt, Mt.length) : Kt == "string" && Pt in Mt) ? Gn(Mt[Pt], Tt) : !1;
	}
	function so(Tt) {
		var Pt = typeof Tt;
		return Pt == "string" || Pt == "number" || Pt == "symbol" || Pt == "boolean" ? Tt !== "__proto__" : Tt === null;
	}
	function lo(Tt) {
		return !!Rn && Rn in Tt;
	}
	function lr(Tt) {
		var Pt = Tt && Tt.constructor,
			Mt = (typeof Pt == "function" && Pt.prototype) || gn;
		return Tt === Mt;
	}
	function uo(Tt) {
		var Pt = [];
		if (Tt != null) for (var Mt in Object(Tt)) Pt.push(Mt);
		return Pt;
	}
	function co(Tt) {
		return Mn.call(Tt);
	}
	function fo(Tt, Pt, Mt) {
		return (
			(Pt = jn(Pt === void 0 ? Tt.length - 1 : Pt, 0)),
			function () {
				for (var Kt = arguments, rn = -1, un = jn(Kt.length - Pt, 0), cn = Array(un); ++rn < un; ) cn[rn] = Kt[Pt + rn];
				rn = -1;
				for (var nn = Array(Pt + 1); ++rn < Pt; ) nn[rn] = Kt[rn];
				return (nn[Pt] = Mt(cn)), yn(Tt, this, nn);
			}
		);
	}
	function Qn(Tt, Pt) {
		if (!(Pt === "constructor" && typeof Tt[Pt] == "function") && Pt != "__proto__") return Tt[Pt];
	}
	var po = ho(Qr);
	function ho(Tt) {
		var Pt = 0,
			Mt = 0;
		return function () {
			var Kt = Pn(),
				rn = it - (Kt - Mt);
			if (((Mt = Kt), rn > 0)) {
				if (++Pt >= rt) return arguments[0];
			} else Pt = 0;
			return Tt.apply(void 0, arguments);
		};
	}
	function mo(Tt) {
		if (Tt != null) {
			try {
				return kn.call(Tt);
			} catch {}
			try {
				return Tt + "";
			} catch {}
		}
		return "";
	}
	function Gn(Tt, Pt) {
		return Tt === Pt || (Tt !== Tt && Pt !== Pt);
	}
	var Zn = or(
			(function () {
				return arguments;
			})()
		)
			? or
			: function (Tt) {
					return Vn(Tt) && Cn.call(Tt, "callee") && !ln.call(Tt, "callee");
			  },
		Jn = Array.isArray;
	function er(Tt) {
		return Tt != null && cr(Tt.length) && !tr(Tt);
	}
	function go(Tt) {
		return Vn(Tt) && er(Tt);
	}
	var ur = hn || So;
	function tr(Tt) {
		if (!Ln(Tt)) return !1;
		var Pt = Wn(Tt);
		return Pt == ft || Pt == mt || Pt == lt || Pt == yt;
	}
	function cr(Tt) {
		return typeof Tt == "number" && Tt > -1 && Tt % 1 == 0 && Tt <= ot;
	}
	function Ln(Tt) {
		var Pt = typeof Tt;
		return Tt != null && (Pt == "object" || Pt == "function");
	}
	function Vn(Tt) {
		return Tt != null && typeof Tt == "object";
	}
	function yo(Tt) {
		if (!Vn(Tt) || Wn(Tt) != gt) return !1;
		var Pt = wn(Tt);
		if (Pt === null) return !0;
		var Mt = Cn.call(Pt, "constructor") && Pt.constructor;
		return typeof Mt == "function" && Mt instanceof Mt && kn.call(Mt) == Nn;
	}
	var dr = Sn ? Jt(Sn) : Gr;
	function vo(Tt) {
		return to(Tt, fr(Tt));
	}
	function fr(Tt) {
		return er(Tt) ? Hr(Tt, !0) : Yr(Tt);
	}
	var bo = no(function (Tt, Pt, Mt, Kt) {
		ar(Tt, Pt, Mt, Kt);
	});
	function xo(Tt) {
		return function () {
			return Tt;
		};
	}
	function pr(Tt) {
		return Tt;
	}
	function So() {
		return !1;
	}
	_.exports = bo;
})(lodash_mergewith, lodash_mergewith.exports);
const mergeWith = lodash_mergewith.exports;
function isObject$6(_) {
	const et = typeof _;
	return _ != null && (et === "object" || et === "function") && !Array.isArray(_);
}
function runIfFn$5(_, ...et) {
	return isFunction$9(_) ? _(...et) : _;
}
var isFunction$9 = (_) => typeof _ == "function",
	isImportant = (_) => /!(important)?$/.test(_),
	withoutImportant = (_) => (typeof _ == "string" ? _.replace(/!(important)?$/, "").trim() : _),
	tokenToCSSVar = (_, et) => (tt) => {
		const nt = String(et),
			rt = isImportant(nt),
			it = withoutImportant(nt),
			ot = _ ? `${_}.${it}` : it;
		let at = isObject$6(tt.__cssMap) && ot in tt.__cssMap ? tt.__cssMap[ot].varRef : et;
		return (at = withoutImportant(at)), rt ? `${at} !important` : at;
	};
function createTransform(_) {
	const { scale: et, transform: tt, compose: nt } = _;
	return (it, ot) => {
		var lt;
		const at = tokenToCSSVar(et, it)(ot);
		let st = (lt = tt == null ? void 0 : tt(at, ot)) != null ? lt : at;
		return nt && (st = nt(st, ot)), st;
	};
}
var pipe$2 =
	(..._) =>
	(et) =>
		_.reduce((tt, nt) => nt(tt), et);
function toConfig(_, et) {
	return (tt) => {
		const nt = { property: tt, scale: _ };
		return (nt.transform = createTransform({ scale: _, transform: et })), nt;
	};
}
var getRtl =
	({ rtl: _, ltr: et }) =>
	(tt) =>
		tt.direction === "rtl" ? _ : et;
function logical(_) {
	const { property: et, scale: tt, transform: nt } = _;
	return { scale: tt, property: getRtl(et), transform: tt ? createTransform({ scale: tt, compose: nt }) : nt };
}
var transformTemplate = [
	"rotate(var(--chakra-rotate, 0))",
	"scaleX(var(--chakra-scale-x, 1))",
	"scaleY(var(--chakra-scale-y, 1))",
	"skewX(var(--chakra-skew-x, 0))",
	"skewY(var(--chakra-skew-y, 0))",
];
function getTransformTemplate() {
	return [
		"translateX(var(--chakra-translate-x, 0))",
		"translateY(var(--chakra-translate-y, 0))",
		...transformTemplate,
	].join(" ");
}
function getTransformGpuTemplate() {
	return ["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)", ...transformTemplate].join(" ");
}
var filterTemplate = {
		"--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
		filter: [
			"var(--chakra-blur)",
			"var(--chakra-brightness)",
			"var(--chakra-contrast)",
			"var(--chakra-grayscale)",
			"var(--chakra-hue-rotate)",
			"var(--chakra-invert)",
			"var(--chakra-saturate)",
			"var(--chakra-sepia)",
			"var(--chakra-drop-shadow)",
		].join(" "),
	},
	backdropFilterTemplate = {
		backdropFilter: [
			"var(--chakra-backdrop-blur)",
			"var(--chakra-backdrop-brightness)",
			"var(--chakra-backdrop-contrast)",
			"var(--chakra-backdrop-grayscale)",
			"var(--chakra-backdrop-hue-rotate)",
			"var(--chakra-backdrop-invert)",
			"var(--chakra-backdrop-opacity)",
			"var(--chakra-backdrop-saturate)",
			"var(--chakra-backdrop-sepia)",
		].join(" "),
		"--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
		"--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
	};
function getRingTemplate(_) {
	return {
		"--chakra-ring-offset-shadow":
			"var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
		"--chakra-ring-shadow":
			"var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
		"--chakra-ring-width": _,
		boxShadow: [
			"var(--chakra-ring-offset-shadow)",
			"var(--chakra-ring-shadow)",
			"var(--chakra-shadow, 0 0 #0000)",
		].join(", "),
	};
}
var flexDirectionTemplate = {
		"row-reverse": { space: "--chakra-space-x-reverse", divide: "--chakra-divide-x-reverse" },
		"column-reverse": { space: "--chakra-space-y-reverse", divide: "--chakra-divide-y-reverse" },
	},
	owlSelector = "& > :not(style) ~ :not(style)",
	spaceXTemplate = {
		[owlSelector]: {
			marginInlineStart: "calc(var(--chakra-space-x) * calc(1 - var(--chakra-space-x-reverse)))",
			marginInlineEnd: "calc(var(--chakra-space-x) * var(--chakra-space-x-reverse))",
		},
	},
	spaceYTemplate = {
		[owlSelector]: {
			marginTop: "calc(var(--chakra-space-y) * calc(1 - var(--chakra-space-y-reverse)))",
			marginBottom: "calc(var(--chakra-space-y) * var(--chakra-space-y-reverse))",
		},
	},
	directionMap = {
		"to-t": "to top",
		"to-tr": "to top right",
		"to-r": "to right",
		"to-br": "to bottom right",
		"to-b": "to bottom",
		"to-bl": "to bottom left",
		"to-l": "to left",
		"to-tl": "to top left",
	},
	valueSet = new Set(Object.values(directionMap)),
	globalSet = new Set(["none", "-moz-initial", "inherit", "initial", "revert", "unset"]),
	trimSpace = (_) => _.trim();
function parseGradient(_, et) {
	var dt;
	var tt;
	if (_ == null || globalSet.has(_)) return _;
	const nt = /(?<type>^[a-z-A-Z]+)\((?<values>(.*))\)/g,
		{ type: rt, values: it } = (dt = (tt = nt.exec(_)) == null ? void 0 : tt.groups) != null ? dt : {};
	if (!rt || !it) return _;
	const ot = rt.includes("-gradient") ? rt : `${rt}-gradient`,
		[at, ...st] = it.split(",").map(trimSpace).filter(Boolean);
	if ((st == null ? void 0 : st.length) === 0) return _;
	const lt = at in directionMap ? directionMap[at] : at;
	st.unshift(lt);
	const ut = st.map((ct) => {
		if (valueSet.has(ct)) return ct;
		const ft = ct.indexOf(" "),
			[mt, pt] = ft !== -1 ? [ct.substr(0, ft), ct.substr(ft + 1)] : [ct],
			vt = isCSSFunction(pt) ? pt : pt && pt.split(" "),
			ht = `colors.${mt}`,
			gt = ht in et.__cssMap ? et.__cssMap[ht].varRef : mt;
		return vt ? [gt, ...(Array.isArray(vt) ? vt : [vt])].join(" ") : gt;
	});
	return `${ot}(${ut.join(", ")})`;
}
var isCSSFunction = (_) => typeof _ == "string" && _.includes("(") && _.includes(")"),
	gradientTransform = (_, et) => parseGradient(_, et != null ? et : {});
function isCssVar(_) {
	return /^var\(--.+\)$/.test(_);
}
var analyzeCSSValue = (_) => {
		const et = parseFloat(_.toString()),
			tt = _.toString().replace(String(et), "");
		return { unitless: !tt, value: et, unit: tt };
	},
	wrap$3 = (_) => (et) => `${_}(${et})`,
	transformFunctions = {
		filter(_) {
			return _ !== "auto" ? _ : filterTemplate;
		},
		backdropFilter(_) {
			return _ !== "auto" ? _ : backdropFilterTemplate;
		},
		ring(_) {
			return getRingTemplate(transformFunctions.px(_));
		},
		bgClip(_) {
			return _ === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: _ };
		},
		transform(_) {
			return _ === "auto" ? getTransformTemplate() : _ === "auto-gpu" ? getTransformGpuTemplate() : _;
		},
		vh(_) {
			return _ === "$100vh" ? "var(--chakra-vh)" : _;
		},
		px(_) {
			if (_ == null) return _;
			const { unitless: et } = analyzeCSSValue(_);
			return et || typeof _ == "number" ? `${_}px` : _;
		},
		fraction(_) {
			return typeof _ != "number" || _ > 1 ? _ : `${_ * 100}%`;
		},
		float(_, et) {
			const tt = { left: "right", right: "left" };
			return et.direction === "rtl" ? tt[_] : _;
		},
		degree(_) {
			if (isCssVar(_) || _ == null) return _;
			const et = typeof _ == "string" && !_.endsWith("deg");
			return typeof _ == "number" || et ? `${_}deg` : _;
		},
		gradient: gradientTransform,
		blur: wrap$3("blur"),
		opacity: wrap$3("opacity"),
		brightness: wrap$3("brightness"),
		contrast: wrap$3("contrast"),
		dropShadow: wrap$3("drop-shadow"),
		grayscale: wrap$3("grayscale"),
		hueRotate: wrap$3("hue-rotate"),
		invert: wrap$3("invert"),
		saturate: wrap$3("saturate"),
		sepia: wrap$3("sepia"),
		bgImage(_) {
			return _ == null || isCSSFunction(_) || globalSet.has(_) ? _ : `url(${_})`;
		},
		outline(_) {
			const et = String(_) === "0" || String(_) === "none";
			return _ !== null && et ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: _ };
		},
		flexDirection(_) {
			var rt;
			const { space: et, divide: tt } = (rt = flexDirectionTemplate[_]) != null ? rt : {},
				nt = { flexDirection: _ };
			return et && (nt[et] = 1), tt && (nt[tt] = 1), nt;
		},
	},
	t$2 = {
		borderWidths: toConfig("borderWidths"),
		borderStyles: toConfig("borderStyles"),
		colors: toConfig("colors"),
		borders: toConfig("borders"),
		radii: toConfig("radii", transformFunctions.px),
		space: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
		spaceT: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
		degreeT(_) {
			return { property: _, transform: transformFunctions.degree };
		},
		prop(_, et, tt) {
			return { property: _, scale: et, ...(et && { transform: createTransform({ scale: et, transform: tt }) }) };
		},
		propT(_, et) {
			return { property: _, transform: et };
		},
		sizes: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.px)),
		sizesT: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.fraction)),
		shadows: toConfig("shadows"),
		logical,
		blur: toConfig("blur", transformFunctions.blur),
	},
	background = {
		background: t$2.colors("background"),
		backgroundColor: t$2.colors("backgroundColor"),
		backgroundImage: t$2.propT("backgroundImage", transformFunctions.bgImage),
		backgroundSize: !0,
		backgroundPosition: !0,
		backgroundRepeat: !0,
		backgroundAttachment: !0,
		backgroundClip: { transform: transformFunctions.bgClip },
		bgSize: t$2.prop("backgroundSize"),
		bgPosition: t$2.prop("backgroundPosition"),
		bg: t$2.colors("background"),
		bgColor: t$2.colors("backgroundColor"),
		bgPos: t$2.prop("backgroundPosition"),
		bgRepeat: t$2.prop("backgroundRepeat"),
		bgAttachment: t$2.prop("backgroundAttachment"),
		bgGradient: t$2.propT("backgroundImage", transformFunctions.gradient),
		bgClip: { transform: transformFunctions.bgClip },
	};
Object.assign(background, { bgImage: background.backgroundImage, bgImg: background.backgroundImage });
var border = {
	border: t$2.borders("border"),
	borderWidth: t$2.borderWidths("borderWidth"),
	borderStyle: t$2.borderStyles("borderStyle"),
	borderColor: t$2.colors("borderColor"),
	borderRadius: t$2.radii("borderRadius"),
	borderTop: t$2.borders("borderTop"),
	borderBlockStart: t$2.borders("borderBlockStart"),
	borderTopLeftRadius: t$2.radii("borderTopLeftRadius"),
	borderStartStartRadius: t$2.logical({
		scale: "radii",
		property: { ltr: "borderTopLeftRadius", rtl: "borderTopRightRadius" },
	}),
	borderEndStartRadius: t$2.logical({
		scale: "radii",
		property: { ltr: "borderBottomLeftRadius", rtl: "borderBottomRightRadius" },
	}),
	borderTopRightRadius: t$2.radii("borderTopRightRadius"),
	borderStartEndRadius: t$2.logical({
		scale: "radii",
		property: { ltr: "borderTopRightRadius", rtl: "borderTopLeftRadius" },
	}),
	borderEndEndRadius: t$2.logical({
		scale: "radii",
		property: { ltr: "borderBottomRightRadius", rtl: "borderBottomLeftRadius" },
	}),
	borderRight: t$2.borders("borderRight"),
	borderInlineEnd: t$2.borders("borderInlineEnd"),
	borderBottom: t$2.borders("borderBottom"),
	borderBlockEnd: t$2.borders("borderBlockEnd"),
	borderBottomLeftRadius: t$2.radii("borderBottomLeftRadius"),
	borderBottomRightRadius: t$2.radii("borderBottomRightRadius"),
	borderLeft: t$2.borders("borderLeft"),
	borderInlineStart: { property: "borderInlineStart", scale: "borders" },
	borderInlineStartRadius: t$2.logical({
		scale: "radii",
		property: {
			ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
			rtl: ["borderTopRightRadius", "borderBottomRightRadius"],
		},
	}),
	borderInlineEndRadius: t$2.logical({
		scale: "radii",
		property: {
			ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
			rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"],
		},
	}),
	borderX: t$2.borders(["borderLeft", "borderRight"]),
	borderInline: t$2.borders("borderInline"),
	borderY: t$2.borders(["borderTop", "borderBottom"]),
	borderBlock: t$2.borders("borderBlock"),
	borderTopWidth: t$2.borderWidths("borderTopWidth"),
	borderBlockStartWidth: t$2.borderWidths("borderBlockStartWidth"),
	borderTopColor: t$2.colors("borderTopColor"),
	borderBlockStartColor: t$2.colors("borderBlockStartColor"),
	borderTopStyle: t$2.borderStyles("borderTopStyle"),
	borderBlockStartStyle: t$2.borderStyles("borderBlockStartStyle"),
	borderBottomWidth: t$2.borderWidths("borderBottomWidth"),
	borderBlockEndWidth: t$2.borderWidths("borderBlockEndWidth"),
	borderBottomColor: t$2.colors("borderBottomColor"),
	borderBlockEndColor: t$2.colors("borderBlockEndColor"),
	borderBottomStyle: t$2.borderStyles("borderBottomStyle"),
	borderBlockEndStyle: t$2.borderStyles("borderBlockEndStyle"),
	borderLeftWidth: t$2.borderWidths("borderLeftWidth"),
	borderInlineStartWidth: t$2.borderWidths("borderInlineStartWidth"),
	borderLeftColor: t$2.colors("borderLeftColor"),
	borderInlineStartColor: t$2.colors("borderInlineStartColor"),
	borderLeftStyle: t$2.borderStyles("borderLeftStyle"),
	borderInlineStartStyle: t$2.borderStyles("borderInlineStartStyle"),
	borderRightWidth: t$2.borderWidths("borderRightWidth"),
	borderInlineEndWidth: t$2.borderWidths("borderInlineEndWidth"),
	borderRightColor: t$2.colors("borderRightColor"),
	borderInlineEndColor: t$2.colors("borderInlineEndColor"),
	borderRightStyle: t$2.borderStyles("borderRightStyle"),
	borderInlineEndStyle: t$2.borderStyles("borderInlineEndStyle"),
	borderTopRadius: t$2.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
	borderBottomRadius: t$2.radii(["borderBottomLeftRadius", "borderBottomRightRadius"]),
	borderLeftRadius: t$2.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
	borderRightRadius: t$2.radii(["borderTopRightRadius", "borderBottomRightRadius"]),
};
Object.assign(border, {
	rounded: border.borderRadius,
	roundedTop: border.borderTopRadius,
	roundedTopLeft: border.borderTopLeftRadius,
	roundedTopRight: border.borderTopRightRadius,
	roundedTopStart: border.borderStartStartRadius,
	roundedTopEnd: border.borderStartEndRadius,
	roundedBottom: border.borderBottomRadius,
	roundedBottomLeft: border.borderBottomLeftRadius,
	roundedBottomRight: border.borderBottomRightRadius,
	roundedBottomStart: border.borderEndStartRadius,
	roundedBottomEnd: border.borderEndEndRadius,
	roundedLeft: border.borderLeftRadius,
	roundedRight: border.borderRightRadius,
	roundedStart: border.borderInlineStartRadius,
	roundedEnd: border.borderInlineEndRadius,
	borderStart: border.borderInlineStart,
	borderEnd: border.borderInlineEnd,
	borderTopStartRadius: border.borderStartStartRadius,
	borderTopEndRadius: border.borderStartEndRadius,
	borderBottomStartRadius: border.borderEndStartRadius,
	borderBottomEndRadius: border.borderEndEndRadius,
	borderStartRadius: border.borderInlineStartRadius,
	borderEndRadius: border.borderInlineEndRadius,
	borderStartWidth: border.borderInlineStartWidth,
	borderEndWidth: border.borderInlineEndWidth,
	borderStartColor: border.borderInlineStartColor,
	borderEndColor: border.borderInlineEndColor,
	borderStartStyle: border.borderInlineStartStyle,
	borderEndStyle: border.borderInlineEndStyle,
});
var color$2 = {
		color: t$2.colors("color"),
		textColor: t$2.colors("color"),
		fill: t$2.colors("fill"),
		stroke: t$2.colors("stroke"),
	},
	effect$3 = {
		boxShadow: t$2.shadows("boxShadow"),
		mixBlendMode: !0,
		blendMode: t$2.prop("mixBlendMode"),
		backgroundBlendMode: !0,
		bgBlendMode: t$2.prop("backgroundBlendMode"),
		opacity: !0,
	};
Object.assign(effect$3, { shadow: effect$3.boxShadow });
var filter$2 = {
		filter: { transform: transformFunctions.filter },
		blur: t$2.blur("--chakra-blur"),
		brightness: t$2.propT("--chakra-brightness", transformFunctions.brightness),
		contrast: t$2.propT("--chakra-contrast", transformFunctions.contrast),
		hueRotate: t$2.degreeT("--chakra-hue-rotate"),
		invert: t$2.propT("--chakra-invert", transformFunctions.invert),
		saturate: t$2.propT("--chakra-saturate", transformFunctions.saturate),
		dropShadow: t$2.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
		backdropFilter: { transform: transformFunctions.backdropFilter },
		backdropBlur: t$2.blur("--chakra-backdrop-blur"),
		backdropBrightness: t$2.propT("--chakra-backdrop-brightness", transformFunctions.brightness),
		backdropContrast: t$2.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
		backdropHueRotate: t$2.degreeT("--chakra-backdrop-hue-rotate"),
		backdropInvert: t$2.propT("--chakra-backdrop-invert", transformFunctions.invert),
		backdropSaturate: t$2.propT("--chakra-backdrop-saturate", transformFunctions.saturate),
	},
	flexbox = {
		alignItems: !0,
		alignContent: !0,
		justifyItems: !0,
		justifyContent: !0,
		flexWrap: !0,
		flexDirection: { transform: transformFunctions.flexDirection },
		experimental_spaceX: {
			static: spaceXTemplate,
			transform: createTransform({ scale: "space", transform: (_) => (_ !== null ? { "--chakra-space-x": _ } : null) }),
		},
		experimental_spaceY: {
			static: spaceYTemplate,
			transform: createTransform({ scale: "space", transform: (_) => (_ != null ? { "--chakra-space-y": _ } : null) }),
		},
		flex: !0,
		flexFlow: !0,
		flexGrow: !0,
		flexShrink: !0,
		flexBasis: t$2.sizes("flexBasis"),
		justifySelf: !0,
		alignSelf: !0,
		order: !0,
		placeItems: !0,
		placeContent: !0,
		placeSelf: !0,
		gap: t$2.space("gap"),
		rowGap: t$2.space("rowGap"),
		columnGap: t$2.space("columnGap"),
	};
Object.assign(flexbox, { flexDir: flexbox.flexDirection });
var grid = {
		gridGap: t$2.space("gridGap"),
		gridColumnGap: t$2.space("gridColumnGap"),
		gridRowGap: t$2.space("gridRowGap"),
		gridColumn: !0,
		gridRow: !0,
		gridAutoFlow: !0,
		gridAutoColumns: !0,
		gridColumnStart: !0,
		gridColumnEnd: !0,
		gridRowStart: !0,
		gridRowEnd: !0,
		gridAutoRows: !0,
		gridTemplate: !0,
		gridTemplateColumns: !0,
		gridTemplateRows: !0,
		gridTemplateAreas: !0,
		gridArea: !0,
	},
	interactivity = {
		appearance: !0,
		cursor: !0,
		resize: !0,
		userSelect: !0,
		pointerEvents: !0,
		outline: { transform: transformFunctions.outline },
		outlineOffset: !0,
		outlineColor: t$2.colors("outlineColor"),
	},
	layout = {
		width: t$2.sizesT("width"),
		inlineSize: t$2.sizesT("inlineSize"),
		height: t$2.sizes("height"),
		blockSize: t$2.sizes("blockSize"),
		boxSize: t$2.sizes(["width", "height"]),
		minWidth: t$2.sizes("minWidth"),
		minInlineSize: t$2.sizes("minInlineSize"),
		minHeight: t$2.sizes("minHeight"),
		minBlockSize: t$2.sizes("minBlockSize"),
		maxWidth: t$2.sizes("maxWidth"),
		maxInlineSize: t$2.sizes("maxInlineSize"),
		maxHeight: t$2.sizes("maxHeight"),
		maxBlockSize: t$2.sizes("maxBlockSize"),
		overflow: !0,
		overflowX: !0,
		overflowY: !0,
		overscrollBehavior: !0,
		overscrollBehaviorX: !0,
		overscrollBehaviorY: !0,
		display: !0,
		verticalAlign: !0,
		boxSizing: !0,
		boxDecorationBreak: !0,
		float: t$2.propT("float", transformFunctions.float),
		objectFit: !0,
		objectPosition: !0,
		visibility: !0,
		isolation: !0,
	};
Object.assign(layout, {
	w: layout.width,
	h: layout.height,
	minW: layout.minWidth,
	maxW: layout.maxWidth,
	minH: layout.minHeight,
	maxH: layout.maxHeight,
	overscroll: layout.overscrollBehavior,
	overscrollX: layout.overscrollBehaviorX,
	overscrollY: layout.overscrollBehaviorY,
});
var list$2 = {
	listStyleType: !0,
	listStylePosition: !0,
	listStylePos: t$2.prop("listStylePosition"),
	listStyleImage: !0,
	listStyleImg: t$2.prop("listStyleImage"),
};
function get$1(_, et, tt, nt) {
	const rt = typeof et == "string" ? et.split(".") : [et];
	for (nt = 0; nt < rt.length && _; nt += 1) _ = _[rt[nt]];
	return _ === void 0 ? tt : _;
}
var memoize$2 = (_) => {
		const et = new WeakMap();
		return (nt, rt, it, ot) => {
			if (typeof nt > "u") return _(nt, rt, it);
			et.has(nt) || et.set(nt, new Map());
			const at = et.get(nt);
			if (at.has(rt)) return at.get(rt);
			const st = _(nt, rt, it, ot);
			return at.set(rt, st), st;
		};
	},
	memoizedGet$1 = memoize$2(get$1),
	srOnly = {
		border: "0px",
		clip: "rect(0, 0, 0, 0)",
		width: "1px",
		height: "1px",
		margin: "-1px",
		padding: "0px",
		overflow: "hidden",
		whiteSpace: "nowrap",
		position: "absolute",
	},
	srFocusable = {
		position: "static",
		width: "auto",
		height: "auto",
		clip: "auto",
		padding: "0",
		margin: "0",
		overflow: "visible",
		whiteSpace: "normal",
	},
	getWithPriority = (_, et, tt) => {
		const nt = {},
			rt = memoizedGet$1(_, et, {});
		for (const it in rt) (it in tt && tt[it] != null) || (nt[it] = rt[it]);
		return nt;
	},
	others = {
		srOnly: {
			transform(_) {
				return _ === !0 ? srOnly : _ === "focusable" ? srFocusable : {};
			},
		},
		layerStyle: { processResult: !0, transform: (_, et, tt) => getWithPriority(et, `layerStyles.${_}`, tt) },
		textStyle: { processResult: !0, transform: (_, et, tt) => getWithPriority(et, `textStyles.${_}`, tt) },
		apply: { processResult: !0, transform: (_, et, tt) => getWithPriority(et, _, tt) },
	},
	position$2 = {
		position: !0,
		pos: t$2.prop("position"),
		zIndex: t$2.prop("zIndex", "zIndices"),
		inset: t$2.spaceT("inset"),
		insetX: t$2.spaceT(["left", "right"]),
		insetInline: t$2.spaceT("insetInline"),
		insetY: t$2.spaceT(["top", "bottom"]),
		insetBlock: t$2.spaceT("insetBlock"),
		top: t$2.spaceT("top"),
		insetBlockStart: t$2.spaceT("insetBlockStart"),
		bottom: t$2.spaceT("bottom"),
		insetBlockEnd: t$2.spaceT("insetBlockEnd"),
		left: t$2.spaceT("left"),
		insetInlineStart: t$2.logical({ scale: "space", property: { ltr: "left", rtl: "right" } }),
		right: t$2.spaceT("right"),
		insetInlineEnd: t$2.logical({ scale: "space", property: { ltr: "right", rtl: "left" } }),
	};
Object.assign(position$2, { insetStart: position$2.insetInlineStart, insetEnd: position$2.insetInlineEnd });
var ring = {
		ring: { transform: transformFunctions.ring },
		ringColor: t$2.colors("--chakra-ring-color"),
		ringOffset: t$2.prop("--chakra-ring-offset-width"),
		ringOffsetColor: t$2.colors("--chakra-ring-offset-color"),
		ringInset: t$2.prop("--chakra-ring-inset"),
	},
	space$1 = {
		margin: t$2.spaceT("margin"),
		marginTop: t$2.spaceT("marginTop"),
		marginBlockStart: t$2.spaceT("marginBlockStart"),
		marginRight: t$2.spaceT("marginRight"),
		marginInlineEnd: t$2.spaceT("marginInlineEnd"),
		marginBottom: t$2.spaceT("marginBottom"),
		marginBlockEnd: t$2.spaceT("marginBlockEnd"),
		marginLeft: t$2.spaceT("marginLeft"),
		marginInlineStart: t$2.spaceT("marginInlineStart"),
		marginX: t$2.spaceT(["marginInlineStart", "marginInlineEnd"]),
		marginInline: t$2.spaceT("marginInline"),
		marginY: t$2.spaceT(["marginTop", "marginBottom"]),
		marginBlock: t$2.spaceT("marginBlock"),
		padding: t$2.space("padding"),
		paddingTop: t$2.space("paddingTop"),
		paddingBlockStart: t$2.space("paddingBlockStart"),
		paddingRight: t$2.space("paddingRight"),
		paddingBottom: t$2.space("paddingBottom"),
		paddingBlockEnd: t$2.space("paddingBlockEnd"),
		paddingLeft: t$2.space("paddingLeft"),
		paddingInlineStart: t$2.space("paddingInlineStart"),
		paddingInlineEnd: t$2.space("paddingInlineEnd"),
		paddingX: t$2.space(["paddingInlineStart", "paddingInlineEnd"]),
		paddingInline: t$2.space("paddingInline"),
		paddingY: t$2.space(["paddingTop", "paddingBottom"]),
		paddingBlock: t$2.space("paddingBlock"),
	};
Object.assign(space$1, {
	m: space$1.margin,
	mt: space$1.marginTop,
	mr: space$1.marginRight,
	me: space$1.marginInlineEnd,
	marginEnd: space$1.marginInlineEnd,
	mb: space$1.marginBottom,
	ml: space$1.marginLeft,
	ms: space$1.marginInlineStart,
	marginStart: space$1.marginInlineStart,
	mx: space$1.marginX,
	my: space$1.marginY,
	p: space$1.padding,
	pt: space$1.paddingTop,
	py: space$1.paddingY,
	px: space$1.paddingX,
	pb: space$1.paddingBottom,
	pl: space$1.paddingLeft,
	ps: space$1.paddingInlineStart,
	paddingStart: space$1.paddingInlineStart,
	pr: space$1.paddingRight,
	pe: space$1.paddingInlineEnd,
	paddingEnd: space$1.paddingInlineEnd,
});
var textDecoration = {
		textDecorationColor: t$2.colors("textDecorationColor"),
		textDecoration: !0,
		textDecor: { property: "textDecoration" },
		textDecorationLine: !0,
		textDecorationStyle: !0,
		textDecorationThickness: !0,
		textUnderlineOffset: !0,
		textShadow: t$2.shadows("textShadow"),
	},
	transform = {
		clipPath: !0,
		transform: t$2.propT("transform", transformFunctions.transform),
		transformOrigin: !0,
		translateX: t$2.spaceT("--chakra-translate-x"),
		translateY: t$2.spaceT("--chakra-translate-y"),
		skewX: t$2.degreeT("--chakra-skew-x"),
		skewY: t$2.degreeT("--chakra-skew-y"),
		scaleX: t$2.prop("--chakra-scale-x"),
		scaleY: t$2.prop("--chakra-scale-y"),
		scale: t$2.prop(["--chakra-scale-x", "--chakra-scale-y"]),
		rotate: t$2.degreeT("--chakra-rotate"),
	},
	transition$1 = {
		transition: !0,
		transitionDelay: !0,
		animation: !0,
		willChange: !0,
		transitionDuration: t$2.prop("transitionDuration", "transition.duration"),
		transitionProperty: t$2.prop("transitionProperty", "transition.property"),
		transitionTimingFunction: t$2.prop("transitionTimingFunction", "transition.easing"),
	},
	typography$1 = {
		fontFamily: t$2.prop("fontFamily", "fonts"),
		fontSize: t$2.prop("fontSize", "fontSizes", transformFunctions.px),
		fontWeight: t$2.prop("fontWeight", "fontWeights"),
		lineHeight: t$2.prop("lineHeight", "lineHeights"),
		letterSpacing: t$2.prop("letterSpacing", "letterSpacings"),
		textAlign: !0,
		fontStyle: !0,
		wordBreak: !0,
		overflowWrap: !0,
		textOverflow: !0,
		textTransform: !0,
		whiteSpace: !0,
		noOfLines: {
			static: {
				overflow: "hidden",
				textOverflow: "ellipsis",
				display: "-webkit-box",
				WebkitBoxOrient: "vertical",
				WebkitLineClamp: "var(--chakra-line-clamp)",
			},
			property: "--chakra-line-clamp",
		},
	},
	scroll = {
		scrollBehavior: !0,
		scrollSnapAlign: !0,
		scrollSnapStop: !0,
		scrollSnapType: !0,
		scrollMargin: t$2.spaceT("scrollMargin"),
		scrollMarginTop: t$2.spaceT("scrollMarginTop"),
		scrollMarginBottom: t$2.spaceT("scrollMarginBottom"),
		scrollMarginLeft: t$2.spaceT("scrollMarginLeft"),
		scrollMarginRight: t$2.spaceT("scrollMarginRight"),
		scrollMarginX: t$2.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
		scrollMarginY: t$2.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
		scrollPadding: t$2.spaceT("scrollPadding"),
		scrollPaddingTop: t$2.spaceT("scrollPaddingTop"),
		scrollPaddingBottom: t$2.spaceT("scrollPaddingBottom"),
		scrollPaddingLeft: t$2.spaceT("scrollPaddingLeft"),
		scrollPaddingRight: t$2.spaceT("scrollPaddingRight"),
		scrollPaddingX: t$2.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
		scrollPaddingY: t$2.spaceT(["scrollPaddingTop", "scrollPaddingBottom"]),
	};
function resolveReference(_) {
	return isObject$6(_) && _.reference ? _.reference : String(_);
}
var toExpression = (_, ...et) => et.map(resolveReference).join(` ${_} `).replace(/calc/g, ""),
	add$1 = (..._) => `calc(${toExpression("+", ..._)})`,
	subtract$1 = (..._) => `calc(${toExpression("-", ..._)})`,
	multiply$1 = (..._) => `calc(${toExpression("*", ..._)})`,
	divide$1 = (..._) => `calc(${toExpression("/", ..._)})`,
	negate$1 = (_) => {
		const et = resolveReference(_);
		return et != null && !Number.isNaN(parseFloat(et))
			? String(et).startsWith("-")
				? String(et).slice(1)
				: `-${et}`
			: multiply$1(et, -1);
	},
	calc$1 = Object.assign(
		(_) => ({
			add: (...et) => calc$1(add$1(_, ...et)),
			subtract: (...et) => calc$1(subtract$1(_, ...et)),
			multiply: (...et) => calc$1(multiply$1(_, ...et)),
			divide: (...et) => calc$1(divide$1(_, ...et)),
			negate: () => calc$1(negate$1(_)),
			toString: () => _.toString(),
		}),
		{ add: add$1, subtract: subtract$1, multiply: multiply$1, divide: divide$1, negate: negate$1 }
	);
function replaceWhiteSpace$1(_, et = "-") {
	return _.replace(/\s+/g, et);
}
function escape$1(_) {
	const et = replaceWhiteSpace$1(_.toString());
	return escapeSymbol(escapeDot(et));
}
function escapeDot(_) {
	return _.includes("\\.") ? _ : !Number.isInteger(parseFloat(_.toString())) ? _.replace(".", "\\.") : _;
}
function escapeSymbol(_) {
	return _.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function addPrefix$1(_, et = "") {
	return [et, _].filter(Boolean).join("-");
}
function toVarReference(_, et) {
	return `var(${_}${et ? `, ${et}` : ""})`;
}
function toVarDefinition(_, et = "") {
	return escape$1(`--${addPrefix$1(_, et)}`);
}
function cssVar$1(_, et, tt) {
	const nt = toVarDefinition(_, tt);
	return { variable: nt, reference: toVarReference(nt, et) };
}
function isObject2(_) {
	const et = typeof _;
	return _ != null && (et === "object" || et === "function") && !Array.isArray(_);
}
Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);
function getLastItem(_) {
	const et = _ == null ? 0 : _.length;
	return et ? _[et - 1] : void 0;
}
function analyzeCSSValue2(_) {
	const et = parseFloat(_.toString()),
		tt = _.toString().replace(String(et), "");
	return { unitless: !tt, value: et, unit: tt };
}
function px$2(_) {
	if (_ == null) return _;
	const { unitless: et } = analyzeCSSValue2(_);
	return et || typeof _ == "number" ? `${_}px` : _;
}
var sortByBreakpointValue = (_, et) => (parseInt(_[1], 10) > parseInt(et[1], 10) ? 1 : -1),
	sortBps = (_) => Object.fromEntries(Object.entries(_).sort(sortByBreakpointValue));
function normalize$3(_) {
	const et = sortBps(_);
	return Object.assign(Object.values(et), et);
}
function keys$1(_) {
	const et = Object.keys(sortBps(_));
	return new Set(et);
}
function subtract2(_) {
	var tt;
	if (!_) return _;
	_ = (tt = px$2(_)) != null ? tt : _;
	const et = _.endsWith("px") ? -1 : -0.0625;
	return typeof _ == "number" ? `${_ + et}` : _.replace(/(\d+\.?\d*)/u, (nt) => `${parseFloat(nt) + et}`);
}
function toMediaQueryString(_, et) {
	const tt = ["@media screen"];
	return _ && tt.push("and", `(min-width: ${px$2(_)})`), et && tt.push("and", `(max-width: ${px$2(et)})`), tt.join(" ");
}
function analyzeBreakpoints(_) {
	var it;
	if (!_) return null;
	_.base = (it = _.base) != null ? it : "0px";
	const et = normalize$3(_),
		tt = Object.entries(_)
			.sort(sortByBreakpointValue)
			.map(([ot, at], st, lt) => {
				var dt;
				let [, ut] = (dt = lt[st + 1]) != null ? dt : [];
				return (
					(ut = parseFloat(ut) > 0 ? subtract2(ut) : void 0),
					{
						_minW: subtract2(at),
						breakpoint: ot,
						minW: at,
						maxW: ut,
						maxWQuery: toMediaQueryString(null, ut),
						minWQuery: toMediaQueryString(at),
						minMaxQuery: toMediaQueryString(at, ut),
					}
				);
			}),
		nt = keys$1(_),
		rt = Array.from(nt.values());
	return {
		keys: nt,
		normalized: et,
		isResponsive(ot) {
			const at = Object.keys(ot);
			return at.length > 0 && at.every((st) => nt.has(st));
		},
		asObject: sortBps(_),
		asArray: normalize$3(_),
		details: tt,
		media: [null, ...et.map((ot) => toMediaQueryString(ot)).slice(1)],
		toArrayValue(ot) {
			if (!isObject2(ot)) throw new Error("toArrayValue: value must be an object");
			const at = rt.map((st) => {
				var lt;
				return (lt = ot[st]) != null ? lt : null;
			});
			for (; getLastItem(at) === null; ) at.pop();
			return at;
		},
		toObjectValue(ot) {
			if (!Array.isArray(ot)) throw new Error("toObjectValue: value must be an array");
			return ot.reduce((at, st, lt) => {
				const ut = rt[lt];
				return ut != null && st != null && (at[ut] = st), at;
			}, {});
		},
	};
}
var state = {
		hover: (_, et) => `${_}:hover ${et}, ${_}[data-hover] ${et}`,
		focus: (_, et) => `${_}:focus ${et}, ${_}[data-focus] ${et}`,
		focusVisible: (_, et) => `${_}:focus-visible ${et}`,
		focusWithin: (_, et) => `${_}:focus-within ${et}`,
		active: (_, et) => `${_}:active ${et}, ${_}[data-active] ${et}`,
		disabled: (_, et) => `${_}:disabled ${et}, ${_}[data-disabled] ${et}`,
		invalid: (_, et) => `${_}:invalid ${et}, ${_}[data-invalid] ${et}`,
		checked: (_, et) => `${_}:checked ${et}, ${_}[data-checked] ${et}`,
		indeterminate: (_, et) =>
			`${_}:indeterminate ${et}, ${_}[aria-checked=mixed] ${et}, ${_}[data-indeterminate] ${et}`,
		readOnly: (_, et) => `${_}:read-only ${et}, ${_}[readonly] ${et}, ${_}[data-read-only] ${et}`,
		expanded: (_, et) => `${_}:read-only ${et}, ${_}[aria-expanded=true] ${et}, ${_}[data-expanded] ${et}`,
		placeholderShown: (_, et) => `${_}:placeholder-shown ${et}`,
	},
	toGroup = (_) => merge$2((et) => _(et, "&"), "[role=group]", "[data-group]", ".group"),
	toPeer = (_) => merge$2((et) => _(et, "~ &"), "[data-peer]", ".peer"),
	merge$2 = (_, ...et) => et.map(_).join(", "),
	pseudoSelectors = {
		_hover: "&:hover, &[data-hover]",
		_active: "&:active, &[data-active]",
		_focus: "&:focus, &[data-focus]",
		_highlighted: "&[data-highlighted]",
		_focusWithin: "&:focus-within",
		_focusVisible: "&:focus-visible, &[data-focus-visible]",
		_disabled: "&[disabled], &[aria-disabled=true], &[data-disabled]",
		_readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
		_before: "&::before",
		_after: "&::after",
		_empty: "&:empty",
		_expanded: "&[aria-expanded=true], &[data-expanded]",
		_checked: "&[aria-checked=true], &[data-checked]",
		_grabbed: "&[aria-grabbed=true], &[data-grabbed]",
		_pressed: "&[aria-pressed=true], &[data-pressed]",
		_invalid: "&[aria-invalid=true], &[data-invalid]",
		_valid: "&[data-valid], &[data-state=valid]",
		_loading: "&[data-loading], &[aria-busy=true]",
		_selected: "&[aria-selected=true], &[data-selected]",
		_hidden: "&[hidden], &[data-hidden]",
		_autofill: "&:-webkit-autofill",
		_even: "&:nth-of-type(even)",
		_odd: "&:nth-of-type(odd)",
		_first: "&:first-of-type",
		_last: "&:last-of-type",
		_notFirst: "&:not(:first-of-type)",
		_notLast: "&:not(:last-of-type)",
		_visited: "&:visited",
		_activeLink: "&[aria-current=page]",
		_activeStep: "&[aria-current=step]",
		_indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
		_groupHover: toGroup(state.hover),
		_peerHover: toPeer(state.hover),
		_groupFocus: toGroup(state.focus),
		_peerFocus: toPeer(state.focus),
		_groupFocusVisible: toGroup(state.focusVisible),
		_peerFocusVisible: toPeer(state.focusVisible),
		_groupActive: toGroup(state.active),
		_peerActive: toPeer(state.active),
		_groupDisabled: toGroup(state.disabled),
		_peerDisabled: toPeer(state.disabled),
		_groupInvalid: toGroup(state.invalid),
		_peerInvalid: toPeer(state.invalid),
		_groupChecked: toGroup(state.checked),
		_peerChecked: toPeer(state.checked),
		_groupFocusWithin: toGroup(state.focusWithin),
		_peerFocusWithin: toPeer(state.focusWithin),
		_peerPlaceholderShown: toPeer(state.placeholderShown),
		_placeholder: "&::placeholder",
		_placeholderShown: "&:placeholder-shown",
		_fullScreen: "&:fullscreen",
		_selection: "&::selection",
		_rtl: "[dir=rtl] &, &[dir=rtl]",
		_ltr: "[dir=ltr] &, &[dir=ltr]",
		_mediaDark: "@media (prefers-color-scheme: dark)",
		_mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
		_dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
		_light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
	},
	pseudoPropNames = Object.keys(pseudoSelectors);
function tokenToCssVar(_, et) {
	return cssVar$1(String(_).replace(/\./g, "-"), void 0, et);
}
function createThemeVars(_, et) {
	let tt = {};
	const nt = {};
	for (const [rt, it] of Object.entries(_)) {
		const { isSemantic: ot, value: at } = it,
			{ variable: st, reference: lt } = tokenToCssVar(rt, et == null ? void 0 : et.cssVarPrefix);
		if (!ot) {
			if (rt.startsWith("space")) {
				const ct = rt.split("."),
					[ft, ...mt] = ct,
					pt = `${ft}.-${mt.join(".")}`,
					vt = calc$1.negate(at),
					ht = calc$1.negate(lt);
				nt[pt] = { value: vt, var: st, varRef: ht };
			}
			(tt[st] = at), (nt[rt] = { value: at, var: st, varRef: lt });
			continue;
		}
		const ut = (ct) => {
				const mt = [String(rt).split(".")[0], ct].join(".");
				if (!_[mt]) return ct;
				const { reference: vt } = tokenToCssVar(mt, et == null ? void 0 : et.cssVarPrefix);
				return vt;
			},
			dt = isObject$6(at) ? at : { default: at };
		(tt = mergeWith(
			tt,
			Object.entries(dt).reduce((ct, [ft, mt]) => {
				var gt;
				var pt;
				const vt = ut(mt);
				if (ft === "default") return (ct[st] = vt), ct;
				const ht = (gt = (pt = pseudoSelectors) == null ? void 0 : pt[ft]) != null ? gt : ft;
				return (ct[ht] = { [st]: vt }), ct;
			}, {})
		)),
			(nt[rt] = { value: lt, var: st, varRef: lt });
	}
	return { cssVars: tt, cssMap: nt };
}
function omit$3(_, et = []) {
	const tt = Object.assign({}, _);
	for (const nt of et) nt in tt && delete tt[nt];
	return tt;
}
function pick(_, et) {
	const tt = {};
	for (const nt of et) nt in _ && (tt[nt] = _[nt]);
	return tt;
}
var tokens = [
	"colors",
	"borders",
	"borderWidths",
	"borderStyles",
	"fonts",
	"fontSizes",
	"fontWeights",
	"letterSpacings",
	"lineHeights",
	"radii",
	"space",
	"shadows",
	"sizes",
	"zIndices",
	"transition",
	"blur",
];
function extractTokens(_) {
	return pick(_, tokens);
}
function extractSemanticTokens(_) {
	return _.semanticTokens;
}
function omitVars(_) {
	const { __cssMap: et, __cssVars: tt, __breakpoints: nt, ...rt } = _;
	return rt;
}
function flattenTokens({ tokens: _, semanticTokens: et }) {
	var rt, it;
	const tt = Object.entries((rt = flatten(_)) != null ? rt : {}).map(([ot, at]) => [ot, { isSemantic: !1, value: at }]),
		nt = Object.entries((it = flatten(et, 1)) != null ? it : {}).map(([ot, at]) => [ot, { isSemantic: !0, value: at }]);
	return Object.fromEntries([...tt, ...nt]);
}
function flatten(_, et = 1 / 0) {
	return (!isObject$6(_) && !Array.isArray(_)) || !et
		? _
		: Object.entries(_).reduce(
				(tt, [nt, rt]) => (
					isObject$6(rt) || Array.isArray(rt)
						? Object.entries(flatten(rt, et - 1)).forEach(([it, ot]) => {
								tt[`${nt}.${it}`] = ot;
						  })
						: (tt[nt] = rt),
					tt
				),
				{}
		  );
}
function toCSSVar(_) {
	var et;
	const tt = omitVars(_),
		nt = extractTokens(tt),
		rt = extractSemanticTokens(tt),
		it = flattenTokens({ tokens: nt, semanticTokens: rt }),
		ot = (et = tt.config) == null ? void 0 : et.cssVarPrefix,
		{ cssMap: at, cssVars: st } = createThemeVars(it, { cssVarPrefix: ot });
	return (
		Object.assign(tt, {
			__cssVars: {
				...{
					"--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
					"--chakra-ring-offset-width": "0px",
					"--chakra-ring-offset-color": "#fff",
					"--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
					"--chakra-ring-offset-shadow": "0 0 #0000",
					"--chakra-ring-shadow": "0 0 #0000",
					"--chakra-space-x-reverse": "0",
					"--chakra-space-y-reverse": "0",
				},
				...st,
			},
			__cssMap: at,
			__breakpoints: analyzeBreakpoints(tt.breakpoints),
		}),
		tt
	);
}
var systemProps = mergeWith(
	{},
	background,
	border,
	color$2,
	flexbox,
	layout,
	filter$2,
	ring,
	interactivity,
	grid,
	others,
	position$2,
	effect$3,
	space$1,
	scroll,
	typography$1,
	textDecoration,
	transform,
	list$2,
	transition$1
);
Object.assign({}, space$1, layout, flexbox, grid, position$2);
var propNames = [...Object.keys(systemProps), ...pseudoPropNames],
	styleProps = { ...systemProps, ...pseudoSelectors },
	isStyleProp = (_) => _ in styleProps;
function isCssVar2(_) {
	return /^var\(--.+\)$/.test(_);
}
var isCSSVariableTokenValue = (_, et) => _.startsWith("--") && typeof et == "string" && !isCssVar2(et),
	resolveTokenValue = (_, et) => {
		var at, st;
		if (et == null) return et;
		const tt = (lt) => {
				var ut, dt;
				return (dt = (ut = _.__cssMap) == null ? void 0 : ut[lt]) == null ? void 0 : dt.varRef;
			},
			nt = (lt) => {
				var ut;
				return (ut = tt(lt)) != null ? ut : lt;
			},
			rt = et.split(",").map((lt) => lt.trim()),
			[it, ot] = rt;
		return (et = (st = (at = tt(it)) != null ? at : nt(ot)) != null ? st : nt(et)), et;
	};
function getCss(_) {
	const { configs: et = {}, pseudos: tt = {}, theme: nt } = _;
	if (!nt.__breakpoints) return () => ({});
	const { isResponsive: rt, toArrayValue: it, media: ot } = nt.__breakpoints,
		at = (st, lt = !1) => {
			var ft, mt;
			var ut;
			const dt = runIfFn$5(st, nt);
			let ct = {};
			for (let pt in dt) {
				let vt = runIfFn$5(dt[pt], nt);
				if (vt == null) continue;
				if (Array.isArray(vt) || (isObject$6(vt) && rt(vt))) {
					let xt = Array.isArray(vt) ? vt : it(vt);
					xt = xt.slice(0, ot.length);
					for (let St = 0; St < xt.length; St++) {
						const wt = ot[St],
							Ct = xt[St];
						wt
							? Ct == null
								? (ft = ct[wt]) != null || (ct[wt] = {})
								: (ct[wt] = Object.assign({}, ct[wt], at({ [pt]: Ct }, !0)))
							: (ct = Object.assign({}, ct, at({ ...dt, [pt]: Ct }, !1)));
					}
					continue;
				}
				if (
					(pt in tt && (pt = tt[pt]),
					isCSSVariableTokenValue(pt, vt) && (vt = resolveTokenValue(nt, vt)),
					isObject$6(vt))
				) {
					ct[pt] = Object.assign({}, ct[pt], at(vt, !0));
					continue;
				}
				let ht = et[pt];
				if ((ht === !0 && (ht = { property: pt }), !lt && (ht == null ? void 0 : ht.static))) {
					const xt = runIfFn$5(ht.static, nt);
					ct = Object.assign({}, ct, xt);
				}
				let gt =
					(mt = (ut = ht == null ? void 0 : ht.transform) == null ? void 0 : ut.call(ht, vt, nt, dt)) != null ? mt : vt;
				if (((gt = ht != null && ht.processResult ? at(gt, !0) : gt), isObject$6(gt))) {
					ct = Object.assign({}, ct, gt);
					continue;
				}
				const yt = runIfFn$5(ht == null ? void 0 : ht.property, nt);
				if (yt) {
					if (Array.isArray(yt)) {
						for (const xt of yt) ct[xt] = gt;
						continue;
					}
					yt === "&" && isObject$6(gt) ? (ct = Object.assign({}, ct, gt)) : (ct[yt] = gt);
					continue;
				}
				ct[pt] = gt;
			}
			return ct;
		};
	return at;
}
var css$1 = (_) => (et) => getCss({ theme: et, pseudos: pseudoSelectors, configs: systemProps })(_);
function defineStyle(_) {
	return _;
}
function defineStyleConfig(_) {
	return _;
}
function createMultiStyleConfigHelpers(_) {
	return {
		definePartsStyle(et) {
			return et;
		},
		defineMultiStyleConfig(et) {
			return { parts: _, ...et };
		},
	};
}
function normalize2(_, et) {
	if (Array.isArray(_)) return _;
	if (isObject$6(_)) return et(_);
	if (_ != null) return [_];
}
function getNextIndex$1(_, et) {
	for (let tt = et + 1; tt < _.length; tt++) if (_[tt] != null) return tt;
	return -1;
}
function createResolver$1(_) {
	const et = _.__breakpoints;
	return function (nt, rt, it, ot) {
		var at, st;
		if (!et) return;
		const lt = {},
			ut = normalize2(it, et.toArrayValue);
		if (!ut) return lt;
		const dt = ut.length,
			ct = dt === 1,
			ft = !!nt.parts;
		for (let mt = 0; mt < dt; mt++) {
			const pt = et.details[mt],
				vt = et.details[getNextIndex$1(ut, mt)],
				ht = toMediaQueryString(pt.minW, vt == null ? void 0 : vt._minW),
				gt = runIfFn$5((at = nt[rt]) == null ? void 0 : at[ut[mt]], ot);
			if (!!gt) {
				if (ft) {
					(st = nt.parts) == null ||
						st.forEach((yt) => {
							mergeWith(lt, { [yt]: ct ? gt[yt] : { [ht]: gt[yt] } });
						});
					continue;
				}
				if (!ft) {
					ct ? mergeWith(lt, gt) : (lt[ht] = gt);
					continue;
				}
				lt[ht] = gt;
			}
		}
		return lt;
	};
}
function resolveStyleConfig(_) {
	return (et) => {
		var ot;
		const { variant: tt, size: nt, theme: rt } = et,
			it = createResolver$1(rt);
		return mergeWith(
			{},
			runIfFn$5((ot = _.baseStyle) != null ? ot : {}, et),
			it(_, "sizes", nt, et),
			it(_, "variants", tt, et)
		);
	};
}
function omitThemingProps(_) {
	return omit$3(_, ["styleConfig", "size", "variant", "colorScheme"]);
}
function sheetForTag(_) {
	if (_.sheet) return _.sheet;
	for (var et = 0; et < document.styleSheets.length; et++)
		if (document.styleSheets[et].ownerNode === _) return document.styleSheets[et];
}
function createStyleElement(_) {
	var et = document.createElement("style");
	return (
		et.setAttribute("data-emotion", _.key),
		_.nonce !== void 0 && et.setAttribute("nonce", _.nonce),
		et.appendChild(document.createTextNode("")),
		et.setAttribute("data-s", ""),
		et
	);
}
var StyleSheet = (function () {
		function _(tt) {
			var nt = this;
			(this._insertTag = function (rt) {
				var it;
				nt.tags.length === 0
					? nt.insertionPoint
						? (it = nt.insertionPoint.nextSibling)
						: nt.prepend
						? (it = nt.container.firstChild)
						: (it = nt.before)
					: (it = nt.tags[nt.tags.length - 1].nextSibling),
					nt.container.insertBefore(rt, it),
					nt.tags.push(rt);
			}),
				(this.isSpeedy = tt.speedy === void 0 ? !0 : tt.speedy),
				(this.tags = []),
				(this.ctr = 0),
				(this.nonce = tt.nonce),
				(this.key = tt.key),
				(this.container = tt.container),
				(this.prepend = tt.prepend),
				(this.insertionPoint = tt.insertionPoint),
				(this.before = null);
		}
		var et = _.prototype;
		return (
			(et.hydrate = function (nt) {
				nt.forEach(this._insertTag);
			}),
			(et.insert = function (nt) {
				this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
				var rt = this.tags[this.tags.length - 1];
				if (this.isSpeedy) {
					var it = sheetForTag(rt);
					try {
						it.insertRule(nt, it.cssRules.length);
					} catch {}
				} else rt.appendChild(document.createTextNode(nt));
				this.ctr++;
			}),
			(et.flush = function () {
				this.tags.forEach(function (nt) {
					return nt.parentNode && nt.parentNode.removeChild(nt);
				}),
					(this.tags = []),
					(this.ctr = 0);
			}),
			_
		);
	})(),
	MS = "-ms-",
	MOZ = "-moz-",
	WEBKIT = "-webkit-",
	COMMENT = "comm",
	RULESET = "rule",
	DECLARATION = "decl",
	IMPORT = "@import",
	KEYFRAMES = "@keyframes",
	abs = Math.abs,
	from = String.fromCharCode,
	assign = Object.assign;
function hash$2(_, et) {
	return (((((((et << 2) ^ charat(_, 0)) << 2) ^ charat(_, 1)) << 2) ^ charat(_, 2)) << 2) ^ charat(_, 3);
}
function trim$2(_) {
	return _.trim();
}
function match(_, et) {
	return (_ = et.exec(_)) ? _[0] : _;
}
function replace(_, et, tt) {
	return _.replace(et, tt);
}
function indexof(_, et) {
	return _.indexOf(et);
}
function charat(_, et) {
	return _.charCodeAt(et) | 0;
}
function substr(_, et, tt) {
	return _.slice(et, tt);
}
function strlen(_) {
	return _.length;
}
function sizeof(_) {
	return _.length;
}
function append$1(_, et) {
	return et.push(_), _;
}
function combine(_, et) {
	return _.map(et).join("");
}
var line = 1,
	column = 1,
	length = 0,
	position$1 = 0,
	character = 0,
	characters = "";
function node$1(_, et, tt, nt, rt, it, ot) {
	return { value: _, root: et, parent: tt, type: nt, props: rt, children: it, line, column, length: ot, return: "" };
}
function copy(_, et) {
	return assign(node$1("", null, null, "", null, null, 0), _, { length: -_.length }, et);
}
function char() {
	return character;
}
function prev() {
	return (
		(character = position$1 > 0 ? charat(characters, --position$1) : 0),
		column--,
		character === 10 && ((column = 1), line--),
		character
	);
}
function next() {
	return (
		(character = position$1 < length ? charat(characters, position$1++) : 0),
		column++,
		character === 10 && ((column = 1), line++),
		character
	);
}
function peek() {
	return charat(characters, position$1);
}
function caret() {
	return position$1;
}
function slice(_, et) {
	return substr(characters, _, et);
}
function token(_) {
	switch (_) {
		case 0:
		case 9:
		case 10:
		case 13:
		case 32:
			return 5;
		case 33:
		case 43:
		case 44:
		case 47:
		case 62:
		case 64:
		case 126:
		case 59:
		case 123:
		case 125:
			return 4;
		case 58:
			return 3;
		case 34:
		case 39:
		case 40:
		case 91:
			return 2;
		case 41:
		case 93:
			return 1;
	}
	return 0;
}
function alloc(_) {
	return (line = column = 1), (length = strlen((characters = _))), (position$1 = 0), [];
}
function dealloc(_) {
	return (characters = ""), _;
}
function delimit(_) {
	return trim$2(slice(position$1 - 1, delimiter(_ === 91 ? _ + 2 : _ === 40 ? _ + 1 : _)));
}
function whitespace$1(_) {
	for (; (character = peek()) && character < 33; ) next();
	return token(_) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(_, et) {
	for (
		;
		--et &&
		next() &&
		!(character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97));

	);
	return slice(_, caret() + (et < 6 && peek() == 32 && next() == 32));
}
function delimiter(_) {
	for (; next(); )
		switch (character) {
			case _:
				return position$1;
			case 34:
			case 39:
				_ !== 34 && _ !== 39 && delimiter(character);
				break;
			case 40:
				_ === 41 && delimiter(_);
				break;
			case 92:
				next();
				break;
		}
	return position$1;
}
function commenter(_, et) {
	for (; next() && _ + character !== 47 + 10; ) if (_ + character === 42 + 42 && peek() === 47) break;
	return "/*" + slice(et, position$1 - 1) + "*" + from(_ === 47 ? _ : next());
}
function identifier(_) {
	for (; !token(peek()); ) next();
	return slice(_, position$1);
}
function compile(_) {
	return dealloc(parse$4("", null, null, null, [""], (_ = alloc(_)), 0, [0], _));
}
function parse$4(_, et, tt, nt, rt, it, ot, at, st) {
	for (
		var lt = 0,
			ut = 0,
			dt = ot,
			ct = 0,
			ft = 0,
			mt = 0,
			pt = 1,
			vt = 1,
			ht = 1,
			gt = 0,
			yt = "",
			xt = rt,
			St = it,
			wt = nt,
			Ct = yt;
		vt;

	)
		switch (((mt = gt), (gt = next()))) {
			case 40:
				if (mt != 108 && Ct.charCodeAt(dt - 1) == 58) {
					indexof((Ct += replace(delimit(gt), "&", "&\f")), "&\f") != -1 && (ht = -1);
					break;
				}
			case 34:
			case 39:
			case 91:
				Ct += delimit(gt);
				break;
			case 9:
			case 10:
			case 13:
			case 32:
				Ct += whitespace$1(mt);
				break;
			case 92:
				Ct += escaping(caret() - 1, 7);
				continue;
			case 47:
				switch (peek()) {
					case 42:
					case 47:
						append$1(comment(commenter(next(), caret()), et, tt), st);
						break;
					default:
						Ct += "/";
				}
				break;
			case 123 * pt:
				at[lt++] = strlen(Ct) * ht;
			case 125 * pt:
			case 59:
			case 0:
				switch (gt) {
					case 0:
					case 125:
						vt = 0;
					case 59 + ut:
						ft > 0 &&
							strlen(Ct) - dt &&
							append$1(
								ft > 32
									? declaration(Ct + ";", nt, tt, dt - 1)
									: declaration(replace(Ct, " ", "") + ";", nt, tt, dt - 2),
								st
							);
						break;
					case 59:
						Ct += ";";
					default:
						if ((append$1((wt = ruleset(Ct, et, tt, lt, ut, rt, at, yt, (xt = []), (St = []), dt)), it), gt === 123))
							if (ut === 0) parse$4(Ct, et, wt, wt, xt, it, dt, at, St);
							else
								switch (ct) {
									case 100:
									case 109:
									case 115:
										parse$4(
											_,
											wt,
											wt,
											nt && append$1(ruleset(_, wt, wt, 0, 0, rt, at, yt, rt, (xt = []), dt), St),
											rt,
											St,
											dt,
											at,
											nt ? xt : St
										);
										break;
									default:
										parse$4(Ct, wt, wt, wt, [""], St, 0, at, St);
								}
				}
				(lt = ut = ft = 0), (pt = ht = 1), (yt = Ct = ""), (dt = ot);
				break;
			case 58:
				(dt = 1 + strlen(Ct)), (ft = mt);
			default:
				if (pt < 1) {
					if (gt == 123) --pt;
					else if (gt == 125 && pt++ == 0 && prev() == 125) continue;
				}
				switch (((Ct += from(gt)), gt * pt)) {
					case 38:
						ht = ut > 0 ? 1 : ((Ct += "\f"), -1);
						break;
					case 44:
						(at[lt++] = (strlen(Ct) - 1) * ht), (ht = 1);
						break;
					case 64:
						peek() === 45 && (Ct += delimit(next())),
							(ct = peek()),
							(ut = dt = strlen((yt = Ct += identifier(caret())))),
							gt++;
						break;
					case 45:
						mt === 45 && strlen(Ct) == 2 && (pt = 0);
				}
		}
	return it;
}
function ruleset(_, et, tt, nt, rt, it, ot, at, st, lt, ut) {
	for (var dt = rt - 1, ct = rt === 0 ? it : [""], ft = sizeof(ct), mt = 0, pt = 0, vt = 0; mt < nt; ++mt)
		for (var ht = 0, gt = substr(_, dt + 1, (dt = abs((pt = ot[mt])))), yt = _; ht < ft; ++ht)
			(yt = trim$2(pt > 0 ? ct[ht] + " " + gt : replace(gt, /&\f/g, ct[ht]))) && (st[vt++] = yt);
	return node$1(_, et, tt, rt === 0 ? RULESET : at, st, lt, ut);
}
function comment(_, et, tt) {
	return node$1(_, et, tt, COMMENT, from(char()), substr(_, 2, -2), 0);
}
function declaration(_, et, tt, nt) {
	return node$1(_, et, tt, DECLARATION, substr(_, 0, nt), substr(_, nt + 1, -1), nt);
}
function prefix(_, et) {
	switch (hash$2(_, et)) {
		case 5103:
			return WEBKIT + "print-" + _ + _;
		case 5737:
		case 4201:
		case 3177:
		case 3433:
		case 1641:
		case 4457:
		case 2921:
		case 5572:
		case 6356:
		case 5844:
		case 3191:
		case 6645:
		case 3005:
		case 6391:
		case 5879:
		case 5623:
		case 6135:
		case 4599:
		case 4855:
		case 4215:
		case 6389:
		case 5109:
		case 5365:
		case 5621:
		case 3829:
			return WEBKIT + _ + _;
		case 5349:
		case 4246:
		case 4810:
		case 6968:
		case 2756:
			return WEBKIT + _ + MOZ + _ + MS + _ + _;
		case 6828:
		case 4268:
			return WEBKIT + _ + MS + _ + _;
		case 6165:
			return WEBKIT + _ + MS + "flex-" + _ + _;
		case 5187:
			return WEBKIT + _ + replace(_, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + _;
		case 5443:
			return WEBKIT + _ + MS + "flex-item-" + replace(_, /flex-|-self/, "") + _;
		case 4675:
			return WEBKIT + _ + MS + "flex-line-pack" + replace(_, /align-content|flex-|-self/, "") + _;
		case 5548:
			return WEBKIT + _ + MS + replace(_, "shrink", "negative") + _;
		case 5292:
			return WEBKIT + _ + MS + replace(_, "basis", "preferred-size") + _;
		case 6060:
			return WEBKIT + "box-" + replace(_, "-grow", "") + WEBKIT + _ + MS + replace(_, "grow", "positive") + _;
		case 4554:
			return WEBKIT + replace(_, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + _;
		case 6187:
			return replace(replace(replace(_, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), _, "") + _;
		case 5495:
		case 3959:
			return replace(_, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
		case 4968:
			return (
				replace(
					replace(_, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"),
					/s.+-b[^;]+/,
					"justify"
				) +
				WEBKIT +
				_ +
				_
			);
		case 4095:
		case 3583:
		case 4068:
		case 2532:
			return replace(_, /(.+)-inline(.+)/, WEBKIT + "$1$2") + _;
		case 8116:
		case 7059:
		case 5753:
		case 5535:
		case 5445:
		case 5701:
		case 4933:
		case 4677:
		case 5533:
		case 5789:
		case 5021:
		case 4765:
			if (strlen(_) - 1 - et > 6)
				switch (charat(_, et + 1)) {
					case 109:
						if (charat(_, et + 4) !== 45) break;
					case 102:
						return (
							replace(
								_,
								/(.+:)(.+)-([^]+)/,
								"$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(_, et + 3) == 108 ? "$3" : "$2-$3")
							) + _
						);
					case 115:
						return ~indexof(_, "stretch") ? prefix(replace(_, "stretch", "fill-available"), et) + _ : _;
				}
			break;
		case 4949:
			if (charat(_, et + 1) !== 115) break;
		case 6444:
			switch (charat(_, strlen(_) - 3 - (~indexof(_, "!important") && 10))) {
				case 107:
					return replace(_, ":", ":" + WEBKIT) + _;
				case 101:
					return (
						replace(
							_,
							/(.+:)([^;!]+)(;|!.+)?/,
							"$1" + WEBKIT + (charat(_, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3"
						) + _
					);
			}
			break;
		case 5936:
			switch (charat(_, et + 11)) {
				case 114:
					return WEBKIT + _ + MS + replace(_, /[svh]\w+-[tblr]{2}/, "tb") + _;
				case 108:
					return WEBKIT + _ + MS + replace(_, /[svh]\w+-[tblr]{2}/, "tb-rl") + _;
				case 45:
					return WEBKIT + _ + MS + replace(_, /[svh]\w+-[tblr]{2}/, "lr") + _;
			}
			return WEBKIT + _ + MS + _ + _;
	}
	return _;
}
function serialize$1(_, et) {
	for (var tt = "", nt = sizeof(_), rt = 0; rt < nt; rt++) tt += et(_[rt], rt, _, et) || "";
	return tt;
}
function stringify$3(_, et, tt, nt) {
	switch (_.type) {
		case IMPORT:
		case DECLARATION:
			return (_.return = _.return || _.value);
		case COMMENT:
			return "";
		case KEYFRAMES:
			return (_.return = _.value + "{" + serialize$1(_.children, nt) + "}");
		case RULESET:
			_.value = _.props.join(",");
	}
	return strlen((tt = serialize$1(_.children, nt))) ? (_.return = _.value + "{" + tt + "}") : "";
}
function middleware(_) {
	var et = sizeof(_);
	return function (tt, nt, rt, it) {
		for (var ot = "", at = 0; at < et; at++) ot += _[at](tt, nt, rt, it) || "";
		return ot;
	};
}
function rulesheet(_) {
	return function (et) {
		et.root || ((et = et.return) && _(et));
	};
}
function prefixer(_, et, tt, nt) {
	if (_.length > -1 && !_.return)
		switch (_.type) {
			case DECLARATION:
				_.return = prefix(_.value, _.length);
				break;
			case KEYFRAMES:
				return serialize$1([copy(_, { value: replace(_.value, "@", "@" + WEBKIT) })], nt);
			case RULESET:
				if (_.length)
					return combine(_.props, function (rt) {
						switch (match(rt, /(::plac\w+|:read-\w+)/)) {
							case ":read-only":
							case ":read-write":
								return serialize$1([copy(_, { props: [replace(rt, /:(read-\w+)/, ":" + MOZ + "$1")] })], nt);
							case "::placeholder":
								return serialize$1(
									[
										copy(_, { props: [replace(rt, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }),
										copy(_, { props: [replace(rt, /:(plac\w+)/, ":" + MOZ + "$1")] }),
										copy(_, { props: [replace(rt, /:(plac\w+)/, MS + "input-$1")] }),
									],
									nt
								);
						}
						return "";
					});
		}
}
var weakMemoize = function (et) {
	var tt = new WeakMap();
	return function (nt) {
		if (tt.has(nt)) return tt.get(nt);
		var rt = et(nt);
		return tt.set(nt, rt), rt;
	};
};
function memoize$1(_) {
	var et = Object.create(null);
	return function (tt) {
		return et[tt] === void 0 && (et[tt] = _(tt)), et[tt];
	};
}
var identifierWithPointTracking = function (et, tt, nt) {
		for (var rt = 0, it = 0; (rt = it), (it = peek()), rt === 38 && it === 12 && (tt[nt] = 1), !token(it); ) next();
		return slice(et, position$1);
	},
	toRules = function (et, tt) {
		var nt = -1,
			rt = 44;
		do
			switch (token(rt)) {
				case 0:
					rt === 38 && peek() === 12 && (tt[nt] = 1), (et[nt] += identifierWithPointTracking(position$1 - 1, tt, nt));
					break;
				case 2:
					et[nt] += delimit(rt);
					break;
				case 4:
					if (rt === 44) {
						(et[++nt] = peek() === 58 ? "&\f" : ""), (tt[nt] = et[nt].length);
						break;
					}
				default:
					et[nt] += from(rt);
			}
		while ((rt = next()));
		return et;
	},
	getRules = function (et, tt) {
		return dealloc(toRules(alloc(et), tt));
	},
	fixedElements = new WeakMap(),
	compat = function (et) {
		if (!(et.type !== "rule" || !et.parent || et.length < 1)) {
			for (var tt = et.value, nt = et.parent, rt = et.column === nt.column && et.line === nt.line; nt.type !== "rule"; )
				if (((nt = nt.parent), !nt)) return;
			if (!(et.props.length === 1 && tt.charCodeAt(0) !== 58 && !fixedElements.get(nt)) && !rt) {
				fixedElements.set(et, !0);
				for (var it = [], ot = getRules(tt, it), at = nt.props, st = 0, lt = 0; st < ot.length; st++)
					for (var ut = 0; ut < at.length; ut++, lt++)
						et.props[lt] = it[st] ? ot[st].replace(/&\f/g, at[ut]) : at[ut] + " " + ot[st];
			}
		}
	},
	removeLabel = function (et) {
		if (et.type === "decl") {
			var tt = et.value;
			tt.charCodeAt(0) === 108 && tt.charCodeAt(2) === 98 && ((et.return = ""), (et.value = ""));
		}
	},
	defaultStylisPlugins = [prefixer],
	createCache = function (et) {
		var tt = et.key;
		if (tt === "css") {
			var nt = document.querySelectorAll("style[data-emotion]:not([data-s])");
			Array.prototype.forEach.call(nt, function (pt) {
				var vt = pt.getAttribute("data-emotion");
				vt.indexOf(" ") !== -1 && (document.head.appendChild(pt), pt.setAttribute("data-s", ""));
			});
		}
		var rt = et.stylisPlugins || defaultStylisPlugins,
			it = {},
			ot,
			at = [];
		(ot = et.container || document.head),
			Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + tt + ' "]'), function (pt) {
				for (var vt = pt.getAttribute("data-emotion").split(" "), ht = 1; ht < vt.length; ht++) it[vt[ht]] = !0;
				at.push(pt);
			});
		var st,
			lt = [compat, removeLabel];
		{
			var ut,
				dt = [
					stringify$3,
					rulesheet(function (pt) {
						ut.insert(pt);
					}),
				],
				ct = middleware(lt.concat(rt, dt)),
				ft = function (vt) {
					return serialize$1(compile(vt), ct);
				};
			st = function (vt, ht, gt, yt) {
				(ut = gt), ft(vt ? vt + "{" + ht.styles + "}" : ht.styles), yt && (mt.inserted[ht.name] = !0);
			};
		}
		var mt = {
			key: tt,
			sheet: new StyleSheet({
				key: tt,
				container: ot,
				nonce: et.nonce,
				speedy: et.speedy,
				prepend: et.prepend,
				insertionPoint: et.insertionPoint,
			}),
			nonce: et.nonce,
			inserted: it,
			registered: {},
			insert: st,
		};
		return mt.sheet.hydrate(at), mt;
	};
function _extends$1() {
	return (
		(_extends$1 = Object.assign
			? Object.assign.bind()
			: function (_) {
					for (var et = 1; et < arguments.length; et++) {
						var tt = arguments[et];
						for (var nt in tt) Object.prototype.hasOwnProperty.call(tt, nt) && (_[nt] = tt[nt]);
					}
					return _;
			  }),
		_extends$1.apply(this, arguments)
	);
}
var reactIs$2 = { exports: {} },
	reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b$2 = typeof Symbol == "function" && Symbol.for,
	c$2 = b$2 ? Symbol.for("react.element") : 60103,
	d$1 = b$2 ? Symbol.for("react.portal") : 60106,
	e$3 = b$2 ? Symbol.for("react.fragment") : 60107,
	f$1 = b$2 ? Symbol.for("react.strict_mode") : 60108,
	g$1 = b$2 ? Symbol.for("react.profiler") : 60114,
	h$2 = b$2 ? Symbol.for("react.provider") : 60109,
	k$2 = b$2 ? Symbol.for("react.context") : 60110,
	l$2 = b$2 ? Symbol.for("react.async_mode") : 60111,
	m$3 = b$2 ? Symbol.for("react.concurrent_mode") : 60111,
	n$1 = b$2 ? Symbol.for("react.forward_ref") : 60112,
	p$4 = b$2 ? Symbol.for("react.suspense") : 60113,
	q$2 = b$2 ? Symbol.for("react.suspense_list") : 60120,
	r$3 = b$2 ? Symbol.for("react.memo") : 60115,
	t$1 = b$2 ? Symbol.for("react.lazy") : 60116,
	v$2 = b$2 ? Symbol.for("react.block") : 60121,
	w$1 = b$2 ? Symbol.for("react.fundamental") : 60117,
	x$1 = b$2 ? Symbol.for("react.responder") : 60118,
	y$2 = b$2 ? Symbol.for("react.scope") : 60119;
function z$1(_) {
	if (typeof _ == "object" && _ !== null) {
		var et = _.$$typeof;
		switch (et) {
			case c$2:
				switch (((_ = _.type), _)) {
					case l$2:
					case m$3:
					case e$3:
					case g$1:
					case f$1:
					case p$4:
						return _;
					default:
						switch (((_ = _ && _.$$typeof), _)) {
							case k$2:
							case n$1:
							case t$1:
							case r$3:
							case h$2:
								return _;
							default:
								return et;
						}
				}
			case d$1:
				return et;
		}
	}
}
function A$1(_) {
	return z$1(_) === m$3;
}
reactIs_production_min$1.AsyncMode = l$2;
reactIs_production_min$1.ConcurrentMode = m$3;
reactIs_production_min$1.ContextConsumer = k$2;
reactIs_production_min$1.ContextProvider = h$2;
reactIs_production_min$1.Element = c$2;
reactIs_production_min$1.ForwardRef = n$1;
reactIs_production_min$1.Fragment = e$3;
reactIs_production_min$1.Lazy = t$1;
reactIs_production_min$1.Memo = r$3;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$1;
reactIs_production_min$1.Suspense = p$4;
reactIs_production_min$1.isAsyncMode = function (_) {
	return A$1(_) || z$1(_) === l$2;
};
reactIs_production_min$1.isConcurrentMode = A$1;
reactIs_production_min$1.isContextConsumer = function (_) {
	return z$1(_) === k$2;
};
reactIs_production_min$1.isContextProvider = function (_) {
	return z$1(_) === h$2;
};
reactIs_production_min$1.isElement = function (_) {
	return typeof _ == "object" && _ !== null && _.$$typeof === c$2;
};
reactIs_production_min$1.isForwardRef = function (_) {
	return z$1(_) === n$1;
};
reactIs_production_min$1.isFragment = function (_) {
	return z$1(_) === e$3;
};
reactIs_production_min$1.isLazy = function (_) {
	return z$1(_) === t$1;
};
reactIs_production_min$1.isMemo = function (_) {
	return z$1(_) === r$3;
};
reactIs_production_min$1.isPortal = function (_) {
	return z$1(_) === d$1;
};
reactIs_production_min$1.isProfiler = function (_) {
	return z$1(_) === g$1;
};
reactIs_production_min$1.isStrictMode = function (_) {
	return z$1(_) === f$1;
};
reactIs_production_min$1.isSuspense = function (_) {
	return z$1(_) === p$4;
};
reactIs_production_min$1.isValidElementType = function (_) {
	return (
		typeof _ == "string" ||
		typeof _ == "function" ||
		_ === e$3 ||
		_ === m$3 ||
		_ === g$1 ||
		_ === f$1 ||
		_ === p$4 ||
		_ === q$2 ||
		(typeof _ == "object" &&
			_ !== null &&
			(_.$$typeof === t$1 ||
				_.$$typeof === r$3 ||
				_.$$typeof === h$2 ||
				_.$$typeof === k$2 ||
				_.$$typeof === n$1 ||
				_.$$typeof === w$1 ||
				_.$$typeof === x$1 ||
				_.$$typeof === y$2 ||
				_.$$typeof === v$2))
	);
};
reactIs_production_min$1.typeOf = z$1;
(function (_) {
	_.exports = reactIs_production_min$1;
})(reactIs$2);
var reactIs$1 = reactIs$2.exports,
	FORWARD_REF_STATICS = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 },
	MEMO_STATICS = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 },
	TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var isBrowser$3 = !0;
function getRegisteredStyles(_, et, tt) {
	var nt = "";
	return (
		tt.split(" ").forEach(function (rt) {
			_[rt] !== void 0 ? et.push(_[rt] + ";") : (nt += rt + " ");
		}),
		nt
	);
}
var registerStyles = function (et, tt, nt) {
		var rt = et.key + "-" + tt.name;
		(nt === !1 || isBrowser$3 === !1) && et.registered[rt] === void 0 && (et.registered[rt] = tt.styles);
	},
	insertStyles = function (et, tt, nt) {
		registerStyles(et, tt, nt);
		var rt = et.key + "-" + tt.name;
		if (et.inserted[tt.name] === void 0) {
			var it = tt;
			do et.insert(tt === it ? "." + rt : "", it, et.sheet, !0), (it = it.next);
			while (it !== void 0);
		}
	};
function murmur2(_) {
	for (var et = 0, tt, nt = 0, rt = _.length; rt >= 4; ++nt, rt -= 4)
		(tt =
			(_.charCodeAt(nt) & 255) |
			((_.charCodeAt(++nt) & 255) << 8) |
			((_.charCodeAt(++nt) & 255) << 16) |
			((_.charCodeAt(++nt) & 255) << 24)),
			(tt = (tt & 65535) * 1540483477 + (((tt >>> 16) * 59797) << 16)),
			(tt ^= tt >>> 24),
			(et =
				((tt & 65535) * 1540483477 + (((tt >>> 16) * 59797) << 16)) ^
				((et & 65535) * 1540483477 + (((et >>> 16) * 59797) << 16)));
	switch (rt) {
		case 3:
			et ^= (_.charCodeAt(nt + 2) & 255) << 16;
		case 2:
			et ^= (_.charCodeAt(nt + 1) & 255) << 8;
		case 1:
			(et ^= _.charCodeAt(nt) & 255), (et = (et & 65535) * 1540483477 + (((et >>> 16) * 59797) << 16));
	}
	return (
		(et ^= et >>> 13),
		(et = (et & 65535) * 1540483477 + (((et >>> 16) * 59797) << 16)),
		((et ^ (et >>> 15)) >>> 0).toString(36)
	);
}
var unitlessKeys = {
		animationIterationCount: 1,
		borderImageOutset: 1,
		borderImageSlice: 1,
		borderImageWidth: 1,
		boxFlex: 1,
		boxFlexGroup: 1,
		boxOrdinalGroup: 1,
		columnCount: 1,
		columns: 1,
		flex: 1,
		flexGrow: 1,
		flexPositive: 1,
		flexShrink: 1,
		flexNegative: 1,
		flexOrder: 1,
		gridRow: 1,
		gridRowEnd: 1,
		gridRowSpan: 1,
		gridRowStart: 1,
		gridColumn: 1,
		gridColumnEnd: 1,
		gridColumnSpan: 1,
		gridColumnStart: 1,
		msGridRow: 1,
		msGridRowSpan: 1,
		msGridColumn: 1,
		msGridColumnSpan: 1,
		fontWeight: 1,
		lineHeight: 1,
		opacity: 1,
		order: 1,
		orphans: 1,
		tabSize: 1,
		widows: 1,
		zIndex: 1,
		zoom: 1,
		WebkitLineClamp: 1,
		fillOpacity: 1,
		floodOpacity: 1,
		stopOpacity: 1,
		strokeDasharray: 1,
		strokeDashoffset: 1,
		strokeMiterlimit: 1,
		strokeOpacity: 1,
		strokeWidth: 1,
	},
	hyphenateRegex = /[A-Z]|^ms/g,
	animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
	isCustomProperty = function (et) {
		return et.charCodeAt(1) === 45;
	},
	isProcessableValue = function (et) {
		return et != null && typeof et != "boolean";
	},
	processStyleName = memoize$1(function (_) {
		return isCustomProperty(_) ? _ : _.replace(hyphenateRegex, "-$&").toLowerCase();
	}),
	processStyleValue = function (et, tt) {
		switch (et) {
			case "animation":
			case "animationName":
				if (typeof tt == "string")
					return tt.replace(animationRegex, function (nt, rt, it) {
						return (cursor = { name: rt, styles: it, next: cursor }), rt;
					});
		}
		return unitlessKeys[et] !== 1 && !isCustomProperty(et) && typeof tt == "number" && tt !== 0 ? tt + "px" : tt;
	},
	noComponentSelectorMessage =
		"Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(_, et, tt) {
	if (tt == null) return "";
	if (tt.__emotion_styles !== void 0) return tt;
	switch (typeof tt) {
		case "boolean":
			return "";
		case "object": {
			if (tt.anim === 1) return (cursor = { name: tt.name, styles: tt.styles, next: cursor }), tt.name;
			if (tt.styles !== void 0) {
				var nt = tt.next;
				if (nt !== void 0)
					for (; nt !== void 0; ) (cursor = { name: nt.name, styles: nt.styles, next: cursor }), (nt = nt.next);
				var rt = tt.styles + ";";
				return rt;
			}
			return createStringFromObject(_, et, tt);
		}
		case "function": {
			if (_ !== void 0) {
				var it = cursor,
					ot = tt(_);
				return (cursor = it), handleInterpolation(_, et, ot);
			}
			break;
		}
	}
	if (et == null) return tt;
	var at = et[tt];
	return at !== void 0 ? at : tt;
}
function createStringFromObject(_, et, tt) {
	var nt = "";
	if (Array.isArray(tt)) for (var rt = 0; rt < tt.length; rt++) nt += handleInterpolation(_, et, tt[rt]) + ";";
	else
		for (var it in tt) {
			var ot = tt[it];
			if (typeof ot != "object")
				et != null && et[ot] !== void 0
					? (nt += it + "{" + et[ot] + "}")
					: isProcessableValue(ot) && (nt += processStyleName(it) + ":" + processStyleValue(it, ot) + ";");
			else if (Array.isArray(ot) && typeof ot[0] == "string" && (et == null || et[ot[0]] === void 0))
				for (var at = 0; at < ot.length; at++)
					isProcessableValue(ot[at]) && (nt += processStyleName(it) + ":" + processStyleValue(it, ot[at]) + ";");
			else {
				var st = handleInterpolation(_, et, ot);
				switch (it) {
					case "animation":
					case "animationName": {
						nt += processStyleName(it) + ":" + st + ";";
						break;
					}
					default:
						nt += it + "{" + st + "}";
				}
			}
		}
	return nt;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
	cursor,
	serializeStyles = function (et, tt, nt) {
		if (et.length === 1 && typeof et[0] == "object" && et[0] !== null && et[0].styles !== void 0) return et[0];
		var rt = !0,
			it = "";
		cursor = void 0;
		var ot = et[0];
		ot == null || ot.raw === void 0 ? ((rt = !1), (it += handleInterpolation(nt, tt, ot))) : (it += ot[0]);
		for (var at = 1; at < et.length; at++) (it += handleInterpolation(nt, tt, et[at])), rt && (it += ot[at]);
		labelPattern.lastIndex = 0;
		for (var st = "", lt; (lt = labelPattern.exec(it)) !== null; ) st += "-" + lt[1];
		var ut = murmur2(it) + st;
		return { name: ut, styles: it, next: cursor };
	},
	syncFallback = function (et) {
		return et();
	},
	useInsertionEffect = React$2["useInsertionEffect"] ? React$2["useInsertionEffect"] : !1,
	useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback,
	useInsertionEffectWithLayoutFallback = useInsertionEffect || react.exports.useLayoutEffect,
	EmotionCacheContext = react.exports.createContext(typeof HTMLElement < "u" ? createCache({ key: "css" }) : null);
EmotionCacheContext.Provider;
var withEmotionCache = function (et) {
		return react.exports.forwardRef(function (tt, nt) {
			var rt = react.exports.useContext(EmotionCacheContext);
			return et(tt, rt, nt);
		});
	},
	ThemeContext = react.exports.createContext({}),
	getTheme = function (et, tt) {
		if (typeof tt == "function") {
			var nt = tt(et);
			return nt;
		}
		return _extends$1({}, et, tt);
	},
	createCacheWithTheme = weakMemoize(function (_) {
		return weakMemoize(function (et) {
			return getTheme(_, et);
		});
	}),
	ThemeProvider$1 = function (et) {
		var tt = react.exports.useContext(ThemeContext);
		return (
			et.theme !== tt && (tt = createCacheWithTheme(tt)(et.theme)),
			react.exports.createElement(ThemeContext.Provider, { value: tt }, et.children)
		);
	},
	Global = withEmotionCache(function (_, et) {
		var tt = _.styles,
			nt = serializeStyles([tt], void 0, react.exports.useContext(ThemeContext)),
			rt = react.exports.useRef();
		return (
			useInsertionEffectWithLayoutFallback(
				function () {
					var it = et.key + "-global",
						ot = new et.sheet.constructor({
							key: it,
							nonce: et.sheet.nonce,
							container: et.sheet.container,
							speedy: et.sheet.isSpeedy,
						}),
						at = !1,
						st = document.querySelector('style[data-emotion="' + it + " " + nt.name + '"]');
					return (
						et.sheet.tags.length && (ot.before = et.sheet.tags[0]),
						st !== null && ((at = !0), st.setAttribute("data-emotion", it), ot.hydrate([st])),
						(rt.current = [ot, at]),
						function () {
							ot.flush();
						}
					);
				},
				[et]
			),
			useInsertionEffectWithLayoutFallback(
				function () {
					var it = rt.current,
						ot = it[0],
						at = it[1];
					if (at) {
						it[1] = !1;
						return;
					}
					if ((nt.next !== void 0 && insertStyles(et, nt.next, !0), ot.tags.length)) {
						var st = ot.tags[ot.tags.length - 1].nextElementSibling;
						(ot.before = st), ot.flush();
					}
					et.insert("", nt, ot, !1);
				},
				[et, nt.name]
			),
			null
		);
	});
function css() {
	for (var _ = arguments.length, et = new Array(_), tt = 0; tt < _; tt++) et[tt] = arguments[tt];
	return serializeStyles(et);
}
var keyframes$2 = function () {
	var et = css.apply(void 0, arguments),
		tt = "animation-" + et.name;
	return {
		name: tt,
		styles: "@keyframes " + tt + "{" + et.styles + "}",
		anim: 1,
		toString: function () {
			return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
		},
	};
};
function isFunction$8(_) {
	return typeof _ == "function";
}
var __DEV__ = !1;
function isRefObject$1(_) {
	return "current" in _;
}
function omit$2(_, et) {
	const tt = {};
	return (
		Object.keys(_).forEach((nt) => {
			et.includes(nt) || (tt[nt] = _[nt]);
		}),
		tt
	);
}
function get(_, et, tt, nt) {
	const rt = typeof et == "string" ? et.split(".") : [et];
	for (nt = 0; nt < rt.length && _; nt += 1) _ = _[rt[nt]];
	return _ === void 0 ? tt : _;
}
var memoize = (_) => {
		const et = new WeakMap();
		return (nt, rt, it, ot) => {
			if (typeof nt > "u") return _(nt, rt, it);
			et.has(nt) || et.set(nt, new Map());
			const at = et.get(nt);
			if (at.has(rt)) return at.get(rt);
			const st = _(nt, rt, it, ot);
			return at.set(rt, st), st;
		};
	},
	memoizedGet = memoize(get);
function objectFilter(_, et) {
	const tt = {};
	return (
		Object.keys(_).forEach((nt) => {
			const rt = _[nt];
			et(rt, nt, _) && (tt[nt] = rt);
		}),
		tt
	);
}
var filterUndefined = (_) => objectFilter(_, (et) => et != null);
function isElement$6(_) {
	return _ != null && typeof _ == "object" && "nodeType" in _ && _.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement$3(_) {
	var tt;
	if (!isElement$6(_)) return !1;
	const et = (tt = _.ownerDocument.defaultView) != null ? tt : window;
	return _ instanceof et.HTMLElement;
}
function getOwnerWindow$1(_) {
	var tt;
	var et;
	return isElement$6(_) && (tt = (et = getOwnerDocument$3(_)) == null ? void 0 : et.defaultView) != null ? tt : window;
}
function getOwnerDocument$3(_) {
	var et;
	return isElement$6(_) && (et = _.ownerDocument) != null ? et : document;
}
function getEventWindow(_) {
	var et;
	return (et = _.view) != null ? et : window;
}
function canUseDOM$1() {
	return !!(typeof window < "u" && window.document && window.document.createElement);
}
var isBrowser$2 = canUseDOM$1();
function getActiveElement$2(_) {
	const et = getOwnerDocument$3(_);
	return et == null ? void 0 : et.activeElement;
}
function contains$3(_, et) {
	return _ ? _ === et || _.contains(et) : !1;
}
var hasTabIndex$1 = (_) => _.hasAttribute("tabindex"),
	hasNegativeTabIndex$1 = (_) => hasTabIndex$1(_) && _.tabIndex === -1;
function isDisabled$1(_) {
	return Boolean(_.getAttribute("disabled")) === !0 || Boolean(_.getAttribute("aria-disabled")) === !0;
}
function isInputElement(_) {
	return isHTMLElement$3(_) && _.localName === "input" && "select" in _;
}
function isActiveElement$1(_) {
	return (isHTMLElement$3(_) ? getOwnerDocument$3(_) : document).activeElement === _;
}
function isHidden$1(_) {
	return _.parentElement && isHidden$1(_.parentElement) ? !0 : _.hidden;
}
function isContentEditable$1(_) {
	const et = _.getAttribute("contenteditable");
	return et !== "false" && et != null;
}
function isFocusable$1(_) {
	if (!isHTMLElement$3(_) || isHidden$1(_) || isDisabled$1(_)) return !1;
	const { localName: et } = _;
	if (["input", "select", "textarea", "button"].indexOf(et) >= 0) return !0;
	const nt = {
		a: () => _.hasAttribute("href"),
		audio: () => _.hasAttribute("controls"),
		video: () => _.hasAttribute("controls"),
	};
	return et in nt ? nt[et]() : isContentEditable$1(_) ? !0 : hasTabIndex$1(_);
}
function isTabbable$1(_) {
	return _ ? isHTMLElement$3(_) && isFocusable$1(_) && !hasNegativeTabIndex$1(_) : !1;
}
var focusableElList$1 = [
		"input:not([disabled])",
		"select:not([disabled])",
		"textarea:not([disabled])",
		"embed",
		"iframe",
		"object",
		"a[href]",
		"area[href]",
		"button:not([disabled])",
		"[tabindex]",
		"audio[controls]",
		"video[controls]",
		"*[tabindex]:not([aria-disabled])",
		"*[contenteditable]",
	],
	focusableElSelector$1 = focusableElList$1.join(),
	isVisible$2 = (_) => _.offsetWidth > 0 && _.offsetHeight > 0;
function getAllFocusable$1(_) {
	const et = Array.from(_.querySelectorAll(focusableElSelector$1));
	return et.unshift(_), et.filter((tt) => isFocusable$1(tt) && isVisible$2(tt));
}
function runIfFn$4(_, ...et) {
	return isFunction$8(_) ? _(...et) : _;
}
function callAllHandlers$5(..._) {
	return function (tt) {
		_.some((nt) => (nt == null || nt(tt), tt == null ? void 0 : tt.defaultPrevented));
	};
}
function once$1(_) {
	let et;
	return function (...nt) {
		return _ && ((et = _.apply(this, nt)), (_ = null)), et;
	};
}
var warn$1 = once$1((_) => () => {
		const { condition: et, message: tt } = _;
		et && __DEV__ && console.warn(tt);
	}),
	pipe$1 =
		(..._) =>
		(et) =>
			_.reduce((tt, nt) => nt(tt), et);
function focus(_, et = {}) {
	const { isActive: tt = isActiveElement$1, nextTick: nt, preventScroll: rt = !0, selectTextIfInput: it = !0 } = et;
	if (!_ || tt(_)) return -1;
	function ot() {
		if (!_) {
			warn$1({ condition: !0, message: "[chakra-ui]: can't call focus() on `null` or `undefined` element" });
			return;
		}
		if (supportsPreventScroll()) _.focus({ preventScroll: rt });
		else if ((_.focus(), rt)) {
			const at = getScrollableElements(_);
			restoreScrollPosition(at);
		}
		if (it) {
			if (isInputElement(_)) _.select();
			else if ("setSelectionRange" in _) {
				const at = _;
				at.setSelectionRange(at.value.length, at.value.length);
			}
		}
	}
	return nt ? requestAnimationFrame(ot) : (ot(), -1);
}
var supportsPreventScrollCached = null;
function supportsPreventScroll() {
	if (supportsPreventScrollCached == null) {
		supportsPreventScrollCached = !1;
		try {
			document.createElement("div").focus({
				get preventScroll() {
					return (supportsPreventScrollCached = !0), !0;
				},
			});
		} catch {}
	}
	return supportsPreventScrollCached;
}
function getScrollableElements(_) {
	var ot;
	const et = getOwnerDocument$3(_),
		tt = (ot = et.defaultView) != null ? ot : window;
	let nt = _.parentNode;
	const rt = [],
		it = et.scrollingElement || et.documentElement;
	for (; nt instanceof tt.HTMLElement && nt !== it; )
		(nt.offsetHeight < nt.scrollHeight || nt.offsetWidth < nt.scrollWidth) &&
			rt.push({ element: nt, scrollTop: nt.scrollTop, scrollLeft: nt.scrollLeft }),
			(nt = nt.parentNode);
	return (
		it instanceof tt.HTMLElement && rt.push({ element: it, scrollTop: it.scrollTop, scrollLeft: it.scrollLeft }), rt
	);
}
function restoreScrollPosition(_) {
	for (const { element: et, scrollTop: tt, scrollLeft: nt } of _) (et.scrollTop = tt), (et.scrollLeft = nt);
}
function isTouchEvent$1(_) {
	return !!_.touches;
}
function filterPrimaryPointer$1(_) {
	return (et) => {
		const tt = getEventWindow(et),
			nt = et instanceof tt.MouseEvent;
		(!nt || (nt && et.button === 0)) && _(et);
	};
}
var defaultPagePoint$1 = { pageX: 0, pageY: 0 };
function pointFromTouch$1(_, et = "page") {
	const nt = _.touches[0] || _.changedTouches[0] || defaultPagePoint$1;
	return { x: nt[`${et}X`], y: nt[`${et}Y`] };
}
function pointFromMouse$1(_, et = "page") {
	return { x: _[`${et}X`], y: _[`${et}Y`] };
}
function extractEventInfo$1(_, et = "page") {
	return { point: isTouchEvent$1(_) ? pointFromTouch$1(_, et) : pointFromMouse$1(_, et) };
}
var wrapPointerEventHandler = (_, et = !1) => {
		const tt = (nt) => _(nt, extractEventInfo$1(nt));
		return et ? filterPrimaryPointer$1(tt) : tt;
	},
	supportsPointerEvents$1 = () => isBrowser$2 && window.onpointerdown === null,
	supportsTouchEvents$1 = () => isBrowser$2 && window.ontouchstart === null,
	supportsMouseEvents$1 = () => isBrowser$2 && window.onmousedown === null,
	mouseEventNames$1 = {
		pointerdown: "mousedown",
		pointermove: "mousemove",
		pointerup: "mouseup",
		pointercancel: "mousecancel",
		pointerover: "mouseover",
		pointerout: "mouseout",
		pointerenter: "mouseenter",
		pointerleave: "mouseleave",
	},
	touchEventNames$1 = {
		pointerdown: "touchstart",
		pointermove: "touchmove",
		pointerup: "touchend",
		pointercancel: "touchcancel",
	};
function getPointerEventName$1(_) {
	return supportsPointerEvents$1()
		? _
		: supportsTouchEvents$1()
		? touchEventNames$1[_]
		: supportsMouseEvents$1()
		? mouseEventNames$1[_]
		: _;
}
Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);
function getUserAgentBrowser(_) {
	const { userAgent: et, vendor: tt } = _,
		nt = /(android)/i.test(et);
	switch (!0) {
		case /CriOS/.test(et):
			return "Chrome for iOS";
		case /Edg\//.test(et):
			return "Edge";
		case nt && /Silk\//.test(et):
			return "Silk";
		case /Chrome/.test(et) && /Google Inc/.test(tt):
			return "Chrome";
		case /Firefox\/\d+\.\d+$/.test(et):
			return "Firefox";
		case nt:
			return "AOSP";
		case /MSIE|Trident/.test(et):
			return "IE";
		case /Safari/.test(_.userAgent) && /Apple Computer/.test(et):
			return "Safari";
		case /AppleWebKit/.test(et):
			return "WebKit";
		default:
			return null;
	}
}
function detectBrowser(_) {
	return isBrowser$2 ? getUserAgentBrowser(window.navigator) === _ : !1;
}
function createContext$1(_ = {}) {
	const {
			strict: et = !0,
			errorMessage: tt = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
			name: nt,
		} = _,
		rt = react.exports.createContext(void 0);
	rt.displayName = nt;
	function it() {
		var ot;
		const at = react.exports.useContext(rt);
		if (!at && et) {
			const st = new Error(tt);
			throw ((st.name = "ContextError"), (ot = Error.captureStackTrace) == null || ot.call(Error, st, it), st);
		}
		return at;
	}
	return [rt.Provider, it, rt];
}
var reactPropsRegex =
		/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
	isPropValid = memoize$1(function (_) {
		return reactPropsRegex.test(_) || (_.charCodeAt(0) === 111 && _.charCodeAt(1) === 110 && _.charCodeAt(2) < 91);
	}),
	testOmitPropsOnStringTag = isPropValid,
	testOmitPropsOnComponent = function (et) {
		return et !== "theme";
	},
	getDefaultShouldForwardProp = function (et) {
		return typeof et == "string" && et.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
	},
	composeShouldForwardProps = function (et, tt, nt) {
		var rt;
		if (tt) {
			var it = tt.shouldForwardProp;
			rt =
				et.__emotion_forwardProp && it
					? function (ot) {
							return et.__emotion_forwardProp(ot) && it(ot);
					  }
					: it;
		}
		return typeof rt != "function" && nt && (rt = et.__emotion_forwardProp), rt;
	},
	Insertion = function (et) {
		var tt = et.cache,
			nt = et.serialized,
			rt = et.isStringTag;
		return (
			registerStyles(tt, nt, rt),
			useInsertionEffectAlwaysWithSyncFallback(function () {
				return insertStyles(tt, nt, rt);
			}),
			null
		);
	},
	createStyled = function _(et, tt) {
		var nt = et.__emotion_real === et,
			rt = (nt && et.__emotion_base) || et,
			it,
			ot;
		tt !== void 0 && ((it = tt.label), (ot = tt.target));
		var at = composeShouldForwardProps(et, tt, nt),
			st = at || getDefaultShouldForwardProp(rt),
			lt = !st("as");
		return function () {
			var ut = arguments,
				dt = nt && et.__emotion_styles !== void 0 ? et.__emotion_styles.slice(0) : [];
			if ((it !== void 0 && dt.push("label:" + it + ";"), ut[0] == null || ut[0].raw === void 0)) dt.push.apply(dt, ut);
			else {
				dt.push(ut[0][0]);
				for (var ct = ut.length, ft = 1; ft < ct; ft++) dt.push(ut[ft], ut[0][ft]);
			}
			var mt = withEmotionCache(function (pt, vt, ht) {
				var gt = (lt && pt.as) || rt,
					yt = "",
					xt = [],
					St = pt;
				if (pt.theme == null) {
					St = {};
					for (var wt in pt) St[wt] = pt[wt];
					St.theme = react.exports.useContext(ThemeContext);
				}
				typeof pt.className == "string"
					? (yt = getRegisteredStyles(vt.registered, xt, pt.className))
					: pt.className != null && (yt = pt.className + " ");
				var Ct = serializeStyles(dt.concat(xt), vt.registered, St);
				(yt += vt.key + "-" + Ct.name), ot !== void 0 && (yt += " " + ot);
				var Et = lt && at === void 0 ? getDefaultShouldForwardProp(gt) : st,
					_t = {};
				for (var $t in pt) (lt && $t === "as") || (Et($t) && (_t[$t] = pt[$t]));
				return (
					(_t.className = yt),
					(_t.ref = ht),
					react.exports.createElement(
						react.exports.Fragment,
						null,
						react.exports.createElement(Insertion, { cache: vt, serialized: Ct, isStringTag: typeof gt == "string" }),
						react.exports.createElement(gt, _t)
					)
				);
			});
			return (
				(mt.displayName =
					it !== void 0
						? it
						: "Styled(" + (typeof rt == "string" ? rt : rt.displayName || rt.name || "Component") + ")"),
				(mt.defaultProps = et.defaultProps),
				(mt.__emotion_real = mt),
				(mt.__emotion_base = rt),
				(mt.__emotion_styles = dt),
				(mt.__emotion_forwardProp = at),
				Object.defineProperty(mt, "toString", {
					value: function () {
						return "." + ot;
					},
				}),
				(mt.withComponent = function (pt, vt) {
					return _(pt, _extends$1({}, tt, vt, { shouldForwardProp: composeShouldForwardProps(mt, vt, !0) })).apply(
						void 0,
						dt
					);
				}),
				mt
			);
		};
	},
	tags = [
		"a",
		"abbr",
		"address",
		"area",
		"article",
		"aside",
		"audio",
		"b",
		"base",
		"bdi",
		"bdo",
		"big",
		"blockquote",
		"body",
		"br",
		"button",
		"canvas",
		"caption",
		"cite",
		"code",
		"col",
		"colgroup",
		"data",
		"datalist",
		"dd",
		"del",
		"details",
		"dfn",
		"dialog",
		"div",
		"dl",
		"dt",
		"em",
		"embed",
		"fieldset",
		"figcaption",
		"figure",
		"footer",
		"form",
		"h1",
		"h2",
		"h3",
		"h4",
		"h5",
		"h6",
		"head",
		"header",
		"hgroup",
		"hr",
		"html",
		"i",
		"iframe",
		"img",
		"input",
		"ins",
		"kbd",
		"keygen",
		"label",
		"legend",
		"li",
		"link",
		"main",
		"map",
		"mark",
		"marquee",
		"menu",
		"menuitem",
		"meta",
		"meter",
		"nav",
		"noscript",
		"object",
		"ol",
		"optgroup",
		"option",
		"output",
		"p",
		"param",
		"picture",
		"pre",
		"progress",
		"q",
		"rp",
		"rt",
		"ruby",
		"s",
		"samp",
		"script",
		"section",
		"select",
		"small",
		"source",
		"span",
		"strong",
		"style",
		"sub",
		"summary",
		"sup",
		"table",
		"tbody",
		"td",
		"textarea",
		"tfoot",
		"th",
		"thead",
		"time",
		"title",
		"tr",
		"track",
		"u",
		"ul",
		"var",
		"video",
		"wbr",
		"circle",
		"clipPath",
		"defs",
		"ellipse",
		"foreignObject",
		"g",
		"image",
		"line",
		"linearGradient",
		"mask",
		"path",
		"pattern",
		"polygon",
		"polyline",
		"radialGradient",
		"rect",
		"stop",
		"svg",
		"text",
		"tspan",
	],
	newStyled = createStyled.bind();
tags.forEach(function (_) {
	newStyled[_] = newStyled(_);
});
var hasElementType = typeof Element < "u",
	hasMap = typeof Map == "function",
	hasSet = typeof Set == "function",
	hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function equal(_, et) {
	if (_ === et) return !0;
	if (_ && et && typeof _ == "object" && typeof et == "object") {
		if (_.constructor !== et.constructor) return !1;
		var tt, nt, rt;
		if (Array.isArray(_)) {
			if (((tt = _.length), tt != et.length)) return !1;
			for (nt = tt; nt-- !== 0; ) if (!equal(_[nt], et[nt])) return !1;
			return !0;
		}
		var it;
		if (hasMap && _ instanceof Map && et instanceof Map) {
			if (_.size !== et.size) return !1;
			for (it = _.entries(); !(nt = it.next()).done; ) if (!et.has(nt.value[0])) return !1;
			for (it = _.entries(); !(nt = it.next()).done; ) if (!equal(nt.value[1], et.get(nt.value[0]))) return !1;
			return !0;
		}
		if (hasSet && _ instanceof Set && et instanceof Set) {
			if (_.size !== et.size) return !1;
			for (it = _.entries(); !(nt = it.next()).done; ) if (!et.has(nt.value[0])) return !1;
			return !0;
		}
		if (hasArrayBuffer && ArrayBuffer.isView(_) && ArrayBuffer.isView(et)) {
			if (((tt = _.length), tt != et.length)) return !1;
			for (nt = tt; nt-- !== 0; ) if (_[nt] !== et[nt]) return !1;
			return !0;
		}
		if (_.constructor === RegExp) return _.source === et.source && _.flags === et.flags;
		if (_.valueOf !== Object.prototype.valueOf) return _.valueOf() === et.valueOf();
		if (_.toString !== Object.prototype.toString) return _.toString() === et.toString();
		if (((rt = Object.keys(_)), (tt = rt.length), tt !== Object.keys(et).length)) return !1;
		for (nt = tt; nt-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(et, rt[nt])) return !1;
		if (hasElementType && _ instanceof Element) return !1;
		for (nt = tt; nt-- !== 0; )
			if (
				!((rt[nt] === "_owner" || rt[nt] === "__v" || rt[nt] === "__o") && _.$$typeof) &&
				!equal(_[rt[nt]], et[rt[nt]])
			)
				return !1;
		return !0;
	}
	return _ !== _ && et !== et;
}
var reactFastCompare = function (et, tt) {
	try {
		return equal(et, tt);
	} catch (nt) {
		if ((nt.message || "").match(/stack|recursion/i))
			return console.warn("react-fast-compare cannot handle circular refs"), !1;
		throw nt;
	}
};
function useTheme() {
	const _ = react.exports.useContext(ThemeContext);
	if (!_)
		throw Error(
			"useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
		);
	return _;
}
function useChakra() {
	const _ = useColorMode(),
		et = useTheme();
	return { ..._, theme: et };
}
function getBreakpointValue(_, et, tt) {
	var rt, it;
	if (et == null) return et;
	const nt = (ot) => {
		var at, st;
		return (st = (at = _.__breakpoints) == null ? void 0 : at.asArray) == null ? void 0 : st[ot];
	};
	return (it = (rt = nt(et)) != null ? rt : nt(tt)) != null ? it : tt;
}
function getTokenValue(_, et, tt) {
	var rt, it;
	if (et == null) return et;
	const nt = (ot) => {
		var at, st;
		return (st = (at = _.__cssMap) == null ? void 0 : at[ot]) == null ? void 0 : st.value;
	};
	return (it = (rt = nt(et)) != null ? rt : nt(tt)) != null ? it : tt;
}
function getToken(_, et, tt) {
	const nt = Array.isArray(et) ? et : [et],
		rt = Array.isArray(tt) ? tt : [tt];
	return (it) => {
		const ot = rt.filter(Boolean),
			at = nt.map((st, lt) => {
				var dt, ct;
				if (_ === "breakpoints") return getBreakpointValue(it, st, (dt = ot[lt]) != null ? dt : st);
				const ut = `${_}.${st}`;
				return getTokenValue(it, ut, (ct = ot[lt]) != null ? ct : st);
			});
		return Array.isArray(et) ? at : at[0];
	};
}
function ThemeProvider(_) {
	const { cssVarsRoot: et, theme: tt, children: nt } = _,
		rt = react.exports.useMemo(() => toCSSVar(tt), [tt]);
	return jsxs(ThemeProvider$1, { theme: rt, children: [jsx(CSSVars, { root: et }), nt] });
}
function CSSVars({ root: _ = ":host, :root" }) {
	const et = [_, "[data-theme]"].join(",");
	return jsx(Global, { styles: (tt) => ({ [et]: tt.__cssVars }) });
}
createContext$1({
	name: "StylesContext",
	errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` ",
});
function GlobalStyle() {
	const { colorMode: _ } = useColorMode();
	return jsx(Global, {
		styles: (et) => {
			const tt = memoizedGet(et, "styles.global"),
				nt = runIfFn$4(tt, { theme: et, colorMode: _ });
			return nt ? css$1(nt)(et) : void 0;
		},
	});
}
var allPropNames = new Set([
		...propNames,
		"textStyle",
		"layerStyle",
		"apply",
		"noOfLines",
		"focusBorderColor",
		"errorBorderColor",
		"as",
		"__css",
		"css",
		"sx",
	]),
	validHTMLProps = new Set(["htmlWidth", "htmlHeight", "htmlSize"]);
function shouldForwardProp(_) {
	return validHTMLProps.has(_) || !allPropNames.has(_);
}
var toCSSObject =
	({ baseStyle: _ }) =>
	(et) => {
		const { theme: tt, css: nt, __css: rt, sx: it, ...ot } = et,
			at = objectFilter(ot, (dt, ct) => isStyleProp(ct)),
			st = runIfFn$4(_, et),
			lt = Object.assign({}, rt, st, filterUndefined(at), it),
			ut = css$1(lt)(et.theme);
		return nt ? [ut, nt] : ut;
	};
function styled(_, et) {
	const { baseStyle: tt, ...nt } = et != null ? et : {};
	nt.shouldForwardProp || (nt.shouldForwardProp = shouldForwardProp);
	const rt = toCSSObject({ baseStyle: tt });
	return newStyled(_, nt)(rt);
}
function forwardRef(_) {
	return react.exports.forwardRef(_);
}
function useStyleConfigImpl(_, et = {}) {
	var ut;
	const { styleConfig: tt, ...nt } = et,
		{ theme: rt, colorMode: it } = useChakra(),
		ot = memoizedGet(rt, `components.${_}`),
		at = tt || ot,
		st = mergeWith(
			{ theme: rt, colorMode: it },
			(ut = at == null ? void 0 : at.defaultProps) != null ? ut : {},
			filterUndefined(omit$2(nt, ["children"]))
		),
		lt = react.exports.useRef({});
	if (at) {
		const ct = resolveStyleConfig(at)(st);
		reactFastCompare(lt.current, ct) || (lt.current = ct);
	}
	return lt.current;
}
function useStyleConfig(_, et = {}) {
	return useStyleConfigImpl(_, et);
}
function useMultiStyleConfig(_, et = {}) {
	return useStyleConfigImpl(_, et);
}
function factory$1() {
	const _ = new Map();
	return new Proxy(styled, {
		apply(et, tt, nt) {
			return styled(...nt);
		},
		get(et, tt) {
			return _.has(tt) || _.set(tt, styled(tt)), _.get(tt);
		},
	});
}
var chakra = factory$1();
function getErrorMessage(_, et) {
	return `${_} returned \`undefined\`. Seems you forgot to wrap component within ${et}`;
}
function createContext(_ = {}) {
	const { name: et, strict: tt = !0, hookName: nt = "useContext", providerName: rt = "Provider", errorMessage: it } = _,
		ot = react.exports.createContext(void 0);
	ot.displayName = et;
	function at() {
		var st;
		const lt = react.exports.useContext(ot);
		if (!lt && tt) {
			const ut = new Error(it != null ? it : getErrorMessage(nt, rt));
			throw ((ut.name = "ContextError"), (st = Error.captureStackTrace) == null || st.call(Error, ut, at), ut);
		}
		return lt;
	}
	return [ot.Provider, at, ot];
}
function assignRef$1(_, et) {
	if (_ != null) {
		if (typeof _ == "function") {
			_(et);
			return;
		}
		try {
			_.current = et;
		} catch {
			throw new Error(`Cannot assign value '${et}' to ref '${_}'`);
		}
	}
}
function mergeRefs(..._) {
	return (et) => {
		_.forEach((tt) => {
			assignRef$1(tt, et);
		});
	};
}
function useMergeRefs$1(..._) {
	return react.exports.useMemo(() => mergeRefs(..._), _);
}
function sortNodes(_) {
	return _.sort((et, tt) => {
		const nt = et.compareDocumentPosition(tt);
		if (nt & Node.DOCUMENT_POSITION_FOLLOWING || nt & Node.DOCUMENT_POSITION_CONTAINED_BY) return -1;
		if (nt & Node.DOCUMENT_POSITION_PRECEDING || nt & Node.DOCUMENT_POSITION_CONTAINS) return 1;
		if (nt & Node.DOCUMENT_POSITION_DISCONNECTED || nt & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC)
			throw Error("Cannot sort the given nodes.");
		return 0;
	});
}
var isElement$5 = (_) => typeof _ == "object" && "nodeType" in _ && _.nodeType === Node.ELEMENT_NODE;
function getNextIndex(_, et, tt) {
	let nt = _ + 1;
	return tt && nt >= et && (nt = 0), nt;
}
function getPrevIndex(_, et, tt) {
	let nt = _ - 1;
	return tt && nt < 0 && (nt = et), nt;
}
var useSafeLayoutEffect$1 = typeof window < "u" ? react.exports.useLayoutEffect : react.exports.useEffect,
	cast = (_) => _,
	DescendantsManager = class {
		constructor() {
			fn(this, "descendants", new Map());
			fn(this, "register", (_) => {
				if (_ != null)
					return isElement$5(_)
						? this.registerNode(_)
						: (et) => {
								this.registerNode(et, _);
						  };
			});
			fn(this, "unregister", (_) => {
				this.descendants.delete(_);
				const et = sortNodes(Array.from(this.descendants.keys()));
				this.assignIndex(et);
			});
			fn(this, "destroy", () => {
				this.descendants.clear();
			});
			fn(this, "assignIndex", (_) => {
				this.descendants.forEach((et) => {
					const tt = _.indexOf(et.node);
					(et.index = tt), (et.node.dataset.index = et.index.toString());
				});
			});
			fn(this, "count", () => this.descendants.size);
			fn(this, "enabledCount", () => this.enabledValues().length);
			fn(this, "values", () => Array.from(this.descendants.values()).sort((et, tt) => et.index - tt.index));
			fn(this, "enabledValues", () => this.values().filter((_) => !_.disabled));
			fn(this, "item", (_) => {
				if (this.count() !== 0) return this.values()[_];
			});
			fn(this, "enabledItem", (_) => {
				if (this.enabledCount() !== 0) return this.enabledValues()[_];
			});
			fn(this, "first", () => this.item(0));
			fn(this, "firstEnabled", () => this.enabledItem(0));
			fn(this, "last", () => this.item(this.descendants.size - 1));
			fn(this, "lastEnabled", () => {
				const _ = this.enabledValues().length - 1;
				return this.enabledItem(_);
			});
			fn(this, "indexOf", (_) => {
				var tt;
				var et;
				return _ && (tt = (et = this.descendants.get(_)) == null ? void 0 : et.index) != null ? tt : -1;
			});
			fn(this, "enabledIndexOf", (_) =>
				_ == null ? -1 : this.enabledValues().findIndex((et) => et.node.isSameNode(_))
			);
			fn(this, "next", (_, et = !0) => {
				const tt = getNextIndex(_, this.count(), et);
				return this.item(tt);
			});
			fn(this, "nextEnabled", (_, et = !0) => {
				const tt = this.item(_);
				if (!tt) return;
				const nt = this.enabledIndexOf(tt.node),
					rt = getNextIndex(nt, this.enabledCount(), et);
				return this.enabledItem(rt);
			});
			fn(this, "prev", (_, et = !0) => {
				const tt = getPrevIndex(_, this.count() - 1, et);
				return this.item(tt);
			});
			fn(this, "prevEnabled", (_, et = !0) => {
				const tt = this.item(_);
				if (!tt) return;
				const nt = this.enabledIndexOf(tt.node),
					rt = getPrevIndex(nt, this.enabledCount() - 1, et);
				return this.enabledItem(rt);
			});
			fn(this, "registerNode", (_, et) => {
				if (!_ || this.descendants.has(_)) return;
				const tt = Array.from(this.descendants.keys()).concat(_),
					nt = sortNodes(tt);
				et != null && et.disabled && (et.disabled = !!et.disabled);
				const rt = { node: _, index: -1, ...et };
				this.descendants.set(_, rt), this.assignIndex(nt);
			});
		}
	};
function useDescendants() {
	const _ = react.exports.useRef(new DescendantsManager());
	return useSafeLayoutEffect$1(() => () => _.current.destroy()), _.current;
}
var [DescendantsContextProvider, useDescendantsContext] = createContext({
	name: "DescendantsProvider",
	errorMessage: "useDescendantsContext must be used within DescendantsProvider",
});
function useDescendant(_) {
	const et = useDescendantsContext(),
		[tt, nt] = react.exports.useState(-1),
		rt = react.exports.useRef(null);
	useSafeLayoutEffect$1(
		() => () => {
			!rt.current || et.unregister(rt.current);
		},
		[]
	),
		useSafeLayoutEffect$1(() => {
			if (!rt.current) return;
			const ot = Number(rt.current.dataset.index);
			tt != ot && !Number.isNaN(ot) && nt(ot);
		});
	const it = cast(_ ? et.register(_) : et.register);
	return { descendants: et, index: tt, enabledIndex: et.enabledIndexOf(rt.current), register: mergeRefs(it, rt) };
}
function createDescendantContext() {
	return [
		cast(DescendantsContextProvider),
		() => cast(useDescendantsContext()),
		() => useDescendants(),
		(rt) => useDescendant(rt),
	];
}
var cx$a = (..._) => _.filter(Boolean).join(" "),
	fallbackIcon = {
		path: jsxs("g", {
			stroke: "currentColor",
			strokeWidth: "1.5",
			children: [
				jsx("path", { strokeLinecap: "round", fill: "none", d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25" }),
				jsx("path", {
					fill: "currentColor",
					strokeLinecap: "round",
					d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0",
				}),
				jsx("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" }),
			],
		}),
		viewBox: "0 0 24 24",
	},
	Icon = forwardRef((_, et) => {
		const {
				as: tt,
				viewBox: nt,
				color: rt = "currentColor",
				focusable: it = !1,
				children: ot,
				className: at,
				__css: st,
				...lt
			} = _,
			ut = cx$a("chakra-icon", at),
			dt = { w: "1em", h: "1em", display: "inline-block", lineHeight: "1em", flexShrink: 0, color: rt, ...st },
			ct = { ref: et, focusable: it, className: ut, __css: dt },
			ft = nt != null ? nt : fallbackIcon.viewBox;
		if (tt && typeof tt != "string") return React$1.createElement(chakra.svg, { as: tt, ...ct, ...lt });
		const mt = ot != null ? ot : fallbackIcon.path;
		return React$1.createElement(chakra.svg, { verticalAlign: "middle", viewBox: ft, ...ct, ...lt }, mt);
	});
Icon.displayName = "Icon";
function createIcon(_) {
	const { viewBox: et = "0 0 24 24", d: tt, displayName: nt, defaultProps: rt = {} } = _,
		it = react.exports.Children.toArray(_.path),
		ot = forwardRef((at, st) =>
			jsx(Icon, {
				ref: st,
				viewBox: et,
				...rt,
				...at,
				children: it.length ? it : jsx("path", { fill: "currentColor", d: tt }),
			})
		);
	return (ot.displayName = nt), ot;
}
function useCallbackRef$2(_, et = []) {
	const tt = react.exports.useRef(_);
	return (
		react.exports.useEffect(() => {
			tt.current = _;
		}),
		react.exports.useCallback((...nt) => {
			var rt;
			return (rt = tt.current) == null ? void 0 : rt.call(tt, ...nt);
		}, et)
	);
}
function useControllableState(_) {
	const { value: et, defaultValue: tt, onChange: nt, shouldUpdate: rt = (ct, ft) => ct !== ft } = _,
		it = useCallbackRef$2(nt),
		ot = useCallbackRef$2(rt),
		[at, st] = react.exports.useState(tt),
		lt = et !== void 0,
		ut = lt ? et : at,
		dt = react.exports.useCallback(
			(ct) => {
				const mt = typeof ct == "function" ? ct(ut) : ct;
				!ot(ut, mt) || (lt || st(mt), it(mt));
			},
			[lt, it, ut, ot]
		);
	return [ut, dt];
}
const MotionConfigContext = react.exports.createContext({
		transformPagePoint: (_) => _,
		isStatic: !1,
		reducedMotion: "never",
	}),
	MotionContext = react.exports.createContext({});
function useVisualElementContext() {
	return react.exports.useContext(MotionContext).visualElement;
}
const PresenceContext = react.exports.createContext(null),
	isBrowser$1 = typeof document < "u",
	useIsomorphicLayoutEffect$1 = isBrowser$1 ? react.exports.useLayoutEffect : react.exports.useEffect,
	LazyContext = react.exports.createContext({ strict: !1 });
function useVisualElement(_, et, tt, nt) {
	const rt = useVisualElementContext(),
		it = react.exports.useContext(LazyContext),
		ot = react.exports.useContext(PresenceContext),
		at = react.exports.useContext(MotionConfigContext).reducedMotion,
		st = react.exports.useRef(void 0);
	(nt = nt || it.renderer),
		!st.current &&
			nt &&
			(st.current = nt(_, {
				visualState: et,
				parent: rt,
				props: tt,
				presenceId: ot ? ot.id : void 0,
				blockInitialAnimation: ot ? ot.initial === !1 : !1,
				reducedMotionConfig: at,
			}));
	const lt = st.current;
	return (
		useIsomorphicLayoutEffect$1(() => {
			lt && lt.syncRender();
		}),
		react.exports.useEffect(() => {
			lt && lt.animationState && lt.animationState.animateChanges();
		}),
		useIsomorphicLayoutEffect$1(() => () => lt && lt.notifyUnmount(), []),
		lt
	);
}
function isRefObject(_) {
	return typeof _ == "object" && Object.prototype.hasOwnProperty.call(_, "current");
}
function useMotionRef(_, et, tt) {
	return react.exports.useCallback(
		(nt) => {
			nt && _.mount && _.mount(nt),
				et && (nt ? et.mount(nt) : et.unmount()),
				tt && (typeof tt == "function" ? tt(nt) : isRefObject(tt) && (tt.current = nt));
		},
		[et]
	);
}
function isVariantLabel(_) {
	return typeof _ == "string" || Array.isArray(_);
}
function isAnimationControls(_) {
	return typeof _ == "object" && typeof _.start == "function";
}
const variantProps$1 = [
	"initial",
	"animate",
	"exit",
	"whileHover",
	"whileDrag",
	"whileTap",
	"whileFocus",
	"whileInView",
];
function isControllingVariants(_) {
	return isAnimationControls(_.animate) || variantProps$1.some((et) => isVariantLabel(_[et]));
}
function isVariantNode(_) {
	return Boolean(isControllingVariants(_) || _.variants);
}
function getCurrentTreeVariants(_, et) {
	if (isControllingVariants(_)) {
		const { initial: tt, animate: nt } = _;
		return { initial: tt === !1 || isVariantLabel(tt) ? tt : void 0, animate: isVariantLabel(nt) ? nt : void 0 };
	}
	return _.inherit !== !1 ? et : {};
}
function useCreateMotionContext(_) {
	const { initial: et, animate: tt } = getCurrentTreeVariants(_, react.exports.useContext(MotionContext));
	return react.exports.useMemo(
		() => ({ initial: et, animate: tt }),
		[variantLabelsAsDependency(et), variantLabelsAsDependency(tt)]
	);
}
function variantLabelsAsDependency(_) {
	return Array.isArray(_) ? _.join(" ") : _;
}
const createDefinition = (_) => ({ isEnabled: (et) => _.some((tt) => !!et[tt]) }),
	featureDefinitions = {
		measureLayout: createDefinition(["layout", "layoutId", "drag"]),
		animation: createDefinition([
			"animate",
			"exit",
			"variants",
			"whileHover",
			"whileTap",
			"whileFocus",
			"whileDrag",
			"whileInView",
		]),
		exit: createDefinition(["exit"]),
		drag: createDefinition(["drag", "dragControls"]),
		focus: createDefinition(["whileFocus"]),
		hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
		tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
		pan: createDefinition(["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"]),
		inView: createDefinition(["whileInView", "onViewportEnter", "onViewportLeave"]),
	};
function loadFeatures(_) {
	for (const et in _)
		et === "projectionNodeConstructor"
			? (featureDefinitions.projectionNodeConstructor = _[et])
			: (featureDefinitions[et].Component = _[et]);
}
function useConstant(_) {
	const et = react.exports.useRef(null);
	return et.current === null && (et.current = _()), et.current;
}
const globalProjectionState = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
let id$1 = 1;
function useProjectionId() {
	return useConstant(() => {
		if (globalProjectionState.hasEverUpdated) return id$1++;
	});
}
const LayoutGroupContext = react.exports.createContext({});
class VisualElementHandler extends React$1.Component {
	getSnapshotBeforeUpdate() {
		const { visualElement: et, props: tt } = this.props;
		return et && et.setProps(tt), null;
	}
	componentDidUpdate() {}
	render() {
		return this.props.children;
	}
}
const SwitchLayoutGroupContext = react.exports.createContext({}),
	motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({
	preloadedFeatures: _,
	createVisualElement: et,
	projectionNodeConstructor: tt,
	useRender: nt,
	useVisualState: rt,
	Component: it,
}) {
	_ && loadFeatures(_);
	function ot(st, lt) {
		const ut = { ...react.exports.useContext(MotionConfigContext), ...st, layoutId: useLayoutId(st) },
			{ isStatic: dt } = ut;
		let ct = null;
		const ft = useCreateMotionContext(st),
			mt = dt ? void 0 : useProjectionId(),
			pt = rt(st, dt);
		if (!dt && isBrowser$1) {
			ft.visualElement = useVisualElement(it, pt, ut, et);
			const vt = react.exports.useContext(LazyContext).strict,
				ht = react.exports.useContext(SwitchLayoutGroupContext);
			ft.visualElement &&
				(ct = ft.visualElement.loadFeatures(ut, vt, _, mt, tt || featureDefinitions.projectionNodeConstructor, ht));
		}
		return jsxs(VisualElementHandler, {
			visualElement: ft.visualElement,
			props: ut,
			children: [
				ct,
				jsx(MotionContext.Provider, {
					value: ft,
					children: nt(it, st, mt, useMotionRef(pt, ft.visualElement, lt), pt, dt, ft.visualElement),
				}),
			],
		});
	}
	const at = react.exports.forwardRef(ot);
	return (at[motionComponentSymbol] = it), at;
}
function useLayoutId({ layoutId: _ }) {
	const et = react.exports.useContext(LayoutGroupContext).id;
	return et && _ !== void 0 ? et + "-" + _ : _;
}
function createMotionProxy(_) {
	function et(nt, rt = {}) {
		return createMotionComponent(_(nt, rt));
	}
	if (typeof Proxy > "u") return et;
	const tt = new Map();
	return new Proxy(et, { get: (nt, rt) => (tt.has(rt) || tt.set(rt, et(rt)), tt.get(rt)) });
}
const lowercaseSVGElements = [
	"animate",
	"circle",
	"defs",
	"desc",
	"ellipse",
	"g",
	"image",
	"line",
	"filter",
	"marker",
	"mask",
	"metadata",
	"path",
	"pattern",
	"polygon",
	"polyline",
	"rect",
	"stop",
	"svg",
	"switch",
	"symbol",
	"text",
	"tspan",
	"use",
	"view",
];
function isSVGComponent(_) {
	return typeof _ != "string" || _.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(_) > -1 || /[A-Z]/.test(_));
}
const scaleCorrectors = {};
function addScaleCorrector(_) {
	Object.assign(scaleCorrectors, _);
}
const transformPropOrder = [
		"transformPerspective",
		"x",
		"y",
		"z",
		"translateX",
		"translateY",
		"translateZ",
		"scale",
		"scaleX",
		"scaleY",
		"rotate",
		"rotateX",
		"rotateY",
		"rotateZ",
		"skew",
		"skewX",
		"skewY",
	],
	transformProps = new Set(transformPropOrder);
function isForcedMotionValue(_, { layout: et, layoutId: tt }) {
	return (
		transformProps.has(_) ||
		_.startsWith("origin") ||
		((et || tt !== void 0) && (!!scaleCorrectors[_] || _ === "opacity"))
	);
}
const isMotionValue = (_) => !!(_ != null && _.getVelocity),
	translateAlias = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" },
	sortTransformProps = (_, et) => transformPropOrder.indexOf(_) - transformPropOrder.indexOf(et);
function buildTransform(
	{ transform: _, transformKeys: et },
	{ enableHardwareAcceleration: tt = !0, allowTransformNone: nt = !0 },
	rt,
	it
) {
	let ot = "";
	et.sort(sortTransformProps);
	for (const at of et) ot += `${translateAlias[at] || at}(${_[at]}) `;
	return (
		tt && !_.z && (ot += "translateZ(0)"),
		(ot = ot.trim()),
		it ? (ot = it(_, rt ? "" : ot)) : nt && rt && (ot = "none"),
		ot
	);
}
function isCSSVariable$1(_) {
	return _.startsWith("--");
}
const getValueAsType = (_, et) => (et && typeof _ == "number" ? et.transform(_) : _),
	clamp$2 = (_, et) => (tt) => Math.max(Math.min(tt, et), _),
	sanitize = (_) => (_ % 1 ? Number(_.toFixed(5)) : _),
	floatRegex = /(-)?([\d]*\.?[\d])+/g,
	colorRegex =
		/(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
	singleColorRegex =
		/^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString$3(_) {
	return typeof _ == "string";
}
const number$1 = { test: (_) => typeof _ == "number", parse: parseFloat, transform: (_) => _ },
	alpha = Object.assign(Object.assign({}, number$1), { transform: clamp$2(0, 1) }),
	scale = Object.assign(Object.assign({}, number$1), { default: 1 }),
	createUnitType = (_) => ({
		test: (et) => isString$3(et) && et.endsWith(_) && et.split(" ").length === 1,
		parse: parseFloat,
		transform: (et) => `${et}${_}`,
	}),
	degrees = createUnitType("deg"),
	percent = createUnitType("%"),
	px$1 = createUnitType("px"),
	vh$1 = createUnitType("vh"),
	vw = createUnitType("vw"),
	progressPercentage = Object.assign(Object.assign({}, percent), {
		parse: (_) => percent.parse(_) / 100,
		transform: (_) => percent.transform(_ * 100),
	}),
	isColorString = (_, et) => (tt) =>
		Boolean(
			(isString$3(tt) && singleColorRegex.test(tt) && tt.startsWith(_)) ||
				(et && Object.prototype.hasOwnProperty.call(tt, et))
		),
	splitColor = (_, et, tt) => (nt) => {
		if (!isString$3(nt)) return nt;
		const [rt, it, ot, at] = nt.match(floatRegex);
		return {
			[_]: parseFloat(rt),
			[et]: parseFloat(it),
			[tt]: parseFloat(ot),
			alpha: at !== void 0 ? parseFloat(at) : 1,
		};
	},
	hsla = {
		test: isColorString("hsl", "hue"),
		parse: splitColor("hue", "saturation", "lightness"),
		transform: ({ hue: _, saturation: et, lightness: tt, alpha: nt = 1 }) =>
			"hsla(" +
			Math.round(_) +
			", " +
			percent.transform(sanitize(et)) +
			", " +
			percent.transform(sanitize(tt)) +
			", " +
			sanitize(alpha.transform(nt)) +
			")",
	},
	clampRgbUnit = clamp$2(0, 255),
	rgbUnit = Object.assign(Object.assign({}, number$1), { transform: (_) => Math.round(clampRgbUnit(_)) }),
	rgba = {
		test: isColorString("rgb", "red"),
		parse: splitColor("red", "green", "blue"),
		transform: ({ red: _, green: et, blue: tt, alpha: nt = 1 }) =>
			"rgba(" +
			rgbUnit.transform(_) +
			", " +
			rgbUnit.transform(et) +
			", " +
			rgbUnit.transform(tt) +
			", " +
			sanitize(alpha.transform(nt)) +
			")",
	};
function parseHex(_) {
	let et = "",
		tt = "",
		nt = "",
		rt = "";
	return (
		_.length > 5
			? ((et = _.substr(1, 2)), (tt = _.substr(3, 2)), (nt = _.substr(5, 2)), (rt = _.substr(7, 2)))
			: ((et = _.substr(1, 1)),
			  (tt = _.substr(2, 1)),
			  (nt = _.substr(3, 1)),
			  (rt = _.substr(4, 1)),
			  (et += et),
			  (tt += tt),
			  (nt += nt),
			  (rt += rt)),
		{ red: parseInt(et, 16), green: parseInt(tt, 16), blue: parseInt(nt, 16), alpha: rt ? parseInt(rt, 16) / 255 : 1 }
	);
}
const hex = { test: isColorString("#"), parse: parseHex, transform: rgba.transform },
	color$1 = {
		test: (_) => rgba.test(_) || hex.test(_) || hsla.test(_),
		parse: (_) => (rgba.test(_) ? rgba.parse(_) : hsla.test(_) ? hsla.parse(_) : hex.parse(_)),
		transform: (_) => (isString$3(_) ? _ : _.hasOwnProperty("red") ? rgba.transform(_) : hsla.transform(_)),
	},
	colorToken = "${c}",
	numberToken = "${n}";
function test(_) {
	var et, tt, nt, rt;
	return (
		isNaN(_) &&
		isString$3(_) &&
		((tt = (et = _.match(floatRegex)) === null || et === void 0 ? void 0 : et.length) !== null && tt !== void 0
			? tt
			: 0) +
			((rt = (nt = _.match(colorRegex)) === null || nt === void 0 ? void 0 : nt.length) !== null && rt !== void 0
				? rt
				: 0) >
			0
	);
}
function analyse$1(_) {
	typeof _ == "number" && (_ = `${_}`);
	const et = [];
	let tt = 0;
	const nt = _.match(colorRegex);
	nt && ((tt = nt.length), (_ = _.replace(colorRegex, colorToken)), et.push(...nt.map(color$1.parse)));
	const rt = _.match(floatRegex);
	return (
		rt && ((_ = _.replace(floatRegex, numberToken)), et.push(...rt.map(number$1.parse))),
		{ values: et, numColors: tt, tokenised: _ }
	);
}
function parse$3(_) {
	return analyse$1(_).values;
}
function createTransformer(_) {
	const { values: et, numColors: tt, tokenised: nt } = analyse$1(_),
		rt = et.length;
	return (it) => {
		let ot = nt;
		for (let at = 0; at < rt; at++)
			ot = ot.replace(at < tt ? colorToken : numberToken, at < tt ? color$1.transform(it[at]) : sanitize(it[at]));
		return ot;
	};
}
const convertNumbersToZero = (_) => (typeof _ == "number" ? 0 : _);
function getAnimatableNone$1(_) {
	const et = parse$3(_);
	return createTransformer(_)(et.map(convertNumbersToZero));
}
const complex = { test, parse: parse$3, createTransformer, getAnimatableNone: getAnimatableNone$1 },
	maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(_) {
	let [et, tt] = _.slice(0, -1).split("(");
	if (et === "drop-shadow") return _;
	const [nt] = tt.match(floatRegex) || [];
	if (!nt) return _;
	const rt = tt.replace(nt, "");
	let it = maxDefaults.has(et) ? 1 : 0;
	return nt !== tt && (it *= 100), et + "(" + it + rt + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g,
	filter$1 = Object.assign(Object.assign({}, complex), {
		getAnimatableNone: (_) => {
			const et = _.match(functionRegex);
			return et ? et.map(applyDefaultFilter).join(" ") : _;
		},
	}),
	int = { ...number$1, transform: Math.round },
	numberValueTypes = {
		borderWidth: px$1,
		borderTopWidth: px$1,
		borderRightWidth: px$1,
		borderBottomWidth: px$1,
		borderLeftWidth: px$1,
		borderRadius: px$1,
		radius: px$1,
		borderTopLeftRadius: px$1,
		borderTopRightRadius: px$1,
		borderBottomRightRadius: px$1,
		borderBottomLeftRadius: px$1,
		width: px$1,
		maxWidth: px$1,
		height: px$1,
		maxHeight: px$1,
		size: px$1,
		top: px$1,
		right: px$1,
		bottom: px$1,
		left: px$1,
		padding: px$1,
		paddingTop: px$1,
		paddingRight: px$1,
		paddingBottom: px$1,
		paddingLeft: px$1,
		margin: px$1,
		marginTop: px$1,
		marginRight: px$1,
		marginBottom: px$1,
		marginLeft: px$1,
		rotate: degrees,
		rotateX: degrees,
		rotateY: degrees,
		rotateZ: degrees,
		scale,
		scaleX: scale,
		scaleY: scale,
		scaleZ: scale,
		skew: degrees,
		skewX: degrees,
		skewY: degrees,
		distance: px$1,
		translateX: px$1,
		translateY: px$1,
		translateZ: px$1,
		x: px$1,
		y: px$1,
		z: px$1,
		perspective: px$1,
		transformPerspective: px$1,
		opacity: alpha,
		originX: progressPercentage,
		originY: progressPercentage,
		originZ: px$1,
		zIndex: int,
		fillOpacity: alpha,
		strokeOpacity: alpha,
		numOctaves: int,
	};
function buildHTMLStyles(_, et, tt, nt) {
	const { style: rt, vars: it, transform: ot, transformKeys: at, transformOrigin: st } = _;
	at.length = 0;
	let lt = !1,
		ut = !1,
		dt = !0;
	for (const ct in et) {
		const ft = et[ct];
		if (isCSSVariable$1(ct)) {
			it[ct] = ft;
			continue;
		}
		const mt = numberValueTypes[ct],
			pt = getValueAsType(ft, mt);
		if (transformProps.has(ct)) {
			if (((lt = !0), (ot[ct] = pt), at.push(ct), !dt)) continue;
			ft !== (mt.default || 0) && (dt = !1);
		} else ct.startsWith("origin") ? ((ut = !0), (st[ct] = pt)) : (rt[ct] = pt);
	}
	if (
		(lt || nt
			? (rt.transform = buildTransform(_, tt, dt, nt))
			: !et.transform && rt.transform && (rt.transform = "none"),
		ut)
	) {
		const { originX: ct = "50%", originY: ft = "50%", originZ: mt = 0 } = st;
		rt.transformOrigin = `${ct} ${ft} ${mt}`;
	}
}
const createHtmlRenderState = () => ({ style: {}, transform: {}, transformKeys: [], transformOrigin: {}, vars: {} });
function copyRawValuesOnly(_, et, tt) {
	for (const nt in et) !isMotionValue(et[nt]) && !isForcedMotionValue(nt, tt) && (_[nt] = et[nt]);
}
function useInitialMotionValues({ transformTemplate: _ }, et, tt) {
	return react.exports.useMemo(() => {
		const nt = createHtmlRenderState();
		return buildHTMLStyles(nt, et, { enableHardwareAcceleration: !tt }, _), Object.assign({}, nt.vars, nt.style);
	}, [et]);
}
function useStyle(_, et, tt) {
	const nt = _.style || {},
		rt = {};
	return (
		copyRawValuesOnly(rt, nt, _),
		Object.assign(rt, useInitialMotionValues(_, et, tt)),
		_.transformValues ? _.transformValues(rt) : rt
	);
}
function useHTMLProps(_, et, tt) {
	const nt = {},
		rt = useStyle(_, et, tt);
	return (
		_.drag &&
			_.dragListener !== !1 &&
			((nt.draggable = !1),
			(rt.userSelect = rt.WebkitUserSelect = rt.WebkitTouchCallout = "none"),
			(rt.touchAction = _.drag === !0 ? "none" : `pan-${_.drag === "x" ? "y" : "x"}`)),
		(nt.style = rt),
		nt
	);
}
const animationProps = [
		"animate",
		"exit",
		"variants",
		"whileHover",
		"whileTap",
		"whileFocus",
		"whileDrag",
		"whileInView",
	],
	tapProps = ["whileTap", "onTap", "onTapStart", "onTapCancel"],
	panProps = ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
	inViewProps = ["whileInView", "onViewportEnter", "onViewportLeave", "viewport"],
	validMotionProps = new Set([
		"initial",
		"style",
		"variants",
		"transition",
		"transformTemplate",
		"transformValues",
		"custom",
		"inherit",
		"layout",
		"layoutId",
		"layoutDependency",
		"onLayoutAnimationStart",
		"onLayoutAnimationComplete",
		"onLayoutMeasure",
		"onBeforeLayoutMeasure",
		"onAnimationStart",
		"onAnimationComplete",
		"onUpdate",
		"onDragStart",
		"onDrag",
		"onDragEnd",
		"onMeasureDragConstraints",
		"onDirectionLock",
		"onDragTransitionEnd",
		"drag",
		"dragControls",
		"dragListener",
		"dragConstraints",
		"dragDirectionLock",
		"dragSnapToOrigin",
		"_dragX",
		"_dragY",
		"dragElastic",
		"dragMomentum",
		"dragPropagation",
		"dragTransition",
		"onHoverStart",
		"onHoverEnd",
		"layoutScroll",
		...inViewProps,
		...tapProps,
		...animationProps,
		...panProps,
	]);
function isValidMotionProp(_) {
	return validMotionProps.has(_);
}
let shouldForward = (_) => !isValidMotionProp(_);
function loadExternalIsValidProp(_) {
	!_ || (shouldForward = (et) => (et.startsWith("on") ? !isValidMotionProp(et) : _(et)));
}
try {
	loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {}
function filterProps(_, et, tt) {
	const nt = {};
	for (const rt in _)
		(shouldForward(rt) ||
			(tt === !0 && isValidMotionProp(rt)) ||
			(!et && !isValidMotionProp(rt)) ||
			(_.draggable && rt.startsWith("onDrag"))) &&
			(nt[rt] = _[rt]);
	return nt;
}
function calcOrigin$1(_, et, tt) {
	return typeof _ == "string" ? _ : px$1.transform(et + tt * _);
}
function calcSVGTransformOrigin(_, et, tt) {
	const nt = calcOrigin$1(et, _.x, _.width),
		rt = calcOrigin$1(tt, _.y, _.height);
	return `${nt} ${rt}`;
}
const dashKeys = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
	camelKeys = { offset: "strokeDashoffset", array: "strokeDasharray" };
function buildSVGPath(_, et, tt = 1, nt = 0, rt = !0) {
	_.pathLength = 1;
	const it = rt ? dashKeys : camelKeys;
	_[it.offset] = px$1.transform(-nt);
	const ot = px$1.transform(et),
		at = px$1.transform(tt);
	_[it.array] = `${ot} ${at}`;
}
function buildSVGAttrs(
	_,
	{ attrX: et, attrY: tt, originX: nt, originY: rt, pathLength: it, pathSpacing: ot = 1, pathOffset: at = 0, ...st },
	lt,
	ut
) {
	buildHTMLStyles(_, st, lt, ut), (_.attrs = _.style), (_.style = {});
	const { attrs: dt, style: ct, dimensions: ft } = _;
	dt.transform && (ft && (ct.transform = dt.transform), delete dt.transform),
		ft &&
			(nt !== void 0 || rt !== void 0 || ct.transform) &&
			(ct.transformOrigin = calcSVGTransformOrigin(ft, nt !== void 0 ? nt : 0.5, rt !== void 0 ? rt : 0.5)),
		et !== void 0 && (dt.x = et),
		tt !== void 0 && (dt.y = tt),
		it !== void 0 && buildSVGPath(dt, it, ot, at, !1);
}
const createSvgRenderState = () => ({ ...createHtmlRenderState(), attrs: {} });
function useSVGProps(_, et) {
	const tt = react.exports.useMemo(() => {
		const nt = createSvgRenderState();
		return (
			buildSVGAttrs(nt, et, { enableHardwareAcceleration: !1 }, _.transformTemplate),
			{ ...nt.attrs, style: { ...nt.style } }
		);
	}, [et]);
	if (_.style) {
		const nt = {};
		copyRawValuesOnly(nt, _.style, _), (tt.style = { ...nt, ...tt.style });
	}
	return tt;
}
function createUseRender(_ = !1) {
	return (tt, nt, rt, it, { latestValues: ot }, at) => {
		const lt = (isSVGComponent(tt) ? useSVGProps : useHTMLProps)(nt, ot, at),
			dt = { ...filterProps(nt, typeof tt == "string", _), ...lt, ref: it };
		return rt && (dt["data-projection-id"] = rt), react.exports.createElement(tt, dt);
	};
}
const camelToDash = (_) => _.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(_, { style: et, vars: tt }, nt, rt) {
	Object.assign(_.style, et, rt && rt.getProjectionStyles(nt));
	for (const it in tt) _.style.setProperty(it, tt[it]);
}
const camelCaseAttributes = new Set([
	"baseFrequency",
	"diffuseConstant",
	"kernelMatrix",
	"kernelUnitLength",
	"keySplines",
	"keyTimes",
	"limitingConeAngle",
	"markerHeight",
	"markerWidth",
	"numOctaves",
	"targetX",
	"targetY",
	"surfaceScale",
	"specularConstant",
	"specularExponent",
	"stdDeviation",
	"tableValues",
	"viewBox",
	"gradientTransform",
	"pathLength",
]);
function renderSVG(_, et, tt, nt) {
	renderHTML(_, et, void 0, nt);
	for (const rt in et.attrs) _.setAttribute(camelCaseAttributes.has(rt) ? rt : camelToDash(rt), et.attrs[rt]);
}
function scrapeMotionValuesFromProps$1(_) {
	const { style: et } = _,
		tt = {};
	for (const nt in et) (isMotionValue(et[nt]) || isForcedMotionValue(nt, _)) && (tt[nt] = et[nt]);
	return tt;
}
function scrapeMotionValuesFromProps(_) {
	const et = scrapeMotionValuesFromProps$1(_);
	for (const tt in _)
		if (isMotionValue(_[tt])) {
			const nt = tt === "x" || tt === "y" ? "attr" + tt.toUpperCase() : tt;
			et[nt] = _[tt];
		}
	return et;
}
function resolveVariantFromProps(_, et, tt, nt = {}, rt = {}) {
	return (
		typeof et == "function" && (et = et(tt !== void 0 ? tt : _.custom, nt, rt)),
		typeof et == "string" && (et = _.variants && _.variants[et]),
		typeof et == "function" && (et = et(tt !== void 0 ? tt : _.custom, nt, rt)),
		et
	);
}
const isKeyframesTarget = (_) => Array.isArray(_),
	isCustomValue = (_) => Boolean(_ && typeof _ == "object" && _.mix && _.toValue),
	resolveFinalValueInKeyframes = (_) => (isKeyframesTarget(_) ? _[_.length - 1] || 0 : _);
function resolveMotionValue(_) {
	const et = isMotionValue(_) ? _.get() : _;
	return isCustomValue(et) ? et.toValue() : et;
}
function makeState({ scrapeMotionValuesFromProps: _, createRenderState: et, onMount: tt }, nt, rt, it) {
	const ot = { latestValues: makeLatestValues(nt, rt, it, _), renderState: et() };
	return tt && (ot.mount = (at) => tt(nt, at, ot)), ot;
}
const makeUseVisualState = (_) => (et, tt) => {
	const nt = react.exports.useContext(MotionContext),
		rt = react.exports.useContext(PresenceContext),
		it = () => makeState(_, et, nt, rt);
	return tt ? it() : useConstant(it);
};
function makeLatestValues(_, et, tt, nt) {
	const rt = {},
		it = nt(_);
	for (const ct in it) rt[ct] = resolveMotionValue(it[ct]);
	let { initial: ot, animate: at } = _;
	const st = isControllingVariants(_),
		lt = isVariantNode(_);
	et && lt && !st && _.inherit !== !1 && (ot === void 0 && (ot = et.initial), at === void 0 && (at = et.animate));
	let ut = tt ? tt.initial === !1 : !1;
	ut = ut || ot === !1;
	const dt = ut ? at : ot;
	return (
		dt &&
			typeof dt != "boolean" &&
			!isAnimationControls(dt) &&
			(Array.isArray(dt) ? dt : [dt]).forEach((ft) => {
				const mt = resolveVariantFromProps(_, ft);
				if (!mt) return;
				const { transitionEnd: pt, transition: vt, ...ht } = mt;
				for (const gt in ht) {
					let yt = ht[gt];
					if (Array.isArray(yt)) {
						const xt = ut ? yt.length - 1 : 0;
						yt = yt[xt];
					}
					yt !== null && (rt[gt] = yt);
				}
				for (const gt in pt) rt[gt] = pt[gt];
			}),
		rt
	);
}
const svgMotionConfig = {
		useVisualState: makeUseVisualState({
			scrapeMotionValuesFromProps,
			createRenderState: createSvgRenderState,
			onMount: (_, et, { renderState: tt, latestValues: nt }) => {
				try {
					tt.dimensions = typeof et.getBBox == "function" ? et.getBBox() : et.getBoundingClientRect();
				} catch {
					tt.dimensions = { x: 0, y: 0, width: 0, height: 0 };
				}
				buildSVGAttrs(tt, nt, { enableHardwareAcceleration: !1 }, _.transformTemplate), renderSVG(et, tt);
			},
		}),
	},
	htmlMotionConfig = {
		useVisualState: makeUseVisualState({
			scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
			createRenderState: createHtmlRenderState,
		}),
	};
function createDomMotionConfig(_, { forwardMotionProps: et = !1 }, tt, nt, rt) {
	return {
		...(isSVGComponent(_) ? svgMotionConfig : htmlMotionConfig),
		preloadedFeatures: tt,
		useRender: createUseRender(et),
		createVisualElement: nt,
		projectionNodeConstructor: rt,
		Component: _,
	};
}
var AnimationType;
(function (_) {
	(_.Animate = "animate"),
		(_.Hover = "whileHover"),
		(_.Tap = "whileTap"),
		(_.Drag = "whileDrag"),
		(_.Focus = "whileFocus"),
		(_.InView = "whileInView"),
		(_.Exit = "exit");
})(AnimationType || (AnimationType = {}));
function addDomEvent(_, et, tt, nt = { passive: !0 }) {
	return _.addEventListener(et, tt, nt), () => _.removeEventListener(et, tt);
}
function useDomEvent(_, et, tt, nt) {
	react.exports.useEffect(() => {
		const rt = _.current;
		if (tt && rt) return addDomEvent(rt, et, tt, nt);
	}, [_, et, tt, nt]);
}
function useFocusGesture({ whileFocus: _, visualElement: et }) {
	const { animationState: tt } = et,
		nt = () => {
			tt && tt.setActive(AnimationType.Focus, !0);
		},
		rt = () => {
			tt && tt.setActive(AnimationType.Focus, !1);
		};
	useDomEvent(et, "focus", _ ? nt : void 0), useDomEvent(et, "blur", _ ? rt : void 0);
}
function isMouseEvent(_) {
	return typeof PointerEvent < "u" && _ instanceof PointerEvent ? _.pointerType === "mouse" : _ instanceof MouseEvent;
}
function isTouchEvent(_) {
	return !!_.touches;
}
function filterPrimaryPointer(_) {
	return (et) => {
		const tt = et instanceof MouseEvent;
		(!tt || (tt && et.button === 0)) && _(et);
	};
}
const defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(_, et = "page") {
	const nt = _.touches[0] || _.changedTouches[0] || defaultPagePoint;
	return { x: nt[et + "X"], y: nt[et + "Y"] };
}
function pointFromMouse(_, et = "page") {
	return { x: _[et + "X"], y: _[et + "Y"] };
}
function extractEventInfo(_, et = "page") {
	return { point: isTouchEvent(_) ? pointFromTouch(_, et) : pointFromMouse(_, et) };
}
const wrapHandler = (_, et = !1) => {
		const tt = (nt) => _(nt, extractEventInfo(nt));
		return et ? filterPrimaryPointer(tt) : tt;
	},
	supportsPointerEvents = () => isBrowser$1 && window.onpointerdown === null,
	supportsTouchEvents = () => isBrowser$1 && window.ontouchstart === null,
	supportsMouseEvents = () => isBrowser$1 && window.onmousedown === null,
	mouseEventNames = {
		pointerdown: "mousedown",
		pointermove: "mousemove",
		pointerup: "mouseup",
		pointercancel: "mousecancel",
		pointerover: "mouseover",
		pointerout: "mouseout",
		pointerenter: "mouseenter",
		pointerleave: "mouseleave",
	},
	touchEventNames = {
		pointerdown: "touchstart",
		pointermove: "touchmove",
		pointerup: "touchend",
		pointercancel: "touchcancel",
	};
function getPointerEventName(_) {
	return supportsPointerEvents()
		? _
		: supportsTouchEvents()
		? touchEventNames[_]
		: supportsMouseEvents()
		? mouseEventNames[_]
		: _;
}
function addPointerEvent(_, et, tt, nt) {
	return addDomEvent(_, getPointerEventName(et), wrapHandler(tt, et === "pointerdown"), nt);
}
function usePointerEvent$1(_, et, tt, nt) {
	return useDomEvent(_, getPointerEventName(et), tt && wrapHandler(tt, et === "pointerdown"), nt);
}
function createLock(_) {
	let et = null;
	return () => {
		const tt = () => {
			et = null;
		};
		return et === null ? ((et = _), tt) : !1;
	};
}
const globalHorizontalLock = createLock("dragHorizontal"),
	globalVerticalLock = createLock("dragVertical");
function getGlobalLock(_) {
	let et = !1;
	if (_ === "y") et = globalVerticalLock();
	else if (_ === "x") et = globalHorizontalLock();
	else {
		const tt = globalHorizontalLock(),
			nt = globalVerticalLock();
		tt && nt
			? (et = () => {
					tt(), nt();
			  })
			: (tt && tt(), nt && nt());
	}
	return et;
}
function isDragActive() {
	const _ = getGlobalLock(!0);
	return _ ? (_(), !1) : !0;
}
function createHoverEvent(_, et, tt) {
	return (nt, rt) => {
		!isMouseEvent(nt) ||
			isDragActive() ||
			(_.animationState && _.animationState.setActive(AnimationType.Hover, et), tt && tt(nt, rt));
	};
}
function useHoverGesture({ onHoverStart: _, onHoverEnd: et, whileHover: tt, visualElement: nt }) {
	usePointerEvent$1(nt, "pointerenter", _ || tt ? createHoverEvent(nt, !0, _) : void 0, { passive: !_ }),
		usePointerEvent$1(nt, "pointerleave", et || tt ? createHoverEvent(nt, !1, et) : void 0, { passive: !et });
}
const isNodeOrChild = (_, et) => (et ? (_ === et ? !0 : isNodeOrChild(_, et.parentElement)) : !1);
function useUnmountEffect$1(_) {
	return react.exports.useEffect(() => () => _(), []);
}
var __assign$4 = function () {
	return (
		(__assign$4 =
			Object.assign ||
			function (et) {
				for (var tt, nt = 1, rt = arguments.length; nt < rt; nt++) {
					tt = arguments[nt];
					for (var it in tt) Object.prototype.hasOwnProperty.call(tt, it) && (et[it] = tt[it]);
				}
				return et;
			}),
		__assign$4.apply(this, arguments)
	);
};
function __rest$2(_, et) {
	var tt = {};
	for (var nt in _) Object.prototype.hasOwnProperty.call(_, nt) && et.indexOf(nt) < 0 && (tt[nt] = _[nt]);
	if (_ != null && typeof Object.getOwnPropertySymbols == "function")
		for (var rt = 0, nt = Object.getOwnPropertySymbols(_); rt < nt.length; rt++)
			et.indexOf(nt[rt]) < 0 && Object.prototype.propertyIsEnumerable.call(_, nt[rt]) && (tt[nt[rt]] = _[nt[rt]]);
	return tt;
}
function __spreadArray(_, et, tt) {
	if (tt || arguments.length === 2)
		for (var nt = 0, rt = et.length, it; nt < rt; nt++)
			(it || !(nt in et)) && (it || (it = Array.prototype.slice.call(et, 0, nt)), (it[nt] = et[nt]));
	return _.concat(it || Array.prototype.slice.call(et));
}
var warning = function () {},
	invariant$1 = function () {};
const clamp$1 = (_, et, tt) => Math.min(Math.max(tt, _), et),
	safeMin = 0.001,
	minDuration = 0.01,
	maxDuration = 10,
	minDamping = 0.05,
	maxDamping = 1;
function findSpring({ duration: _ = 800, bounce: et = 0.25, velocity: tt = 0, mass: nt = 1 }) {
	let rt, it;
	warning(_ <= maxDuration * 1e3);
	let ot = 1 - et;
	(ot = clamp$1(minDamping, maxDamping, ot)),
		(_ = clamp$1(minDuration, maxDuration, _ / 1e3)),
		ot < 1
			? ((rt = (lt) => {
					const ut = lt * ot,
						dt = ut * _,
						ct = ut - tt,
						ft = calcAngularFreq(lt, ot),
						mt = Math.exp(-dt);
					return safeMin - (ct / ft) * mt;
			  }),
			  (it = (lt) => {
					const dt = lt * ot * _,
						ct = dt * tt + tt,
						ft = Math.pow(ot, 2) * Math.pow(lt, 2) * _,
						mt = Math.exp(-dt),
						pt = calcAngularFreq(Math.pow(lt, 2), ot);
					return ((-rt(lt) + safeMin > 0 ? -1 : 1) * ((ct - ft) * mt)) / pt;
			  }))
			: ((rt = (lt) => {
					const ut = Math.exp(-lt * _),
						dt = (lt - tt) * _ + 1;
					return -safeMin + ut * dt;
			  }),
			  (it = (lt) => {
					const ut = Math.exp(-lt * _),
						dt = (tt - lt) * (_ * _);
					return ut * dt;
			  }));
	const at = 5 / _,
		st = approximateRoot(rt, it, at);
	if (((_ = _ * 1e3), isNaN(st))) return { stiffness: 100, damping: 10, duration: _ };
	{
		const lt = Math.pow(st, 2) * nt;
		return { stiffness: lt, damping: ot * 2 * Math.sqrt(nt * lt), duration: _ };
	}
}
const rootIterations = 12;
function approximateRoot(_, et, tt) {
	let nt = tt;
	for (let rt = 1; rt < rootIterations; rt++) nt = nt - _(nt) / et(nt);
	return nt;
}
function calcAngularFreq(_, et) {
	return _ * Math.sqrt(1 - et * et);
}
const durationKeys = ["duration", "bounce"],
	physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(_, et) {
	return et.some((tt) => _[tt] !== void 0);
}
function getSpringOptions(_) {
	let et = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1 }, _);
	if (!isSpringType(_, physicsKeys) && isSpringType(_, durationKeys)) {
		const tt = findSpring(_);
		(et = Object.assign(Object.assign(Object.assign({}, et), tt), { velocity: 0, mass: 1 })),
			(et.isResolvedFromDuration = !0);
	}
	return et;
}
function spring(_) {
	var { from: et = 0, to: tt = 1, restSpeed: nt = 2, restDelta: rt } = _,
		it = __rest$2(_, ["from", "to", "restSpeed", "restDelta"]);
	const ot = { done: !1, value: et };
	let {
			stiffness: at,
			damping: st,
			mass: lt,
			velocity: ut,
			duration: dt,
			isResolvedFromDuration: ct,
		} = getSpringOptions(it),
		ft = zero,
		mt = zero;
	function pt() {
		const vt = ut ? -(ut / 1e3) : 0,
			ht = tt - et,
			gt = st / (2 * Math.sqrt(at * lt)),
			yt = Math.sqrt(at / lt) / 1e3;
		if ((rt === void 0 && (rt = Math.min(Math.abs(tt - et) / 100, 0.4)), gt < 1)) {
			const xt = calcAngularFreq(yt, gt);
			(ft = (St) => {
				const wt = Math.exp(-gt * yt * St);
				return tt - wt * (((vt + gt * yt * ht) / xt) * Math.sin(xt * St) + ht * Math.cos(xt * St));
			}),
				(mt = (St) => {
					const wt = Math.exp(-gt * yt * St);
					return (
						gt * yt * wt * ((Math.sin(xt * St) * (vt + gt * yt * ht)) / xt + ht * Math.cos(xt * St)) -
						wt * (Math.cos(xt * St) * (vt + gt * yt * ht) - xt * ht * Math.sin(xt * St))
					);
				});
		} else if (gt === 1) ft = (xt) => tt - Math.exp(-yt * xt) * (ht + (vt + yt * ht) * xt);
		else {
			const xt = yt * Math.sqrt(gt * gt - 1);
			ft = (St) => {
				const wt = Math.exp(-gt * yt * St),
					Ct = Math.min(xt * St, 300);
				return tt - (wt * ((vt + gt * yt * ht) * Math.sinh(Ct) + xt * ht * Math.cosh(Ct))) / xt;
			};
		}
	}
	return (
		pt(),
		{
			next: (vt) => {
				const ht = ft(vt);
				if (ct) ot.done = vt >= dt;
				else {
					const gt = mt(vt) * 1e3,
						yt = Math.abs(gt) <= nt,
						xt = Math.abs(tt - ht) <= rt;
					ot.done = yt && xt;
				}
				return (ot.value = ot.done ? tt : ht), ot;
			},
			flipTarget: () => {
				(ut = -ut), ([et, tt] = [tt, et]), pt();
			},
		}
	);
}
spring.needsInterpolation = (_, et) => typeof _ == "string" || typeof et == "string";
const zero = (_) => 0,
	progress = (_, et, tt) => {
		const nt = et - _;
		return nt === 0 ? 1 : (tt - _) / nt;
	},
	mix = (_, et, tt) => -tt * _ + tt * et + _;
function hueToRgb(_, et, tt) {
	return (
		tt < 0 && (tt += 1),
		tt > 1 && (tt -= 1),
		tt < 1 / 6 ? _ + (et - _) * 6 * tt : tt < 1 / 2 ? et : tt < 2 / 3 ? _ + (et - _) * (2 / 3 - tt) * 6 : _
	);
}
function hslaToRgba({ hue: _, saturation: et, lightness: tt, alpha: nt }) {
	(_ /= 360), (et /= 100), (tt /= 100);
	let rt = 0,
		it = 0,
		ot = 0;
	if (!et) rt = it = ot = tt;
	else {
		const at = tt < 0.5 ? tt * (1 + et) : tt + et - tt * et,
			st = 2 * tt - at;
		(rt = hueToRgb(st, at, _ + 1 / 3)), (it = hueToRgb(st, at, _)), (ot = hueToRgb(st, at, _ - 1 / 3));
	}
	return { red: Math.round(rt * 255), green: Math.round(it * 255), blue: Math.round(ot * 255), alpha: nt };
}
const mixLinearColor = (_, et, tt) => {
		const nt = _ * _,
			rt = et * et;
		return Math.sqrt(Math.max(0, tt * (rt - nt) + nt));
	},
	colorTypes = [hex, rgba, hsla],
	getColorType = (_) => colorTypes.find((et) => et.test(_)),
	mixColor = (_, et) => {
		let tt = getColorType(_),
			nt = getColorType(et),
			rt = tt.parse(_),
			it = nt.parse(et);
		tt === hsla && ((rt = hslaToRgba(rt)), (tt = rgba)), nt === hsla && ((it = hslaToRgba(it)), (nt = rgba));
		const ot = Object.assign({}, rt);
		return (at) => {
			for (const st in ot) st !== "alpha" && (ot[st] = mixLinearColor(rt[st], it[st], at));
			return (ot.alpha = mix(rt.alpha, it.alpha, at)), tt.transform(ot);
		};
	},
	isNum = (_) => typeof _ == "number",
	combineFunctions = (_, et) => (tt) => et(_(tt)),
	pipe = (..._) => _.reduce(combineFunctions);
function getMixer(_, et) {
	return isNum(_) ? (tt) => mix(_, et, tt) : color$1.test(_) ? mixColor(_, et) : mixComplex(_, et);
}
const mixArray = (_, et) => {
		const tt = [..._],
			nt = tt.length,
			rt = _.map((it, ot) => getMixer(it, et[ot]));
		return (it) => {
			for (let ot = 0; ot < nt; ot++) tt[ot] = rt[ot](it);
			return tt;
		};
	},
	mixObject = (_, et) => {
		const tt = Object.assign(Object.assign({}, _), et),
			nt = {};
		for (const rt in tt) _[rt] !== void 0 && et[rt] !== void 0 && (nt[rt] = getMixer(_[rt], et[rt]));
		return (rt) => {
			for (const it in nt) tt[it] = nt[it](rt);
			return tt;
		};
	};
function analyse(_) {
	const et = complex.parse(_),
		tt = et.length;
	let nt = 0,
		rt = 0,
		it = 0;
	for (let ot = 0; ot < tt; ot++) nt || typeof et[ot] == "number" ? nt++ : et[ot].hue !== void 0 ? it++ : rt++;
	return { parsed: et, numNumbers: nt, numRGB: rt, numHSL: it };
}
const mixComplex = (_, et) => {
		const tt = complex.createTransformer(et),
			nt = analyse(_),
			rt = analyse(et);
		return nt.numHSL === rt.numHSL && nt.numRGB === rt.numRGB && nt.numNumbers >= rt.numNumbers
			? pipe(mixArray(nt.parsed, rt.parsed), tt)
			: (ot) => `${ot > 0 ? et : _}`;
	},
	mixNumber = (_, et) => (tt) => mix(_, et, tt);
function detectMixerFactory(_) {
	if (typeof _ == "number") return mixNumber;
	if (typeof _ == "string") return color$1.test(_) ? mixColor : mixComplex;
	if (Array.isArray(_)) return mixArray;
	if (typeof _ == "object") return mixObject;
}
function createMixers(_, et, tt) {
	const nt = [],
		rt = tt || detectMixerFactory(_[0]),
		it = _.length - 1;
	for (let ot = 0; ot < it; ot++) {
		let at = rt(_[ot], _[ot + 1]);
		if (et) {
			const st = Array.isArray(et) ? et[ot] : et;
			at = pipe(st, at);
		}
		nt.push(at);
	}
	return nt;
}
function fastInterpolate([_, et], [tt]) {
	return (nt) => tt(progress(_, et, nt));
}
function slowInterpolate(_, et) {
	const tt = _.length,
		nt = tt - 1;
	return (rt) => {
		let it = 0,
			ot = !1;
		if ((rt <= _[0] ? (ot = !0) : rt >= _[nt] && ((it = nt - 1), (ot = !0)), !ot)) {
			let st = 1;
			for (; st < tt && !(_[st] > rt || st === nt); st++);
			it = st - 1;
		}
		const at = progress(_[it], _[it + 1], rt);
		return et[it](at);
	};
}
function interpolate(_, et, { clamp: tt = !0, ease: nt, mixer: rt } = {}) {
	const it = _.length;
	invariant$1(it === et.length),
		invariant$1(!nt || !Array.isArray(nt) || nt.length === it - 1),
		_[0] > _[it - 1] && ((_ = [].concat(_)), (et = [].concat(et)), _.reverse(), et.reverse());
	const ot = createMixers(et, nt, rt),
		at = it === 2 ? fastInterpolate(_, ot) : slowInterpolate(_, ot);
	return tt ? (st) => at(clamp$1(_[0], _[it - 1], st)) : at;
}
const reverseEasing = (_) => (et) => 1 - _(1 - et),
	mirrorEasing = (_) => (et) => et <= 0.5 ? _(2 * et) / 2 : (2 - _(2 * (1 - et))) / 2,
	createExpoIn = (_) => (et) => Math.pow(et, _),
	createBackIn = (_) => (et) => et * et * ((_ + 1) * et - _),
	createAnticipate = (_) => {
		const et = createBackIn(_);
		return (tt) => ((tt *= 2) < 1 ? 0.5 * et(tt) : 0.5 * (2 - Math.pow(2, -10 * (tt - 1))));
	},
	DEFAULT_OVERSHOOT_STRENGTH = 1.525,
	BOUNCE_FIRST_THRESHOLD = 4 / 11,
	BOUNCE_SECOND_THRESHOLD = 8 / 11,
	BOUNCE_THIRD_THRESHOLD = 9 / 10,
	linear = (_) => _,
	easeIn = createExpoIn(2),
	easeOut = reverseEasing(easeIn),
	easeInOut = mirrorEasing(easeIn),
	circIn = (_) => 1 - Math.sin(Math.acos(_)),
	circOut = reverseEasing(circIn),
	circInOut = mirrorEasing(circOut),
	backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH),
	backOut = reverseEasing(backIn),
	backInOut = mirrorEasing(backIn),
	anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH),
	ca$1 = 4356 / 361,
	cb$1 = 35442 / 1805,
	cc$1 = 16061 / 1805,
	bounceOut = (_) => {
		if (_ === 1 || _ === 0) return _;
		const et = _ * _;
		return _ < BOUNCE_FIRST_THRESHOLD
			? 7.5625 * et
			: _ < BOUNCE_SECOND_THRESHOLD
			? 9.075 * et - 9.9 * _ + 3.4
			: _ < BOUNCE_THIRD_THRESHOLD
			? ca$1 * et - cb$1 * _ + cc$1
			: 10.8 * _ * _ - 20.52 * _ + 10.72;
	},
	bounceIn = reverseEasing(bounceOut),
	bounceInOut = (_) => (_ < 0.5 ? 0.5 * (1 - bounceOut(1 - _ * 2)) : 0.5 * bounceOut(_ * 2 - 1) + 0.5);
function defaultEasing(_, et) {
	return _.map(() => et || easeInOut).splice(0, _.length - 1);
}
function defaultOffset(_) {
	const et = _.length;
	return _.map((tt, nt) => (nt !== 0 ? nt / (et - 1) : 0));
}
function convertOffsetToTimes(_, et) {
	return _.map((tt) => tt * et);
}
function keyframes$1({ from: _ = 0, to: et = 1, ease: tt, offset: nt, duration: rt = 300 }) {
	const it = { done: !1, value: _ },
		ot = Array.isArray(et) ? et : [_, et],
		at = convertOffsetToTimes(nt && nt.length === ot.length ? nt : defaultOffset(ot), rt);
	function st() {
		return interpolate(at, ot, { ease: Array.isArray(tt) ? tt : defaultEasing(ot, tt) });
	}
	let lt = st();
	return {
		next: (ut) => ((it.value = lt(ut)), (it.done = ut >= rt), it),
		flipTarget: () => {
			ot.reverse(), (lt = st());
		},
	};
}
function decay({
	velocity: _ = 0,
	from: et = 0,
	power: tt = 0.8,
	timeConstant: nt = 350,
	restDelta: rt = 0.5,
	modifyTarget: it,
}) {
	const ot = { done: !1, value: et };
	let at = tt * _;
	const st = et + at,
		lt = it === void 0 ? st : it(st);
	return (
		lt !== st && (at = lt - et),
		{
			next: (ut) => {
				const dt = -at * Math.exp(-ut / nt);
				return (ot.done = !(dt > rt || dt < -rt)), (ot.value = ot.done ? lt : lt + dt), ot;
			},
			flipTarget: () => {},
		}
	);
}
const types$2 = { keyframes: keyframes$1, spring, decay };
function detectAnimationFromOptions(_) {
	if (Array.isArray(_.to)) return keyframes$1;
	if (types$2[_.type]) return types$2[_.type];
	const et = new Set(Object.keys(_));
	return et.has("ease") || (et.has("duration") && !et.has("dampingRatio"))
		? keyframes$1
		: et.has("dampingRatio") ||
		  et.has("stiffness") ||
		  et.has("mass") ||
		  et.has("damping") ||
		  et.has("restSpeed") ||
		  et.has("restDelta")
		? spring
		: keyframes$1;
}
const defaultTimestep$1 = (1 / 60) * 1e3,
	getCurrentTime$1 = typeof performance < "u" ? () => performance.now() : () => Date.now(),
	onNextFrame$1 =
		typeof window < "u"
			? (_) => window.requestAnimationFrame(_)
			: (_) => setTimeout(() => _(getCurrentTime$1()), defaultTimestep$1);
function createRenderStep$1(_) {
	let et = [],
		tt = [],
		nt = 0,
		rt = !1,
		it = !1;
	const ot = new WeakSet(),
		at = {
			schedule: (st, lt = !1, ut = !1) => {
				const dt = ut && rt,
					ct = dt ? et : tt;
				return lt && ot.add(st), ct.indexOf(st) === -1 && (ct.push(st), dt && rt && (nt = et.length)), st;
			},
			cancel: (st) => {
				const lt = tt.indexOf(st);
				lt !== -1 && tt.splice(lt, 1), ot.delete(st);
			},
			process: (st) => {
				if (rt) {
					it = !0;
					return;
				}
				if (((rt = !0), ([et, tt] = [tt, et]), (tt.length = 0), (nt = et.length), nt))
					for (let lt = 0; lt < nt; lt++) {
						const ut = et[lt];
						ut(st), ot.has(ut) && (at.schedule(ut), _());
					}
				(rt = !1), it && ((it = !1), at.process(st));
			},
		};
	return at;
}
const maxElapsed$1 = 40;
let useDefaultElapsed$1 = !0,
	runNextFrame$1 = !1,
	isProcessing$1 = !1;
const frame$1 = { delta: 0, timestamp: 0 },
	stepsOrder$1 = ["read", "update", "preRender", "render", "postRender"],
	steps$2 = stepsOrder$1.reduce((_, et) => ((_[et] = createRenderStep$1(() => (runNextFrame$1 = !0))), _), {}),
	sync$1 = stepsOrder$1.reduce((_, et) => {
		const tt = steps$2[et];
		return (_[et] = (nt, rt = !1, it = !1) => (runNextFrame$1 || startLoop$1(), tt.schedule(nt, rt, it))), _;
	}, {}),
	cancelSync$1 = stepsOrder$1.reduce((_, et) => ((_[et] = steps$2[et].cancel), _), {});
stepsOrder$1.reduce((_, et) => ((_[et] = () => steps$2[et].process(frame$1)), _), {});
const processStep$1 = (_) => steps$2[_].process(frame$1),
	processFrame$1 = (_) => {
		(runNextFrame$1 = !1),
			(frame$1.delta = useDefaultElapsed$1
				? defaultTimestep$1
				: Math.max(Math.min(_ - frame$1.timestamp, maxElapsed$1), 1)),
			(frame$1.timestamp = _),
			(isProcessing$1 = !0),
			stepsOrder$1.forEach(processStep$1),
			(isProcessing$1 = !1),
			runNextFrame$1 && ((useDefaultElapsed$1 = !1), onNextFrame$1(processFrame$1));
	},
	startLoop$1 = () => {
		(runNextFrame$1 = !0), (useDefaultElapsed$1 = !0), isProcessing$1 || onNextFrame$1(processFrame$1);
	},
	getFrameData$1 = () => frame$1;
function loopElapsed(_, et, tt = 0) {
	return _ - et - tt;
}
function reverseElapsed(_, et, tt = 0, nt = !0) {
	return nt ? loopElapsed(et + -_, et, tt) : et - (_ - et) + tt;
}
function hasRepeatDelayElapsed(_, et, tt, nt) {
	return nt ? _ >= et + tt : _ <= -tt;
}
const framesync = (_) => {
	const et = ({ delta: tt }) => _(tt);
	return { start: () => sync$1.update(et, !0), stop: () => cancelSync$1.update(et) };
};
function animate$1(_) {
	var et,
		tt,
		{
			from: nt,
			autoplay: rt = !0,
			driver: it = framesync,
			elapsed: ot = 0,
			repeat: at = 0,
			repeatType: st = "loop",
			repeatDelay: lt = 0,
			onPlay: ut,
			onStop: dt,
			onComplete: ct,
			onRepeat: ft,
			onUpdate: mt,
		} = _,
		pt = __rest$2(_, [
			"from",
			"autoplay",
			"driver",
			"elapsed",
			"repeat",
			"repeatType",
			"repeatDelay",
			"onPlay",
			"onStop",
			"onComplete",
			"onRepeat",
			"onUpdate",
		]);
	let { to: vt } = pt,
		ht,
		gt = 0,
		yt = pt.duration,
		xt,
		St = !1,
		wt = !0,
		Ct;
	const Et = detectAnimationFromOptions(pt);
	!((tt = (et = Et).needsInterpolation) === null || tt === void 0) &&
		tt.call(et, nt, vt) &&
		((Ct = interpolate([0, 100], [nt, vt], { clamp: !1 })), (nt = 0), (vt = 100));
	const _t = Et(Object.assign(Object.assign({}, pt), { from: nt, to: vt }));
	function $t() {
		gt++,
			st === "reverse"
				? ((wt = gt % 2 === 0), (ot = reverseElapsed(ot, yt, lt, wt)))
				: ((ot = loopElapsed(ot, yt, lt)), st === "mirror" && _t.flipTarget()),
			(St = !1),
			ft && ft();
	}
	function At() {
		ht.stop(), ct && ct();
	}
	function Lt(Ft) {
		if ((wt || (Ft = -Ft), (ot += Ft), !St)) {
			const Gt = _t.next(Math.max(0, ot));
			(xt = Gt.value), Ct && (xt = Ct(xt)), (St = wt ? Gt.done : ot <= 0);
		}
		mt == null || mt(xt),
			St && (gt === 0 && (yt != null || (yt = ot)), gt < at ? hasRepeatDelayElapsed(ot, yt, lt, wt) && $t() : At());
	}
	function Nt() {
		ut == null || ut(), (ht = it(Lt)), ht.start();
	}
	return (
		rt && Nt(),
		{
			stop: () => {
				dt == null || dt(), ht.stop();
			},
		}
	);
}
function velocityPerSecond(_, et) {
	return et ? _ * (1e3 / et) : 0;
}
function inertia({
	from: _ = 0,
	velocity: et = 0,
	min: tt,
	max: nt,
	power: rt = 0.8,
	timeConstant: it = 750,
	bounceStiffness: ot = 500,
	bounceDamping: at = 10,
	restDelta: st = 1,
	modifyTarget: lt,
	driver: ut,
	onUpdate: dt,
	onComplete: ct,
	onStop: ft,
}) {
	let mt;
	function pt(yt) {
		return (tt !== void 0 && yt < tt) || (nt !== void 0 && yt > nt);
	}
	function vt(yt) {
		return tt === void 0 ? nt : nt === void 0 || Math.abs(tt - yt) < Math.abs(nt - yt) ? tt : nt;
	}
	function ht(yt) {
		mt == null || mt.stop(),
			(mt = animate$1(
				Object.assign(Object.assign({}, yt), {
					driver: ut,
					onUpdate: (xt) => {
						var St;
						dt == null || dt(xt), (St = yt.onUpdate) === null || St === void 0 || St.call(yt, xt);
					},
					onComplete: ct,
					onStop: ft,
				})
			));
	}
	function gt(yt) {
		ht(Object.assign({ type: "spring", stiffness: ot, damping: at, restDelta: st }, yt));
	}
	if (pt(_)) gt({ from: _, velocity: et, to: vt(_) });
	else {
		let yt = rt * et + _;
		typeof lt < "u" && (yt = lt(yt));
		const xt = vt(yt),
			St = xt === tt ? -1 : 1;
		let wt, Ct;
		const Et = (_t) => {
			(wt = Ct),
				(Ct = _t),
				(et = velocityPerSecond(_t - wt, getFrameData$1().delta)),
				((St === 1 && _t > xt) || (St === -1 && _t < xt)) && gt({ from: _t, to: xt, velocity: et });
		};
		ht({
			type: "decay",
			from: _,
			velocity: et,
			timeConstant: it,
			power: rt,
			restDelta: st,
			modifyTarget: lt,
			onUpdate: pt(yt) ? Et : void 0,
		});
	}
	return { stop: () => (mt == null ? void 0 : mt.stop()) };
}
const isPoint = (_) => _.hasOwnProperty("x") && _.hasOwnProperty("y"),
	isPoint3D = (_) => isPoint(_) && _.hasOwnProperty("z"),
	distance1D = (_, et) => Math.abs(_ - et);
function distance(_, et) {
	if (isNum(_) && isNum(et)) return distance1D(_, et);
	if (isPoint(_) && isPoint(et)) {
		const tt = distance1D(_.x, et.x),
			nt = distance1D(_.y, et.y),
			rt = isPoint3D(_) && isPoint3D(et) ? distance1D(_.z, et.z) : 0;
		return Math.sqrt(Math.pow(tt, 2) + Math.pow(nt, 2) + Math.pow(rt, 2));
	}
}
const a$1 = (_, et) => 1 - 3 * et + 3 * _,
	b$1 = (_, et) => 3 * et - 6 * _,
	c$1 = (_) => 3 * _,
	calcBezier = (_, et, tt) => ((a$1(et, tt) * _ + b$1(et, tt)) * _ + c$1(et)) * _,
	getSlope = (_, et, tt) => 3 * a$1(et, tt) * _ * _ + 2 * b$1(et, tt) * _ + c$1(et),
	subdivisionPrecision = 1e-7,
	subdivisionMaxIterations = 10;
function binarySubdivide(_, et, tt, nt, rt) {
	let it,
		ot,
		at = 0;
	do (ot = et + (tt - et) / 2), (it = calcBezier(ot, nt, rt) - _), it > 0 ? (tt = ot) : (et = ot);
	while (Math.abs(it) > subdivisionPrecision && ++at < subdivisionMaxIterations);
	return ot;
}
const newtonIterations = 8,
	newtonMinSlope = 0.001;
function newtonRaphsonIterate(_, et, tt, nt) {
	for (let rt = 0; rt < newtonIterations; ++rt) {
		const it = getSlope(et, tt, nt);
		if (it === 0) return et;
		et -= (calcBezier(et, tt, nt) - _) / it;
	}
	return et;
}
const kSplineTableSize = 11,
	kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(_, et, tt, nt) {
	if (_ === et && tt === nt) return linear;
	const rt = new Float32Array(kSplineTableSize);
	for (let ot = 0; ot < kSplineTableSize; ++ot) rt[ot] = calcBezier(ot * kSampleStepSize, _, tt);
	function it(ot) {
		let at = 0,
			st = 1;
		const lt = kSplineTableSize - 1;
		for (; st !== lt && rt[st] <= ot; ++st) at += kSampleStepSize;
		--st;
		const ut = (ot - rt[st]) / (rt[st + 1] - rt[st]),
			dt = at + ut * kSampleStepSize,
			ct = getSlope(dt, _, tt);
		return ct >= newtonMinSlope
			? newtonRaphsonIterate(ot, dt, _, tt)
			: ct === 0
			? dt
			: binarySubdivide(ot, at, at + kSampleStepSize, _, tt);
	}
	return (ot) => (ot === 0 || ot === 1 ? ot : calcBezier(it(ot), et, nt));
}
function useTapGesture({ onTap: _, onTapStart: et, onTapCancel: tt, whileTap: nt, visualElement: rt }) {
	const it = _ || et || tt || nt,
		ot = react.exports.useRef(!1),
		at = react.exports.useRef(null),
		st = { passive: !(et || _ || tt || ft) };
	function lt() {
		at.current && at.current(), (at.current = null);
	}
	function ut() {
		return (
			lt(), (ot.current = !1), rt.animationState && rt.animationState.setActive(AnimationType.Tap, !1), !isDragActive()
		);
	}
	function dt(mt, pt) {
		!ut() || (isNodeOrChild(rt.getInstance(), mt.target) ? _ && _(mt, pt) : tt && tt(mt, pt));
	}
	function ct(mt, pt) {
		!ut() || (tt && tt(mt, pt));
	}
	function ft(mt, pt) {
		lt(),
			!ot.current &&
				((ot.current = !0),
				(at.current = pipe(
					addPointerEvent(window, "pointerup", dt, st),
					addPointerEvent(window, "pointercancel", ct, st)
				)),
				rt.animationState && rt.animationState.setActive(AnimationType.Tap, !0),
				et && et(mt, pt));
	}
	usePointerEvent$1(rt, "pointerdown", it ? ft : void 0, st), useUnmountEffect$1(lt);
}
const defaultEnvironment = "production",
	env = typeof process > "u" || process.env === void 0 ? defaultEnvironment : "production",
	warned = new Set();
function warnOnce(_, et, tt) {
	_ || warned.has(et) || (console.warn(et), tt && console.warn(tt), warned.add(et));
}
const observerCallbacks = new WeakMap(),
	observers$1 = new WeakMap(),
	fireObserverCallback = (_) => {
		const et = observerCallbacks.get(_.target);
		et && et(_);
	},
	fireAllObserverCallbacks = (_) => {
		_.forEach(fireObserverCallback);
	};
function initIntersectionObserver({ root: _, ...et }) {
	const tt = _ || document;
	observers$1.has(tt) || observers$1.set(tt, {});
	const nt = observers$1.get(tt),
		rt = JSON.stringify(et);
	return nt[rt] || (nt[rt] = new IntersectionObserver(fireAllObserverCallbacks, { root: _, ...et })), nt[rt];
}
function observeIntersection(_, et, tt) {
	const nt = initIntersectionObserver(et);
	return (
		observerCallbacks.set(_, tt),
		nt.observe(_),
		() => {
			observerCallbacks.delete(_), nt.unobserve(_);
		}
	);
}
function useViewport({
	visualElement: _,
	whileInView: et,
	onViewportEnter: tt,
	onViewportLeave: nt,
	viewport: rt = {},
}) {
	const it = react.exports.useRef({ hasEnteredView: !1, isInView: !1 });
	let ot = Boolean(et || tt || nt);
	rt.once && it.current.hasEnteredView && (ot = !1),
		(typeof IntersectionObserver > "u" ? useMissingIntersectionObserver : useIntersectionObserver)(
			ot,
			it.current,
			_,
			rt
		);
}
const thresholdNames = { some: 0, all: 1 };
function useIntersectionObserver(_, et, tt, { root: nt, margin: rt, amount: it = "some", once: ot }) {
	react.exports.useEffect(() => {
		if (!_) return;
		const at = {
				root: nt == null ? void 0 : nt.current,
				rootMargin: rt,
				threshold: typeof it == "number" ? it : thresholdNames[it],
			},
			st = (lt) => {
				const { isIntersecting: ut } = lt;
				if (et.isInView === ut || ((et.isInView = ut), ot && !ut && et.hasEnteredView)) return;
				ut && (et.hasEnteredView = !0), tt.animationState && tt.animationState.setActive(AnimationType.InView, ut);
				const dt = tt.getProps(),
					ct = ut ? dt.onViewportEnter : dt.onViewportLeave;
				ct && ct(lt);
			};
		return observeIntersection(tt.getInstance(), at, st);
	}, [_, nt, rt, it]);
}
function useMissingIntersectionObserver(_, et, tt, { fallback: nt = !0 }) {
	react.exports.useEffect(() => {
		!_ ||
			!nt ||
			(env !== "production" &&
				warnOnce(
					!1,
					"IntersectionObserver not available on this device. whileInView animations will trigger on mount."
				),
			requestAnimationFrame(() => {
				et.hasEnteredView = !0;
				const { onViewportEnter: rt } = tt.getProps();
				rt && rt(null), tt.animationState && tt.animationState.setActive(AnimationType.InView, !0);
			}));
	}, [_]);
}
const makeRenderlessComponent = (_) => (et) => (_(et), null),
	gestureAnimations = {
		inView: makeRenderlessComponent(useViewport),
		tap: makeRenderlessComponent(useTapGesture),
		focus: makeRenderlessComponent(useFocusGesture),
		hover: makeRenderlessComponent(useHoverGesture),
	};
function usePresence() {
	const _ = react.exports.useContext(PresenceContext);
	if (_ === null) return [!0, null];
	const { isPresent: et, onExitComplete: tt, register: nt } = _,
		rt = react.exports.useId();
	return react.exports.useEffect(() => nt(rt), []), !et && tt ? [!1, () => tt && tt(rt)] : [!0];
}
function useIsPresent() {
	return isPresent(react.exports.useContext(PresenceContext));
}
function isPresent(_) {
	return _ === null ? !0 : _.isPresent;
}
function shallowCompare(_, et) {
	if (!Array.isArray(et)) return !1;
	const tt = et.length;
	if (tt !== _.length) return !1;
	for (let nt = 0; nt < tt; nt++) if (et[nt] !== _[nt]) return !1;
	return !0;
}
const secondsToMilliseconds = (_) => _ * 1e3,
	easingLookup = {
		linear,
		easeIn,
		easeInOut,
		easeOut,
		circIn,
		circInOut,
		circOut,
		backIn,
		backInOut,
		backOut,
		anticipate,
		bounceIn,
		bounceInOut,
		bounceOut,
	},
	easingDefinitionToFunction = (_) => {
		if (Array.isArray(_)) {
			invariant$1(_.length === 4);
			const [et, tt, nt, rt] = _;
			return cubicBezier(et, tt, nt, rt);
		} else if (typeof _ == "string") return easingLookup[_];
		return _;
	},
	isEasingArray = (_) => Array.isArray(_) && typeof _[0] != "number",
	isAnimatable = (_, et) =>
		_ === "zIndex"
			? !1
			: !!(
					typeof et == "number" ||
					Array.isArray(et) ||
					(typeof et == "string" && complex.test(et) && !et.startsWith("url("))
			  ),
	underDampedSpring = () => ({ type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }),
	criticallyDampedSpring = (_) => ({
		type: "spring",
		stiffness: 550,
		damping: _ === 0 ? 2 * Math.sqrt(550) : 30,
		restSpeed: 10,
	}),
	linearTween = () => ({ type: "keyframes", ease: "linear", duration: 0.3 }),
	keyframes = (_) => ({ type: "keyframes", duration: 0.8, values: _ }),
	defaultTransitions$1 = {
		x: underDampedSpring,
		y: underDampedSpring,
		z: underDampedSpring,
		rotate: underDampedSpring,
		rotateX: underDampedSpring,
		rotateY: underDampedSpring,
		rotateZ: underDampedSpring,
		scaleX: criticallyDampedSpring,
		scaleY: criticallyDampedSpring,
		scale: criticallyDampedSpring,
		opacity: linearTween,
		backgroundColor: linearTween,
		color: linearTween,
		default: criticallyDampedSpring,
	},
	getDefaultTransition = (_, et) => {
		let tt;
		return (
			isKeyframesTarget(et) ? (tt = keyframes) : (tt = defaultTransitions$1[_] || defaultTransitions$1.default),
			{ to: et, ...tt(et) }
		);
	},
	defaultValueTypes = {
		...numberValueTypes,
		color: color$1,
		backgroundColor: color$1,
		outlineColor: color$1,
		fill: color$1,
		stroke: color$1,
		borderColor: color$1,
		borderTopColor: color$1,
		borderRightColor: color$1,
		borderBottomColor: color$1,
		borderLeftColor: color$1,
		filter: filter$1,
		WebkitFilter: filter$1,
	},
	getDefaultValueType = (_) => defaultValueTypes[_];
function getAnimatableNone(_, et) {
	var tt;
	let nt = getDefaultValueType(_);
	return (
		nt !== filter$1 && (nt = complex), (tt = nt.getAnimatableNone) === null || tt === void 0 ? void 0 : tt.call(nt, et)
	);
}
const instantAnimationState = { current: !1 };
function isTransitionDefined({
	when: _,
	delay: et,
	delayChildren: tt,
	staggerChildren: nt,
	staggerDirection: rt,
	repeat: it,
	repeatType: ot,
	repeatDelay: at,
	from: st,
	...lt
}) {
	return !!Object.keys(lt).length;
}
function convertTransitionToAnimationOptions({ ease: _, times: et, yoyo: tt, flip: nt, loop: rt, ...it }) {
	const ot = { ...it };
	return (
		et && (ot.offset = et),
		it.duration && (ot.duration = secondsToMilliseconds(it.duration)),
		it.repeatDelay && (ot.repeatDelay = secondsToMilliseconds(it.repeatDelay)),
		_ && (ot.ease = isEasingArray(_) ? _.map(easingDefinitionToFunction) : easingDefinitionToFunction(_)),
		it.type === "tween" && (ot.type = "keyframes"),
		(tt || rt || nt) &&
			(tt ? (ot.repeatType = "reverse") : rt ? (ot.repeatType = "loop") : nt && (ot.repeatType = "mirror"),
			(ot.repeat = rt || tt || nt || it.repeat)),
		it.type !== "spring" && (ot.type = "keyframes"),
		ot
	);
}
function getDelayFromTransition(_, et) {
	var tt, nt;
	return (nt = (tt = (getValueTransition(_, et) || {}).delay) !== null && tt !== void 0 ? tt : _.delay) !== null &&
		nt !== void 0
		? nt
		: 0;
}
function hydrateKeyframes(_) {
	return Array.isArray(_.to) && _.to[0] === null && ((_.to = [..._.to]), (_.to[0] = _.from)), _;
}
function getPopmotionAnimationOptions(_, et, tt) {
	return (
		Array.isArray(et.to) && _.duration === void 0 && (_.duration = 0.8),
		hydrateKeyframes(et),
		isTransitionDefined(_) || (_ = { ..._, ...getDefaultTransition(tt, et.to) }),
		{ ...et, ...convertTransitionToAnimationOptions(_) }
	);
}
function getAnimation(_, et, tt, nt, rt) {
	const it = getValueTransition(nt, _) || {};
	let ot = it.from !== void 0 ? it.from : et.get();
	const at = isAnimatable(_, tt);
	ot === "none" && at && typeof tt == "string"
		? (ot = getAnimatableNone(_, tt))
		: isZero(ot) && typeof tt == "string"
		? (ot = getZeroUnit(tt))
		: !Array.isArray(tt) && isZero(tt) && typeof ot == "string" && (tt = getZeroUnit(ot));
	const st = isAnimatable(_, ot);
	function lt() {
		const dt = { from: ot, to: tt, velocity: et.getVelocity(), onComplete: rt, onUpdate: (ct) => et.set(ct) };
		return it.type === "inertia" || it.type === "decay"
			? inertia({ ...dt, ...it })
			: animate$1({
					...getPopmotionAnimationOptions(it, dt, _),
					onUpdate: (ct) => {
						dt.onUpdate(ct), it.onUpdate && it.onUpdate(ct);
					},
					onComplete: () => {
						dt.onComplete(), it.onComplete && it.onComplete();
					},
			  });
	}
	function ut() {
		const dt = resolveFinalValueInKeyframes(tt);
		return et.set(dt), rt(), it.onUpdate && it.onUpdate(dt), it.onComplete && it.onComplete(), { stop: () => {} };
	}
	return !st || !at || it.type === !1 ? ut : lt;
}
function isZero(_) {
	return _ === 0 || (typeof _ == "string" && parseFloat(_) === 0 && _.indexOf(" ") === -1);
}
function getZeroUnit(_) {
	return typeof _ == "number" ? 0 : getAnimatableNone("", _);
}
function getValueTransition(_, et) {
	return _[et] || _.default || _;
}
function startAnimation(_, et, tt, nt = {}) {
	return (
		instantAnimationState.current && (nt = { type: !1 }),
		et.start((rt) => {
			let it, ot;
			const at = getAnimation(_, et, tt, nt, rt),
				st = getDelayFromTransition(nt, _),
				lt = () => (ot = at());
			return (
				st ? (it = window.setTimeout(lt, secondsToMilliseconds(st))) : lt(),
				() => {
					clearTimeout(it), ot && ot.stop();
				}
			);
		})
	);
}
const isNumericalString = (_) => /^\-?\d*\.?\d+$/.test(_),
	isZeroValueString = (_) => /^0[^.\s]+$/.test(_),
	defaultTimestep = (1 / 60) * 1e3,
	getCurrentTime = typeof performance < "u" ? () => performance.now() : () => Date.now(),
	onNextFrame =
		typeof window < "u"
			? (_) => window.requestAnimationFrame(_)
			: (_) => setTimeout(() => _(getCurrentTime()), defaultTimestep);
function createRenderStep(_) {
	let et = [],
		tt = [],
		nt = 0,
		rt = !1,
		it = !1;
	const ot = new WeakSet(),
		at = {
			schedule: (st, lt = !1, ut = !1) => {
				const dt = ut && rt,
					ct = dt ? et : tt;
				return lt && ot.add(st), ct.indexOf(st) === -1 && (ct.push(st), dt && rt && (nt = et.length)), st;
			},
			cancel: (st) => {
				const lt = tt.indexOf(st);
				lt !== -1 && tt.splice(lt, 1), ot.delete(st);
			},
			process: (st) => {
				if (rt) {
					it = !0;
					return;
				}
				if (((rt = !0), ([et, tt] = [tt, et]), (tt.length = 0), (nt = et.length), nt))
					for (let lt = 0; lt < nt; lt++) {
						const ut = et[lt];
						ut(st), ot.has(ut) && (at.schedule(ut), _());
					}
				(rt = !1), it && ((it = !1), at.process(st));
			},
		};
	return at;
}
const maxElapsed = 40;
let useDefaultElapsed = !0,
	runNextFrame = !1,
	isProcessing = !1;
const frame = { delta: 0, timestamp: 0 },
	stepsOrder = ["read", "update", "preRender", "render", "postRender"],
	steps$1 = stepsOrder.reduce((_, et) => ((_[et] = createRenderStep(() => (runNextFrame = !0))), _), {}),
	sync = stepsOrder.reduce((_, et) => {
		const tt = steps$1[et];
		return (_[et] = (nt, rt = !1, it = !1) => (runNextFrame || startLoop(), tt.schedule(nt, rt, it))), _;
	}, {}),
	cancelSync = stepsOrder.reduce((_, et) => ((_[et] = steps$1[et].cancel), _), {}),
	flushSync = stepsOrder.reduce((_, et) => ((_[et] = () => steps$1[et].process(frame)), _), {}),
	processStep = (_) => steps$1[_].process(frame),
	processFrame = (_) => {
		(runNextFrame = !1),
			(frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(_ - frame.timestamp, maxElapsed), 1)),
			(frame.timestamp = _),
			(isProcessing = !0),
			stepsOrder.forEach(processStep),
			(isProcessing = !1),
			runNextFrame && ((useDefaultElapsed = !1), onNextFrame(processFrame));
	},
	startLoop = () => {
		(runNextFrame = !0), (useDefaultElapsed = !0), isProcessing || onNextFrame(processFrame);
	},
	getFrameData = () => frame;
function addUniqueItem(_, et) {
	_.indexOf(et) === -1 && _.push(et);
}
function removeItem(_, et) {
	const tt = _.indexOf(et);
	tt > -1 && _.splice(tt, 1);
}
class SubscriptionManager {
	constructor() {
		this.subscriptions = [];
	}
	add(et) {
		return addUniqueItem(this.subscriptions, et), () => removeItem(this.subscriptions, et);
	}
	notify(et, tt, nt) {
		const rt = this.subscriptions.length;
		if (!!rt)
			if (rt === 1) this.subscriptions[0](et, tt, nt);
			else
				for (let it = 0; it < rt; it++) {
					const ot = this.subscriptions[it];
					ot && ot(et, tt, nt);
				}
	}
	getSize() {
		return this.subscriptions.length;
	}
	clear() {
		this.subscriptions.length = 0;
	}
}
const isFloat = (_) => !isNaN(parseFloat(_));
class MotionValue {
	constructor(et) {
		(this.version = "7.3.5"),
			(this.timeDelta = 0),
			(this.lastUpdated = 0),
			(this.updateSubscribers = new SubscriptionManager()),
			(this.velocityUpdateSubscribers = new SubscriptionManager()),
			(this.renderSubscribers = new SubscriptionManager()),
			(this.canTrackVelocity = !1),
			(this.updateAndNotify = (tt, nt = !0) => {
				(this.prev = this.current), (this.current = tt);
				const { delta: rt, timestamp: it } = getFrameData();
				this.lastUpdated !== it &&
					((this.timeDelta = rt), (this.lastUpdated = it), sync.postRender(this.scheduleVelocityCheck)),
					this.prev !== this.current && this.updateSubscribers.notify(this.current),
					this.velocityUpdateSubscribers.getSize() && this.velocityUpdateSubscribers.notify(this.getVelocity()),
					nt && this.renderSubscribers.notify(this.current);
			}),
			(this.scheduleVelocityCheck = () => sync.postRender(this.velocityCheck)),
			(this.velocityCheck = ({ timestamp: tt }) => {
				tt !== this.lastUpdated &&
					((this.prev = this.current), this.velocityUpdateSubscribers.notify(this.getVelocity()));
			}),
			(this.hasAnimated = !1),
			(this.prev = this.current = et),
			(this.canTrackVelocity = isFloat(this.current));
	}
	onChange(et) {
		return this.updateSubscribers.add(et);
	}
	clearListeners() {
		this.updateSubscribers.clear();
	}
	onRenderRequest(et) {
		return et(this.get()), this.renderSubscribers.add(et);
	}
	attach(et) {
		this.passiveEffect = et;
	}
	set(et, tt = !0) {
		!tt || !this.passiveEffect ? this.updateAndNotify(et, tt) : this.passiveEffect(et, this.updateAndNotify);
	}
	get() {
		return this.current;
	}
	getPrevious() {
		return this.prev;
	}
	getVelocity() {
		return this.canTrackVelocity
			? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
			: 0;
	}
	start(et) {
		return (
			this.stop(),
			new Promise((tt) => {
				(this.hasAnimated = !0), (this.stopAnimation = et(tt));
			}).then(() => this.clearAnimation())
		);
	}
	stop() {
		this.stopAnimation && this.stopAnimation(), this.clearAnimation();
	}
	isAnimating() {
		return !!this.stopAnimation;
	}
	clearAnimation() {
		this.stopAnimation = null;
	}
	destroy() {
		this.updateSubscribers.clear(), this.renderSubscribers.clear(), this.stop();
	}
}
function motionValue(_) {
	return new MotionValue(_);
}
const testValueType = (_) => (et) => et.test(_),
	auto$1 = { test: (_) => _ === "auto", parse: (_) => _ },
	dimensionValueTypes = [number$1, px$1, percent, degrees, vw, vh$1, auto$1],
	findDimensionValueType = (_) => dimensionValueTypes.find(testValueType(_)),
	valueTypes = [...dimensionValueTypes, color$1, complex],
	findValueType = (_) => valueTypes.find(testValueType(_));
function getCurrent(_) {
	const et = {};
	return _.forEachValue((tt, nt) => (et[nt] = tt.get())), et;
}
function getVelocity$1(_) {
	const et = {};
	return _.forEachValue((tt, nt) => (et[nt] = tt.getVelocity())), et;
}
function resolveVariant(_, et, tt) {
	const nt = _.getProps();
	return resolveVariantFromProps(nt, et, tt !== void 0 ? tt : nt.custom, getCurrent(_), getVelocity$1(_));
}
function setMotionValue(_, et, tt) {
	_.hasValue(et) ? _.getValue(et).set(tt) : _.addValue(et, motionValue(tt));
}
function setTarget(_, et) {
	const tt = resolveVariant(_, et);
	let { transitionEnd: nt = {}, transition: rt = {}, ...it } = tt ? _.makeTargetAnimatable(tt, !1) : {};
	it = { ...it, ...nt };
	for (const ot in it) {
		const at = resolveFinalValueInKeyframes(it[ot]);
		setMotionValue(_, ot, at);
	}
}
function checkTargetForNewValues(_, et, tt) {
	var nt, rt;
	const it = Object.keys(et).filter((at) => !_.hasValue(at)),
		ot = it.length;
	if (!!ot)
		for (let at = 0; at < ot; at++) {
			const st = it[at],
				lt = et[st];
			let ut = null;
			Array.isArray(lt) && (ut = lt[0]),
				ut === null &&
					(ut =
						(rt = (nt = tt[st]) !== null && nt !== void 0 ? nt : _.readValue(st)) !== null && rt !== void 0
							? rt
							: et[st]),
				ut != null &&
					(typeof ut == "string" && (isNumericalString(ut) || isZeroValueString(ut))
						? (ut = parseFloat(ut))
						: !findValueType(ut) && complex.test(lt) && (ut = getAnimatableNone(st, lt)),
					_.addValue(st, motionValue(ut)),
					tt[st] === void 0 && (tt[st] = ut),
					_.setBaseTarget(st, ut));
		}
}
function getOriginFromTransition(_, et) {
	return et ? (et[_] || et.default || et).from : void 0;
}
function getOrigin(_, et, tt) {
	var nt;
	const rt = {};
	for (const it in _) {
		const ot = getOriginFromTransition(it, et);
		rt[it] = ot !== void 0 ? ot : (nt = tt.getValue(it)) === null || nt === void 0 ? void 0 : nt.get();
	}
	return rt;
}
function isWillChangeMotionValue(_) {
	return Boolean(isMotionValue(_) && _.add);
}
function animateVisualElement(_, et, tt = {}) {
	_.notifyAnimationStart(et);
	let nt;
	if (Array.isArray(et)) {
		const rt = et.map((it) => animateVariant(_, it, tt));
		nt = Promise.all(rt);
	} else if (typeof et == "string") nt = animateVariant(_, et, tt);
	else {
		const rt = typeof et == "function" ? resolveVariant(_, et, tt.custom) : et;
		nt = animateTarget(_, rt, tt);
	}
	return nt.then(() => _.notifyAnimationComplete(et));
}
function animateVariant(_, et, tt = {}) {
	var nt;
	const rt = resolveVariant(_, et, tt.custom);
	let { transition: it = _.getDefaultTransition() || {} } = rt || {};
	tt.transitionOverride && (it = tt.transitionOverride);
	const ot = rt ? () => animateTarget(_, rt, tt) : () => Promise.resolve(),
		at =
			!((nt = _.variantChildren) === null || nt === void 0) && nt.size
				? (lt = 0) => {
						const { delayChildren: ut = 0, staggerChildren: dt, staggerDirection: ct } = it;
						return animateChildren(_, et, ut + lt, dt, ct, tt);
				  }
				: () => Promise.resolve(),
		{ when: st } = it;
	if (st) {
		const [lt, ut] = st === "beforeChildren" ? [ot, at] : [at, ot];
		return lt().then(ut);
	} else return Promise.all([ot(), at(tt.delay)]);
}
function animateTarget(_, et, { delay: tt = 0, transitionOverride: nt, type: rt } = {}) {
	var it;
	let { transition: ot = _.getDefaultTransition(), transitionEnd: at, ...st } = _.makeTargetAnimatable(et);
	const lt = _.getValue("willChange");
	nt && (ot = nt);
	const ut = [],
		dt = rt && ((it = _.animationState) === null || it === void 0 ? void 0 : it.getState()[rt]);
	for (const ct in st) {
		const ft = _.getValue(ct),
			mt = st[ct];
		if (!ft || mt === void 0 || (dt && shouldBlockAnimation(dt, ct))) continue;
		let pt = { delay: tt, ...ot };
		_.shouldReduceMotion && transformProps.has(ct) && (pt = { ...pt, type: !1, delay: 0 });
		let vt = startAnimation(ct, ft, mt, pt);
		isWillChangeMotionValue(lt) && (lt.add(ct), (vt = vt.then(() => lt.remove(ct)))), ut.push(vt);
	}
	return Promise.all(ut).then(() => {
		at && setTarget(_, at);
	});
}
function animateChildren(_, et, tt = 0, nt = 0, rt = 1, it) {
	const ot = [],
		at = (_.variantChildren.size - 1) * nt,
		st = rt === 1 ? (lt = 0) => lt * nt : (lt = 0) => at - lt * nt;
	return (
		Array.from(_.variantChildren)
			.sort(sortByTreeOrder)
			.forEach((lt, ut) => {
				ot.push(animateVariant(lt, et, { ...it, delay: tt + st(ut) }).then(() => lt.notifyAnimationComplete(et)));
			}),
		Promise.all(ot)
	);
}
function sortByTreeOrder(_, et) {
	return _.sortNodePosition(et);
}
function shouldBlockAnimation({ protectedKeys: _, needsAnimating: et }, tt) {
	const nt = _.hasOwnProperty(tt) && et[tt] !== !0;
	return (et[tt] = !1), nt;
}
const variantPriorityOrder = [
		AnimationType.Animate,
		AnimationType.InView,
		AnimationType.Focus,
		AnimationType.Hover,
		AnimationType.Tap,
		AnimationType.Drag,
		AnimationType.Exit,
	],
	reversePriorityOrder = [...variantPriorityOrder].reverse(),
	numAnimationTypes = variantPriorityOrder.length;
function animateList(_) {
	return (et) => Promise.all(et.map(({ animation: tt, options: nt }) => animateVisualElement(_, tt, nt)));
}
function createAnimationState(_) {
	let et = animateList(_);
	const tt = createState();
	let nt = !0;
	const rt = (st, lt) => {
		const ut = resolveVariant(_, lt);
		if (ut) {
			const { transition: dt, transitionEnd: ct, ...ft } = ut;
			st = { ...st, ...ft, ...ct };
		}
		return st;
	};
	function it(st) {
		et = st(_);
	}
	function ot(st, lt) {
		var ut;
		const dt = _.getProps(),
			ct = _.getVariantContext(!0) || {},
			ft = [],
			mt = new Set();
		let pt = {},
			vt = 1 / 0;
		for (let gt = 0; gt < numAnimationTypes; gt++) {
			const yt = reversePriorityOrder[gt],
				xt = tt[yt],
				St = (ut = dt[yt]) !== null && ut !== void 0 ? ut : ct[yt],
				wt = isVariantLabel(St),
				Ct = yt === lt ? xt.isActive : null;
			Ct === !1 && (vt = gt);
			let Et = St === ct[yt] && St !== dt[yt] && wt;
			if (
				(Et && nt && _.manuallyAnimateOnMount && (Et = !1),
				(xt.protectedKeys = { ...pt }),
				(!xt.isActive && Ct === null) || (!St && !xt.prevProp) || isAnimationControls(St) || typeof St == "boolean")
			)
				continue;
			const _t = checkVariantsDidChange(xt.prevProp, St);
			let $t = _t || (yt === lt && xt.isActive && !Et && wt) || (gt > vt && wt);
			const At = Array.isArray(St) ? St : [St];
			let Lt = At.reduce(rt, {});
			Ct === !1 && (Lt = {});
			const { prevResolvedValues: Nt = {} } = xt,
				Ft = { ...Nt, ...Lt },
				Gt = (Bt) => {
					($t = !0), mt.delete(Bt), (xt.needsAnimating[Bt] = !0);
				};
			for (const Bt in Ft) {
				const jt = Lt[Bt],
					It = Nt[Bt];
				pt.hasOwnProperty(Bt) ||
					(jt !== It
						? isKeyframesTarget(jt) && isKeyframesTarget(It)
							? !shallowCompare(jt, It) || _t
								? Gt(Bt)
								: (xt.protectedKeys[Bt] = !0)
							: jt !== void 0
							? Gt(Bt)
							: mt.add(Bt)
						: jt !== void 0 && mt.has(Bt)
						? Gt(Bt)
						: (xt.protectedKeys[Bt] = !0));
			}
			(xt.prevProp = St),
				(xt.prevResolvedValues = Lt),
				xt.isActive && (pt = { ...pt, ...Lt }),
				nt && _.blockInitialAnimation && ($t = !1),
				$t && !Et && ft.push(...At.map((Bt) => ({ animation: Bt, options: { type: yt, ...st } })));
		}
		if (mt.size) {
			const gt = {};
			mt.forEach((yt) => {
				const xt = _.getBaseTarget(yt);
				xt !== void 0 && (gt[yt] = xt);
			}),
				ft.push({ animation: gt });
		}
		let ht = Boolean(ft.length);
		return (
			nt && dt.initial === !1 && !_.manuallyAnimateOnMount && (ht = !1), (nt = !1), ht ? et(ft) : Promise.resolve()
		);
	}
	function at(st, lt, ut) {
		var dt;
		if (tt[st].isActive === lt) return Promise.resolve();
		(dt = _.variantChildren) === null ||
			dt === void 0 ||
			dt.forEach((ft) => {
				var mt;
				return (mt = ft.animationState) === null || mt === void 0 ? void 0 : mt.setActive(st, lt);
			}),
			(tt[st].isActive = lt);
		const ct = ot(ut, st);
		for (const ft in tt) tt[ft].protectedKeys = {};
		return ct;
	}
	return { animateChanges: ot, setActive: at, setAnimateFunction: it, getState: () => tt };
}
function checkVariantsDidChange(_, et) {
	return typeof et == "string" ? et !== _ : Array.isArray(et) ? !shallowCompare(et, _) : !1;
}
function createTypeState(_ = !1) {
	return { isActive: _, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} };
}
function createState() {
	return {
		[AnimationType.Animate]: createTypeState(!0),
		[AnimationType.InView]: createTypeState(),
		[AnimationType.Hover]: createTypeState(),
		[AnimationType.Tap]: createTypeState(),
		[AnimationType.Drag]: createTypeState(),
		[AnimationType.Focus]: createTypeState(),
		[AnimationType.Exit]: createTypeState(),
	};
}
const animations = {
	animation: makeRenderlessComponent(({ visualElement: _, animate: et }) => {
		_.animationState || (_.animationState = createAnimationState(_)),
			isAnimationControls(et) && react.exports.useEffect(() => et.subscribe(_), [et]);
	}),
	exit: makeRenderlessComponent((_) => {
		const { custom: et, visualElement: tt } = _,
			[nt, rt] = usePresence(),
			it = react.exports.useContext(PresenceContext);
		react.exports.useEffect(() => {
			tt.isPresent = nt;
			const ot =
				tt.animationState && tt.animationState.setActive(AnimationType.Exit, !nt, { custom: (it && it.custom) || et });
			ot && !nt && ot.then(rt);
		}, [nt]);
	}),
};
class PanSession {
	constructor(et, tt, { transformPagePoint: nt } = {}) {
		if (
			((this.startEvent = null),
			(this.lastMoveEvent = null),
			(this.lastMoveEventInfo = null),
			(this.handlers = {}),
			(this.updatePoint = () => {
				if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
				const lt = getPanInfo(this.lastMoveEventInfo, this.history),
					ut = this.startEvent !== null,
					dt = distance(lt.offset, { x: 0, y: 0 }) >= 3;
				if (!ut && !dt) return;
				const { point: ct } = lt,
					{ timestamp: ft } = getFrameData();
				this.history.push({ ...ct, timestamp: ft });
				const { onStart: mt, onMove: pt } = this.handlers;
				ut || (mt && mt(this.lastMoveEvent, lt), (this.startEvent = this.lastMoveEvent)),
					pt && pt(this.lastMoveEvent, lt);
			}),
			(this.handlePointerMove = (lt, ut) => {
				if (
					((this.lastMoveEvent = lt),
					(this.lastMoveEventInfo = transformPoint(ut, this.transformPagePoint)),
					isMouseEvent(lt) && lt.buttons === 0)
				) {
					this.handlePointerUp(lt, ut);
					return;
				}
				sync.update(this.updatePoint, !0);
			}),
			(this.handlePointerUp = (lt, ut) => {
				this.end();
				const { onEnd: dt, onSessionEnd: ct } = this.handlers,
					ft = getPanInfo(transformPoint(ut, this.transformPagePoint), this.history);
				this.startEvent && dt && dt(lt, ft), ct && ct(lt, ft);
			}),
			isTouchEvent(et) && et.touches.length > 1)
		)
			return;
		(this.handlers = tt), (this.transformPagePoint = nt);
		const rt = extractEventInfo(et),
			it = transformPoint(rt, this.transformPagePoint),
			{ point: ot } = it,
			{ timestamp: at } = getFrameData();
		this.history = [{ ...ot, timestamp: at }];
		const { onSessionStart: st } = tt;
		st && st(et, getPanInfo(it, this.history)),
			(this.removeListeners = pipe(
				addPointerEvent(window, "pointermove", this.handlePointerMove),
				addPointerEvent(window, "pointerup", this.handlePointerUp),
				addPointerEvent(window, "pointercancel", this.handlePointerUp)
			));
	}
	updateHandlers(et) {
		this.handlers = et;
	}
	end() {
		this.removeListeners && this.removeListeners(), cancelSync.update(this.updatePoint);
	}
}
function transformPoint(_, et) {
	return et ? { point: et(_.point) } : _;
}
function subtractPoint(_, et) {
	return { x: _.x - et.x, y: _.y - et.y };
}
function getPanInfo({ point: _ }, et) {
	return {
		point: _,
		delta: subtractPoint(_, lastDevicePoint(et)),
		offset: subtractPoint(_, startDevicePoint(et)),
		velocity: getVelocity(et, 0.1),
	};
}
function startDevicePoint(_) {
	return _[0];
}
function lastDevicePoint(_) {
	return _[_.length - 1];
}
function getVelocity(_, et) {
	if (_.length < 2) return { x: 0, y: 0 };
	let tt = _.length - 1,
		nt = null;
	const rt = lastDevicePoint(_);
	for (; tt >= 0 && ((nt = _[tt]), !(rt.timestamp - nt.timestamp > secondsToMilliseconds(et))); ) tt--;
	if (!nt) return { x: 0, y: 0 };
	const it = (rt.timestamp - nt.timestamp) / 1e3;
	if (it === 0) return { x: 0, y: 0 };
	const ot = { x: (rt.x - nt.x) / it, y: (rt.y - nt.y) / it };
	return ot.x === 1 / 0 && (ot.x = 0), ot.y === 1 / 0 && (ot.y = 0), ot;
}
function calcLength(_) {
	return _.max - _.min;
}
function isNear(_, et = 0, tt = 0.01) {
	return distance(_, et) < tt;
}
function calcAxisDelta(_, et, tt, nt = 0.5) {
	(_.origin = nt),
		(_.originPoint = mix(et.min, et.max, _.origin)),
		(_.scale = calcLength(tt) / calcLength(et)),
		(isNear(_.scale, 1, 1e-4) || isNaN(_.scale)) && (_.scale = 1),
		(_.translate = mix(tt.min, tt.max, _.origin) - _.originPoint),
		(isNear(_.translate) || isNaN(_.translate)) && (_.translate = 0);
}
function calcBoxDelta(_, et, tt, nt) {
	calcAxisDelta(_.x, et.x, tt.x, nt == null ? void 0 : nt.originX),
		calcAxisDelta(_.y, et.y, tt.y, nt == null ? void 0 : nt.originY);
}
function calcRelativeAxis(_, et, tt) {
	(_.min = tt.min + et.min), (_.max = _.min + calcLength(et));
}
function calcRelativeBox(_, et, tt) {
	calcRelativeAxis(_.x, et.x, tt.x), calcRelativeAxis(_.y, et.y, tt.y);
}
function calcRelativeAxisPosition(_, et, tt) {
	(_.min = et.min - tt.min), (_.max = _.min + calcLength(et));
}
function calcRelativePosition(_, et, tt) {
	calcRelativeAxisPosition(_.x, et.x, tt.x), calcRelativeAxisPosition(_.y, et.y, tt.y);
}
function applyConstraints(_, { min: et, max: tt }, nt) {
	return (
		et !== void 0 && _ < et
			? (_ = nt ? mix(et, _, nt.min) : Math.max(_, et))
			: tt !== void 0 && _ > tt && (_ = nt ? mix(tt, _, nt.max) : Math.min(_, tt)),
		_
	);
}
function calcRelativeAxisConstraints(_, et, tt) {
	return { min: et !== void 0 ? _.min + et : void 0, max: tt !== void 0 ? _.max + tt - (_.max - _.min) : void 0 };
}
function calcRelativeConstraints(_, { top: et, left: tt, bottom: nt, right: rt }) {
	return { x: calcRelativeAxisConstraints(_.x, tt, rt), y: calcRelativeAxisConstraints(_.y, et, nt) };
}
function calcViewportAxisConstraints(_, et) {
	let tt = et.min - _.min,
		nt = et.max - _.max;
	return et.max - et.min < _.max - _.min && ([tt, nt] = [nt, tt]), { min: tt, max: nt };
}
function calcViewportConstraints(_, et) {
	return { x: calcViewportAxisConstraints(_.x, et.x), y: calcViewportAxisConstraints(_.y, et.y) };
}
function calcOrigin(_, et) {
	let tt = 0.5;
	const nt = calcLength(_),
		rt = calcLength(et);
	return (
		rt > nt ? (tt = progress(et.min, et.max - nt, _.min)) : nt > rt && (tt = progress(_.min, _.max - rt, et.min)),
		clamp$1(0, 1, tt)
	);
}
function rebaseAxisConstraints(_, et) {
	const tt = {};
	return et.min !== void 0 && (tt.min = et.min - _.min), et.max !== void 0 && (tt.max = et.max - _.min), tt;
}
const defaultElastic = 0.35;
function resolveDragElastic(_ = defaultElastic) {
	return (
		_ === !1 ? (_ = 0) : _ === !0 && (_ = defaultElastic),
		{ x: resolveAxisElastic(_, "left", "right"), y: resolveAxisElastic(_, "top", "bottom") }
	);
}
function resolveAxisElastic(_, et, tt) {
	return { min: resolvePointElastic(_, et), max: resolvePointElastic(_, tt) };
}
function resolvePointElastic(_, et) {
	var tt;
	return typeof _ == "number" ? _ : (tt = _[et]) !== null && tt !== void 0 ? tt : 0;
}
const createAxisDelta = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
	createDelta = () => ({ x: createAxisDelta(), y: createAxisDelta() }),
	createAxis = () => ({ min: 0, max: 0 }),
	createBox = () => ({ x: createAxis(), y: createAxis() });
function eachAxis(_) {
	return [_("x"), _("y")];
}
function convertBoundingBoxToBox({ top: _, left: et, right: tt, bottom: nt }) {
	return { x: { min: et, max: tt }, y: { min: _, max: nt } };
}
function convertBoxToBoundingBox({ x: _, y: et }) {
	return { top: et.min, right: _.max, bottom: et.max, left: _.min };
}
function transformBoxPoints(_, et) {
	if (!et) return _;
	const tt = et({ x: _.left, y: _.top }),
		nt = et({ x: _.right, y: _.bottom });
	return { top: tt.y, left: tt.x, bottom: nt.y, right: nt.x };
}
function isIdentityScale(_) {
	return _ === void 0 || _ === 1;
}
function hasScale({ scale: _, scaleX: et, scaleY: tt }) {
	return !isIdentityScale(_) || !isIdentityScale(et) || !isIdentityScale(tt);
}
function hasTransform(_) {
	return hasScale(_) || hasTranslate(_.x) || hasTranslate(_.y) || _.z || _.rotate || _.rotateX || _.rotateY;
}
function hasTranslate(_) {
	return _ && _ !== "0%";
}
function scalePoint(_, et, tt) {
	const nt = _ - tt,
		rt = et * nt;
	return tt + rt;
}
function applyPointDelta(_, et, tt, nt, rt) {
	return rt !== void 0 && (_ = scalePoint(_, rt, nt)), scalePoint(_, tt, nt) + et;
}
function applyAxisDelta(_, et = 0, tt = 1, nt, rt) {
	(_.min = applyPointDelta(_.min, et, tt, nt, rt)), (_.max = applyPointDelta(_.max, et, tt, nt, rt));
}
function applyBoxDelta(_, { x: et, y: tt }) {
	applyAxisDelta(_.x, et.translate, et.scale, et.originPoint),
		applyAxisDelta(_.y, tt.translate, tt.scale, tt.originPoint);
}
function applyTreeDeltas(_, et, tt, nt = !1) {
	var rt, it;
	const ot = tt.length;
	if (!ot) return;
	et.x = et.y = 1;
	let at, st;
	for (let lt = 0; lt < ot; lt++)
		(at = tt[lt]),
			(st = at.projectionDelta),
			((it = (rt = at.instance) === null || rt === void 0 ? void 0 : rt.style) === null || it === void 0
				? void 0
				: it.display) !== "contents" &&
				(nt &&
					at.options.layoutScroll &&
					at.scroll &&
					at !== at.root &&
					transformBox(_, { x: -at.scroll.x, y: -at.scroll.y }),
				st && ((et.x *= st.x.scale), (et.y *= st.y.scale), applyBoxDelta(_, st)),
				nt && hasTransform(at.latestValues) && transformBox(_, at.latestValues));
}
function translateAxis(_, et) {
	(_.min = _.min + et), (_.max = _.max + et);
}
function transformAxis(_, et, [tt, nt, rt]) {
	const it = et[rt] !== void 0 ? et[rt] : 0.5,
		ot = mix(_.min, _.max, it);
	applyAxisDelta(_, et[tt], et[nt], ot, et.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"],
	yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(_, et) {
	transformAxis(_.x, et, xKeys$1), transformAxis(_.y, et, yKeys$1);
}
function measureViewportBox(_, et) {
	return convertBoundingBoxToBox(transformBoxPoints(_.getBoundingClientRect(), et));
}
function measurePageBox(_, et, tt) {
	const nt = measureViewportBox(_, tt),
		{ scroll: rt } = et;
	return rt && (translateAxis(nt.x, rt.x), translateAxis(nt.y, rt.y)), nt;
}
const elementDragControls = new WeakMap();
class VisualElementDragControls {
	constructor(et) {
		(this.openGlobalLock = null),
			(this.isDragging = !1),
			(this.currentDirection = null),
			(this.originPoint = { x: 0, y: 0 }),
			(this.constraints = !1),
			(this.hasMutatedConstraints = !1),
			(this.elastic = createBox()),
			(this.visualElement = et);
	}
	start(et, { snapToCursor: tt = !1 } = {}) {
		if (this.visualElement.isPresent === !1) return;
		const nt = (at) => {
				this.stopAnimation(), tt && this.snapToCursor(extractEventInfo(at, "page").point);
			},
			rt = (at, st) => {
				var lt;
				const { drag: ut, dragPropagation: dt, onDragStart: ct } = this.getProps();
				(ut &&
					!dt &&
					(this.openGlobalLock && this.openGlobalLock(),
					(this.openGlobalLock = getGlobalLock(ut)),
					!this.openGlobalLock)) ||
					((this.isDragging = !0),
					(this.currentDirection = null),
					this.resolveConstraints(),
					this.visualElement.projection &&
						((this.visualElement.projection.isAnimationBlocked = !0), (this.visualElement.projection.target = void 0)),
					eachAxis((ft) => {
						var mt, pt;
						let vt = this.getAxisMotionValue(ft).get() || 0;
						if (percent.test(vt)) {
							const ht =
								(pt = (mt = this.visualElement.projection) === null || mt === void 0 ? void 0 : mt.layout) === null ||
								pt === void 0
									? void 0
									: pt.actual[ft];
							ht && (vt = calcLength(ht) * (parseFloat(vt) / 100));
						}
						this.originPoint[ft] = vt;
					}),
					ct == null || ct(at, st),
					(lt = this.visualElement.animationState) === null || lt === void 0 || lt.setActive(AnimationType.Drag, !0));
			},
			it = (at, st) => {
				const { dragPropagation: lt, dragDirectionLock: ut, onDirectionLock: dt, onDrag: ct } = this.getProps();
				if (!lt && !this.openGlobalLock) return;
				const { offset: ft } = st;
				if (ut && this.currentDirection === null) {
					(this.currentDirection = getCurrentDirection(ft)),
						this.currentDirection !== null && (dt == null || dt(this.currentDirection));
					return;
				}
				this.updateAxis("x", st.point, ft),
					this.updateAxis("y", st.point, ft),
					this.visualElement.syncRender(),
					ct == null || ct(at, st);
			},
			ot = (at, st) => this.stop(at, st);
		this.panSession = new PanSession(
			et,
			{ onSessionStart: nt, onStart: rt, onMove: it, onSessionEnd: ot },
			{ transformPagePoint: this.visualElement.getTransformPagePoint() }
		);
	}
	stop(et, tt) {
		const nt = this.isDragging;
		if ((this.cancel(), !nt)) return;
		const { velocity: rt } = tt;
		this.startAnimation(rt);
		const { onDragEnd: it } = this.getProps();
		it == null || it(et, tt);
	}
	cancel() {
		var et, tt;
		(this.isDragging = !1),
			this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !1),
			(et = this.panSession) === null || et === void 0 || et.end(),
			(this.panSession = void 0);
		const { dragPropagation: nt } = this.getProps();
		!nt && this.openGlobalLock && (this.openGlobalLock(), (this.openGlobalLock = null)),
			(tt = this.visualElement.animationState) === null || tt === void 0 || tt.setActive(AnimationType.Drag, !1);
	}
	updateAxis(et, tt, nt) {
		const { drag: rt } = this.getProps();
		if (!nt || !shouldDrag(et, rt, this.currentDirection)) return;
		const it = this.getAxisMotionValue(et);
		let ot = this.originPoint[et] + nt[et];
		this.constraints && this.constraints[et] && (ot = applyConstraints(ot, this.constraints[et], this.elastic[et])),
			it.set(ot);
	}
	resolveConstraints() {
		const { dragConstraints: et, dragElastic: tt } = this.getProps(),
			{ layout: nt } = this.visualElement.projection || {},
			rt = this.constraints;
		et && isRefObject(et)
			? this.constraints || (this.constraints = this.resolveRefConstraints())
			: et && nt
			? (this.constraints = calcRelativeConstraints(nt.actual, et))
			: (this.constraints = !1),
			(this.elastic = resolveDragElastic(tt)),
			rt !== this.constraints &&
				nt &&
				this.constraints &&
				!this.hasMutatedConstraints &&
				eachAxis((it) => {
					this.getAxisMotionValue(it) &&
						(this.constraints[it] = rebaseAxisConstraints(nt.actual[it], this.constraints[it]));
				});
	}
	resolveRefConstraints() {
		const { dragConstraints: et, onMeasureDragConstraints: tt } = this.getProps();
		if (!et || !isRefObject(et)) return !1;
		const nt = et.current,
			{ projection: rt } = this.visualElement;
		if (!rt || !rt.layout) return !1;
		const it = measurePageBox(nt, rt.root, this.visualElement.getTransformPagePoint());
		let ot = calcViewportConstraints(rt.layout.actual, it);
		if (tt) {
			const at = tt(convertBoxToBoundingBox(ot));
			(this.hasMutatedConstraints = !!at), at && (ot = convertBoundingBoxToBox(at));
		}
		return ot;
	}
	startAnimation(et) {
		const {
				drag: tt,
				dragMomentum: nt,
				dragElastic: rt,
				dragTransition: it,
				dragSnapToOrigin: ot,
				onDragTransitionEnd: at,
			} = this.getProps(),
			st = this.constraints || {},
			lt = eachAxis((ut) => {
				var dt;
				if (!shouldDrag(ut, tt, this.currentDirection)) return;
				let ct = (dt = st == null ? void 0 : st[ut]) !== null && dt !== void 0 ? dt : {};
				ot && (ct = { min: 0, max: 0 });
				const ft = rt ? 200 : 1e6,
					mt = rt ? 40 : 1e7,
					pt = {
						type: "inertia",
						velocity: nt ? et[ut] : 0,
						bounceStiffness: ft,
						bounceDamping: mt,
						timeConstant: 750,
						restDelta: 1,
						restSpeed: 10,
						...it,
						...ct,
					};
				return this.startAxisValueAnimation(ut, pt);
			});
		return Promise.all(lt).then(at);
	}
	startAxisValueAnimation(et, tt) {
		const nt = this.getAxisMotionValue(et);
		return startAnimation(et, nt, 0, tt);
	}
	stopAnimation() {
		eachAxis((et) => this.getAxisMotionValue(et).stop());
	}
	getAxisMotionValue(et) {
		var tt, nt;
		const rt = "_drag" + et.toUpperCase(),
			it = this.visualElement.getProps()[rt];
		return (
			it ||
			this.visualElement.getValue(
				et,
				(nt = (tt = this.visualElement.getProps().initial) === null || tt === void 0 ? void 0 : tt[et]) !== null &&
					nt !== void 0
					? nt
					: 0
			)
		);
	}
	snapToCursor(et) {
		eachAxis((tt) => {
			const { drag: nt } = this.getProps();
			if (!shouldDrag(tt, nt, this.currentDirection)) return;
			const { projection: rt } = this.visualElement,
				it = this.getAxisMotionValue(tt);
			if (rt && rt.layout) {
				const { min: ot, max: at } = rt.layout.actual[tt];
				it.set(et[tt] - mix(ot, at, 0.5));
			}
		});
	}
	scalePositionWithinConstraints() {
		var et;
		const { drag: tt, dragConstraints: nt } = this.getProps(),
			{ projection: rt } = this.visualElement;
		if (!isRefObject(nt) || !rt || !this.constraints) return;
		this.stopAnimation();
		const it = { x: 0, y: 0 };
		eachAxis((at) => {
			const st = this.getAxisMotionValue(at);
			if (st) {
				const lt = st.get();
				it[at] = calcOrigin({ min: lt, max: lt }, this.constraints[at]);
			}
		});
		const { transformTemplate: ot } = this.visualElement.getProps();
		(this.visualElement.getInstance().style.transform = ot ? ot({}, "") : "none"),
			(et = rt.root) === null || et === void 0 || et.updateScroll(),
			rt.updateLayout(),
			this.resolveConstraints(),
			eachAxis((at) => {
				if (!shouldDrag(at, tt, null)) return;
				const st = this.getAxisMotionValue(at),
					{ min: lt, max: ut } = this.constraints[at];
				st.set(mix(lt, ut, it[at]));
			});
	}
	addListeners() {
		var et;
		elementDragControls.set(this.visualElement, this);
		const tt = this.visualElement.getInstance(),
			nt = addPointerEvent(tt, "pointerdown", (lt) => {
				const { drag: ut, dragListener: dt = !0 } = this.getProps();
				ut && dt && this.start(lt);
			}),
			rt = () => {
				const { dragConstraints: lt } = this.getProps();
				isRefObject(lt) && (this.constraints = this.resolveRefConstraints());
			},
			{ projection: it } = this.visualElement,
			ot = it.addEventListener("measure", rt);
		it && !it.layout && ((et = it.root) === null || et === void 0 || et.updateScroll(), it.updateLayout()), rt();
		const at = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()),
			st = it.addEventListener("didUpdate", ({ delta: lt, hasLayoutChanged: ut }) => {
				this.isDragging &&
					ut &&
					(eachAxis((dt) => {
						const ct = this.getAxisMotionValue(dt);
						!ct || ((this.originPoint[dt] += lt[dt].translate), ct.set(ct.get() + lt[dt].translate));
					}),
					this.visualElement.syncRender());
			});
		return () => {
			at(), nt(), ot(), st == null || st();
		};
	}
	getProps() {
		const et = this.visualElement.getProps(),
			{
				drag: tt = !1,
				dragDirectionLock: nt = !1,
				dragPropagation: rt = !1,
				dragConstraints: it = !1,
				dragElastic: ot = defaultElastic,
				dragMomentum: at = !0,
			} = et;
		return {
			...et,
			drag: tt,
			dragDirectionLock: nt,
			dragPropagation: rt,
			dragConstraints: it,
			dragElastic: ot,
			dragMomentum: at,
		};
	}
}
function shouldDrag(_, et, tt) {
	return (et === !0 || et === _) && (tt === null || tt === _);
}
function getCurrentDirection(_, et = 10) {
	let tt = null;
	return Math.abs(_.y) > et ? (tt = "y") : Math.abs(_.x) > et && (tt = "x"), tt;
}
function useDrag(_) {
	const { dragControls: et, visualElement: tt } = _,
		nt = useConstant(() => new VisualElementDragControls(tt));
	react.exports.useEffect(() => et && et.subscribe(nt), [nt, et]),
		react.exports.useEffect(() => nt.addListeners(), [nt]);
}
function usePanGesture({ onPan: _, onPanStart: et, onPanEnd: tt, onPanSessionStart: nt, visualElement: rt }) {
	const it = _ || et || tt || nt,
		ot = react.exports.useRef(null),
		{ transformPagePoint: at } = react.exports.useContext(MotionConfigContext),
		st = {
			onSessionStart: nt,
			onStart: et,
			onMove: _,
			onEnd: (ut, dt) => {
				(ot.current = null), tt && tt(ut, dt);
			},
		};
	react.exports.useEffect(() => {
		ot.current !== null && ot.current.updateHandlers(st);
	});
	function lt(ut) {
		ot.current = new PanSession(ut, st, { transformPagePoint: at });
	}
	usePointerEvent$1(rt, "pointerdown", it && lt), useUnmountEffect$1(() => ot.current && ot.current.end());
}
const drag = { pan: makeRenderlessComponent(usePanGesture), drag: makeRenderlessComponent(useDrag) },
	prefersReducedMotion = { current: null },
	hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
	if (((hasReducedMotionListener.current = !0), !!isBrowser$1))
		if (window.matchMedia) {
			const _ = window.matchMedia("(prefers-reduced-motion)"),
				et = () => (prefersReducedMotion.current = _.matches);
			_.addListener(et), et();
		} else prefersReducedMotion.current = !1;
}
const names$1 = [
	"LayoutMeasure",
	"BeforeLayoutMeasure",
	"LayoutUpdate",
	"ViewportBoxUpdate",
	"Update",
	"Render",
	"AnimationComplete",
	"LayoutAnimationComplete",
	"AnimationStart",
	"LayoutAnimationStart",
	"SetAxisTarget",
	"Unmount",
];
function createLifecycles() {
	const _ = names$1.map(() => new SubscriptionManager()),
		et = {},
		tt = {
			clearAllListeners: () => _.forEach((nt) => nt.clear()),
			updatePropListeners: (nt) => {
				names$1.forEach((rt) => {
					var it;
					const ot = "on" + rt,
						at = nt[ot];
					(it = et[rt]) === null || it === void 0 || it.call(et), at && (et[rt] = tt[ot](at));
				});
			},
		};
	return (
		_.forEach((nt, rt) => {
			(tt["on" + names$1[rt]] = (it) => nt.add(it)), (tt["notify" + names$1[rt]] = (...it) => nt.notify(...it));
		}),
		tt
	);
}
function updateMotionValuesFromProps(_, et, tt) {
	const { willChange: nt } = et;
	for (const rt in et) {
		const it = et[rt],
			ot = tt[rt];
		if (isMotionValue(it)) _.addValue(rt, it), isWillChangeMotionValue(nt) && nt.add(rt);
		else if (isMotionValue(ot)) _.addValue(rt, motionValue(it)), isWillChangeMotionValue(nt) && nt.remove(rt);
		else if (ot !== it)
			if (_.hasValue(rt)) {
				const at = _.getValue(rt);
				!at.hasAnimated && at.set(it);
			} else {
				const at = _.getStaticValue(rt);
				_.addValue(rt, motionValue(at !== void 0 ? at : it));
			}
	}
	for (const rt in tt) et[rt] === void 0 && _.removeValue(rt);
	return et;
}
const featureNames = Object.keys(featureDefinitions),
	numFeatures = featureNames.length,
	visualElement =
		({
			treeType: _ = "",
			build: et,
			getBaseTarget: tt,
			makeTargetAnimatable: nt,
			measureViewportBox: rt,
			render: it,
			readValueFromInstance: ot,
			removeValueFromRenderState: at,
			sortNodePosition: st,
			scrapeMotionValuesFromProps: lt,
		}) =>
		(
			{ parent: ut, props: dt, presenceId: ct, blockInitialAnimation: ft, visualState: mt, reducedMotionConfig: pt },
			vt = {}
		) => {
			let ht = !1;
			const { latestValues: gt, renderState: yt } = mt;
			let xt;
			const St = createLifecycles(),
				wt = new Map(),
				Ct = new Map();
			let Et = {};
			const _t = { ...gt };
			let $t;
			function At() {
				!xt || !ht || (Lt(), it(xt, yt, dt.style, Dt.projection));
			}
			function Lt() {
				et(Dt, yt, gt, vt, dt);
			}
			function Nt() {
				St.notifyUpdate(gt);
			}
			function Ft(Rt, bt) {
				const kt = bt.onChange((Vt) => {
						(gt[Rt] = Vt), dt.onUpdate && sync.update(Nt, !1, !0);
					}),
					zt = bt.onRenderRequest(Dt.scheduleRender);
				Ct.set(Rt, () => {
					kt(), zt();
				});
			}
			const { willChange: Gt, ...Bt } = lt(dt);
			for (const Rt in Bt) {
				const bt = Bt[Rt];
				gt[Rt] !== void 0 && isMotionValue(bt) && (bt.set(gt[Rt], !1), isWillChangeMotionValue(Gt) && Gt.add(Rt));
			}
			const jt = isControllingVariants(dt),
				It = isVariantNode(dt),
				Dt = {
					treeType: _,
					current: null,
					depth: ut ? ut.depth + 1 : 0,
					parent: ut,
					children: new Set(),
					presenceId: ct,
					shouldReduceMotion: null,
					variantChildren: It ? new Set() : void 0,
					isVisible: void 0,
					manuallyAnimateOnMount: Boolean(ut == null ? void 0 : ut.isMounted()),
					blockInitialAnimation: ft,
					isMounted: () => Boolean(xt),
					mount(Rt) {
						(ht = !0),
							(xt = Dt.current = Rt),
							Dt.projection && Dt.projection.mount(Rt),
							It && ut && !jt && ($t = ut == null ? void 0 : ut.addVariantChild(Dt)),
							wt.forEach((bt, kt) => Ft(kt, bt)),
							hasReducedMotionListener.current || initPrefersReducedMotion(),
							(Dt.shouldReduceMotion = pt === "never" ? !1 : pt === "always" ? !0 : prefersReducedMotion.current),
							ut == null || ut.children.add(Dt),
							Dt.setProps(dt);
					},
					unmount() {
						var Rt;
						(Rt = Dt.projection) === null || Rt === void 0 || Rt.unmount(),
							cancelSync.update(Nt),
							cancelSync.render(At),
							Ct.forEach((bt) => bt()),
							$t == null || $t(),
							ut == null || ut.children.delete(Dt),
							St.clearAllListeners(),
							(xt = void 0),
							(ht = !1);
					},
					loadFeatures(Rt, bt, kt, zt, Vt, Yt) {
						const Ut = [];
						for (let qt = 0; qt < numFeatures; qt++) {
							const Wt = featureNames[qt],
								{ isEnabled: Xt, Component: Zt } = featureDefinitions[Wt];
							Xt(Rt) && Zt && Ut.push(react.exports.createElement(Zt, { key: Wt, ...Rt, visualElement: Dt }));
						}
						if (!Dt.projection && Vt) {
							Dt.projection = new Vt(zt, Dt.getLatestValues(), ut && ut.projection);
							const { layoutId: qt, layout: Wt, drag: Xt, dragConstraints: Zt, layoutScroll: pn } = Rt;
							Dt.projection.setOptions({
								layoutId: qt,
								layout: Wt,
								alwaysMeasureLayout: Boolean(Xt) || (Zt && isRefObject(Zt)),
								visualElement: Dt,
								scheduleRender: () => Dt.scheduleRender(),
								animationType: typeof Wt == "string" ? Wt : "both",
								initialPromotionConfig: Yt,
								layoutScroll: pn,
							});
						}
						return Ut;
					},
					addVariantChild(Rt) {
						var bt;
						const kt = Dt.getClosestVariantNode();
						if (kt)
							return (
								(bt = kt.variantChildren) === null || bt === void 0 || bt.add(Rt), () => kt.variantChildren.delete(Rt)
							);
					},
					sortNodePosition(Rt) {
						return !st || _ !== Rt.treeType ? 0 : st(Dt.getInstance(), Rt.getInstance());
					},
					getClosestVariantNode: () => (It ? Dt : ut == null ? void 0 : ut.getClosestVariantNode()),
					getLayoutId: () => dt.layoutId,
					getInstance: () => xt,
					getStaticValue: (Rt) => gt[Rt],
					setStaticValue: (Rt, bt) => (gt[Rt] = bt),
					getLatestValues: () => gt,
					setVisibility(Rt) {
						Dt.isVisible !== Rt && ((Dt.isVisible = Rt), Dt.scheduleRender());
					},
					makeTargetAnimatable(Rt, bt = !0) {
						return nt(Dt, Rt, dt, bt);
					},
					measureViewportBox() {
						return rt(xt, dt);
					},
					addValue(Rt, bt) {
						Dt.hasValue(Rt) && Dt.removeValue(Rt), wt.set(Rt, bt), (gt[Rt] = bt.get()), Ft(Rt, bt);
					},
					removeValue(Rt) {
						var bt;
						wt.delete(Rt),
							(bt = Ct.get(Rt)) === null || bt === void 0 || bt(),
							Ct.delete(Rt),
							delete gt[Rt],
							at(Rt, yt);
					},
					hasValue: (Rt) => wt.has(Rt),
					getValue(Rt, bt) {
						let kt = wt.get(Rt);
						return kt === void 0 && bt !== void 0 && ((kt = motionValue(bt)), Dt.addValue(Rt, kt)), kt;
					},
					forEachValue: (Rt) => wt.forEach(Rt),
					readValue: (Rt) => (gt[Rt] !== void 0 ? gt[Rt] : ot(xt, Rt, vt)),
					setBaseTarget(Rt, bt) {
						_t[Rt] = bt;
					},
					getBaseTarget(Rt) {
						if (tt) {
							const bt = tt(dt, Rt);
							if (bt !== void 0 && !isMotionValue(bt)) return bt;
						}
						return _t[Rt];
					},
					...St,
					build() {
						return Lt(), yt;
					},
					scheduleRender() {
						sync.render(At, !1, !0);
					},
					syncRender: At,
					setProps(Rt) {
						(Rt.transformTemplate || dt.transformTemplate) && Dt.scheduleRender(),
							(dt = Rt),
							St.updatePropListeners(Rt),
							(Et = updateMotionValuesFromProps(Dt, lt(dt), Et));
					},
					getProps: () => dt,
					getVariant: (Rt) => {
						var bt;
						return (bt = dt.variants) === null || bt === void 0 ? void 0 : bt[Rt];
					},
					getDefaultTransition: () => dt.transition,
					getTransformPagePoint: () => dt.transformPagePoint,
					getVariantContext(Rt = !1) {
						if (Rt) return ut == null ? void 0 : ut.getVariantContext();
						if (!jt) {
							const kt = (ut == null ? void 0 : ut.getVariantContext()) || {};
							return dt.initial !== void 0 && (kt.initial = dt.initial), kt;
						}
						const bt = {};
						for (let kt = 0; kt < numVariantProps; kt++) {
							const zt = variantProps[kt],
								Vt = dt[zt];
							(isVariantLabel(Vt) || Vt === !1) && (bt[zt] = Vt);
						}
						return bt;
					},
				};
			return Dt;
		},
	variantProps = ["initial", ...variantPriorityOrder],
	numVariantProps = variantProps.length;
function isCSSVariable(_) {
	return typeof _ == "string" && _.startsWith("var(--");
}
const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(_) {
	const et = cssVariableRegex.exec(_);
	if (!et) return [,];
	const [, tt, nt] = et;
	return [tt, nt];
}
function getVariableValue(_, et, tt = 1) {
	const [nt, rt] = parseCSSVariable(_);
	if (!nt) return;
	const it = window.getComputedStyle(et).getPropertyValue(nt);
	return it ? it.trim() : isCSSVariable(rt) ? getVariableValue(rt, et, tt + 1) : rt;
}
function resolveCSSVariables(_, { ...et }, tt) {
	const nt = _.getInstance();
	if (!(nt instanceof Element)) return { target: et, transitionEnd: tt };
	tt && (tt = { ...tt }),
		_.forEachValue((rt) => {
			const it = rt.get();
			if (!isCSSVariable(it)) return;
			const ot = getVariableValue(it, nt);
			ot && rt.set(ot);
		});
	for (const rt in et) {
		const it = et[rt];
		if (!isCSSVariable(it)) continue;
		const ot = getVariableValue(it, nt);
		!ot || ((et[rt] = ot), tt && tt[rt] === void 0 && (tt[rt] = it));
	}
	return { target: et, transitionEnd: tt };
}
const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"]),
	isPositionalKey = (_) => positionalKeys.has(_),
	hasPositionalKey = (_) => Object.keys(_).some(isPositionalKey),
	setAndResetVelocity = (_, et) => {
		_.set(et, !1), _.set(et);
	},
	isNumOrPxType = (_) => _ === number$1 || _ === px$1;
var BoundingBoxDimension;
(function (_) {
	(_.width = "width"),
		(_.height = "height"),
		(_.left = "left"),
		(_.right = "right"),
		(_.top = "top"),
		(_.bottom = "bottom");
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
const getPosFromMatrix = (_, et) => parseFloat(_.split(", ")[et]),
	getTranslateFromMatrix =
		(_, et) =>
		(tt, { transform: nt }) => {
			if (nt === "none" || !nt) return 0;
			const rt = nt.match(/^matrix3d\((.+)\)$/);
			if (rt) return getPosFromMatrix(rt[1], et);
			{
				const it = nt.match(/^matrix\((.+)\)$/);
				return it ? getPosFromMatrix(it[1], _) : 0;
			}
		},
	transformKeys = new Set(["x", "y", "z"]),
	nonTranslationalTransformKeys = transformPropOrder.filter((_) => !transformKeys.has(_));
function removeNonTranslationalTransform(_) {
	const et = [];
	return (
		nonTranslationalTransformKeys.forEach((tt) => {
			const nt = _.getValue(tt);
			nt !== void 0 && (et.push([tt, nt.get()]), nt.set(tt.startsWith("scale") ? 1 : 0));
		}),
		et.length && _.syncRender(),
		et
	);
}
const positionalValues = {
		width: ({ x: _ }, { paddingLeft: et = "0", paddingRight: tt = "0" }) =>
			_.max - _.min - parseFloat(et) - parseFloat(tt),
		height: ({ y: _ }, { paddingTop: et = "0", paddingBottom: tt = "0" }) =>
			_.max - _.min - parseFloat(et) - parseFloat(tt),
		top: (_, { top: et }) => parseFloat(et),
		left: (_, { left: et }) => parseFloat(et),
		bottom: ({ y: _ }, { top: et }) => parseFloat(et) + (_.max - _.min),
		right: ({ x: _ }, { left: et }) => parseFloat(et) + (_.max - _.min),
		x: getTranslateFromMatrix(4, 13),
		y: getTranslateFromMatrix(5, 14),
	},
	convertChangedValueTypes = (_, et, tt) => {
		const nt = et.measureViewportBox(),
			rt = et.getInstance(),
			it = getComputedStyle(rt),
			{ display: ot } = it,
			at = {};
		ot === "none" && et.setStaticValue("display", _.display || "block"),
			tt.forEach((lt) => {
				at[lt] = positionalValues[lt](nt, it);
			}),
			et.syncRender();
		const st = et.measureViewportBox();
		return (
			tt.forEach((lt) => {
				const ut = et.getValue(lt);
				setAndResetVelocity(ut, at[lt]), (_[lt] = positionalValues[lt](st, it));
			}),
			_
		);
	},
	checkAndConvertChangedValueTypes = (_, et, tt = {}, nt = {}) => {
		(et = { ...et }), (nt = { ...nt });
		const rt = Object.keys(et).filter(isPositionalKey);
		let it = [],
			ot = !1;
		const at = [];
		if (
			(rt.forEach((st) => {
				const lt = _.getValue(st);
				if (!_.hasValue(st)) return;
				let ut = tt[st],
					dt = findDimensionValueType(ut);
				const ct = et[st];
				let ft;
				if (isKeyframesTarget(ct)) {
					const mt = ct.length,
						pt = ct[0] === null ? 1 : 0;
					(ut = ct[pt]), (dt = findDimensionValueType(ut));
					for (let vt = pt; vt < mt; vt++)
						ft ? invariant$1(findDimensionValueType(ct[vt]) === ft) : (ft = findDimensionValueType(ct[vt]));
				} else ft = findDimensionValueType(ct);
				if (dt !== ft)
					if (isNumOrPxType(dt) && isNumOrPxType(ft)) {
						const mt = lt.get();
						typeof mt == "string" && lt.set(parseFloat(mt)),
							typeof ct == "string"
								? (et[st] = parseFloat(ct))
								: Array.isArray(ct) && ft === px$1 && (et[st] = ct.map(parseFloat));
					} else
						(dt == null ? void 0 : dt.transform) && (ft == null ? void 0 : ft.transform) && (ut === 0 || ct === 0)
							? ut === 0
								? lt.set(ft.transform(ut))
								: (et[st] = dt.transform(ct))
							: (ot || ((it = removeNonTranslationalTransform(_)), (ot = !0)),
							  at.push(st),
							  (nt[st] = nt[st] !== void 0 ? nt[st] : et[st]),
							  setAndResetVelocity(lt, ct));
			}),
			at.length)
		) {
			const st = at.indexOf("height") >= 0 ? window.pageYOffset : null,
				lt = convertChangedValueTypes(et, _, at);
			return (
				it.length &&
					it.forEach(([ut, dt]) => {
						_.getValue(ut).set(dt);
					}),
				_.syncRender(),
				isBrowser$1 && st !== null && window.scrollTo({ top: st }),
				{ target: lt, transitionEnd: nt }
			);
		} else return { target: et, transitionEnd: nt };
	};
function unitConversion(_, et, tt, nt) {
	return hasPositionalKey(et) ? checkAndConvertChangedValueTypes(_, et, tt, nt) : { target: et, transitionEnd: nt };
}
const parseDomVariant = (_, et, tt, nt) => {
	const rt = resolveCSSVariables(_, et, nt);
	return (et = rt.target), (nt = rt.transitionEnd), unitConversion(_, et, tt, nt);
};
function getComputedStyle$2(_) {
	return window.getComputedStyle(_);
}
const htmlConfig = {
		treeType: "dom",
		readValueFromInstance(_, et) {
			if (transformProps.has(et)) {
				const tt = getDefaultValueType(et);
				return (tt && tt.default) || 0;
			} else {
				const tt = getComputedStyle$2(_),
					nt = (isCSSVariable$1(et) ? tt.getPropertyValue(et) : tt[et]) || 0;
				return typeof nt == "string" ? nt.trim() : nt;
			}
		},
		sortNodePosition(_, et) {
			return _.compareDocumentPosition(et) & 2 ? 1 : -1;
		},
		getBaseTarget(_, et) {
			var tt;
			return (tt = _.style) === null || tt === void 0 ? void 0 : tt[et];
		},
		measureViewportBox(_, { transformPagePoint: et }) {
			return measureViewportBox(_, et);
		},
		resetTransform(_, et, tt) {
			const { transformTemplate: nt } = tt;
			(et.style.transform = nt ? nt({}, "") : "none"), _.scheduleRender();
		},
		restoreTransform(_, et) {
			_.style.transform = et.style.transform;
		},
		removeValueFromRenderState(_, { vars: et, style: tt }) {
			delete et[_], delete tt[_];
		},
		makeTargetAnimatable(_, { transition: et, transitionEnd: tt, ...nt }, { transformValues: rt }, it = !0) {
			let ot = getOrigin(nt, et || {}, _);
			if ((rt && (tt && (tt = rt(tt)), nt && (nt = rt(nt)), ot && (ot = rt(ot))), it)) {
				checkTargetForNewValues(_, nt, ot);
				const at = parseDomVariant(_, nt, ot, tt);
				(tt = at.transitionEnd), (nt = at.target);
			}
			return { transition: et, transitionEnd: tt, ...nt };
		},
		scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
		build(_, et, tt, nt, rt) {
			_.isVisible !== void 0 && (et.style.visibility = _.isVisible ? "visible" : "hidden"),
				buildHTMLStyles(et, tt, nt, rt.transformTemplate);
		},
		render: renderHTML,
	},
	htmlVisualElement = visualElement(htmlConfig),
	svgVisualElement = visualElement({
		...htmlConfig,
		getBaseTarget(_, et) {
			return _[et];
		},
		readValueFromInstance(_, et) {
			var tt;
			return transformProps.has(et)
				? ((tt = getDefaultValueType(et)) === null || tt === void 0 ? void 0 : tt.default) || 0
				: ((et = camelCaseAttributes.has(et) ? et : camelToDash(et)), _.getAttribute(et));
		},
		scrapeMotionValuesFromProps,
		build(_, et, tt, nt, rt) {
			buildSVGAttrs(et, tt, nt, rt.transformTemplate);
		},
		render: renderSVG,
	}),
	createDomVisualElement = (_, et) =>
		isSVGComponent(_)
			? svgVisualElement(et, { enableHardwareAcceleration: !1 })
			: htmlVisualElement(et, { enableHardwareAcceleration: !0 });
function pixelsToPercent(_, et) {
	return et.max === et.min ? 0 : (_ / (et.max - et.min)) * 100;
}
const correctBorderRadius = {
		correct: (_, et) => {
			if (!et.target) return _;
			if (typeof _ == "string")
				if (px$1.test(_)) _ = parseFloat(_);
				else return _;
			const tt = pixelsToPercent(_, et.target.x),
				nt = pixelsToPercent(_, et.target.y);
			return `${tt}% ${nt}%`;
		},
	},
	varToken = "_$css",
	correctBoxShadow = {
		correct: (_, { treeScale: et, projectionDelta: tt }) => {
			const nt = _,
				rt = _.includes("var("),
				it = [];
			rt && (_ = _.replace(cssVariableRegex, (ft) => (it.push(ft), varToken)));
			const ot = complex.parse(_);
			if (ot.length > 5) return nt;
			const at = complex.createTransformer(_),
				st = typeof ot[0] != "number" ? 1 : 0,
				lt = tt.x.scale * et.x,
				ut = tt.y.scale * et.y;
			(ot[0 + st] /= lt), (ot[1 + st] /= ut);
			const dt = mix(lt, ut, 0.5);
			typeof ot[2 + st] == "number" && (ot[2 + st] /= dt), typeof ot[3 + st] == "number" && (ot[3 + st] /= dt);
			let ct = at(ot);
			if (rt) {
				let ft = 0;
				ct = ct.replace(varToken, () => {
					const mt = it[ft];
					return ft++, mt;
				});
			}
			return ct;
		},
	};
class MeasureLayoutWithContext extends React$1.Component {
	componentDidMount() {
		const { visualElement: et, layoutGroup: tt, switchLayoutGroup: nt, layoutId: rt } = this.props,
			{ projection: it } = et;
		addScaleCorrector(defaultScaleCorrectors),
			it &&
				(tt.group && tt.group.add(it),
				nt && nt.register && rt && nt.register(it),
				it.root.didUpdate(),
				it.addEventListener("animationComplete", () => {
					this.safeToRemove();
				}),
				it.setOptions({ ...it.options, onExitComplete: () => this.safeToRemove() })),
			(globalProjectionState.hasEverUpdated = !0);
	}
	getSnapshotBeforeUpdate(et) {
		const { layoutDependency: tt, visualElement: nt, drag: rt, isPresent: it } = this.props,
			ot = nt.projection;
		return (
			ot &&
				((ot.isPresent = it),
				rt || et.layoutDependency !== tt || tt === void 0 ? ot.willUpdate() : this.safeToRemove(),
				et.isPresent !== it &&
					(it
						? ot.promote()
						: ot.relegate() ||
						  sync.postRender(() => {
								var at;
								(!((at = ot.getStack()) === null || at === void 0) && at.members.length) || this.safeToRemove();
						  }))),
			null
		);
	}
	componentDidUpdate() {
		const { projection: et } = this.props.visualElement;
		et && (et.root.didUpdate(), !et.currentAnimation && et.isLead() && this.safeToRemove());
	}
	componentWillUnmount() {
		const { visualElement: et, layoutGroup: tt, switchLayoutGroup: nt } = this.props,
			{ projection: rt } = et;
		rt &&
			(rt.scheduleCheckAfterUnmount(),
			tt != null && tt.group && tt.group.remove(rt),
			nt != null && nt.deregister && nt.deregister(rt));
	}
	safeToRemove() {
		const { safeToRemove: et } = this.props;
		et == null || et();
	}
	render() {
		return null;
	}
}
function MeasureLayout(_) {
	const [et, tt] = usePresence(),
		nt = react.exports.useContext(LayoutGroupContext);
	return jsx(MeasureLayoutWithContext, {
		..._,
		layoutGroup: nt,
		switchLayoutGroup: react.exports.useContext(SwitchLayoutGroupContext),
		isPresent: et,
		safeToRemove: tt,
	});
}
const defaultScaleCorrectors = {
		borderRadius: {
			...correctBorderRadius,
			applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"],
		},
		borderTopLeftRadius: correctBorderRadius,
		borderTopRightRadius: correctBorderRadius,
		borderBottomLeftRadius: correctBorderRadius,
		borderBottomRightRadius: correctBorderRadius,
		boxShadow: correctBoxShadow,
	},
	layoutFeatures = { measureLayout: MeasureLayout };
function animate(_, et, tt = {}) {
	const nt = isMotionValue(_) ? _ : motionValue(_);
	return startAnimation("", nt, et, tt), { stop: () => nt.stop(), isAnimating: () => nt.isAnimating() };
}
const borders$1 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
	numBorders = borders$1.length,
	asNumber = (_) => (typeof _ == "string" ? parseFloat(_) : _),
	isPx = (_) => typeof _ == "number" || px$1.test(_);
function mixValues(_, et, tt, nt, rt, it) {
	var ot, at, st, lt;
	rt
		? ((_.opacity = mix(0, (ot = tt.opacity) !== null && ot !== void 0 ? ot : 1, easeCrossfadeIn(nt))),
		  (_.opacityExit = mix((at = et.opacity) !== null && at !== void 0 ? at : 1, 0, easeCrossfadeOut(nt))))
		: it &&
		  (_.opacity = mix(
				(st = et.opacity) !== null && st !== void 0 ? st : 1,
				(lt = tt.opacity) !== null && lt !== void 0 ? lt : 1,
				nt
		  ));
	for (let ut = 0; ut < numBorders; ut++) {
		const dt = `border${borders$1[ut]}Radius`;
		let ct = getRadius(et, dt),
			ft = getRadius(tt, dt);
		if (ct === void 0 && ft === void 0) continue;
		ct || (ct = 0),
			ft || (ft = 0),
			ct === 0 || ft === 0 || isPx(ct) === isPx(ft)
				? ((_[dt] = Math.max(mix(asNumber(ct), asNumber(ft), nt), 0)),
				  (percent.test(ft) || percent.test(ct)) && (_[dt] += "%"))
				: (_[dt] = ft);
	}
	(et.rotate || tt.rotate) && (_.rotate = mix(et.rotate || 0, tt.rotate || 0, nt));
}
function getRadius(_, et) {
	var tt;
	return (tt = _[et]) !== null && tt !== void 0 ? tt : _.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut),
	easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(_, et, tt) {
	return (nt) => (nt < _ ? 0 : nt > et ? 1 : tt(progress(_, et, nt)));
}
function copyAxisInto(_, et) {
	(_.min = et.min), (_.max = et.max);
}
function copyBoxInto(_, et) {
	copyAxisInto(_.x, et.x), copyAxisInto(_.y, et.y);
}
function removePointDelta(_, et, tt, nt, rt) {
	return (_ -= et), (_ = scalePoint(_, 1 / tt, nt)), rt !== void 0 && (_ = scalePoint(_, 1 / rt, nt)), _;
}
function removeAxisDelta(_, et = 0, tt = 1, nt = 0.5, rt, it = _, ot = _) {
	if (
		(percent.test(et) && ((et = parseFloat(et)), (et = mix(ot.min, ot.max, et / 100) - ot.min)), typeof et != "number")
	)
		return;
	let at = mix(it.min, it.max, nt);
	_ === it && (at -= et),
		(_.min = removePointDelta(_.min, et, tt, at, rt)),
		(_.max = removePointDelta(_.max, et, tt, at, rt));
}
function removeAxisTransforms(_, et, [tt, nt, rt], it, ot) {
	removeAxisDelta(_, et[tt], et[nt], et[rt], et.scale, it, ot);
}
const xKeys = ["x", "scaleX", "originX"],
	yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(_, et, tt, nt) {
	removeAxisTransforms(_.x, et, xKeys, tt == null ? void 0 : tt.x, nt == null ? void 0 : nt.x),
		removeAxisTransforms(_.y, et, yKeys, tt == null ? void 0 : tt.y, nt == null ? void 0 : nt.y);
}
function isAxisDeltaZero(_) {
	return _.translate === 0 && _.scale === 1;
}
function isDeltaZero(_) {
	return isAxisDeltaZero(_.x) && isAxisDeltaZero(_.y);
}
function boxEquals(_, et) {
	return _.x.min === et.x.min && _.x.max === et.x.max && _.y.min === et.y.min && _.y.max === et.y.max;
}
function aspectRatio(_) {
	return calcLength(_.x) / calcLength(_.y);
}
function isCloseTo(_, et, tt = 0.01) {
	return distance(_, et) <= tt;
}
class NodeStack {
	constructor() {
		this.members = [];
	}
	add(et) {
		addUniqueItem(this.members, et), et.scheduleRender();
	}
	remove(et) {
		if ((removeItem(this.members, et), et === this.prevLead && (this.prevLead = void 0), et === this.lead)) {
			const tt = this.members[this.members.length - 1];
			tt && this.promote(tt);
		}
	}
	relegate(et) {
		const tt = this.members.findIndex((rt) => et === rt);
		if (tt === 0) return !1;
		let nt;
		for (let rt = tt; rt >= 0; rt--) {
			const it = this.members[rt];
			if (it.isPresent !== !1) {
				nt = it;
				break;
			}
		}
		return nt ? (this.promote(nt), !0) : !1;
	}
	promote(et, tt) {
		var nt;
		const rt = this.lead;
		if (et !== rt && ((this.prevLead = rt), (this.lead = et), et.show(), rt)) {
			rt.instance && rt.scheduleRender(),
				et.scheduleRender(),
				(et.resumeFrom = rt),
				tt && (et.resumeFrom.preserveOpacity = !0),
				rt.snapshot &&
					((et.snapshot = rt.snapshot),
					(et.snapshot.latestValues = rt.animationValues || rt.latestValues),
					(et.snapshot.isShared = !0)),
				!((nt = et.root) === null || nt === void 0) && nt.isUpdating && (et.isLayoutDirty = !0);
			const { crossfade: it } = et.options;
			it === !1 && rt.hide();
		}
	}
	exitAnimationComplete() {
		this.members.forEach((et) => {
			var tt, nt, rt, it, ot;
			(nt = (tt = et.options).onExitComplete) === null || nt === void 0 || nt.call(tt),
				(ot = (rt = et.resumingFrom) === null || rt === void 0 ? void 0 : (it = rt.options).onExitComplete) === null ||
					ot === void 0 ||
					ot.call(it);
		});
	}
	scheduleRender() {
		this.members.forEach((et) => {
			et.instance && et.scheduleRender(!1);
		});
	}
	removeLeadSnapshot() {
		this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
	}
}
const identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
function buildProjectionTransform(_, et, tt) {
	const nt = _.x.translate / et.x,
		rt = _.y.translate / et.y;
	let it = `translate3d(${nt}px, ${rt}px, 0) `;
	if (((it += `scale(${1 / et.x}, ${1 / et.y}) `), tt)) {
		const { rotate: st, rotateX: lt, rotateY: ut } = tt;
		st && (it += `rotate(${st}deg) `), lt && (it += `rotateX(${lt}deg) `), ut && (it += `rotateY(${ut}deg) `);
	}
	const ot = _.x.scale * et.x,
		at = _.y.scale * et.y;
	return (it += `scale(${ot}, ${at})`), it === identityProjection ? "none" : it;
}
const compareByDepth = (_, et) => _.depth - et.depth;
class FlatTree {
	constructor() {
		(this.children = []), (this.isDirty = !1);
	}
	add(et) {
		addUniqueItem(this.children, et), (this.isDirty = !0);
	}
	remove(et) {
		removeItem(this.children, et), (this.isDirty = !0);
	}
	forEach(et) {
		this.isDirty && this.children.sort(compareByDepth), (this.isDirty = !1), this.children.forEach(et);
	}
}
const transformAxes = ["", "X", "Y", "Z"],
	animationTarget = 1e3;
function createProjectionNode({
	attachResizeListener: _,
	defaultParent: et,
	measureScroll: tt,
	checkIsScrollRoot: nt,
	resetTransform: rt,
}) {
	return class {
		constructor(ot, at = {}, st = et == null ? void 0 : et()) {
			(this.children = new Set()),
				(this.options = {}),
				(this.isTreeAnimating = !1),
				(this.isAnimationBlocked = !1),
				(this.isLayoutDirty = !1),
				(this.updateManuallyBlocked = !1),
				(this.updateBlockedByResize = !1),
				(this.isUpdating = !1),
				(this.isSVG = !1),
				(this.needsReset = !1),
				(this.shouldResetTransform = !1),
				(this.treeScale = { x: 1, y: 1 }),
				(this.eventHandlers = new Map()),
				(this.potentialNodes = new Map()),
				(this.checkUpdateFailed = () => {
					this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
				}),
				(this.updateProjection = () => {
					this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection);
				}),
				(this.hasProjected = !1),
				(this.isVisible = !0),
				(this.animationProgress = 0),
				(this.sharedNodes = new Map()),
				(this.id = ot),
				(this.latestValues = at),
				(this.root = st ? st.root || st : this),
				(this.path = st ? [...st.path, st] : []),
				(this.parent = st),
				(this.depth = st ? st.depth + 1 : 0),
				ot && this.root.registerPotentialNode(ot, this);
			for (let lt = 0; lt < this.path.length; lt++) this.path[lt].shouldResetTransform = !0;
			this.root === this && (this.nodes = new FlatTree());
		}
		addEventListener(ot, at) {
			return (
				this.eventHandlers.has(ot) || this.eventHandlers.set(ot, new SubscriptionManager()),
				this.eventHandlers.get(ot).add(at)
			);
		}
		notifyListeners(ot, ...at) {
			const st = this.eventHandlers.get(ot);
			st == null || st.notify(...at);
		}
		hasListeners(ot) {
			return this.eventHandlers.has(ot);
		}
		registerPotentialNode(ot, at) {
			this.potentialNodes.set(ot, at);
		}
		mount(ot, at = !1) {
			var st;
			if (this.instance) return;
			(this.isSVG = ot instanceof SVGElement && ot.tagName !== "svg"), (this.instance = ot);
			const { layoutId: lt, layout: ut, visualElement: dt } = this.options;
			if (
				(dt && !dt.getInstance() && dt.mount(ot),
				this.root.nodes.add(this),
				(st = this.parent) === null || st === void 0 || st.children.add(this),
				this.id && this.root.potentialNodes.delete(this.id),
				at && (ut || lt) && (this.isLayoutDirty = !0),
				_)
			) {
				let ct;
				const ft = () => (this.root.updateBlockedByResize = !1);
				_(ot, () => {
					(this.root.updateBlockedByResize = !0),
						clearTimeout(ct),
						(ct = window.setTimeout(ft, 250)),
						globalProjectionState.hasAnimatedSinceResize &&
							((globalProjectionState.hasAnimatedSinceResize = !1), this.nodes.forEach(finishAnimation));
				});
			}
			lt && this.root.registerSharedNode(lt, this),
				this.options.animate !== !1 &&
					dt &&
					(lt || ut) &&
					this.addEventListener(
						"didUpdate",
						({ delta: ct, hasLayoutChanged: ft, hasRelativeTargetChanged: mt, layout: pt }) => {
							var vt, ht, gt, yt, xt;
							if (this.isTreeAnimationBlocked()) {
								(this.target = void 0), (this.relativeTarget = void 0);
								return;
							}
							const St =
									(ht = (vt = this.options.transition) !== null && vt !== void 0 ? vt : dt.getDefaultTransition()) !==
										null && ht !== void 0
										? ht
										: defaultLayoutTransition,
								{ onLayoutAnimationStart: wt, onLayoutAnimationComplete: Ct } = dt.getProps(),
								Et = !this.targetLayout || !boxEquals(this.targetLayout, pt) || mt,
								_t = !ft && mt;
							if (
								((gt = this.resumeFrom) === null || gt === void 0 ? void 0 : gt.instance) ||
								_t ||
								(ft && (Et || !this.currentAnimation))
							) {
								this.resumeFrom && ((this.resumingFrom = this.resumeFrom), (this.resumingFrom.resumingFrom = void 0)),
									this.setAnimationOrigin(ct, _t);
								const $t = { ...getValueTransition(St, "layout"), onPlay: wt, onComplete: Ct };
								dt.shouldReduceMotion && (($t.delay = 0), ($t.type = !1)), this.startAnimation($t);
							} else
								!ft && this.animationProgress === 0 && this.finishAnimation(),
									this.isLead() && ((xt = (yt = this.options).onExitComplete) === null || xt === void 0 || xt.call(yt));
							this.targetLayout = pt;
						}
					);
		}
		unmount() {
			var ot, at;
			this.options.layoutId && this.willUpdate(),
				this.root.nodes.remove(this),
				(ot = this.getStack()) === null || ot === void 0 || ot.remove(this),
				(at = this.parent) === null || at === void 0 || at.children.delete(this),
				(this.instance = void 0),
				cancelSync.preRender(this.updateProjection);
		}
		blockUpdate() {
			this.updateManuallyBlocked = !0;
		}
		unblockUpdate() {
			this.updateManuallyBlocked = !1;
		}
		isUpdateBlocked() {
			return this.updateManuallyBlocked || this.updateBlockedByResize;
		}
		isTreeAnimationBlocked() {
			var ot;
			return (
				this.isAnimationBlocked ||
				((ot = this.parent) === null || ot === void 0 ? void 0 : ot.isTreeAnimationBlocked()) ||
				!1
			);
		}
		startUpdate() {
			var ot;
			this.isUpdateBlocked() ||
				((this.isUpdating = !0), (ot = this.nodes) === null || ot === void 0 || ot.forEach(resetRotation));
		}
		willUpdate(ot = !0) {
			var at, st, lt;
			if (this.root.isUpdateBlocked()) {
				(st = (at = this.options).onExitComplete) === null || st === void 0 || st.call(at);
				return;
			}
			if ((!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)) return;
			this.isLayoutDirty = !0;
			for (let ft = 0; ft < this.path.length; ft++) {
				const mt = this.path[ft];
				(mt.shouldResetTransform = !0), mt.updateScroll();
			}
			const { layoutId: ut, layout: dt } = this.options;
			if (ut === void 0 && !dt) return;
			const ct = (lt = this.options.visualElement) === null || lt === void 0 ? void 0 : lt.getProps().transformTemplate;
			(this.prevTransformTemplateValue = ct == null ? void 0 : ct(this.latestValues, "")),
				this.updateSnapshot(),
				ot && this.notifyListeners("willUpdate");
		}
		didUpdate() {
			if (this.isUpdateBlocked()) {
				this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
				return;
			}
			!this.isUpdating ||
				((this.isUpdating = !1),
				this.potentialNodes.size && (this.potentialNodes.forEach(mountNodeEarly), this.potentialNodes.clear()),
				this.nodes.forEach(resetTransformStyle),
				this.nodes.forEach(updateLayout),
				this.nodes.forEach(notifyLayoutUpdate),
				this.clearAllSnapshots(),
				flushSync.update(),
				flushSync.preRender(),
				flushSync.render());
		}
		clearAllSnapshots() {
			this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
		}
		scheduleUpdateProjection() {
			sync.preRender(this.updateProjection, !1, !0);
		}
		scheduleCheckAfterUnmount() {
			sync.postRender(() => {
				this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
			});
		}
		updateSnapshot() {
			if (this.snapshot || !this.instance) return;
			const ot = this.measure(),
				at = this.removeTransform(this.removeElementScroll(ot));
			roundBox(at), (this.snapshot = { measured: ot, layout: at, latestValues: {} });
		}
		updateLayout() {
			var ot;
			if (
				!this.instance ||
				(this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)
			)
				return;
			if (this.resumeFrom && !this.resumeFrom.instance)
				for (let lt = 0; lt < this.path.length; lt++) this.path[lt].updateScroll();
			const at = this.measure();
			roundBox(at);
			const st = this.layout;
			(this.layout = { measured: at, actual: this.removeElementScroll(at) }),
				(this.layoutCorrected = createBox()),
				(this.isLayoutDirty = !1),
				(this.projectionDelta = void 0),
				this.notifyListeners("measure", this.layout.actual),
				(ot = this.options.visualElement) === null ||
					ot === void 0 ||
					ot.notifyLayoutMeasure(this.layout.actual, st == null ? void 0 : st.actual);
		}
		updateScroll() {
			this.options.layoutScroll &&
				this.instance &&
				((this.isScrollRoot = nt(this.instance)), (this.scroll = tt(this.instance)));
		}
		resetTransform() {
			var ot;
			if (!rt) return;
			const at = this.isLayoutDirty || this.shouldResetTransform,
				st = this.projectionDelta && !isDeltaZero(this.projectionDelta),
				lt = (ot = this.options.visualElement) === null || ot === void 0 ? void 0 : ot.getProps().transformTemplate,
				ut = lt == null ? void 0 : lt(this.latestValues, ""),
				dt = ut !== this.prevTransformTemplateValue;
			at &&
				(st || hasTransform(this.latestValues) || dt) &&
				(rt(this.instance, ut), (this.shouldResetTransform = !1), this.scheduleRender());
		}
		measure() {
			const { visualElement: ot } = this.options;
			if (!ot) return createBox();
			const at = ot.measureViewportBox(),
				{ scroll: st } = this.root;
			return st && (translateAxis(at.x, st.x), translateAxis(at.y, st.y)), at;
		}
		removeElementScroll(ot) {
			const at = createBox();
			copyBoxInto(at, ot);
			for (let st = 0; st < this.path.length; st++) {
				const lt = this.path[st],
					{ scroll: ut, options: dt, isScrollRoot: ct } = lt;
				if (lt !== this.root && ut && dt.layoutScroll) {
					if (ct) {
						copyBoxInto(at, ot);
						const { scroll: ft } = this.root;
						ft && (translateAxis(at.x, -ft.x), translateAxis(at.y, -ft.y));
					}
					translateAxis(at.x, ut.x), translateAxis(at.y, ut.y);
				}
			}
			return at;
		}
		applyTransform(ot, at = !1) {
			const st = createBox();
			copyBoxInto(st, ot);
			for (let lt = 0; lt < this.path.length; lt++) {
				const ut = this.path[lt];
				!at &&
					ut.options.layoutScroll &&
					ut.scroll &&
					ut !== ut.root &&
					transformBox(st, { x: -ut.scroll.x, y: -ut.scroll.y }),
					hasTransform(ut.latestValues) && transformBox(st, ut.latestValues);
			}
			return hasTransform(this.latestValues) && transformBox(st, this.latestValues), st;
		}
		removeTransform(ot) {
			var at;
			const st = createBox();
			copyBoxInto(st, ot);
			for (let lt = 0; lt < this.path.length; lt++) {
				const ut = this.path[lt];
				if (!ut.instance || !hasTransform(ut.latestValues)) continue;
				hasScale(ut.latestValues) && ut.updateSnapshot();
				const dt = createBox(),
					ct = ut.measure();
				copyBoxInto(dt, ct),
					removeBoxTransforms(
						st,
						ut.latestValues,
						(at = ut.snapshot) === null || at === void 0 ? void 0 : at.layout,
						dt
					);
			}
			return hasTransform(this.latestValues) && removeBoxTransforms(st, this.latestValues), st;
		}
		setTargetDelta(ot) {
			(this.targetDelta = ot), this.root.scheduleUpdateProjection();
		}
		setOptions(ot) {
			this.options = { ...this.options, ...ot, crossfade: ot.crossfade !== void 0 ? ot.crossfade : !0 };
		}
		clearMeasurements() {
			(this.scroll = void 0),
				(this.layout = void 0),
				(this.snapshot = void 0),
				(this.prevTransformTemplateValue = void 0),
				(this.targetDelta = void 0),
				(this.target = void 0),
				(this.isLayoutDirty = !1);
		}
		resolveTargetDelta() {
			var ot;
			const { layout: at, layoutId: st } = this.options;
			!this.layout ||
				!(at || st) ||
				(!this.targetDelta &&
					!this.relativeTarget &&
					((this.relativeParent = this.getClosestProjectingParent()),
					this.relativeParent &&
						this.relativeParent.layout &&
						((this.relativeTarget = createBox()),
						(this.relativeTargetOrigin = createBox()),
						calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual),
						copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))),
				!(!this.relativeTarget && !this.targetDelta) &&
					(this.target || ((this.target = createBox()), (this.targetWithTransforms = createBox())),
					this.relativeTarget &&
					this.relativeTargetOrigin &&
					((ot = this.relativeParent) === null || ot === void 0 ? void 0 : ot.target)
						? calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)
						: this.targetDelta
						? (Boolean(this.resumingFrom)
								? (this.target = this.applyTransform(this.layout.actual))
								: copyBoxInto(this.target, this.layout.actual),
						  applyBoxDelta(this.target, this.targetDelta))
						: copyBoxInto(this.target, this.layout.actual),
					this.attemptToResolveRelativeTarget &&
						((this.attemptToResolveRelativeTarget = !1),
						(this.relativeParent = this.getClosestProjectingParent()),
						this.relativeParent &&
							Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) &&
							!this.relativeParent.options.layoutScroll &&
							this.relativeParent.target &&
							((this.relativeTarget = createBox()),
							(this.relativeTargetOrigin = createBox()),
							calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target),
							copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)))));
		}
		getClosestProjectingParent() {
			if (!(!this.parent || hasTransform(this.parent.latestValues)))
				return (this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout
					? this.parent
					: this.parent.getClosestProjectingParent();
		}
		calcProjection() {
			var ot;
			const { layout: at, layoutId: st } = this.options;
			if (
				((this.isTreeAnimating = Boolean(
					((ot = this.parent) === null || ot === void 0 ? void 0 : ot.isTreeAnimating) ||
						this.currentAnimation ||
						this.pendingAnimation
				)),
				this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
				!this.layout || !(at || st))
			)
				return;
			const lt = this.getLead();
			copyBoxInto(this.layoutCorrected, this.layout.actual),
				applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lt);
			const { target: ut } = lt;
			if (!ut) return;
			this.projectionDelta ||
				((this.projectionDelta = createDelta()), (this.projectionDeltaWithTransform = createDelta()));
			const dt = this.treeScale.x,
				ct = this.treeScale.y,
				ft = this.projectionTransform;
			calcBoxDelta(this.projectionDelta, this.layoutCorrected, ut, this.latestValues),
				(this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale)),
				(this.projectionTransform !== ft || this.treeScale.x !== dt || this.treeScale.y !== ct) &&
					((this.hasProjected = !0), this.scheduleRender(), this.notifyListeners("projectionUpdate", ut));
		}
		hide() {
			this.isVisible = !1;
		}
		show() {
			this.isVisible = !0;
		}
		scheduleRender(ot = !0) {
			var at, st, lt;
			(st = (at = this.options).scheduleRender) === null || st === void 0 || st.call(at),
				ot && ((lt = this.getStack()) === null || lt === void 0 || lt.scheduleRender()),
				this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
		}
		setAnimationOrigin(ot, at = !1) {
			var st;
			const lt = this.snapshot,
				ut = (lt == null ? void 0 : lt.latestValues) || {},
				dt = { ...this.latestValues },
				ct = createDelta();
			(this.relativeTarget = this.relativeTargetOrigin = void 0), (this.attemptToResolveRelativeTarget = !at);
			const ft = createBox(),
				mt = lt == null ? void 0 : lt.isShared,
				pt = (((st = this.getStack()) === null || st === void 0 ? void 0 : st.members.length) || 0) <= 1,
				vt = Boolean(mt && !pt && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
			(this.animationProgress = 0),
				(this.mixTargetDelta = (ht) => {
					var gt;
					const yt = ht / 1e3;
					mixAxisDelta(ct.x, ot.x, yt),
						mixAxisDelta(ct.y, ot.y, yt),
						this.setTargetDelta(ct),
						this.relativeTarget &&
							this.relativeTargetOrigin &&
							this.layout &&
							((gt = this.relativeParent) === null || gt === void 0 ? void 0 : gt.layout) &&
							(calcRelativePosition(ft, this.layout.actual, this.relativeParent.layout.actual),
							mixBox(this.relativeTarget, this.relativeTargetOrigin, ft, yt)),
						mt && ((this.animationValues = dt), mixValues(dt, ut, this.latestValues, yt, vt, pt)),
						this.root.scheduleUpdateProjection(),
						this.scheduleRender(),
						(this.animationProgress = yt);
				}),
				this.mixTargetDelta(0);
		}
		startAnimation(ot) {
			var at, st;
			this.notifyListeners("animationStart"),
				(at = this.currentAnimation) === null || at === void 0 || at.stop(),
				this.resumingFrom && ((st = this.resumingFrom.currentAnimation) === null || st === void 0 || st.stop()),
				this.pendingAnimation && (cancelSync.update(this.pendingAnimation), (this.pendingAnimation = void 0)),
				(this.pendingAnimation = sync.update(() => {
					(globalProjectionState.hasAnimatedSinceResize = !0),
						(this.currentAnimation = animate(0, animationTarget, {
							...ot,
							onUpdate: (lt) => {
								var ut;
								this.mixTargetDelta(lt), (ut = ot.onUpdate) === null || ut === void 0 || ut.call(ot, lt);
							},
							onComplete: () => {
								var lt;
								(lt = ot.onComplete) === null || lt === void 0 || lt.call(ot), this.completeAnimation();
							},
						})),
						this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
						(this.pendingAnimation = void 0);
				}));
		}
		completeAnimation() {
			var ot;
			this.resumingFrom &&
				((this.resumingFrom.currentAnimation = void 0), (this.resumingFrom.preserveOpacity = void 0)),
				(ot = this.getStack()) === null || ot === void 0 || ot.exitAnimationComplete(),
				(this.resumingFrom = this.currentAnimation = this.animationValues = void 0),
				this.notifyListeners("animationComplete");
		}
		finishAnimation() {
			var ot;
			this.currentAnimation &&
				((ot = this.mixTargetDelta) === null || ot === void 0 || ot.call(this, animationTarget),
				this.currentAnimation.stop()),
				this.completeAnimation();
		}
		applyTransformsToTarget() {
			const ot = this.getLead();
			let { targetWithTransforms: at, target: st, layout: lt, latestValues: ut } = ot;
			if (!(!at || !st || !lt)) {
				if (
					this !== ot &&
					this.layout &&
					lt &&
					shouldAnimatePositionOnly(this.options.animationType, this.layout.actual, lt.actual)
				) {
					st = this.target || createBox();
					const dt = calcLength(this.layout.actual.x);
					(st.x.min = ot.target.x.min), (st.x.max = st.x.min + dt);
					const ct = calcLength(this.layout.actual.y);
					(st.y.min = ot.target.y.min), (st.y.max = st.y.min + ct);
				}
				copyBoxInto(at, st),
					transformBox(at, ut),
					calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, at, ut);
			}
		}
		registerSharedNode(ot, at) {
			var st, lt, ut;
			this.sharedNodes.has(ot) || this.sharedNodes.set(ot, new NodeStack()),
				this.sharedNodes.get(ot).add(at),
				at.promote({
					transition: (st = at.options.initialPromotionConfig) === null || st === void 0 ? void 0 : st.transition,
					preserveFollowOpacity:
						(ut =
							(lt = at.options.initialPromotionConfig) === null || lt === void 0
								? void 0
								: lt.shouldPreserveFollowOpacity) === null || ut === void 0
							? void 0
							: ut.call(lt, at),
				});
		}
		isLead() {
			const ot = this.getStack();
			return ot ? ot.lead === this : !0;
		}
		getLead() {
			var ot;
			const { layoutId: at } = this.options;
			return at ? ((ot = this.getStack()) === null || ot === void 0 ? void 0 : ot.lead) || this : this;
		}
		getPrevLead() {
			var ot;
			const { layoutId: at } = this.options;
			return at ? ((ot = this.getStack()) === null || ot === void 0 ? void 0 : ot.prevLead) : void 0;
		}
		getStack() {
			const { layoutId: ot } = this.options;
			if (ot) return this.root.sharedNodes.get(ot);
		}
		promote({ needsReset: ot, transition: at, preserveFollowOpacity: st } = {}) {
			const lt = this.getStack();
			lt && lt.promote(this, st),
				ot && ((this.projectionDelta = void 0), (this.needsReset = !0)),
				at && this.setOptions({ transition: at });
		}
		relegate() {
			const ot = this.getStack();
			return ot ? ot.relegate(this) : !1;
		}
		resetRotation() {
			const { visualElement: ot } = this.options;
			if (!ot) return;
			let at = !1;
			const st = {};
			for (let lt = 0; lt < transformAxes.length; lt++) {
				const ut = transformAxes[lt],
					dt = "rotate" + ut;
				!ot.getStaticValue(dt) || ((at = !0), (st[dt] = ot.getStaticValue(dt)), ot.setStaticValue(dt, 0));
			}
			if (!!at) {
				ot == null || ot.syncRender();
				for (const lt in st) ot.setStaticValue(lt, st[lt]);
				ot.scheduleRender();
			}
		}
		getProjectionStyles(ot = {}) {
			var at, st, lt;
			const ut = {};
			if (!this.instance || this.isSVG) return ut;
			if (this.isVisible) ut.visibility = "";
			else return { visibility: "hidden" };
			const dt = (at = this.options.visualElement) === null || at === void 0 ? void 0 : at.getProps().transformTemplate;
			if (this.needsReset)
				return (
					(this.needsReset = !1),
					(ut.opacity = ""),
					(ut.pointerEvents = resolveMotionValue(ot.pointerEvents) || ""),
					(ut.transform = dt ? dt(this.latestValues, "") : "none"),
					ut
				);
			const ct = this.getLead();
			if (!this.projectionDelta || !this.layout || !ct.target) {
				const vt = {};
				return (
					this.options.layoutId &&
						((vt.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1),
						(vt.pointerEvents = resolveMotionValue(ot.pointerEvents) || "")),
					this.hasProjected &&
						!hasTransform(this.latestValues) &&
						((vt.transform = dt ? dt({}, "") : "none"), (this.hasProjected = !1)),
					vt
				);
			}
			const ft = ct.animationValues || ct.latestValues;
			this.applyTransformsToTarget(),
				(ut.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, ft)),
				dt && (ut.transform = dt(ft, ut.transform));
			const { x: mt, y: pt } = this.projectionDelta;
			(ut.transformOrigin = `${mt.origin * 100}% ${pt.origin * 100}% 0`),
				ct.animationValues
					? (ut.opacity =
							ct === this
								? (lt = (st = ft.opacity) !== null && st !== void 0 ? st : this.latestValues.opacity) !== null &&
								  lt !== void 0
									? lt
									: 1
								: this.preserveOpacity
								? this.latestValues.opacity
								: ft.opacityExit)
					: (ut.opacity =
							ct === this ? (ft.opacity !== void 0 ? ft.opacity : "") : ft.opacityExit !== void 0 ? ft.opacityExit : 0);
			for (const vt in scaleCorrectors) {
				if (ft[vt] === void 0) continue;
				const { correct: ht, applyTo: gt } = scaleCorrectors[vt],
					yt = ht(ft[vt], ct);
				if (gt) {
					const xt = gt.length;
					for (let St = 0; St < xt; St++) ut[gt[St]] = yt;
				} else ut[vt] = yt;
			}
			return (
				this.options.layoutId && (ut.pointerEvents = ct === this ? resolveMotionValue(ot.pointerEvents) || "" : "none"),
				ut
			);
		}
		clearSnapshot() {
			this.resumeFrom = this.snapshot = void 0;
		}
		resetTree() {
			this.root.nodes.forEach((ot) => {
				var at;
				return (at = ot.currentAnimation) === null || at === void 0 ? void 0 : at.stop();
			}),
				this.root.nodes.forEach(clearMeasurements),
				this.root.sharedNodes.clear();
		}
	};
}
function updateLayout(_) {
	_.updateLayout();
}
function notifyLayoutUpdate(_) {
	var et, tt, nt;
	const rt = ((et = _.resumeFrom) === null || et === void 0 ? void 0 : et.snapshot) || _.snapshot;
	if (_.isLead() && _.layout && rt && _.hasListeners("didUpdate")) {
		const { actual: it, measured: ot } = _.layout,
			{ animationType: at } = _.options;
		at === "size"
			? eachAxis((ct) => {
					const ft = rt.isShared ? rt.measured[ct] : rt.layout[ct],
						mt = calcLength(ft);
					(ft.min = it[ct].min), (ft.max = ft.min + mt);
			  })
			: shouldAnimatePositionOnly(at, rt.layout, it) &&
			  eachAxis((ct) => {
					const ft = rt.isShared ? rt.measured[ct] : rt.layout[ct],
						mt = calcLength(it[ct]);
					ft.max = ft.min + mt;
			  });
		const st = createDelta();
		calcBoxDelta(st, it, rt.layout);
		const lt = createDelta();
		rt.isShared ? calcBoxDelta(lt, _.applyTransform(ot, !0), rt.measured) : calcBoxDelta(lt, it, rt.layout);
		const ut = !isDeltaZero(st);
		let dt = !1;
		if (
			!_.resumeFrom &&
			((_.relativeParent = _.getClosestProjectingParent()), _.relativeParent && !_.relativeParent.resumeFrom)
		) {
			const { snapshot: ct, layout: ft } = _.relativeParent;
			if (ct && ft) {
				const mt = createBox();
				calcRelativePosition(mt, rt.layout, ct.layout);
				const pt = createBox();
				calcRelativePosition(pt, it, ft.actual), boxEquals(mt, pt) || (dt = !0);
			}
		}
		_.notifyListeners("didUpdate", {
			layout: it,
			snapshot: rt,
			delta: lt,
			layoutDelta: st,
			hasLayoutChanged: ut,
			hasRelativeTargetChanged: dt,
		});
	} else _.isLead() && ((nt = (tt = _.options).onExitComplete) === null || nt === void 0 || nt.call(tt));
	_.options.transition = void 0;
}
function clearSnapshot(_) {
	_.clearSnapshot();
}
function clearMeasurements(_) {
	_.clearMeasurements();
}
function resetTransformStyle(_) {
	const { visualElement: et } = _.options;
	et != null && et.getProps().onBeforeLayoutMeasure && et.notifyBeforeLayoutMeasure(), _.resetTransform();
}
function finishAnimation(_) {
	_.finishAnimation(), (_.targetDelta = _.relativeTarget = _.target = void 0);
}
function resolveTargetDelta(_) {
	_.resolveTargetDelta();
}
function calcProjection(_) {
	_.calcProjection();
}
function resetRotation(_) {
	_.resetRotation();
}
function removeLeadSnapshots(_) {
	_.removeLeadSnapshot();
}
function mixAxisDelta(_, et, tt) {
	(_.translate = mix(et.translate, 0, tt)),
		(_.scale = mix(et.scale, 1, tt)),
		(_.origin = et.origin),
		(_.originPoint = et.originPoint);
}
function mixAxis(_, et, tt, nt) {
	(_.min = mix(et.min, tt.min, nt)), (_.max = mix(et.max, tt.max, nt));
}
function mixBox(_, et, tt, nt) {
	mixAxis(_.x, et.x, tt.x, nt), mixAxis(_.y, et.y, tt.y, nt);
}
function hasOpacityCrossfade(_) {
	return _.animationValues && _.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
function mountNodeEarly(_, et) {
	let tt = _.root;
	for (let it = _.path.length - 1; it >= 0; it--)
		if (Boolean(_.path[it].instance)) {
			tt = _.path[it];
			break;
		}
	const rt = (tt && tt !== _.root ? tt.instance : document).querySelector(`[data-projection-id="${et}"]`);
	rt && _.mount(rt, !0);
}
function roundAxis(_) {
	(_.min = Math.round(_.min)), (_.max = Math.round(_.max));
}
function roundBox(_) {
	roundAxis(_.x), roundAxis(_.y);
}
function shouldAnimatePositionOnly(_, et, tt) {
	return _ === "position" || (_ === "preserve-aspect" && !isCloseTo(aspectRatio(et), aspectRatio(tt)));
}
const DocumentProjectionNode = createProjectionNode({
		attachResizeListener: (_, et) => addDomEvent(_, "resize", et),
		measureScroll: () => ({
			x: document.documentElement.scrollLeft || document.body.scrollLeft,
			y: document.documentElement.scrollTop || document.body.scrollTop,
		}),
		checkIsScrollRoot: () => !0,
	}),
	rootProjectionNode = { current: void 0 },
	HTMLProjectionNode = createProjectionNode({
		measureScroll: (_) => ({ x: _.scrollLeft, y: _.scrollTop }),
		defaultParent: () => {
			if (!rootProjectionNode.current) {
				const _ = new DocumentProjectionNode(0, {});
				_.mount(window), _.setOptions({ layoutScroll: !0 }), (rootProjectionNode.current = _);
			}
			return rootProjectionNode.current;
		},
		resetTransform: (_, et) => {
			_.style.transform = et !== void 0 ? et : "none";
		},
		checkIsScrollRoot: (_) => Boolean(window.getComputedStyle(_).position === "fixed"),
	}),
	featureBundle = { ...animations, ...gestureAnimations, ...drag, ...layoutFeatures },
	motion = createMotionProxy((_, et) =>
		createDomMotionConfig(_, et, featureBundle, createDomVisualElement, HTMLProjectionNode)
	);
function useIsMounted() {
	const _ = react.exports.useRef(!1);
	return (
		useIsomorphicLayoutEffect$1(
			() => (
				(_.current = !0),
				() => {
					_.current = !1;
				}
			),
			[]
		),
		_
	);
}
function useForceUpdate() {
	const _ = useIsMounted(),
		[et, tt] = react.exports.useState(0),
		nt = react.exports.useCallback(() => {
			_.current && tt(et + 1);
		}, [et]);
	return [react.exports.useCallback(() => sync.postRender(nt), [nt]), et];
}
class PopChildMeasure extends react.exports.Component {
	getSnapshotBeforeUpdate(et) {
		const tt = this.props.childRef.current;
		if (tt && et.isPresent && !this.props.isPresent) {
			const nt = this.props.sizeRef.current;
			(nt.height = tt.offsetHeight || 0),
				(nt.width = tt.offsetWidth || 0),
				(nt.top = tt.offsetTop),
				(nt.left = tt.offsetLeft);
		}
		return null;
	}
	componentDidUpdate() {}
	render() {
		return this.props.children;
	}
}
function PopChild({ children: _, isPresent: et }) {
	const tt = react.exports.useId(),
		nt = react.exports.useRef(null),
		rt = react.exports.useRef({ width: 0, height: 0, top: 0, left: 0 });
	return (
		react.exports.useInsertionEffect(() => {
			const { width: it, height: ot, top: at, left: st } = rt.current;
			if (et || !nt.current || !it || !ot) return;
			nt.current.dataset.motionPopId = tt;
			const lt = document.createElement("style");
			return (
				document.head.appendChild(lt),
				lt.sheet &&
					lt.sheet.insertRule(`
          [data-motion-pop-id="${tt}"] {
            position: absolute !important;
            width: ${it}px !important;
            height: ${ot}px !important;
            top: ${at}px !important;
            left: ${st}px !important;
          }
        `),
				() => {
					document.head.removeChild(lt);
				}
			);
		}, [et]),
		jsx(PopChildMeasure, {
			isPresent: et,
			childRef: nt,
			sizeRef: rt,
			children: react.exports.cloneElement(_, { ref: nt }),
		})
	);
}
const PresenceChild = ({
	children: _,
	initial: et,
	isPresent: tt,
	onExitComplete: nt,
	custom: rt,
	presenceAffectsLayout: it,
	mode: ot,
}) => {
	const at = useConstant(newChildrenMap),
		st = react.exports.useId(),
		lt = react.exports.useMemo(
			() => ({
				id: st,
				initial: et,
				isPresent: tt,
				custom: rt,
				onExitComplete: (ut) => {
					at.set(ut, !0);
					for (const dt of at.values()) if (!dt) return;
					nt && nt();
				},
				register: (ut) => (at.set(ut, !1), () => at.delete(ut)),
			}),
			it ? void 0 : [tt]
		);
	return (
		react.exports.useMemo(() => {
			at.forEach((ut, dt) => at.set(dt, !1));
		}, [tt]),
		react.exports.useEffect(() => {
			!tt && !at.size && nt && nt();
		}, [tt]),
		ot === "popLayout" && (_ = jsx(PopChild, { isPresent: tt, children: _ })),
		jsx(PresenceContext.Provider, { value: lt, children: _ })
	);
};
function newChildrenMap() {
	return new Map();
}
const getChildKey = (_) => _.key || "";
function updateChildLookup(_, et) {
	_.forEach((tt) => {
		const nt = getChildKey(tt);
		et.set(nt, tt);
	});
}
function onlyElements(_) {
	const et = [];
	return (
		react.exports.Children.forEach(_, (tt) => {
			react.exports.isValidElement(tt) && et.push(tt);
		}),
		et
	);
}
const AnimatePresence = ({
	children: _,
	custom: et,
	initial: tt = !0,
	onExitComplete: nt,
	exitBeforeEnter: rt,
	presenceAffectsLayout: it = !0,
	mode: ot = "sync",
}) => {
	rt && ((ot = "wait"), warnOnce(!1, "Replace exitBeforeEnter with mode='wait'"));
	let [at] = useForceUpdate();
	const st = react.exports.useContext(LayoutGroupContext).forceRender;
	st && (at = st);
	const lt = useIsMounted(),
		ut = onlyElements(_);
	let dt = ut;
	const ct = new Set(),
		ft = react.exports.useRef(dt),
		mt = react.exports.useRef(new Map()).current,
		pt = react.exports.useRef(!0);
	if (
		(useIsomorphicLayoutEffect$1(() => {
			(pt.current = !1), updateChildLookup(ut, mt), (ft.current = dt);
		}),
		useUnmountEffect$1(() => {
			(pt.current = !0), mt.clear(), ct.clear();
		}),
		pt.current)
	)
		return jsx(Fragment, {
			children: dt.map((yt) =>
				jsx(
					PresenceChild,
					{ isPresent: !0, initial: tt ? void 0 : !1, presenceAffectsLayout: it, mode: ot, children: yt },
					getChildKey(yt)
				)
			),
		});
	dt = [...dt];
	const vt = ft.current.map(getChildKey),
		ht = ut.map(getChildKey),
		gt = vt.length;
	for (let yt = 0; yt < gt; yt++) {
		const xt = vt[yt];
		ht.indexOf(xt) === -1 && ct.add(xt);
	}
	return (
		ot === "wait" && ct.size && (dt = []),
		ct.forEach((yt) => {
			if (ht.indexOf(yt) !== -1) return;
			const xt = mt.get(yt);
			if (!xt) return;
			const St = vt.indexOf(yt),
				wt = () => {
					mt.delete(yt), ct.delete(yt);
					const Ct = ft.current.findIndex((Et) => Et.key === yt);
					if ((ft.current.splice(Ct, 1), !ct.size)) {
						if (((ft.current = ut), lt.current === !1)) return;
						at(), nt && nt();
					}
				};
			dt.splice(
				St,
				0,
				jsx(
					PresenceChild,
					{ isPresent: !1, onExitComplete: wt, custom: et, presenceAffectsLayout: it, mode: ot, children: xt },
					getChildKey(xt)
				)
			);
		}),
		(dt = dt.map((yt) => {
			const xt = yt.key;
			return ct.has(xt)
				? yt
				: jsx(PresenceChild, { isPresent: !0, presenceAffectsLayout: it, mode: ot, children: yt }, getChildKey(yt));
		})),
		env !== "production" &&
			ot === "wait" &&
			dt.length > 1 &&
			console.warn(
				`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`
			),
		jsx(Fragment, { children: ct.size ? dt : dt.map((yt) => react.exports.cloneElement(yt)) })
	);
};
var cx$9 = (..._) => _.filter(Boolean).join(" ");
function isDev() {
	return !1;
}
var warn = (_) => {
		const { condition: et, message: tt } = _;
		et && isDev() && console.warn(tt);
	},
	TransitionEasings = {
		ease: [0.25, 0.1, 0.25, 1],
		easeIn: [0.4, 0, 1, 1],
		easeOut: [0, 0, 0.2, 1],
		easeInOut: [0.4, 0, 0.2, 1],
	},
	TransitionVariants = {
		scale: { enter: { scale: 1 }, exit: { scale: 0.95 } },
		fade: { enter: { opacity: 1 }, exit: { opacity: 0 } },
		pushLeft: { enter: { x: "100%" }, exit: { x: "-30%" } },
		pushRight: { enter: { x: "-100%" }, exit: { x: "30%" } },
		pushUp: { enter: { y: "100%" }, exit: { y: "-30%" } },
		pushDown: { enter: { y: "-100%" }, exit: { y: "30%" } },
		slideLeft: {
			position: { left: 0, top: 0, bottom: 0, width: "100%" },
			enter: { x: 0, y: 0 },
			exit: { x: "-100%", y: 0 },
		},
		slideRight: {
			position: { right: 0, top: 0, bottom: 0, width: "100%" },
			enter: { x: 0, y: 0 },
			exit: { x: "100%", y: 0 },
		},
		slideUp: {
			position: { top: 0, left: 0, right: 0, maxWidth: "100vw" },
			enter: { x: 0, y: 0 },
			exit: { x: 0, y: "-100%" },
		},
		slideDown: {
			position: { bottom: 0, left: 0, right: 0, maxWidth: "100vw" },
			enter: { x: 0, y: 0 },
			exit: { x: 0, y: "100%" },
		},
	};
function slideTransition(_) {
	var tt;
	switch ((tt = _ == null ? void 0 : _.direction) != null ? tt : "right") {
		case "right":
			return TransitionVariants.slideRight;
		case "left":
			return TransitionVariants.slideLeft;
		case "bottom":
			return TransitionVariants.slideDown;
		case "top":
			return TransitionVariants.slideUp;
		default:
			return TransitionVariants.slideRight;
	}
}
var TransitionDefaults = {
		enter: { duration: 0.2, ease: TransitionEasings.easeOut },
		exit: { duration: 0.1, ease: TransitionEasings.easeIn },
	},
	withDelay = {
		enter: (_, et) => ({ ..._, delay: typeof et == "number" ? et : et == null ? void 0 : et.enter }),
		exit: (_, et) => ({ ..._, delay: typeof et == "number" ? et : et == null ? void 0 : et.exit }),
	},
	isNumeric = (_) => _ != null && parseInt(_.toString(), 10) > 0,
	defaultTransitions = {
		exit: {
			height: { duration: 0.2, ease: TransitionEasings.ease },
			opacity: { duration: 0.3, ease: TransitionEasings.ease },
		},
		enter: {
			height: { duration: 0.3, ease: TransitionEasings.ease },
			opacity: { duration: 0.4, ease: TransitionEasings.ease },
		},
	},
	variants$1 = {
		exit: ({ animateOpacity: _, startingHeight: et, transition: tt, transitionEnd: nt, delay: rt }) => {
			var it;
			return {
				...(_ && { opacity: isNumeric(et) ? 1 : 0 }),
				height: et,
				transitionEnd: nt == null ? void 0 : nt.exit,
				transition: (it = tt == null ? void 0 : tt.exit) != null ? it : withDelay.exit(defaultTransitions.exit, rt),
			};
		},
		enter: ({ animateOpacity: _, endingHeight: et, transition: tt, transitionEnd: nt, delay: rt }) => {
			var it;
			return {
				...(_ && { opacity: 1 }),
				height: et,
				transitionEnd: nt == null ? void 0 : nt.enter,
				transition: (it = tt == null ? void 0 : tt.enter) != null ? it : withDelay.enter(defaultTransitions.enter, rt),
			};
		},
	},
	Collapse = react.exports.forwardRef((_, et) => {
		const {
				in: tt,
				unmountOnExit: nt,
				animateOpacity: rt = !0,
				startingHeight: it = 0,
				endingHeight: ot = "auto",
				style: at,
				className: st,
				transition: lt,
				transitionEnd: ut,
				...dt
			} = _,
			[ct, ft] = react.exports.useState(!1);
		react.exports.useEffect(() => {
			const gt = setTimeout(() => {
				ft(!0);
			});
			return () => clearTimeout(gt);
		}, []),
			warn({
				condition: Boolean(it > 0 && nt),
				message: "startingHeight and unmountOnExit are mutually exclusive. You can't use them together",
			});
		const mt = parseFloat(it.toString()) > 0,
			pt = {
				startingHeight: it,
				endingHeight: ot,
				animateOpacity: rt,
				transition: ct ? lt : { enter: { duration: 0 } },
				transitionEnd: {
					enter: ut == null ? void 0 : ut.enter,
					exit: nt
						? ut == null
							? void 0
							: ut.exit
						: { ...(ut == null ? void 0 : ut.exit), display: mt ? "block" : "none" },
				},
			},
			vt = nt ? tt : !0,
			ht = tt || nt ? "enter" : "exit";
		return jsx(AnimatePresence, {
			initial: !1,
			custom: pt,
			children:
				vt &&
				React$1.createElement(motion.div, {
					ref: et,
					...dt,
					className: cx$9("chakra-collapse", st),
					style: { overflow: "hidden", display: "block", ...at },
					custom: pt,
					variants: variants$1,
					initial: nt ? "exit" : !1,
					animate: ht,
					exit: "exit",
				}),
		});
	});
Collapse.displayName = "Collapse";
var variants2$1 = {
		enter: ({ transition: _, transitionEnd: et, delay: tt } = {}) => {
			var nt;
			return {
				opacity: 1,
				transition: (nt = _ == null ? void 0 : _.enter) != null ? nt : withDelay.enter(TransitionDefaults.enter, tt),
				transitionEnd: et == null ? void 0 : et.enter,
			};
		},
		exit: ({ transition: _, transitionEnd: et, delay: tt } = {}) => {
			var nt;
			return {
				opacity: 0,
				transition: (nt = _ == null ? void 0 : _.exit) != null ? nt : withDelay.exit(TransitionDefaults.exit, tt),
				transitionEnd: et == null ? void 0 : et.exit,
			};
		},
	},
	fadeConfig = { initial: "exit", animate: "enter", exit: "exit", variants: variants2$1 },
	Fade = react.exports.forwardRef(function (et, tt) {
		const { unmountOnExit: nt, in: rt, className: it, transition: ot, transitionEnd: at, delay: st, ...lt } = et,
			ut = rt || nt ? "enter" : "exit",
			dt = nt ? rt && nt : !0,
			ct = { transition: ot, transitionEnd: at, delay: st };
		return jsx(AnimatePresence, {
			custom: ct,
			children:
				dt &&
				React$1.createElement(motion.div, {
					ref: tt,
					className: cx$9("chakra-fade", it),
					custom: ct,
					...fadeConfig,
					animate: ut,
					...lt,
				}),
		});
	});
Fade.displayName = "Fade";
var variants3$1 = {
		exit: ({ reverse: _, initialScale: et, transition: tt, transitionEnd: nt, delay: rt }) => {
			var it;
			return {
				opacity: 0,
				...(_
					? { scale: et, transitionEnd: nt == null ? void 0 : nt.exit }
					: { transitionEnd: { scale: et, ...(nt == null ? void 0 : nt.exit) } }),
				transition: (it = tt == null ? void 0 : tt.exit) != null ? it : withDelay.exit(TransitionDefaults.exit, rt),
			};
		},
		enter: ({ transitionEnd: _, transition: et, delay: tt }) => {
			var nt;
			return {
				opacity: 1,
				scale: 1,
				transition: (nt = et == null ? void 0 : et.enter) != null ? nt : withDelay.enter(TransitionDefaults.enter, tt),
				transitionEnd: _ == null ? void 0 : _.enter,
			};
		},
	},
	scaleFadeConfig = { initial: "exit", animate: "enter", exit: "exit", variants: variants3$1 },
	ScaleFade = react.exports.forwardRef(function (et, tt) {
		const {
				unmountOnExit: nt,
				in: rt,
				reverse: it = !0,
				initialScale: ot = 0.95,
				className: at,
				transition: st,
				transitionEnd: lt,
				delay: ut,
				...dt
			} = et,
			ct = nt ? rt && nt : !0,
			ft = rt || nt ? "enter" : "exit",
			mt = { initialScale: ot, reverse: it, transition: st, transitionEnd: lt, delay: ut };
		return jsx(AnimatePresence, {
			custom: mt,
			children:
				ct &&
				React$1.createElement(motion.div, {
					ref: tt,
					className: cx$9("chakra-offset-slide", at),
					...scaleFadeConfig,
					animate: ft,
					custom: mt,
					...dt,
				}),
		});
	});
ScaleFade.displayName = "ScaleFade";
var defaultTransition = {
		exit: { duration: 0.15, ease: TransitionEasings.easeInOut },
		enter: { type: "spring", damping: 25, stiffness: 180 },
	},
	variants4$1 = {
		exit: ({ direction: _, transition: et, transitionEnd: tt, delay: nt }) => {
			var it;
			const { exit: rt } = slideTransition({ direction: _ });
			return {
				...rt,
				transition: (it = et == null ? void 0 : et.exit) != null ? it : withDelay.exit(defaultTransition.exit, nt),
				transitionEnd: tt == null ? void 0 : tt.exit,
			};
		},
		enter: ({ direction: _, transitionEnd: et, transition: tt, delay: nt }) => {
			var it;
			const { enter: rt } = slideTransition({ direction: _ });
			return {
				...rt,
				transition: (it = tt == null ? void 0 : tt.enter) != null ? it : withDelay.enter(defaultTransition.enter, nt),
				transitionEnd: et == null ? void 0 : et.enter,
			};
		},
	},
	Slide = react.exports.forwardRef(function (et, tt) {
		const {
				direction: nt = "right",
				style: rt,
				unmountOnExit: it,
				in: ot,
				className: at,
				transition: st,
				transitionEnd: lt,
				delay: ut,
				...dt
			} = et,
			ct = slideTransition({ direction: nt }),
			ft = Object.assign({ position: "fixed" }, ct.position, rt),
			mt = it ? ot && it : !0,
			pt = ot || it ? "enter" : "exit",
			vt = { transitionEnd: lt, transition: st, direction: nt, delay: ut };
		return jsx(AnimatePresence, {
			custom: vt,
			children:
				mt &&
				React$1.createElement(motion.div, {
					...dt,
					ref: tt,
					initial: "exit",
					className: cx$9("chakra-slide", at),
					animate: pt,
					exit: "exit",
					custom: vt,
					variants: variants4$1,
					style: ft,
				}),
		});
	});
Slide.displayName = "Slide";
var variants5$1 = {
		initial: ({ offsetX: _, offsetY: et, transition: tt, transitionEnd: nt, delay: rt }) => {
			var it;
			return {
				opacity: 0,
				x: _,
				y: et,
				transition: (it = tt == null ? void 0 : tt.exit) != null ? it : withDelay.exit(TransitionDefaults.exit, rt),
				transitionEnd: nt == null ? void 0 : nt.exit,
			};
		},
		enter: ({ transition: _, transitionEnd: et, delay: tt }) => {
			var nt;
			return {
				opacity: 1,
				x: 0,
				y: 0,
				transition: (nt = _ == null ? void 0 : _.enter) != null ? nt : withDelay.enter(TransitionDefaults.enter, tt),
				transitionEnd: et == null ? void 0 : et.enter,
			};
		},
		exit: ({ offsetY: _, offsetX: et, transition: tt, transitionEnd: nt, reverse: rt, delay: it }) => {
			var at;
			const ot = { x: et, y: _ };
			return {
				opacity: 0,
				transition: (at = tt == null ? void 0 : tt.exit) != null ? at : withDelay.exit(TransitionDefaults.exit, it),
				...(rt
					? { ...ot, transitionEnd: nt == null ? void 0 : nt.exit }
					: { transitionEnd: { ...ot, ...(nt == null ? void 0 : nt.exit) } }),
			};
		},
	},
	slideFadeConfig = { initial: "initial", animate: "enter", exit: "exit", variants: variants5$1 },
	SlideFade = react.exports.forwardRef(function (et, tt) {
		const {
				unmountOnExit: nt,
				in: rt,
				reverse: it = !0,
				className: ot,
				offsetX: at = 0,
				offsetY: st = 8,
				transition: lt,
				transitionEnd: ut,
				delay: dt,
				...ct
			} = et,
			ft = nt ? rt && nt : !0,
			mt = rt || nt ? "enter" : "exit",
			pt = { offsetX: at, offsetY: st, reverse: it, transition: lt, transitionEnd: ut, delay: dt };
		return jsx(AnimatePresence, {
			custom: pt,
			children:
				ft &&
				React$1.createElement(motion.div, {
					ref: tt,
					className: cx$9("chakra-offset-slide", ot),
					custom: pt,
					...slideFadeConfig,
					animate: mt,
					...ct,
				}),
		});
	});
SlideFade.displayName = "SlideFade";
var cx$8 = (..._) => _.filter(Boolean).join(" "),
	spin = keyframes$2({ "0%": { transform: "rotate(0deg)" }, "100%": { transform: "rotate(360deg)" } }),
	Spinner = forwardRef((_, et) => {
		const tt = useStyleConfig("Spinner", _),
			{
				label: nt = "Loading...",
				thickness: rt = "2px",
				speed: it = "0.45s",
				emptyColor: ot = "transparent",
				className: at,
				...st
			} = omitThemingProps(_),
			lt = cx$8("chakra-spinner", at),
			ut = {
				display: "inline-block",
				borderColor: "currentColor",
				borderStyle: "solid",
				borderRadius: "99999px",
				borderWidth: rt,
				borderBottomColor: ot,
				borderLeftColor: ot,
				animation: `${spin} ${it} linear infinite`,
				...tt,
			};
		return React$1.createElement(
			chakra.div,
			{ ref: et, __css: ut, className: lt, ...st },
			nt && React$1.createElement(chakra.span, { srOnly: !0 }, nt)
		);
	});
Spinner.displayName = "Spinner";
var cx$7 = (..._) => _.filter(Boolean).join(" ");
function CheckIcon$2(_) {
	return jsx(Icon, {
		viewBox: "0 0 24 24",
		..._,
		children: jsx("path", {
			fill: "currentColor",
			d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z",
		}),
	});
}
function InfoIcon(_) {
	return jsx(Icon, {
		viewBox: "0 0 24 24",
		..._,
		children: jsx("path", {
			fill: "currentColor",
			d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z",
		}),
	});
}
function WarningIcon(_) {
	return jsx(Icon, {
		viewBox: "0 0 24 24",
		..._,
		children: jsx("path", {
			fill: "currentColor",
			d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z",
		}),
	});
}
var [AlertProvider, useAlertContext] = createContext({
		name: "AlertContext",
		hookName: "useAlertContext",
		providerName: "<Alert />",
	}),
	[AlertStylesProvider, useAlertStyles] = createContext({
		name: "AlertStylesContext",
		hookName: "useAlertStyles",
		providerName: "<Alert />",
	}),
	STATUSES = {
		info: { icon: InfoIcon, colorScheme: "blue" },
		warning: { icon: WarningIcon, colorScheme: "orange" },
		success: { icon: CheckIcon$2, colorScheme: "green" },
		error: { icon: WarningIcon, colorScheme: "red" },
		loading: { icon: Spinner, colorScheme: "blue" },
	};
function getStatusColorScheme(_) {
	return STATUSES[_].colorScheme;
}
function getStatusIcon(_) {
	return STATUSES[_].icon;
}
var Alert = forwardRef(function (et, tt) {
	var lt;
	const { status: nt = "info", addRole: rt = !0, ...it } = omitThemingProps(et),
		ot = (lt = et.colorScheme) != null ? lt : getStatusColorScheme(nt),
		at = useMultiStyleConfig("Alert", { ...et, colorScheme: ot }),
		st = {
			width: "100%",
			display: "flex",
			alignItems: "center",
			position: "relative",
			overflow: "hidden",
			...at.container,
		};
	return React$1.createElement(
		AlertProvider,
		{ value: { status: nt } },
		React$1.createElement(
			AlertStylesProvider,
			{ value: at },
			React$1.createElement(chakra.div, {
				role: rt ? "alert" : void 0,
				ref: tt,
				...it,
				className: cx$7("chakra-alert", et.className),
				__css: st,
			})
		)
	);
});
Alert.displayName = "Alert";
var AlertDescription = forwardRef(function (et, tt) {
	const nt = useAlertStyles(),
		rt = { display: "inline", ...nt.description };
	return React$1.createElement(chakra.div, {
		ref: tt,
		...et,
		className: cx$7("chakra-alert__desc", et.className),
		__css: rt,
	});
});
AlertDescription.displayName = "AlertDescription";
function AlertIcon(_) {
	const { status: et } = useAlertContext(),
		tt = getStatusIcon(et),
		nt = useAlertStyles(),
		rt = et === "loading" ? nt.spinner : nt.icon;
	return React$1.createElement(
		chakra.span,
		{ display: "inherit", ..._, className: cx$7("chakra-alert__icon", _.className), __css: rt },
		_.children || jsx(tt, { h: "100%", w: "100%" })
	);
}
AlertIcon.displayName = "AlertIcon";
var AlertTitle = forwardRef(function (et, tt) {
	const nt = useAlertStyles();
	return React$1.createElement(chakra.div, {
		ref: tt,
		...et,
		className: cx$7("chakra-alert__title", et.className),
		__css: nt.title,
	});
});
AlertTitle.displayName = "AlertTitle";
function omit$1(_, et = []) {
	const tt = Object.assign({}, _);
	for (const nt of et) nt in tt && delete tt[nt];
	return tt;
}
function useImage(_) {
	const {
			loading: et,
			src: tt,
			srcSet: nt,
			onLoad: rt,
			onError: it,
			crossOrigin: ot,
			sizes: at,
			ignoreFallback: st,
		} = _,
		[lt, ut] = react.exports.useState("pending");
	react.exports.useEffect(() => {
		ut(tt ? "loading" : "pending");
	}, [tt]);
	const dt = react.exports.useRef(),
		ct = react.exports.useCallback(() => {
			if (!tt) return;
			ft();
			const mt = new Image();
			(mt.src = tt),
				ot && (mt.crossOrigin = ot),
				nt && (mt.srcset = nt),
				at && (mt.sizes = at),
				et && (mt.loading = et),
				(mt.onload = (pt) => {
					ft(), ut("loaded"), rt == null || rt(pt);
				}),
				(mt.onerror = (pt) => {
					ft(), ut("failed"), it == null || it(pt);
				}),
				(dt.current = mt);
		}, [tt, ot, nt, at, rt, it, et]),
		ft = () => {
			dt.current && ((dt.current.onload = null), (dt.current.onerror = null), (dt.current = null));
		};
	return (
		useSafeLayoutEffect$2(() => {
			if (!st)
				return (
					lt === "loading" && ct(),
					() => {
						ft();
					}
				);
		}, [lt, ct, st]),
		st ? "loaded" : lt
	);
}
var shouldShowFallbackImage = (_, et) =>
		(_ !== "loaded" && et === "beforeLoadOrError") || (_ === "failed" && et === "onError"),
	NativeImage = forwardRef(function (et, tt) {
		const { htmlWidth: nt, htmlHeight: rt, alt: it, ...ot } = et;
		return jsx("img", { width: nt, height: rt, ref: tt, alt: it, ...ot });
	});
NativeImage.displayName = "NativeImage";
var Image2 = forwardRef(function (et, tt) {
	const {
			fallbackSrc: nt,
			fallback: rt,
			src: it,
			srcSet: ot,
			align: at,
			fit: st,
			loading: lt,
			ignoreFallback: ut,
			crossOrigin: dt,
			fallbackStrategy: ct = "beforeLoadOrError",
			referrerPolicy: ft,
			...mt
		} = et,
		pt = nt !== void 0 || rt !== void 0,
		vt = lt != null || ut || !pt,
		ht = useImage({ ...et, ignoreFallback: vt }),
		gt = shouldShowFallbackImage(ht, ct),
		yt = { ref: tt, objectFit: st, objectPosition: at, ...(vt ? mt : omit$1(mt, ["onError", "onLoad"])) };
	return gt
		? rt ||
				React$1.createElement(chakra.img, { as: NativeImage, className: "chakra-image__placeholder", src: nt, ...yt })
		: React$1.createElement(chakra.img, {
				as: NativeImage,
				src: it,
				srcSet: ot,
				crossOrigin: dt,
				loading: lt,
				referrerPolicy: ft,
				className: "chakra-image",
				...yt,
		  });
});
Image2.displayName = "Image";
forwardRef((_, et) => React$1.createElement(chakra.img, { ref: et, as: NativeImage, className: "chakra-image", ..._ }));
var __create = Object.create,
	__defProp$1 = Object.defineProperty,
	__getOwnPropDesc = Object.getOwnPropertyDescriptor,
	__getOwnPropNames = Object.getOwnPropertyNames,
	__getProtoOf = Object.getPrototypeOf,
	__hasOwnProp$1 = Object.prototype.hasOwnProperty,
	__commonJS = (_, et) =>
		function () {
			return et || (0, _[__getOwnPropNames(_)[0]])((et = { exports: {} }).exports, et), et.exports;
		},
	__copyProps = (_, et, tt, nt) => {
		if ((et && typeof et == "object") || typeof et == "function")
			for (let rt of __getOwnPropNames(et))
				!__hasOwnProp$1.call(_, rt) &&
					rt !== tt &&
					__defProp$1(_, rt, { get: () => et[rt], enumerable: !(nt = __getOwnPropDesc(et, rt)) || nt.enumerable });
		return _;
	},
	__toESM = (_, et, tt) => (
		(tt = _ != null ? __create(__getProtoOf(_)) : {}),
		__copyProps(et || !_ || !_.__esModule ? __defProp$1(tt, "default", { value: _, enumerable: !0 }) : tt, _)
	),
	require_react_production_min = __commonJS({
		"../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.production.min.js"(_) {
			var et = Symbol.for("react.element"),
				tt = Symbol.for("react.portal"),
				nt = Symbol.for("react.fragment"),
				rt = Symbol.for("react.strict_mode"),
				it = Symbol.for("react.profiler"),
				ot = Symbol.for("react.provider"),
				at = Symbol.for("react.context"),
				st = Symbol.for("react.forward_ref"),
				lt = Symbol.for("react.suspense"),
				ut = Symbol.for("react.memo"),
				dt = Symbol.for("react.lazy"),
				ct = Symbol.iterator;
			function ft(bt) {
				return bt === null || typeof bt != "object"
					? null
					: ((bt = (ct && bt[ct]) || bt["@@iterator"]), typeof bt == "function" ? bt : null);
			}
			var mt = {
					isMounted: function () {
						return !1;
					},
					enqueueForceUpdate: function () {},
					enqueueReplaceState: function () {},
					enqueueSetState: function () {},
				},
				pt = Object.assign,
				vt = {};
			function ht(bt, kt, zt) {
				(this.props = bt), (this.context = kt), (this.refs = vt), (this.updater = zt || mt);
			}
			(ht.prototype.isReactComponent = {}),
				(ht.prototype.setState = function (bt, kt) {
					if (typeof bt != "object" && typeof bt != "function" && bt != null)
						throw Error(
							"setState(...): takes an object of state variables to update or a function which returns an object of state variables."
						);
					this.updater.enqueueSetState(this, bt, kt, "setState");
				}),
				(ht.prototype.forceUpdate = function (bt) {
					this.updater.enqueueForceUpdate(this, bt, "forceUpdate");
				});
			function gt() {}
			gt.prototype = ht.prototype;
			function yt(bt, kt, zt) {
				(this.props = bt), (this.context = kt), (this.refs = vt), (this.updater = zt || mt);
			}
			var xt = (yt.prototype = new gt());
			(xt.constructor = yt), pt(xt, ht.prototype), (xt.isPureReactComponent = !0);
			var St = Array.isArray,
				wt = Object.prototype.hasOwnProperty,
				Ct = { current: null },
				Et = { key: !0, ref: !0, __self: !0, __source: !0 };
			function _t(bt, kt, zt) {
				var Vt,
					Yt = {},
					Ut = null,
					qt = null;
				if (kt != null)
					for (Vt in (kt.ref !== void 0 && (qt = kt.ref), kt.key !== void 0 && (Ut = "" + kt.key), kt))
						wt.call(kt, Vt) && !Et.hasOwnProperty(Vt) && (Yt[Vt] = kt[Vt]);
				var Wt = arguments.length - 2;
				if (Wt === 1) Yt.children = zt;
				else if (1 < Wt) {
					for (var Xt = Array(Wt), Zt = 0; Zt < Wt; Zt++) Xt[Zt] = arguments[Zt + 2];
					Yt.children = Xt;
				}
				if (bt && bt.defaultProps) for (Vt in ((Wt = bt.defaultProps), Wt)) Yt[Vt] === void 0 && (Yt[Vt] = Wt[Vt]);
				return { $$typeof: et, type: bt, key: Ut, ref: qt, props: Yt, _owner: Ct.current };
			}
			function $t(bt, kt) {
				return { $$typeof: et, type: bt.type, key: kt, ref: bt.ref, props: bt.props, _owner: bt._owner };
			}
			function At(bt) {
				return typeof bt == "object" && bt !== null && bt.$$typeof === et;
			}
			function Lt(bt) {
				var kt = { "=": "=0", ":": "=2" };
				return (
					"$" +
					bt.replace(/[=:]/g, function (zt) {
						return kt[zt];
					})
				);
			}
			var Nt = /\/+/g;
			function Ft(bt, kt) {
				return typeof bt == "object" && bt !== null && bt.key != null ? Lt("" + bt.key) : kt.toString(36);
			}
			function Gt(bt, kt, zt, Vt, Yt) {
				var Ut = typeof bt;
				(Ut === "undefined" || Ut === "boolean") && (bt = null);
				var qt = !1;
				if (bt === null) qt = !0;
				else
					switch (Ut) {
						case "string":
						case "number":
							qt = !0;
							break;
						case "object":
							switch (bt.$$typeof) {
								case et:
								case tt:
									qt = !0;
							}
					}
				if (qt)
					return (
						(qt = bt),
						(Yt = Yt(qt)),
						(bt = Vt === "" ? "." + Ft(qt, 0) : Vt),
						St(Yt)
							? ((zt = ""),
							  bt != null && (zt = bt.replace(Nt, "$&/") + "/"),
							  Gt(Yt, kt, zt, "", function (Zt) {
									return Zt;
							  }))
							: Yt != null &&
							  (At(Yt) &&
									(Yt = $t(
										Yt,
										zt + (!Yt.key || (qt && qt.key === Yt.key) ? "" : ("" + Yt.key).replace(Nt, "$&/") + "/") + bt
									)),
							  kt.push(Yt)),
						1
					);
				if (((qt = 0), (Vt = Vt === "" ? "." : Vt + ":"), St(bt)))
					for (var Wt = 0; Wt < bt.length; Wt++) {
						Ut = bt[Wt];
						var Xt = Vt + Ft(Ut, Wt);
						qt += Gt(Ut, kt, zt, Xt, Yt);
					}
				else if (((Xt = ft(bt)), typeof Xt == "function"))
					for (bt = Xt.call(bt), Wt = 0; !(Ut = bt.next()).done; )
						(Ut = Ut.value), (Xt = Vt + Ft(Ut, Wt++)), (qt += Gt(Ut, kt, zt, Xt, Yt));
				else if (Ut === "object")
					throw (
						((kt = String(bt)),
						Error(
							"Objects are not valid as a React child (found: " +
								(kt === "[object Object]" ? "object with keys {" + Object.keys(bt).join(", ") + "}" : kt) +
								"). If you meant to render a collection of children, use an array instead."
						))
					);
				return qt;
			}
			function Bt(bt, kt, zt) {
				if (bt == null) return bt;
				var Vt = [],
					Yt = 0;
				return (
					Gt(bt, Vt, "", "", function (Ut) {
						return kt.call(zt, Ut, Yt++);
					}),
					Vt
				);
			}
			function jt(bt) {
				if (bt._status === -1) {
					var kt = bt._result;
					(kt = kt()),
						kt.then(
							function (zt) {
								(bt._status === 0 || bt._status === -1) && ((bt._status = 1), (bt._result = zt));
							},
							function (zt) {
								(bt._status === 0 || bt._status === -1) && ((bt._status = 2), (bt._result = zt));
							}
						),
						bt._status === -1 && ((bt._status = 0), (bt._result = kt));
				}
				if (bt._status === 1) return bt._result.default;
				throw bt._result;
			}
			var It = { current: null },
				Dt = { transition: null },
				Rt = { ReactCurrentDispatcher: It, ReactCurrentBatchConfig: Dt, ReactCurrentOwner: Ct };
			(_.Children = {
				map: Bt,
				forEach: function (bt, kt, zt) {
					Bt(
						bt,
						function () {
							kt.apply(this, arguments);
						},
						zt
					);
				},
				count: function (bt) {
					var kt = 0;
					return (
						Bt(bt, function () {
							kt++;
						}),
						kt
					);
				},
				toArray: function (bt) {
					return (
						Bt(bt, function (kt) {
							return kt;
						}) || []
					);
				},
				only: function (bt) {
					if (!At(bt)) throw Error("React.Children.only expected to receive a single React element child.");
					return bt;
				},
			}),
				(_.Component = ht),
				(_.Fragment = nt),
				(_.Profiler = it),
				(_.PureComponent = yt),
				(_.StrictMode = rt),
				(_.Suspense = lt),
				(_.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Rt),
				(_.cloneElement = function (bt, kt, zt) {
					if (bt == null)
						throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + bt + ".");
					var Vt = pt({}, bt.props),
						Yt = bt.key,
						Ut = bt.ref,
						qt = bt._owner;
					if (kt != null) {
						if (
							(kt.ref !== void 0 && ((Ut = kt.ref), (qt = Ct.current)),
							kt.key !== void 0 && (Yt = "" + kt.key),
							bt.type && bt.type.defaultProps)
						)
							var Wt = bt.type.defaultProps;
						for (Xt in kt)
							wt.call(kt, Xt) &&
								!Et.hasOwnProperty(Xt) &&
								(Vt[Xt] = kt[Xt] === void 0 && Wt !== void 0 ? Wt[Xt] : kt[Xt]);
					}
					var Xt = arguments.length - 2;
					if (Xt === 1) Vt.children = zt;
					else if (1 < Xt) {
						Wt = Array(Xt);
						for (var Zt = 0; Zt < Xt; Zt++) Wt[Zt] = arguments[Zt + 2];
						Vt.children = Wt;
					}
					return { $$typeof: et, type: bt.type, key: Yt, ref: Ut, props: Vt, _owner: qt };
				}),
				(_.createContext = function (bt) {
					return (
						(bt = {
							$$typeof: at,
							_currentValue: bt,
							_currentValue2: bt,
							_threadCount: 0,
							Provider: null,
							Consumer: null,
							_defaultValue: null,
							_globalName: null,
						}),
						(bt.Provider = { $$typeof: ot, _context: bt }),
						(bt.Consumer = bt)
					);
				}),
				(_.createElement = _t),
				(_.createFactory = function (bt) {
					var kt = _t.bind(null, bt);
					return (kt.type = bt), kt;
				}),
				(_.createRef = function () {
					return { current: null };
				}),
				(_.forwardRef = function (bt) {
					return { $$typeof: st, render: bt };
				}),
				(_.isValidElement = At),
				(_.lazy = function (bt) {
					return { $$typeof: dt, _payload: { _status: -1, _result: bt }, _init: jt };
				}),
				(_.memo = function (bt, kt) {
					return { $$typeof: ut, type: bt, compare: kt === void 0 ? null : kt };
				}),
				(_.startTransition = function (bt) {
					var kt = Dt.transition;
					Dt.transition = {};
					try {
						bt();
					} finally {
						Dt.transition = kt;
					}
				}),
				(_.unstable_act = function () {
					throw Error("act(...) is not supported in production builds of React.");
				}),
				(_.useCallback = function (bt, kt) {
					return It.current.useCallback(bt, kt);
				}),
				(_.useContext = function (bt) {
					return It.current.useContext(bt);
				}),
				(_.useDebugValue = function () {}),
				(_.useDeferredValue = function (bt) {
					return It.current.useDeferredValue(bt);
				}),
				(_.useEffect = function (bt, kt) {
					return It.current.useEffect(bt, kt);
				}),
				(_.useId = function () {
					return It.current.useId();
				}),
				(_.useImperativeHandle = function (bt, kt, zt) {
					return It.current.useImperativeHandle(bt, kt, zt);
				}),
				(_.useInsertionEffect = function (bt, kt) {
					return It.current.useInsertionEffect(bt, kt);
				}),
				(_.useLayoutEffect = function (bt, kt) {
					return It.current.useLayoutEffect(bt, kt);
				}),
				(_.useMemo = function (bt, kt) {
					return It.current.useMemo(bt, kt);
				}),
				(_.useReducer = function (bt, kt, zt) {
					return It.current.useReducer(bt, kt, zt);
				}),
				(_.useRef = function (bt) {
					return It.current.useRef(bt);
				}),
				(_.useState = function (bt) {
					return It.current.useState(bt);
				}),
				(_.useSyncExternalStore = function (bt, kt, zt) {
					return It.current.useSyncExternalStore(bt, kt, zt);
				}),
				(_.useTransition = function () {
					return It.current.useTransition();
				}),
				(_.version = "18.2.0");
		},
	}),
	require_react = __commonJS({
		"../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"(_, et) {
			et.exports = require_react_production_min();
		},
	}),
	import_react = __toESM(require_react());
function getValidChildren(_) {
	return import_react.Children.toArray(_).filter((et) => (0, import_react.isValidElement)(et));
}
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var cx$6 = (..._) => _.filter(Boolean).join(" "),
	dataAttr$4 = (_) => (_ ? "" : void 0),
	[ButtonGroupProvider, useButtonGroup] = createContext({ strict: !1, name: "ButtonGroupContext" });
function ButtonIcon(_) {
	const { children: et, className: tt, ...nt } = _,
		rt = react.exports.isValidElement(et) ? react.exports.cloneElement(et, { "aria-hidden": !0, focusable: !1 }) : et,
		it = cx$6("chakra-button__icon", tt);
	return React$1.createElement(
		chakra.span,
		{ display: "inline-flex", alignSelf: "center", flexShrink: 0, ...nt, className: it },
		rt
	);
}
ButtonIcon.displayName = "ButtonIcon";
function ButtonSpinner(_) {
	const {
			label: et,
			placement: tt,
			spacing: nt = "0.5rem",
			children: rt = jsx(Spinner, { color: "currentColor", width: "1em", height: "1em" }),
			className: it,
			__css: ot,
			...at
		} = _,
		st = cx$6("chakra-button__spinner", it),
		lt = tt === "start" ? "marginEnd" : "marginStart",
		ut = react.exports.useMemo(
			() => ({
				display: "flex",
				alignItems: "center",
				position: et ? "relative" : "absolute",
				[lt]: et ? nt : 0,
				fontSize: "1em",
				lineHeight: "normal",
				...ot,
			}),
			[ot, et, lt, nt]
		);
	return React$1.createElement(chakra.div, { className: st, ...at, __css: ut }, rt);
}
ButtonSpinner.displayName = "ButtonSpinner";
function useButtonType(_) {
	const [et, tt] = react.exports.useState(!_);
	return {
		ref: react.exports.useCallback((it) => {
			!it || tt(it.tagName === "BUTTON");
		}, []),
		type: et ? "button" : void 0,
	};
}
var Button = forwardRef((_, et) => {
	const tt = useButtonGroup(),
		nt = useStyleConfig("Button", { ...tt, ..._ }),
		{
			isDisabled: rt = tt == null ? void 0 : tt.isDisabled,
			isLoading: it,
			isActive: ot,
			children: at,
			leftIcon: st,
			rightIcon: lt,
			loadingText: ut,
			iconSpacing: dt = "0.5rem",
			type: ct,
			spinner: ft,
			spinnerPlacement: mt = "start",
			className: pt,
			as: vt,
			...ht
		} = omitThemingProps(_),
		gt = react.exports.useMemo(() => {
			const wt = { ...(nt == null ? void 0 : nt._focus), zIndex: 1 };
			return {
				display: "inline-flex",
				appearance: "none",
				alignItems: "center",
				justifyContent: "center",
				userSelect: "none",
				position: "relative",
				whiteSpace: "nowrap",
				verticalAlign: "middle",
				outline: "none",
				...nt,
				...(!!tt && { _focus: wt }),
			};
		}, [nt, tt]),
		{ ref: yt, type: xt } = useButtonType(vt),
		St = { rightIcon: lt, leftIcon: st, iconSpacing: dt, children: at };
	return React$1.createElement(
		chakra.button,
		{
			disabled: rt || it,
			ref: useMergeRefs$1(et, yt),
			as: vt,
			type: ct != null ? ct : xt,
			"data-active": dataAttr$4(ot),
			"data-loading": dataAttr$4(it),
			__css: gt,
			className: cx$6("chakra-button", pt),
			...ht,
		},
		it &&
			mt === "start" &&
			jsx(ButtonSpinner, {
				className: "chakra-button__spinner--start",
				label: ut,
				placement: "start",
				spacing: dt,
				children: ft,
			}),
		it
			? ut || React$1.createElement(chakra.span, { opacity: 0 }, jsx(ButtonContent, { ...St }))
			: jsx(ButtonContent, { ...St }),
		it &&
			mt === "end" &&
			jsx(ButtonSpinner, {
				className: "chakra-button__spinner--end",
				label: ut,
				placement: "end",
				spacing: dt,
				children: ft,
			})
	);
});
Button.displayName = "Button";
function ButtonContent(_) {
	const { leftIcon: et, rightIcon: tt, children: nt, iconSpacing: rt } = _;
	return jsxs(Fragment, {
		children: [
			et && jsx(ButtonIcon, { marginEnd: rt, children: et }),
			nt,
			tt && jsx(ButtonIcon, { marginStart: rt, children: tt }),
		],
	});
}
var ButtonGroup = forwardRef(function (et, tt) {
	const {
			size: nt,
			colorScheme: rt,
			variant: it,
			className: ot,
			spacing: at = "0.5rem",
			isAttached: st,
			isDisabled: lt,
			...ut
		} = et,
		dt = cx$6("chakra-button__group", ot),
		ct = react.exports.useMemo(() => ({ size: nt, colorScheme: rt, variant: it, isDisabled: lt }), [nt, rt, it, lt]);
	let ft = { display: "inline-flex" };
	return (
		st
			? (ft = {
					...ft,
					"> *:first-of-type:not(:last-of-type)": { borderEndRadius: 0 },
					"> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
					"> *:not(:first-of-type):last-of-type": { borderStartRadius: 0 },
			  })
			: (ft = { ...ft, "& > *:not(style) ~ *:not(style)": { marginStart: at } }),
		React$1.createElement(
			ButtonGroupProvider,
			{ value: ct },
			React$1.createElement(chakra.div, {
				ref: tt,
				role: "group",
				__css: ft,
				className: dt,
				"data-attached": st ? "" : void 0,
				...ut,
			})
		)
	);
});
ButtonGroup.displayName = "ButtonGroup";
var IconButton = forwardRef((_, et) => {
	const { icon: tt, children: nt, isRound: rt, "aria-label": it, ...ot } = _,
		at = tt || nt,
		st = react.exports.isValidElement(at) ? react.exports.cloneElement(at, { "aria-hidden": !0, focusable: !1 }) : null;
	return jsx(Button, {
		padding: "0",
		borderRadius: rt ? "full" : void 0,
		ref: et,
		"aria-label": it,
		...ot,
		children: st,
	});
});
IconButton.displayName = "IconButton";
var cx$5 = (..._) => _.filter(Boolean).join(" "),
	dataAttr$3 = (_) => (_ ? "" : void 0);
function callAllHandlers$4(..._) {
	return function (tt) {
		_.some((nt) => (nt == null || nt(tt), tt == null ? void 0 : tt.defaultPrevented));
	};
}
var [FormControlStylesProvider, useFormControlStyles] = createContext({
		name: "FormControlStylesContext",
		errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `,
	}),
	[FormControlProvider, useFormControlContext] = createContext({ strict: !1, name: "FormControlContext" });
function useFormControlProvider(_) {
	const { id: et, isRequired: tt, isInvalid: nt, isDisabled: rt, isReadOnly: it, ...ot } = _,
		at = react.exports.useId(),
		st = et || `field-${at}`,
		lt = `${st}-label`,
		ut = `${st}-feedback`,
		dt = `${st}-helptext`,
		[ct, ft] = react.exports.useState(!1),
		[mt, pt] = react.exports.useState(!1),
		[vt, ht] = react.exports.useState(!1),
		gt = react.exports.useCallback(
			(Ct = {}, Et = null) => ({
				id: dt,
				...Ct,
				ref: mergeRefs(Et, (_t) => {
					!_t || pt(!0);
				}),
			}),
			[dt]
		),
		yt = react.exports.useCallback(
			(Ct = {}, Et = null) => {
				var _t, $t;
				return {
					...Ct,
					ref: Et,
					"data-focus": dataAttr$3(vt),
					"data-disabled": dataAttr$3(rt),
					"data-invalid": dataAttr$3(nt),
					"data-readonly": dataAttr$3(it),
					id: (_t = Ct.id) != null ? _t : lt,
					htmlFor: ($t = Ct.htmlFor) != null ? $t : st,
				};
			},
			[st, rt, vt, nt, it, lt]
		),
		xt = react.exports.useCallback(
			(Ct = {}, Et = null) => ({
				id: ut,
				...Ct,
				ref: mergeRefs(Et, (_t) => {
					!_t || ft(!0);
				}),
				"aria-live": "polite",
			}),
			[ut]
		),
		St = react.exports.useCallback((Ct = {}, Et = null) => ({ ...Ct, ...ot, ref: Et, role: "group" }), [ot]),
		wt = react.exports.useCallback(
			(Ct = {}, Et = null) => ({
				...Ct,
				ref: Et,
				role: "presentation",
				"aria-hidden": !0,
				children: Ct.children || "*",
			}),
			[]
		);
	return {
		isRequired: !!tt,
		isInvalid: !!nt,
		isReadOnly: !!it,
		isDisabled: !!rt,
		isFocused: !!vt,
		onFocus: () => ht(!0),
		onBlur: () => ht(!1),
		hasFeedbackText: ct,
		setHasFeedbackText: ft,
		hasHelpText: mt,
		setHasHelpText: pt,
		id: st,
		labelId: lt,
		feedbackId: ut,
		helpTextId: dt,
		htmlProps: ot,
		getHelpTextProps: gt,
		getErrorMessageProps: xt,
		getRootProps: St,
		getLabelProps: yt,
		getRequiredIndicatorProps: wt,
	};
}
var FormControl = forwardRef(function (et, tt) {
	const nt = useMultiStyleConfig("Form", et),
		rt = omitThemingProps(et),
		{ getRootProps: it, htmlProps: ot, ...at } = useFormControlProvider(rt),
		st = cx$5("chakra-form-control", et.className);
	return React$1.createElement(
		FormControlProvider,
		{ value: at },
		React$1.createElement(
			FormControlStylesProvider,
			{ value: nt },
			React$1.createElement(chakra.div, { ...it({}, tt), className: st, __css: nt.container })
		)
	);
});
FormControl.displayName = "FormControl";
var FormHelperText = forwardRef(function (et, tt) {
	const nt = useFormControlContext(),
		rt = useFormControlStyles(),
		it = cx$5("chakra-form__helper-text", et.className);
	return React$1.createElement(chakra.div, {
		...(nt == null ? void 0 : nt.getHelpTextProps(et, tt)),
		__css: rt.helperText,
		className: it,
	});
});
FormHelperText.displayName = "FormHelperText";
function useFormControlProps(_) {
	var mt, pt, vt;
	const et = useFormControlContext(),
		{
			id: tt,
			disabled: nt,
			readOnly: rt,
			required: it,
			isRequired: ot,
			isInvalid: at,
			isReadOnly: st,
			isDisabled: lt,
			onFocus: ut,
			onBlur: dt,
			...ct
		} = _,
		ft = _["aria-describedby"] ? [_["aria-describedby"]] : [];
	return (
		(et == null ? void 0 : et.hasFeedbackText) && (et == null ? void 0 : et.isInvalid) && ft.push(et.feedbackId),
		et != null && et.hasHelpText && ft.push(et.helpTextId),
		{
			...ct,
			"aria-describedby": ft.join(" ") || void 0,
			id: tt != null ? tt : et == null ? void 0 : et.id,
			isDisabled: (mt = nt != null ? nt : lt) != null ? mt : et == null ? void 0 : et.isDisabled,
			isReadOnly: (pt = rt != null ? rt : st) != null ? pt : et == null ? void 0 : et.isReadOnly,
			isRequired: (vt = it != null ? it : ot) != null ? vt : et == null ? void 0 : et.isRequired,
			isInvalid: at != null ? at : et == null ? void 0 : et.isInvalid,
			onFocus: callAllHandlers$4(et == null ? void 0 : et.onFocus, ut),
			onBlur: callAllHandlers$4(et == null ? void 0 : et.onBlur, dt),
		}
	);
}
var [FormErrorStylesProvider, useFormErrorStyles] = createContext({
		name: "FormErrorStylesContext",
		errorMessage: `useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `,
	}),
	FormErrorMessage = forwardRef((_, et) => {
		const tt = useMultiStyleConfig("FormError", _),
			nt = omitThemingProps(_),
			rt = useFormControlContext();
		return rt != null && rt.isInvalid
			? React$1.createElement(
					FormErrorStylesProvider,
					{ value: tt },
					React$1.createElement(chakra.div, {
						...(rt == null ? void 0 : rt.getErrorMessageProps(nt, et)),
						className: cx$5("chakra-form__error-message", _.className),
						__css: { display: "flex", alignItems: "center", ...tt.text },
					})
			  )
			: null;
	});
FormErrorMessage.displayName = "FormErrorMessage";
var FormErrorIcon = forwardRef((_, et) => {
	const tt = useFormErrorStyles(),
		nt = useFormControlContext();
	if (!(nt != null && nt.isInvalid)) return null;
	const rt = cx$5("chakra-form__error-icon", _.className);
	return jsx(Icon, {
		ref: et,
		"aria-hidden": !0,
		..._,
		__css: tt.icon,
		className: rt,
		children: jsx("path", {
			fill: "currentColor",
			d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z",
		}),
	});
});
FormErrorIcon.displayName = "FormErrorIcon";
var FormLabel = forwardRef(function (et, tt) {
	var ct;
	const nt = useStyleConfig("FormLabel", et),
		rt = omitThemingProps(et),
		{
			className: it,
			children: ot,
			requiredIndicator: at = jsx(RequiredIndicator, {}),
			optionalIndicator: st = null,
			...lt
		} = rt,
		ut = useFormControlContext(),
		dt = (ct = ut == null ? void 0 : ut.getLabelProps(lt, tt)) != null ? ct : { ref: tt, ...lt };
	return React$1.createElement(
		chakra.label,
		{
			...dt,
			className: cx$5("chakra-form__label", rt.className),
			__css: { display: "block", textAlign: "start", ...nt },
		},
		ot,
		ut != null && ut.isRequired ? at : st
	);
});
FormLabel.displayName = "FormLabel";
var RequiredIndicator = forwardRef(function (et, tt) {
	const nt = useFormControlContext(),
		rt = useFormControlStyles();
	if (!(nt != null && nt.isRequired)) return null;
	const it = cx$5("chakra-form__required-indicator", et.className);
	return React$1.createElement(chakra.span, {
		...(nt == null ? void 0 : nt.getRequiredIndicatorProps(et, tt)),
		__css: rt.requiredIndicator,
		className: it,
	});
});
RequiredIndicator.displayName = "RequiredIndicator";
function useUpdateEffect$1(_, et) {
	const tt = react.exports.useRef(!1),
		nt = react.exports.useRef(!1);
	react.exports.useEffect(() => {
		if (tt.current && nt.current) return _();
		nt.current = !0;
	}, et),
		react.exports.useEffect(
			() => (
				(tt.current = !0),
				() => {
					tt.current = !1;
				}
			),
			[]
		);
}
var visuallyHiddenStyle = {
		border: "0px",
		clip: "rect(0px, 0px, 0px, 0px)",
		height: "1px",
		width: "1px",
		margin: "-1px",
		padding: "0px",
		overflow: "hidden",
		whiteSpace: "nowrap",
		position: "absolute",
	},
	VisuallyHidden = chakra("span", { baseStyle: visuallyHiddenStyle });
VisuallyHidden.displayName = "VisuallyHidden";
var VisuallyHiddenInput = chakra("input", { baseStyle: visuallyHiddenStyle });
VisuallyHiddenInput.displayName = "VisuallyHiddenInput";
var hasSetup = !1,
	modality = null,
	hasEventBeforeFocus = !1,
	handlers$1 = new Set(),
	isMac = typeof window < "u" && window.navigator != null ? /^Mac/.test(window.navigator.platform) : !1;
function isValidKey(_) {
	return !(_.metaKey || (!isMac && _.altKey) || _.ctrlKey);
}
function trigger$1(_, et) {
	handlers$1.forEach((tt) => tt(_, et));
}
function onKeyboardEvent(_) {
	(hasEventBeforeFocus = !0), isValidKey(_) && ((modality = "keyboard"), trigger$1("keyboard", _));
}
function onPointerEvent(_) {
	(modality = "pointer"),
		(_.type === "mousedown" || _.type === "pointerdown") && ((hasEventBeforeFocus = !0), trigger$1("pointer", _));
}
function onWindowFocus(_) {
	_.target === window ||
		_.target === document ||
		(hasEventBeforeFocus || ((modality = "keyboard"), trigger$1("keyboard", _)), (hasEventBeforeFocus = !1));
}
function onWindowBlur$1() {
	hasEventBeforeFocus = !1;
}
function isFocusVisible() {
	return modality !== "pointer";
}
function setupGlobalFocusEvents() {
	if (typeof window > "u" || hasSetup) return;
	const { focus: _ } = HTMLElement.prototype;
	(HTMLElement.prototype.focus = function (...tt) {
		(hasEventBeforeFocus = !0), _.apply(this, tt);
	}),
		document.addEventListener("keydown", onKeyboardEvent, !0),
		document.addEventListener("keyup", onKeyboardEvent, !0),
		window.addEventListener("focus", onWindowFocus, !0),
		window.addEventListener("blur", onWindowBlur$1, !1),
		typeof PointerEvent < "u"
			? (document.addEventListener("pointerdown", onPointerEvent, !0),
			  document.addEventListener("pointermove", onPointerEvent, !0),
			  document.addEventListener("pointerup", onPointerEvent, !0))
			: (document.addEventListener("mousedown", onPointerEvent, !0),
			  document.addEventListener("mousemove", onPointerEvent, !0),
			  document.addEventListener("mouseup", onPointerEvent, !0)),
		(hasSetup = !0);
}
function trackFocusVisible(_) {
	setupGlobalFocusEvents(), _(isFocusVisible());
	const et = () => _(isFocusVisible());
	return (
		handlers$1.add(et),
		() => {
			handlers$1.delete(et);
		}
	);
}
var [CheckboxGroupProvider, useCheckboxGroupContext] = createContext({ name: "CheckboxGroupContext", strict: !1 }),
	cx$4 = (..._) => _.filter(Boolean).join(" "),
	dataAttr$2 = (_) => (_ ? "" : void 0);
function callAllHandlers$3(..._) {
	return function (tt) {
		_.some((nt) => (nt == null || nt(tt), tt == null ? void 0 : tt.defaultPrevented));
	};
}
function callAll$2(..._) {
	return function (tt) {
		_.forEach((nt) => {
			nt == null || nt(tt);
		});
	};
}
function __motion$1(_) {
	const et = motion;
	return "custom" in et && typeof et.custom == "function" ? et.custom(_) : et(_);
}
var MotionSvg = __motion$1(chakra.svg);
function CheckIcon$1(_) {
	return jsx(MotionSvg, {
		width: "1.2em",
		viewBox: "0 0 12 10",
		variants: {
			unchecked: { opacity: 0, strokeDashoffset: 16 },
			checked: { opacity: 1, strokeDashoffset: 0, transition: { duration: 0.2 } },
		},
		style: { fill: "none", strokeWidth: 2, stroke: "currentColor", strokeDasharray: 16 },
		..._,
		children: jsx("polyline", { points: "1.5 6 4.5 9 10.5 1" }),
	});
}
function IndeterminateIcon(_) {
	return jsx(MotionSvg, {
		width: "1.2em",
		viewBox: "0 0 24 24",
		variants: {
			unchecked: { scaleX: 0.65, opacity: 0 },
			checked: { scaleX: 1, opacity: 1, transition: { scaleX: { duration: 0 }, opacity: { duration: 0.02 } } },
		},
		style: { stroke: "currentColor", strokeWidth: 4 },
		..._,
		children: jsx("line", { x1: "21", x2: "3", y1: "12", y2: "12" }),
	});
}
function CheckboxTransition({ open: _, children: et }) {
	return jsx(AnimatePresence, {
		initial: !1,
		children:
			_ &&
			React$1.createElement(
				motion.div,
				{
					variants: { unchecked: { scale: 0.5 }, checked: { scale: 1 } },
					initial: "unchecked",
					animate: "checked",
					exit: "unchecked",
					style: { display: "flex", alignItems: "center", justifyContent: "center", height: "100%" },
				},
				et
			),
	});
}
function CheckboxIcon(_) {
	const { isIndeterminate: et, isChecked: tt, ...nt } = _;
	return jsx(CheckboxTransition, { open: tt || et, children: jsx(et ? IndeterminateIcon : CheckIcon$1, { ...nt }) });
}
function omit(_, et = []) {
	const tt = Object.assign({}, _);
	for (const nt of et) nt in tt && delete tt[nt];
	return tt;
}
function useCheckbox(_ = {}) {
	const et = useFormControlProps(_),
		{
			isDisabled: tt,
			isReadOnly: nt,
			isRequired: rt,
			isInvalid: it,
			id: ot,
			onBlur: at,
			onFocus: st,
			"aria-describedby": lt,
		} = et,
		{
			defaultChecked: ut,
			isChecked: dt,
			isFocusable: ct,
			onChange: ft,
			isIndeterminate: mt,
			name: pt,
			value: vt,
			tabIndex: ht = void 0,
			"aria-label": gt,
			"aria-labelledby": yt,
			"aria-invalid": xt,
			...St
		} = _,
		wt = omit(St, [
			"isDisabled",
			"isReadOnly",
			"isRequired",
			"isInvalid",
			"id",
			"onBlur",
			"onFocus",
			"aria-describedby",
		]),
		Ct = useCallbackRef$2(ft),
		Et = useCallbackRef$2(at),
		_t = useCallbackRef$2(st),
		[$t, At] = react.exports.useState(!1),
		[Lt, Nt] = react.exports.useState(!1),
		[Ft, Gt] = react.exports.useState(!1),
		[Bt, jt] = react.exports.useState(!1);
	react.exports.useEffect(() => trackFocusVisible(At), []);
	const It = react.exports.useRef(null),
		[Dt, Rt] = react.exports.useState(!0),
		[bt, kt] = react.exports.useState(!!ut),
		zt = dt !== void 0,
		Vt = zt ? dt : bt,
		Yt = react.exports.useCallback(
			(Qt) => {
				if (nt || tt) {
					Qt.preventDefault();
					return;
				}
				zt || kt(Vt ? Qt.target.checked : mt ? !0 : Qt.target.checked), Ct == null || Ct(Qt);
			},
			[nt, tt, Vt, zt, mt, Ct]
		);
	useSafeLayoutEffect$2(() => {
		It.current && (It.current.indeterminate = Boolean(mt));
	}, [mt]),
		useUpdateEffect$1(() => {
			tt && Nt(!1);
		}, [tt, Nt]),
		useSafeLayoutEffect$2(() => {
			const Qt = It.current;
			!(Qt != null && Qt.form) ||
				(Qt.form.onreset = () => {
					kt(!!ut);
				});
		}, []);
	const Ut = tt && !ct,
		qt = react.exports.useCallback(
			(Qt) => {
				Qt.key === " " && jt(!0);
			},
			[jt]
		),
		Wt = react.exports.useCallback(
			(Qt) => {
				Qt.key === " " && jt(!1);
			},
			[jt]
		);
	useSafeLayoutEffect$2(() => {
		if (!It.current) return;
		It.current.checked !== Vt && kt(It.current.checked);
	}, [It.current]);
	const Xt = react.exports.useCallback(
			(Qt = {}, Jt = null) => {
				const tn = (an) => {
					Lt && an.preventDefault(), jt(!0);
				};
				return {
					...Qt,
					ref: Jt,
					"data-active": dataAttr$2(Bt),
					"data-hover": dataAttr$2(Ft),
					"data-checked": dataAttr$2(Vt),
					"data-focus": dataAttr$2(Lt),
					"data-focus-visible": dataAttr$2(Lt && $t),
					"data-indeterminate": dataAttr$2(mt),
					"data-disabled": dataAttr$2(tt),
					"data-invalid": dataAttr$2(it),
					"data-readonly": dataAttr$2(nt),
					"aria-hidden": !0,
					onMouseDown: callAllHandlers$3(Qt.onMouseDown, tn),
					onMouseUp: callAllHandlers$3(Qt.onMouseUp, () => jt(!1)),
					onMouseEnter: callAllHandlers$3(Qt.onMouseEnter, () => Gt(!0)),
					onMouseLeave: callAllHandlers$3(Qt.onMouseLeave, () => Gt(!1)),
				};
			},
			[Bt, Vt, tt, Lt, $t, Ft, mt, it, nt]
		),
		Zt = react.exports.useCallback(
			(Qt = {}, Jt = null) => ({
				...wt,
				...Qt,
				ref: mergeRefs(Jt, (tn) => {
					!tn || Rt(tn.tagName === "LABEL");
				}),
				onClick: callAllHandlers$3(Qt.onClick, () => {
					var tn;
					Dt ||
						((tn = It.current) == null || tn.click(),
						requestAnimationFrame(() => {
							var an;
							(an = It.current) == null || an.focus();
						}));
				}),
				"data-disabled": dataAttr$2(tt),
				"data-checked": dataAttr$2(Vt),
				"data-invalid": dataAttr$2(it),
			}),
			[wt, tt, Vt, it, Dt]
		),
		pn = react.exports.useCallback(
			(Qt = {}, Jt = null) => ({
				...Qt,
				ref: mergeRefs(It, Jt),
				type: "checkbox",
				name: pt,
				value: vt,
				id: ot,
				tabIndex: ht,
				onChange: callAllHandlers$3(Qt.onChange, Yt),
				onBlur: callAllHandlers$3(Qt.onBlur, Et, () => Nt(!1)),
				onFocus: callAllHandlers$3(Qt.onFocus, _t, () => Nt(!0)),
				onKeyDown: callAllHandlers$3(Qt.onKeyDown, qt),
				onKeyUp: callAllHandlers$3(Qt.onKeyUp, Wt),
				required: rt,
				checked: Vt,
				disabled: Ut,
				readOnly: nt,
				"aria-label": gt,
				"aria-labelledby": yt,
				"aria-invalid": xt ? Boolean(xt) : it,
				"aria-describedby": lt,
				"aria-disabled": tt,
				style: visuallyHiddenStyle,
			}),
			[pt, vt, ot, Yt, Et, _t, qt, Wt, rt, Vt, Ut, nt, gt, yt, xt, it, lt, tt, ht]
		),
		Sn = react.exports.useCallback(
			(Qt = {}, Jt = null) => ({
				...Qt,
				ref: Jt,
				onMouseDown: callAllHandlers$3(Qt.onMouseDown, stopEvent),
				onTouchStart: callAllHandlers$3(Qt.onTouchStart, stopEvent),
				"data-disabled": dataAttr$2(tt),
				"data-checked": dataAttr$2(Vt),
				"data-invalid": dataAttr$2(it),
			}),
			[Vt, tt, it]
		);
	return {
		state: {
			isInvalid: it,
			isFocused: Lt,
			isChecked: Vt,
			isActive: Bt,
			isHovered: Ft,
			isIndeterminate: mt,
			isDisabled: tt,
			isReadOnly: nt,
			isRequired: rt,
		},
		getRootProps: Zt,
		getCheckboxProps: Xt,
		getInputProps: pn,
		getLabelProps: Sn,
		htmlProps: wt,
	};
}
function stopEvent(_) {
	_.preventDefault(), _.stopPropagation();
}
var CheckboxControl = chakra("span", {
		baseStyle: {
			display: "inline-flex",
			alignItems: "center",
			justifyContent: "center",
			verticalAlign: "top",
			userSelect: "none",
			flexShrink: 0,
		},
	}),
	CheckboxRoot = chakra("label", {
		baseStyle: {
			cursor: "pointer",
			display: "inline-flex",
			alignItems: "center",
			verticalAlign: "top",
			position: "relative",
		},
	}),
	Checkbox = forwardRef(function (et, tt) {
		const nt = useCheckboxGroupContext(),
			rt = { ...nt, ...et },
			it = useMultiStyleConfig("Checkbox", rt),
			ot = omitThemingProps(et),
			{
				spacing: at = "0.5rem",
				className: st,
				children: lt,
				iconColor: ut,
				iconSize: dt,
				icon: ct = jsx(CheckboxIcon, {}),
				isChecked: ft,
				isDisabled: mt = nt == null ? void 0 : nt.isDisabled,
				onChange: pt,
				inputProps: vt,
				...ht
			} = ot;
		let gt = ft;
		(nt == null ? void 0 : nt.value) && ot.value && (gt = nt.value.includes(ot.value));
		let yt = pt;
		(nt == null ? void 0 : nt.onChange) && ot.value && (yt = callAll$2(nt.onChange, pt));
		const {
				state: xt,
				getInputProps: St,
				getCheckboxProps: wt,
				getLabelProps: Ct,
				getRootProps: Et,
			} = useCheckbox({ ...ht, isDisabled: mt, isChecked: gt, onChange: yt }),
			_t = react.exports.useMemo(
				() => ({
					opacity: xt.isChecked || xt.isIndeterminate ? 1 : 0,
					transform: xt.isChecked || xt.isIndeterminate ? "scale(1)" : "scale(0.95)",
					fontSize: dt,
					color: ut,
					...it.icon,
				}),
				[ut, dt, xt.isChecked, xt.isIndeterminate, it.icon]
			),
			$t = react.exports.cloneElement(ct, { __css: _t, isIndeterminate: xt.isIndeterminate, isChecked: xt.isChecked });
		return jsxs(CheckboxRoot, {
			__css: it.container,
			className: cx$4("chakra-checkbox", st),
			...Et(),
			children: [
				jsx("input", { className: "chakra-checkbox__input", ...St(vt, tt) }),
				jsx(CheckboxControl, { __css: it.control, className: "chakra-checkbox__control", ...wt(), children: $t }),
				lt &&
					React$1.createElement(
						chakra.span,
						{ className: "chakra-checkbox__label", ...Ct(), __css: { marginStart: at, ...it.label } },
						lt
					),
			],
		});
	});
Checkbox.displayName = "Checkbox";
function CloseIcon$1(_) {
	return jsx(Icon, {
		focusable: "false",
		"aria-hidden": !0,
		..._,
		children: jsx("path", {
			fill: "currentColor",
			d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z",
		}),
	});
}
var CloseButton = forwardRef(function (et, tt) {
	const nt = useStyleConfig("CloseButton", et),
		{ children: rt, isDisabled: it, __css: ot, ...at } = omitThemingProps(et),
		st = { outline: 0, display: "flex", alignItems: "center", justifyContent: "center", flexShrink: 0 };
	return React$1.createElement(
		chakra.button,
		{ type: "button", "aria-label": "Close", ref: tt, disabled: it, __css: { ...st, ...nt, ...ot }, ...at },
		rt || jsx(CloseIcon$1, { width: "1em", height: "1em" })
	);
});
CloseButton.displayName = "CloseButton";
var vhPolyfill = `
  :root {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100lvh) {
    :root {
      --chakra-vh: 100lvh;
    }
  }
`,
	CSSPolyfill = () => jsx(Global, { styles: vhPolyfill }),
	CSSReset = () =>
		jsx(Global, {
			styles: `
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        font-feature-settings: 'kern';
      }

      *,
      *::before,
      *::after {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
      }

      main {
        display: block;
      }

      hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      pre,
      code,
      kbd,
      samp {
        font-family: SFMono-Regular,  Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      b,
      strong {
        font-weight: bold;
      }

      small {
        font-size: 80%;
      }

      sub,
      sup {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      sub {
        bottom: -0.25em;
      }

      sup {
        top: -0.5em;
      }

      img {
        border-style: none;
      }

      button,
      input,
      optgroup,
      select,
      textarea {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      button,
      input {
        overflow: visible;
      }

      button,
      select {
        text-transform: none;
      }

      button::-moz-focus-inner,
      [type="button"]::-moz-focus-inner,
      [type="reset"]::-moz-focus-inner,
      [type="submit"]::-moz-focus-inner {
        border-style: none;
        padding: 0;
      }

      fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      progress {
        vertical-align: baseline;
      }

      textarea {
        overflow: auto;
      }

      [type="checkbox"],
      [type="radio"] {
        box-sizing: border-box;
        padding: 0;
      }

      [type="number"]::-webkit-inner-spin-button,
      [type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      input[type="number"] {
        -moz-appearance: textfield;
      }

      [type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      [type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      details {
        display: block;
      }

      summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      body,
      blockquote,
      dl,
      dd,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      hr,
      figure,
      p,
      pre {
        margin: 0;
      }

      button {
        background: transparent;
        padding: 0;
      }

      fieldset {
        margin: 0;
        padding: 0;
      }

      ol,
      ul {
        margin: 0;
        padding: 0;
      }

      textarea {
        resize: vertical;
      }

      button,
      [role="button"] {
        cursor: pointer;
      }

      button::-moz-focus-inner {
        border: 0 !important;
      }

      table {
        border-collapse: collapse;
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-size: inherit;
        font-weight: inherit;
      }

      button,
      input,
      optgroup,
      select,
      textarea {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      img,
      svg,
      video,
      canvas,
      audio,
      iframe,
      embed,
      object {
        display: block;
      }

      img,
      video {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible] :focus:not([data-focus-visible-added]):not([data-focus-visible-disabled]) {
        outline: none;
        box-shadow: none;
      }

      select::-ms-expand {
        display: none;
      }

      ${vhPolyfill}
    `,
		});
function useEventListener$1(_, et, tt, nt) {
	const rt = useCallbackRef$2(tt);
	return (
		react.exports.useEffect(() => {
			const it = typeof _ == "function" ? _() : _ != null ? _ : document;
			if (!(!tt || !it))
				return (
					it.addEventListener(et, rt, nt),
					() => {
						it.removeEventListener(et, rt, nt);
					}
				);
		}, [et, _, nt, rt, tt]),
		() => {
			const it = typeof _ == "function" ? _() : _ != null ? _ : document;
			it == null || it.removeEventListener(et, rt, nt);
		}
	);
}
var useSafeLayoutEffect = isBrowser$2 ? react.exports.useLayoutEffect : react.exports.useEffect;
function useCallbackRef$1(_, et = []) {
	const tt = react.exports.useRef(_);
	return (
		useSafeLayoutEffect(() => {
			tt.current = _;
		}),
		react.exports.useCallback((...nt) => {
			var rt;
			return (rt = tt.current) == null ? void 0 : rt.call(tt, ...nt);
		}, et)
	);
}
function useEventListener(_, et, tt, nt) {
	const rt = useCallbackRef$1(et);
	return (
		react.exports.useEffect(() => {
			var ot;
			const it = (ot = runIfFn$4(tt)) != null ? ot : document;
			if (!!et)
				return (
					it.addEventListener(_, rt, nt),
					() => {
						it.removeEventListener(_, rt, nt);
					}
				);
		}, [_, tt, nt, rt, et]),
		() => {
			var ot;
			((ot = runIfFn$4(tt)) != null ? ot : document).removeEventListener(_, rt, nt);
		}
	);
}
function useAnimationState$1(_) {
	const { isOpen: et, ref: tt } = _,
		[nt, rt] = react.exports.useState(et),
		[it, ot] = react.exports.useState(!1);
	return (
		react.exports.useEffect(() => {
			it || (rt(et), ot(!0));
		}, [et, it, nt]),
		useEventListener(
			"animationend",
			() => {
				rt(et);
			},
			() => tt.current
		),
		{
			present: !(et ? !1 : !nt),
			onComplete() {
				var st;
				const lt = getOwnerWindow$1(tt.current),
					ut = new lt.CustomEvent("animationend", { bubbles: !0 });
				(st = tt.current) == null || st.dispatchEvent(ut);
			},
		}
	);
}
function useControllableProp(_, et) {
	const tt = _ !== void 0;
	return [tt, tt && typeof _ < "u" ? _ : et];
}
function useId(_, et) {
	const tt = react.exports.useId();
	return react.exports.useMemo(() => _ || [et, tt].filter(Boolean).join("-"), [_, et, tt]);
}
function useDisclosure$1(_ = {}) {
	const { onClose: et, onOpen: tt, isOpen: nt, id: rt } = _,
		it = useCallbackRef$1(tt),
		ot = useCallbackRef$1(et),
		[at, st] = react.exports.useState(_.defaultIsOpen || !1),
		[lt, ut] = useControllableProp(nt, at),
		dt = useId(rt, "disclosure"),
		ct = react.exports.useCallback(() => {
			lt || st(!1), ot == null || ot();
		}, [lt, ot]),
		ft = react.exports.useCallback(() => {
			lt || st(!0), it == null || it();
		}, [lt, it]),
		mt = react.exports.useCallback(() => {
			(ut ? ct : ft)();
		}, [ut, ft, ct]);
	return {
		isOpen: !!ut,
		onOpen: ft,
		onClose: ct,
		onToggle: mt,
		isControlled: lt,
		getButtonProps: (pt = {}) => ({
			...pt,
			"aria-expanded": ut,
			"aria-controls": dt,
			onClick: callAllHandlers$5(pt.onClick, mt),
		}),
		getDisclosureProps: (pt = {}) => ({ ...pt, hidden: !ut, id: dt }),
	};
}
var useUpdateEffect = (_, et) => {
	const tt = react.exports.useRef(!1),
		nt = react.exports.useRef(!1);
	react.exports.useEffect(() => {
		if (tt.current && nt.current) return _();
		nt.current = !0;
	}, et),
		react.exports.useEffect(
			() => (
				(tt.current = !0),
				() => {
					tt.current = !1;
				}
			),
			[]
		);
};
function preventReturnFocus$1(_) {
	const et = _.current;
	if (!et) return !1;
	const tt = getActiveElement$2(et);
	return !tt || contains$3(et, tt) ? !1 : !!isTabbable$1(tt);
}
function useFocusOnHide$1(_, et) {
	const { shouldFocus: tt, visible: nt, focusRef: rt } = et,
		it = tt && !nt;
	useUpdateEffect(() => {
		if (!it || preventReturnFocus$1(_)) return;
		const ot = (rt == null ? void 0 : rt.current) || _.current;
		ot && focus(ot, { nextTick: !0 });
	}, [it, _, rt]);
}
function usePointerEvent(_, et, tt, nt) {
	return useEventListener(getPointerEventName$1(et), wrapPointerEventHandler(tt, et === "pointerdown"), _, nt);
}
function useFocusOnPointerDown(_) {
	const { ref: et, elements: tt, enabled: nt } = _,
		rt = detectBrowser("Safari");
	usePointerEvent(
		() => getOwnerDocument$3(et.current),
		"pointerdown",
		(ot) => {
			if (!rt || !nt) return;
			const at = ot.target,
				lt = (tt != null ? tt : [et]).some((ut) => {
					const dt = isRefObject$1(ut) ? ut.current : ut;
					return contains$3(dt, at);
				});
			!isActiveElement$1(at) && lt && (ot.preventDefault(), focus(at));
		}
	);
}
var defaultOptions = { preventScroll: !0, shouldFocus: !1 };
function useFocusOnShow(_, et = defaultOptions) {
	const { focusRef: tt, preventScroll: nt, shouldFocus: rt, visible: it } = et,
		ot = isRefObject$1(_) ? _.current : _,
		at = rt && it,
		st = react.exports.useCallback(() => {
			if (!(!ot || !at) && !contains$3(ot, document.activeElement))
				if (tt != null && tt.current) focus(tt.current, { preventScroll: nt, nextTick: !0 });
				else {
					const lt = getAllFocusable$1(ot);
					lt.length > 0 && focus(lt[0], { preventScroll: nt, nextTick: !0 });
				}
		}, [at, nt, ot, tt]);
	useUpdateEffect(() => {
		st();
	}, [st]),
		useEventListener("transitionend", st, ot);
}
function compact(_) {
	const et = Object.assign({}, _);
	for (let tt in et) et[tt] === void 0 && delete et[tt];
	return et;
}
function isObject$5(_) {
	const et = typeof _;
	return _ != null && (et === "object" || et === "function") && !Array.isArray(_);
}
Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);
function mapResponsive(_, et) {
	return Array.isArray(_)
		? _.map((tt) => (tt === null ? null : et(tt)))
		: isObject$5(_)
		? Object.keys(_).reduce((tt, nt) => ((tt[nt] = et(_[nt])), tt), {})
		: _ != null
		? et(_)
		: null;
}
var AspectRatio = forwardRef(function (_, et) {
	const { ratio: tt = 4 / 3, children: nt, className: rt, ...it } = _,
		ot = react.exports.Children.only(nt),
		at = cx$a("chakra-aspect-ratio", rt);
	return React$1.createElement(
		chakra.div,
		{
			ref: et,
			position: "relative",
			className: at,
			_before: {
				height: 0,
				content: '""',
				display: "block",
				paddingBottom: mapResponsive(tt, (st) => `${(1 / st) * 100}%`),
			},
			__css: {
				"& > *:not(style)": {
					overflow: "hidden",
					position: "absolute",
					top: "0",
					right: "0",
					bottom: "0",
					left: "0",
					display: "flex",
					justifyContent: "center",
					alignItems: "center",
					width: "100%",
					height: "100%",
				},
				"& > img, & > video": { objectFit: "cover" },
			},
			...it,
		},
		ot
	);
});
AspectRatio.displayName = "AspectRatio";
var Badge$1 = forwardRef(function (et, tt) {
	const nt = useStyleConfig("Badge", et),
		{ className: rt, ...it } = omitThemingProps(et);
	return React$1.createElement(chakra.span, {
		ref: tt,
		className: cx$a("chakra-badge", et.className),
		...it,
		__css: { display: "inline-block", whiteSpace: "nowrap", verticalAlign: "middle", ...nt },
	});
});
Badge$1.displayName = "Badge";
var Box = chakra("div");
Box.displayName = "Box";
var Square = forwardRef(function (et, tt) {
	const { size: nt, centerContent: rt = !0, ...it } = et;
	return jsx(Box, {
		ref: tt,
		boxSize: nt,
		__css: {
			...(rt ? { display: "flex", alignItems: "center", justifyContent: "center" } : {}),
			flexShrink: 0,
			flexGrow: 0,
		},
		...it,
	});
});
Square.displayName = "Square";
var Circle = forwardRef(function (et, tt) {
	const { size: nt, ...rt } = et;
	return jsx(Square, { size: nt, ref: tt, borderRadius: "9999px", ...rt });
});
Circle.displayName = "Circle";
var Center = chakra("div", { baseStyle: { display: "flex", alignItems: "center", justifyContent: "center" } });
Center.displayName = "Center";
var centerStyles = {
	horizontal: { insetStart: "50%", transform: "translateX(-50%)" },
	vertical: { top: "50%", transform: "translateY(-50%)" },
	both: { insetStart: "50%", top: "50%", transform: "translate(-50%, -50%)" },
};
forwardRef(function (et, tt) {
	const { axis: nt = "both", ...rt } = et;
	return React$1.createElement(chakra.div, { ref: tt, __css: centerStyles[nt], ...rt, position: "absolute" });
});
var Code = forwardRef(function (et, tt) {
	const nt = useStyleConfig("Code", et),
		{ className: rt, ...it } = omitThemingProps(et);
	return React$1.createElement(chakra.code, {
		ref: tt,
		className: cx$a("chakra-code", et.className),
		...it,
		__css: { display: "inline-block", ...nt },
	});
});
Code.displayName = "Code";
var Container$1 = forwardRef(function (et, tt) {
	const { className: nt, centerContent: rt, ...it } = omitThemingProps(et),
		ot = useStyleConfig("Container", et);
	return React$1.createElement(chakra.div, {
		ref: tt,
		className: cx$a("chakra-container", nt),
		...it,
		__css: { ...ot, ...(rt && { display: "flex", flexDirection: "column", alignItems: "center" }) },
	});
});
Container$1.displayName = "Container";
var Divider = forwardRef(function (et, tt) {
	const {
			borderLeftWidth: nt,
			borderBottomWidth: rt,
			borderTopWidth: it,
			borderRightWidth: ot,
			borderWidth: at,
			borderStyle: st,
			borderColor: lt,
			...ut
		} = useStyleConfig("Divider", et),
		{ className: dt, orientation: ct = "horizontal", __css: ft, ...mt } = omitThemingProps(et),
		pt = {
			vertical: { borderLeftWidth: nt || ot || at || "1px", height: "100%" },
			horizontal: { borderBottomWidth: rt || it || at || "1px", width: "100%" },
		};
	return React$1.createElement(chakra.hr, {
		ref: tt,
		"aria-orientation": ct,
		...mt,
		__css: { ...ut, border: "0", borderColor: lt, borderStyle: st, ...pt[ct], ...ft },
		className: cx$a("chakra-divider", dt),
	});
});
Divider.displayName = "Divider";
var Flex = forwardRef(function (et, tt) {
	const { direction: nt, align: rt, justify: it, wrap: ot, basis: at, grow: st, shrink: lt, ...ut } = et,
		dt = {
			display: "flex",
			flexDirection: nt,
			alignItems: rt,
			justifyContent: it,
			flexWrap: ot,
			flexBasis: at,
			flexGrow: st,
			flexShrink: lt,
		};
	return React$1.createElement(chakra.div, { ref: tt, __css: dt, ...ut });
});
Flex.displayName = "Flex";
var Grid = forwardRef(function (et, tt) {
	const {
			templateAreas: nt,
			gap: rt,
			rowGap: it,
			columnGap: ot,
			column: at,
			row: st,
			autoFlow: lt,
			autoRows: ut,
			templateRows: dt,
			autoColumns: ct,
			templateColumns: ft,
			...mt
		} = et,
		pt = {
			display: "grid",
			gridTemplateAreas: nt,
			gridGap: rt,
			gridRowGap: it,
			gridColumnGap: ot,
			gridAutoColumns: ct,
			gridColumn: at,
			gridRow: st,
			gridAutoFlow: lt,
			gridAutoRows: ut,
			gridTemplateRows: dt,
			gridTemplateColumns: ft,
		};
	return React$1.createElement(chakra.div, { ref: tt, __css: pt, ...mt });
});
Grid.displayName = "Grid";
function spanFn(_) {
	return mapResponsive(_, (et) => (et === "auto" ? "auto" : `span ${et}/span ${et}`));
}
var GridItem = forwardRef(function (et, tt) {
	const { area: nt, colSpan: rt, colStart: it, colEnd: ot, rowEnd: at, rowSpan: st, rowStart: lt, ...ut } = et,
		dt = compact({
			gridArea: nt,
			gridColumn: spanFn(rt),
			gridRow: spanFn(st),
			gridColumnStart: it,
			gridColumnEnd: ot,
			gridRowStart: lt,
			gridRowEnd: at,
		});
	return React$1.createElement(chakra.div, { ref: tt, __css: dt, ...ut });
});
GridItem.displayName = "GridItem";
var Heading = forwardRef(function (et, tt) {
	const nt = useStyleConfig("Heading", et),
		{ className: rt, ...it } = omitThemingProps(et);
	return React$1.createElement(chakra.h2, {
		ref: tt,
		className: cx$a("chakra-heading", et.className),
		...it,
		__css: nt,
	});
});
Heading.displayName = "Heading";
forwardRef(function (et, tt) {
	const nt = useStyleConfig("Mark", et),
		rt = omitThemingProps(et);
	return jsx(Box, { ref: tt, ...rt, as: "mark", __css: { bg: "transparent", whiteSpace: "nowrap", ...nt } });
});
var Kbd = forwardRef(function (et, tt) {
	const nt = useStyleConfig("Kbd", et),
		{ className: rt, ...it } = omitThemingProps(et);
	return React$1.createElement(chakra.kbd, {
		ref: tt,
		className: cx$a("chakra-kbd", rt),
		...it,
		__css: { fontFamily: "mono", ...nt },
	});
});
Kbd.displayName = "Kbd";
var Link = forwardRef(function (et, tt) {
	const nt = useStyleConfig("Link", et),
		{ className: rt, isExternal: it, ...ot } = omitThemingProps(et);
	return React$1.createElement(chakra.a, {
		target: it ? "_blank" : void 0,
		rel: it ? "noopener" : void 0,
		ref: tt,
		className: cx$a("chakra-link", rt),
		...ot,
		__css: nt,
	});
});
Link.displayName = "Link";
forwardRef(function (et, tt) {
	const { isExternal: nt, target: rt, rel: it, className: ot, ...at } = et;
	return React$1.createElement(chakra.a, {
		...at,
		ref: tt,
		className: cx$a("chakra-linkbox__overlay", ot),
		rel: nt ? "noopener noreferrer" : it,
		target: nt ? "_blank" : rt,
		__css: {
			position: "static",
			"&::before": {
				content: "''",
				cursor: "inherit",
				display: "block",
				position: "absolute",
				top: 0,
				left: 0,
				zIndex: 0,
				width: "100%",
				height: "100%",
			},
		},
	});
});
forwardRef(function (et, tt) {
	const { className: nt, ...rt } = et;
	return React$1.createElement(chakra.div, {
		ref: tt,
		position: "relative",
		...rt,
		className: cx$a("chakra-linkbox", nt),
		__css: { "a[href]:not(.chakra-linkbox__overlay), abbr[title]": { position: "relative", zIndex: 1 } },
	});
});
var [ListStylesProvider, useListStyles] = createContext({
		name: "ListStylesContext",
		errorMessage: `useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `,
	}),
	List = forwardRef(function (et, tt) {
		const nt = useMultiStyleConfig("List", et),
			{ children: rt, styleType: it = "none", stylePosition: ot, spacing: at, ...st } = omitThemingProps(et),
			lt = getValidChildren(rt),
			dt = at ? { ["& > *:not(style) ~ *:not(style)"]: { mt: at } } : {};
		return React$1.createElement(
			ListStylesProvider,
			{ value: nt },
			React$1.createElement(
				chakra.ul,
				{ ref: tt, listStyleType: it, listStylePosition: ot, role: "list", __css: { ...nt.container, ...dt }, ...st },
				lt
			)
		);
	});
List.displayName = "List";
var OrderedList = forwardRef((_, et) => {
	const { as: tt, ...nt } = _;
	return jsx(List, { ref: et, as: "ol", styleType: "decimal", marginStart: "1em", ...nt });
});
OrderedList.displayName = "OrderedList";
var UnorderedList = forwardRef(function (et, tt) {
	const { as: nt, ...rt } = et;
	return jsx(List, { ref: tt, as: "ul", styleType: "initial", marginStart: "1em", ...rt });
});
UnorderedList.displayName = "UnorderedList";
var ListItem = forwardRef(function (et, tt) {
	const nt = useListStyles();
	return React$1.createElement(chakra.li, { ref: tt, ...et, __css: nt.item });
});
ListItem.displayName = "ListItem";
var ListIcon = forwardRef(function (et, tt) {
	const nt = useListStyles();
	return jsx(Icon, { ref: tt, role: "presentation", ...et, __css: nt.icon });
});
ListIcon.displayName = "ListIcon";
var SimpleGrid = forwardRef(function (et, tt) {
	const { columns: nt, spacingX: rt, spacingY: it, spacing: ot, minChildWidth: at, ...st } = et,
		lt = useTheme(),
		ut = at ? widthToColumns(at, lt) : countToColumns(nt);
	return jsx(Grid, { ref: tt, gap: ot, columnGap: rt, rowGap: it, templateColumns: ut, ...st });
});
SimpleGrid.displayName = "SimpleGrid";
function toPx(_) {
	return typeof _ == "number" ? `${_}px` : _;
}
function widthToColumns(_, et) {
	return mapResponsive(_, (tt) => {
		const nt = getToken("sizes", tt, toPx(tt))(et);
		return tt === null ? null : `repeat(auto-fit, minmax(${nt}, 1fr))`;
	});
}
function countToColumns(_) {
	return mapResponsive(_, (et) => (et === null ? null : `repeat(${et}, minmax(0, 1fr))`));
}
var Spacer = chakra("div", { baseStyle: { flex: 1, justifySelf: "stretch", alignSelf: "stretch" } });
Spacer.displayName = "Spacer";
var selector = "& > *:not(style) ~ *:not(style)";
function getStackStyles(_) {
	const { spacing: et, direction: tt } = _,
		nt = {
			column: { marginTop: et, marginEnd: 0, marginBottom: 0, marginStart: 0 },
			row: { marginTop: 0, marginEnd: 0, marginBottom: 0, marginStart: et },
			"column-reverse": { marginTop: 0, marginEnd: 0, marginBottom: et, marginStart: 0 },
			"row-reverse": { marginTop: 0, marginEnd: et, marginBottom: 0, marginStart: 0 },
		};
	return { flexDirection: tt, [selector]: mapResponsive(tt, (rt) => nt[rt]) };
}
function getDividerStyles(_) {
	const { spacing: et, direction: tt } = _,
		nt = {
			column: { my: et, mx: 0, borderLeftWidth: 0, borderBottomWidth: "1px" },
			"column-reverse": { my: et, mx: 0, borderLeftWidth: 0, borderBottomWidth: "1px" },
			row: { mx: et, my: 0, borderLeftWidth: "1px", borderBottomWidth: 0 },
			"row-reverse": { mx: et, my: 0, borderLeftWidth: "1px", borderBottomWidth: 0 },
		};
	return { "&": mapResponsive(tt, (rt) => nt[rt]) };
}
var StackItem = (_) =>
	React$1.createElement(chakra.div, {
		className: "chakra-stack__item",
		..._,
		__css: { display: "inline-block", flex: "0 0 auto", minWidth: 0, ..._.__css },
	});
StackItem.displayName = "StackItem";
var Stack = forwardRef((_, et) => {
	const {
			isInline: tt,
			direction: nt,
			align: rt,
			justify: it,
			spacing: ot = "0.5rem",
			wrap: at,
			children: st,
			divider: lt,
			className: ut,
			shouldWrapChildren: dt,
			...ct
		} = _,
		ft = tt ? "row" : nt != null ? nt : "column",
		mt = react.exports.useMemo(() => getStackStyles({ direction: ft, spacing: ot }), [ft, ot]),
		pt = react.exports.useMemo(() => getDividerStyles({ spacing: ot, direction: ft }), [ot, ft]),
		vt = !!lt,
		ht = !dt && !vt,
		gt = getValidChildren(st),
		yt = ht
			? gt
			: gt.map((St, wt) => {
					const Ct = typeof St.key < "u" ? St.key : wt,
						Et = wt + 1 === gt.length,
						$t = dt ? jsx(StackItem, { children: St }, Ct) : St;
					if (!vt) return $t;
					const At = react.exports.cloneElement(lt, { __css: pt }),
						Lt = Et ? null : At;
					return jsxs(react.exports.Fragment, { children: [$t, Lt] }, Ct);
			  }),
		xt = cx$a("chakra-stack", ut);
	return React$1.createElement(
		chakra.div,
		{
			ref: et,
			display: "flex",
			alignItems: rt,
			justifyContent: it,
			flexDirection: mt.flexDirection,
			flexWrap: at,
			className: xt,
			__css: vt ? {} : { [selector]: mt[selector] },
			...ct,
		},
		yt
	);
});
Stack.displayName = "Stack";
var HStack = forwardRef((_, et) => jsx(Stack, { align: "center", ..._, direction: "row", ref: et }));
HStack.displayName = "HStack";
var VStack = forwardRef((_, et) => jsx(Stack, { align: "center", ..._, direction: "column", ref: et }));
VStack.displayName = "VStack";
var Text$2 = forwardRef(function (et, tt) {
	const nt = useStyleConfig("Text", et),
		{ className: rt, align: it, decoration: ot, casing: at, ...st } = omitThemingProps(et),
		lt = compact({ textAlign: et.align, textDecoration: et.decoration, textTransform: et.casing });
	return React$1.createElement(chakra.p, {
		ref: tt,
		className: cx$a("chakra-text", et.className),
		...lt,
		...st,
		__css: nt,
	});
});
Text$2.displayName = "Text";
function px(_) {
	return typeof _ == "number" ? `${_}px` : _;
}
var Wrap = forwardRef(function (et, tt) {
	const {
			spacing: nt = "0.5rem",
			spacingX: rt,
			spacingY: it,
			children: ot,
			justify: at,
			direction: st,
			align: lt,
			className: ut,
			shouldWrapChildren: dt,
			...ct
		} = et,
		ft = react.exports.useMemo(() => {
			const { spacingX: pt = nt, spacingY: vt = nt } = { spacingX: rt, spacingY: it };
			return {
				"--chakra-wrap-x-spacing": (ht) => mapResponsive(pt, (gt) => px(tokenToCSSVar("space", gt)(ht))),
				"--chakra-wrap-y-spacing": (ht) => mapResponsive(vt, (gt) => px(tokenToCSSVar("space", gt)(ht))),
				"--wrap-x-spacing": "calc(var(--chakra-wrap-x-spacing) / 2)",
				"--wrap-y-spacing": "calc(var(--chakra-wrap-y-spacing) / 2)",
				display: "flex",
				flexWrap: "wrap",
				justifyContent: at,
				alignItems: lt,
				flexDirection: st,
				listStyleType: "none",
				padding: "0",
				margin: "calc(var(--wrap-y-spacing) * -1) calc(var(--wrap-x-spacing) * -1)",
				"& > *:not(style)": { margin: "var(--wrap-y-spacing) var(--wrap-x-spacing)" },
			};
		}, [nt, rt, it, at, lt, st]),
		mt = dt ? react.exports.Children.map(ot, (pt, vt) => jsx(WrapItem, { children: pt }, vt)) : ot;
	return React$1.createElement(
		chakra.div,
		{ ref: tt, className: cx$a("chakra-wrap", ut), overflow: "hidden", ...ct },
		React$1.createElement(chakra.ul, { className: "chakra-wrap__list", __css: ft }, mt)
	);
});
Wrap.displayName = "Wrap";
var WrapItem = forwardRef(function (et, tt) {
	const { className: nt, ...rt } = et;
	return React$1.createElement(chakra.li, {
		ref: tt,
		__css: { display: "flex", alignItems: "flex-start" },
		className: cx$a("chakra-wrap__listitem", nt),
		...rt,
	});
});
WrapItem.displayName = "WrapItem";
var doc = {
		body: { classList: { add() {}, remove() {} } },
		addEventListener() {},
		removeEventListener() {},
		activeElement: { blur() {}, nodeName: "" },
		querySelector() {
			return null;
		},
		querySelectorAll() {
			return [];
		},
		getElementById() {
			return null;
		},
		createEvent() {
			return { initEvent() {} };
		},
		createElement() {
			return {
				children: [],
				childNodes: [],
				style: {},
				setAttribute() {},
				getElementsByTagName() {
					return [];
				},
			};
		},
	},
	ssrDocument = doc,
	noop$3 = () => {},
	win = {
		document: ssrDocument,
		navigator: { userAgent: "" },
		CustomEvent: function () {
			return this;
		},
		addEventListener: noop$3,
		removeEventListener: noop$3,
		getComputedStyle() {
			return {
				getPropertyValue() {
					return "";
				},
			};
		},
		matchMedia() {
			return { matches: !1, addListener: noop$3, removeListener: noop$3 };
		},
		requestAnimationFrame(_) {
			return typeof setTimeout > "u" ? (_(), null) : setTimeout(_, 0);
		},
		cancelAnimationFrame(_) {
			typeof setTimeout > "u" || clearTimeout(_);
		},
		setTimeout: () => 0,
		clearTimeout: noop$3,
		setInterval: () => 0,
		clearInterval: noop$3,
	},
	ssrWindow = win,
	mockEnv = { window: ssrWindow, document: ssrDocument },
	defaultEnv = typeof window < "u" ? { window, document } : mockEnv,
	EnvironmentContext = react.exports.createContext(defaultEnv);
EnvironmentContext.displayName = "EnvironmentContext";
function EnvironmentProvider(_) {
	const { children: et, environment: tt } = _,
		[nt, rt] = react.exports.useState(null),
		[it, ot] = react.exports.useState(!1);
	react.exports.useEffect(() => ot(!0), []);
	const at = react.exports.useMemo(() => {
		if (tt) return tt;
		const st = nt == null ? void 0 : nt.ownerDocument,
			lt = nt == null ? void 0 : nt.ownerDocument.defaultView;
		return st ? { document: st, window: lt } : defaultEnv;
	}, [nt, tt]);
	return jsxs(EnvironmentContext.Provider, {
		value: at,
		children: [
			et,
			!tt &&
				it &&
				jsx("span", {
					id: "__chakra_env",
					hidden: !0,
					ref: (st) => {
						react.exports.startTransition(() => {
							st && rt(st);
						});
					},
				}),
		],
	});
}
EnvironmentProvider.displayName = "EnvironmentProvider";
var dataAttr$1 = (_) => (_ ? "" : void 0);
function useEventListeners() {
	const _ = react.exports.useRef(new Map()),
		et = _.current,
		tt = react.exports.useCallback((rt, it, ot, at) => {
			_.current.set(ot, { type: it, el: rt, options: at }), rt.addEventListener(it, ot, at);
		}, []),
		nt = react.exports.useCallback((rt, it, ot, at) => {
			rt.removeEventListener(it, ot, at), _.current.delete(ot);
		}, []);
	return (
		react.exports.useEffect(
			() => () => {
				et.forEach((rt, it) => {
					nt(rt.el, rt.type, it, rt.options);
				});
			},
			[nt, et]
		),
		{ add: tt, remove: nt }
	);
}
function isValidElement(_) {
	const et = _.target,
		{ tagName: tt, isContentEditable: nt } = et;
	return tt !== "INPUT" && tt !== "TEXTAREA" && nt !== !0;
}
function useClickable(_ = {}) {
	const {
			ref: et,
			isDisabled: tt,
			isFocusable: nt,
			clickOnEnter: rt = !0,
			clickOnSpace: it = !0,
			onMouseDown: ot,
			onMouseUp: at,
			onClick: st,
			onKeyDown: lt,
			onKeyUp: ut,
			tabIndex: dt,
			onMouseOver: ct,
			onMouseLeave: ft,
			...mt
		} = _,
		[pt, vt] = react.exports.useState(!0),
		[ht, gt] = react.exports.useState(!1),
		yt = useEventListeners(),
		xt = (jt) => {
			!jt || (jt.tagName !== "BUTTON" && vt(!1));
		},
		St = pt ? dt : dt || 0,
		wt = tt && !nt,
		Ct = react.exports.useCallback(
			(jt) => {
				if (tt) {
					jt.stopPropagation(), jt.preventDefault();
					return;
				}
				jt.currentTarget.focus(), st == null || st(jt);
			},
			[tt, st]
		),
		Et = react.exports.useCallback(
			(jt) => {
				ht &&
					isValidElement(jt) &&
					(jt.preventDefault(), jt.stopPropagation(), gt(!1), yt.remove(document, "keyup", Et, !1));
			},
			[ht, yt]
		),
		_t = react.exports.useCallback(
			(jt) => {
				if ((lt == null || lt(jt), tt || jt.defaultPrevented || jt.metaKey || !isValidElement(jt.nativeEvent) || pt))
					return;
				const It = rt && jt.key === "Enter";
				it && jt.key === " " && (jt.preventDefault(), gt(!0)),
					It && (jt.preventDefault(), jt.currentTarget.click()),
					yt.add(document, "keyup", Et, !1);
			},
			[tt, pt, lt, rt, it, yt, Et]
		),
		$t = react.exports.useCallback(
			(jt) => {
				if ((ut == null || ut(jt), tt || jt.defaultPrevented || jt.metaKey || !isValidElement(jt.nativeEvent) || pt))
					return;
				it && jt.key === " " && (jt.preventDefault(), gt(!1), jt.currentTarget.click());
			},
			[it, pt, tt, ut]
		),
		At = react.exports.useCallback(
			(jt) => {
				jt.button === 0 && (gt(!1), yt.remove(document, "mouseup", At, !1));
			},
			[yt]
		),
		Lt = react.exports.useCallback(
			(jt) => {
				if (jt.button !== 0) return;
				if (tt) {
					jt.stopPropagation(), jt.preventDefault();
					return;
				}
				pt || gt(!0),
					jt.currentTarget.focus({ preventScroll: !0 }),
					yt.add(document, "mouseup", At, !1),
					ot == null || ot(jt);
			},
			[tt, pt, ot, yt, At]
		),
		Nt = react.exports.useCallback(
			(jt) => {
				jt.button === 0 && (pt || gt(!1), at == null || at(jt));
			},
			[at, pt]
		),
		Ft = react.exports.useCallback(
			(jt) => {
				if (tt) {
					jt.preventDefault();
					return;
				}
				ct == null || ct(jt);
			},
			[tt, ct]
		),
		Gt = react.exports.useCallback(
			(jt) => {
				ht && (jt.preventDefault(), gt(!1)), ft == null || ft(jt);
			},
			[ht, ft]
		),
		Bt = mergeRefs(et, xt);
	return pt
		? {
				...mt,
				ref: Bt,
				type: "button",
				"aria-disabled": wt ? void 0 : tt,
				disabled: wt,
				onClick: Ct,
				onMouseDown: ot,
				onMouseUp: at,
				onKeyUp: ut,
				onKeyDown: lt,
				onMouseOver: ct,
				onMouseLeave: ft,
		  }
		: {
				...mt,
				ref: Bt,
				role: "button",
				"data-active": dataAttr$1(ht),
				"aria-disabled": tt ? "true" : void 0,
				tabIndex: wt ? void 0 : St,
				onClick: Ct,
				onMouseDown: Lt,
				onMouseUp: Nt,
				onKeyUp: $t,
				onKeyDown: _t,
				onMouseOver: Ft,
				onMouseLeave: Gt,
		  };
}
function isElement$4(_) {
	return _ != null && typeof _ == "object" && "nodeType" in _ && _.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement$2(_) {
	var tt;
	if (!isElement$4(_)) return !1;
	const et = (tt = _.ownerDocument.defaultView) != null ? tt : window;
	return _ instanceof et.HTMLElement;
}
function getOwnerWindow(_) {
	var tt;
	var et;
	return (tt = (et = getOwnerDocument$2(_)) == null ? void 0 : et.defaultView) != null ? tt : window;
}
function getOwnerDocument$2(_) {
	return isElement$4(_) ? _.ownerDocument : document;
}
function getActiveElement$1(_) {
	return getOwnerDocument$2(_).activeElement;
}
var hasTabIndex = (_) => _.hasAttribute("tabindex"),
	hasNegativeTabIndex = (_) => hasTabIndex(_) && _.tabIndex === -1;
function isDisabled(_) {
	return Boolean(_.getAttribute("disabled")) === !0 || Boolean(_.getAttribute("aria-disabled")) === !0;
}
function isHidden(_) {
	return _.parentElement && isHidden(_.parentElement) ? !0 : _.hidden;
}
function isContentEditable(_) {
	const et = _.getAttribute("contenteditable");
	return et !== "false" && et != null;
}
function isFocusable(_) {
	if (!isHTMLElement$2(_) || isHidden(_) || isDisabled(_)) return !1;
	const { localName: et } = _;
	if (["input", "select", "textarea", "button"].indexOf(et) >= 0) return !0;
	const nt = {
		a: () => _.hasAttribute("href"),
		audio: () => _.hasAttribute("controls"),
		video: () => _.hasAttribute("controls"),
	};
	return et in nt ? nt[et]() : isContentEditable(_) ? !0 : hasTabIndex(_);
}
function isTabbable(_) {
	return _ ? isHTMLElement$2(_) && isFocusable(_) && !hasNegativeTabIndex(_) : !1;
}
var focusableElList = [
		"input:not([disabled])",
		"select:not([disabled])",
		"textarea:not([disabled])",
		"embed",
		"iframe",
		"object",
		"a[href]",
		"area[href]",
		"button:not([disabled])",
		"[tabindex]",
		"audio[controls]",
		"video[controls]",
		"*[tabindex]:not([aria-disabled])",
		"*[contenteditable]",
	],
	focusableElSelector = focusableElList.join(),
	isVisible$1 = (_) => _.offsetWidth > 0 && _.offsetHeight > 0;
function getAllFocusable(_) {
	const et = Array.from(_.querySelectorAll(focusableElSelector));
	return et.unshift(_), et.filter((tt) => isFocusable(tt) && isVisible$1(tt));
}
function preventReturnFocus(_) {
	const et = _.current;
	if (!et) return !1;
	const tt = getActiveElement$1(et);
	return !tt || et.contains(tt) ? !1 : !!isTabbable(tt);
}
function useFocusOnHide(_, et) {
	const { shouldFocus: tt, visible: nt, focusRef: rt } = et,
		it = tt && !nt;
	useUpdateEffect$1(() => {
		if (!it || preventReturnFocus(_)) return;
		const ot = (rt == null ? void 0 : rt.current) || _.current;
		ot &&
			requestAnimationFrame(() => {
				ot.focus();
			});
	}, [it, _, rt]);
}
var top = "top",
	bottom = "bottom",
	right = "right",
	left = "left",
	auto = "auto",
	basePlacements = [top, bottom, right, left],
	start = "start",
	end = "end",
	clippingParents = "clippingParents",
	viewport = "viewport",
	popper = "popper",
	reference = "reference",
	variationPlacements = basePlacements.reduce(function (_, et) {
		return _.concat([et + "-" + start, et + "-" + end]);
	}, []),
	placements = [].concat(basePlacements, [auto]).reduce(function (_, et) {
		return _.concat([et, et + "-" + start, et + "-" + end]);
	}, []),
	beforeRead = "beforeRead",
	read = "read",
	afterRead = "afterRead",
	beforeMain = "beforeMain",
	main = "main",
	afterMain = "afterMain",
	beforeWrite = "beforeWrite",
	write = "write",
	afterWrite = "afterWrite",
	modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(_) {
	return _ ? (_.nodeName || "").toLowerCase() : null;
}
function getWindow$1(_) {
	if (_ == null) return window;
	if (_.toString() !== "[object Window]") {
		var et = _.ownerDocument;
		return (et && et.defaultView) || window;
	}
	return _;
}
function isElement$3(_) {
	var et = getWindow$1(_).Element;
	return _ instanceof et || _ instanceof Element;
}
function isHTMLElement$1(_) {
	var et = getWindow$1(_).HTMLElement;
	return _ instanceof et || _ instanceof HTMLElement;
}
function isShadowRoot(_) {
	if (typeof ShadowRoot > "u") return !1;
	var et = getWindow$1(_).ShadowRoot;
	return _ instanceof et || _ instanceof ShadowRoot;
}
function applyStyles(_) {
	var et = _.state;
	Object.keys(et.elements).forEach(function (tt) {
		var nt = et.styles[tt] || {},
			rt = et.attributes[tt] || {},
			it = et.elements[tt];
		!isHTMLElement$1(it) ||
			!getNodeName(it) ||
			(Object.assign(it.style, nt),
			Object.keys(rt).forEach(function (ot) {
				var at = rt[ot];
				at === !1 ? it.removeAttribute(ot) : it.setAttribute(ot, at === !0 ? "" : at);
			}));
	});
}
function effect$2(_) {
	var et = _.state,
		tt = {
			popper: { position: et.options.strategy, left: "0", top: "0", margin: "0" },
			arrow: { position: "absolute" },
			reference: {},
		};
	return (
		Object.assign(et.elements.popper.style, tt.popper),
		(et.styles = tt),
		et.elements.arrow && Object.assign(et.elements.arrow.style, tt.arrow),
		function () {
			Object.keys(et.elements).forEach(function (nt) {
				var rt = et.elements[nt],
					it = et.attributes[nt] || {},
					ot = Object.keys(et.styles.hasOwnProperty(nt) ? et.styles[nt] : tt[nt]),
					at = ot.reduce(function (st, lt) {
						return (st[lt] = ""), st;
					}, {});
				!isHTMLElement$1(rt) ||
					!getNodeName(rt) ||
					(Object.assign(rt.style, at),
					Object.keys(it).forEach(function (st) {
						rt.removeAttribute(st);
					}));
			});
		}
	);
}
const applyStyles$1 = {
	name: "applyStyles",
	enabled: !0,
	phase: "write",
	fn: applyStyles,
	effect: effect$2,
	requires: ["computeStyles"],
};
function getBasePlacement(_) {
	return _.split("-")[0];
}
var max = Math.max,
	min = Math.min,
	round$1 = Math.round;
function getUAString() {
	var _ = navigator.userAgentData;
	return _ != null && _.brands
		? _.brands
				.map(function (et) {
					return et.brand + "/" + et.version;
				})
				.join(" ")
		: navigator.userAgent;
}
function isLayoutViewport() {
	return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(_, et, tt) {
	et === void 0 && (et = !1), tt === void 0 && (tt = !1);
	var nt = _.getBoundingClientRect(),
		rt = 1,
		it = 1;
	et &&
		isHTMLElement$1(_) &&
		((rt = (_.offsetWidth > 0 && round$1(nt.width) / _.offsetWidth) || 1),
		(it = (_.offsetHeight > 0 && round$1(nt.height) / _.offsetHeight) || 1));
	var ot = isElement$3(_) ? getWindow$1(_) : window,
		at = ot.visualViewport,
		st = !isLayoutViewport() && tt,
		lt = (nt.left + (st && at ? at.offsetLeft : 0)) / rt,
		ut = (nt.top + (st && at ? at.offsetTop : 0)) / it,
		dt = nt.width / rt,
		ct = nt.height / it;
	return { width: dt, height: ct, top: ut, right: lt + dt, bottom: ut + ct, left: lt, x: lt, y: ut };
}
function getLayoutRect(_) {
	var et = getBoundingClientRect(_),
		tt = _.offsetWidth,
		nt = _.offsetHeight;
	return (
		Math.abs(et.width - tt) <= 1 && (tt = et.width),
		Math.abs(et.height - nt) <= 1 && (nt = et.height),
		{ x: _.offsetLeft, y: _.offsetTop, width: tt, height: nt }
	);
}
function contains$2(_, et) {
	var tt = et.getRootNode && et.getRootNode();
	if (_.contains(et)) return !0;
	if (tt && isShadowRoot(tt)) {
		var nt = et;
		do {
			if (nt && _.isSameNode(nt)) return !0;
			nt = nt.parentNode || nt.host;
		} while (nt);
	}
	return !1;
}
function getComputedStyle$1(_) {
	return getWindow$1(_).getComputedStyle(_);
}
function isTableElement(_) {
	return ["table", "td", "th"].indexOf(getNodeName(_)) >= 0;
}
function getDocumentElement(_) {
	return ((isElement$3(_) ? _.ownerDocument : _.document) || window.document).documentElement;
}
function getParentNode$1(_) {
	return getNodeName(_) === "html"
		? _
		: _.assignedSlot || _.parentNode || (isShadowRoot(_) ? _.host : null) || getDocumentElement(_);
}
function getTrueOffsetParent(_) {
	return !isHTMLElement$1(_) || getComputedStyle$1(_).position === "fixed" ? null : _.offsetParent;
}
function getContainingBlock(_) {
	var et = /firefox/i.test(getUAString()),
		tt = /Trident/i.test(getUAString());
	if (tt && isHTMLElement$1(_)) {
		var nt = getComputedStyle$1(_);
		if (nt.position === "fixed") return null;
	}
	var rt = getParentNode$1(_);
	for (isShadowRoot(rt) && (rt = rt.host); isHTMLElement$1(rt) && ["html", "body"].indexOf(getNodeName(rt)) < 0; ) {
		var it = getComputedStyle$1(rt);
		if (
			it.transform !== "none" ||
			it.perspective !== "none" ||
			it.contain === "paint" ||
			["transform", "perspective"].indexOf(it.willChange) !== -1 ||
			(et && it.willChange === "filter") ||
			(et && it.filter && it.filter !== "none")
		)
			return rt;
		rt = rt.parentNode;
	}
	return null;
}
function getOffsetParent(_) {
	for (
		var et = getWindow$1(_), tt = getTrueOffsetParent(_);
		tt && isTableElement(tt) && getComputedStyle$1(tt).position === "static";

	)
		tt = getTrueOffsetParent(tt);
	return tt &&
		(getNodeName(tt) === "html" || (getNodeName(tt) === "body" && getComputedStyle$1(tt).position === "static"))
		? et
		: tt || getContainingBlock(_) || et;
}
function getMainAxisFromPlacement(_) {
	return ["top", "bottom"].indexOf(_) >= 0 ? "x" : "y";
}
function within(_, et, tt) {
	return max(_, min(et, tt));
}
function withinMaxClamp(_, et, tt) {
	var nt = within(_, et, tt);
	return nt > tt ? tt : nt;
}
function getFreshSideObject() {
	return { top: 0, right: 0, bottom: 0, left: 0 };
}
function mergePaddingObject(_) {
	return Object.assign({}, getFreshSideObject(), _);
}
function expandToHashMap(_, et) {
	return et.reduce(function (tt, nt) {
		return (tt[nt] = _), tt;
	}, {});
}
var toPaddingObject = function (et, tt) {
	return (
		(et = typeof et == "function" ? et(Object.assign({}, tt.rects, { placement: tt.placement })) : et),
		mergePaddingObject(typeof et != "number" ? et : expandToHashMap(et, basePlacements))
	);
};
function arrow(_) {
	var et,
		tt = _.state,
		nt = _.name,
		rt = _.options,
		it = tt.elements.arrow,
		ot = tt.modifiersData.popperOffsets,
		at = getBasePlacement(tt.placement),
		st = getMainAxisFromPlacement(at),
		lt = [left, right].indexOf(at) >= 0,
		ut = lt ? "height" : "width";
	if (!(!it || !ot)) {
		var dt = toPaddingObject(rt.padding, tt),
			ct = getLayoutRect(it),
			ft = st === "y" ? top : left,
			mt = st === "y" ? bottom : right,
			pt = tt.rects.reference[ut] + tt.rects.reference[st] - ot[st] - tt.rects.popper[ut],
			vt = ot[st] - tt.rects.reference[st],
			ht = getOffsetParent(it),
			gt = ht ? (st === "y" ? ht.clientHeight || 0 : ht.clientWidth || 0) : 0,
			yt = pt / 2 - vt / 2,
			xt = dt[ft],
			St = gt - ct[ut] - dt[mt],
			wt = gt / 2 - ct[ut] / 2 + yt,
			Ct = within(xt, wt, St),
			Et = st;
		tt.modifiersData[nt] = ((et = {}), (et[Et] = Ct), (et.centerOffset = Ct - wt), et);
	}
}
function effect$1(_) {
	var et = _.state,
		tt = _.options,
		nt = tt.element,
		rt = nt === void 0 ? "[data-popper-arrow]" : nt;
	rt != null &&
		((typeof rt == "string" && ((rt = et.elements.popper.querySelector(rt)), !rt)) ||
			!contains$2(et.elements.popper, rt) ||
			(et.elements.arrow = rt));
}
const arrow$1 = {
	name: "arrow",
	enabled: !0,
	phase: "main",
	fn: arrow,
	effect: effect$1,
	requires: ["popperOffsets"],
	requiresIfExists: ["preventOverflow"],
};
function getVariation(_) {
	return _.split("-")[1];
}
var unsetSides = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function roundOffsetsByDPR(_) {
	var et = _.x,
		tt = _.y,
		nt = window,
		rt = nt.devicePixelRatio || 1;
	return { x: round$1(et * rt) / rt || 0, y: round$1(tt * rt) / rt || 0 };
}
function mapToStyles(_) {
	var et,
		tt = _.popper,
		nt = _.popperRect,
		rt = _.placement,
		it = _.variation,
		ot = _.offsets,
		at = _.position,
		st = _.gpuAcceleration,
		lt = _.adaptive,
		ut = _.roundOffsets,
		dt = _.isFixed,
		ct = ot.x,
		ft = ct === void 0 ? 0 : ct,
		mt = ot.y,
		pt = mt === void 0 ? 0 : mt,
		vt = typeof ut == "function" ? ut({ x: ft, y: pt }) : { x: ft, y: pt };
	(ft = vt.x), (pt = vt.y);
	var ht = ot.hasOwnProperty("x"),
		gt = ot.hasOwnProperty("y"),
		yt = left,
		xt = top,
		St = window;
	if (lt) {
		var wt = getOffsetParent(tt),
			Ct = "clientHeight",
			Et = "clientWidth";
		if (
			(wt === getWindow$1(tt) &&
				((wt = getDocumentElement(tt)),
				getComputedStyle$1(wt).position !== "static" &&
					at === "absolute" &&
					((Ct = "scrollHeight"), (Et = "scrollWidth"))),
			(wt = wt),
			rt === top || ((rt === left || rt === right) && it === end))
		) {
			xt = bottom;
			var _t = dt && wt === St && St.visualViewport ? St.visualViewport.height : wt[Ct];
			(pt -= _t - nt.height), (pt *= st ? 1 : -1);
		}
		if (rt === left || ((rt === top || rt === bottom) && it === end)) {
			yt = right;
			var $t = dt && wt === St && St.visualViewport ? St.visualViewport.width : wt[Et];
			(ft -= $t - nt.width), (ft *= st ? 1 : -1);
		}
	}
	var At = Object.assign({ position: at }, lt && unsetSides),
		Lt = ut === !0 ? roundOffsetsByDPR({ x: ft, y: pt }) : { x: ft, y: pt };
	if (((ft = Lt.x), (pt = Lt.y), st)) {
		var Nt;
		return Object.assign(
			{},
			At,
			((Nt = {}),
			(Nt[xt] = gt ? "0" : ""),
			(Nt[yt] = ht ? "0" : ""),
			(Nt.transform =
				(St.devicePixelRatio || 1) <= 1
					? "translate(" + ft + "px, " + pt + "px)"
					: "translate3d(" + ft + "px, " + pt + "px, 0)"),
			Nt)
		);
	}
	return Object.assign(
		{},
		At,
		((et = {}), (et[xt] = gt ? pt + "px" : ""), (et[yt] = ht ? ft + "px" : ""), (et.transform = ""), et)
	);
}
function computeStyles(_) {
	var et = _.state,
		tt = _.options,
		nt = tt.gpuAcceleration,
		rt = nt === void 0 ? !0 : nt,
		it = tt.adaptive,
		ot = it === void 0 ? !0 : it,
		at = tt.roundOffsets,
		st = at === void 0 ? !0 : at,
		lt = {
			placement: getBasePlacement(et.placement),
			variation: getVariation(et.placement),
			popper: et.elements.popper,
			popperRect: et.rects.popper,
			gpuAcceleration: rt,
			isFixed: et.options.strategy === "fixed",
		};
	et.modifiersData.popperOffsets != null &&
		(et.styles.popper = Object.assign(
			{},
			et.styles.popper,
			mapToStyles(
				Object.assign({}, lt, {
					offsets: et.modifiersData.popperOffsets,
					position: et.options.strategy,
					adaptive: ot,
					roundOffsets: st,
				})
			)
		)),
		et.modifiersData.arrow != null &&
			(et.styles.arrow = Object.assign(
				{},
				et.styles.arrow,
				mapToStyles(
					Object.assign({}, lt, {
						offsets: et.modifiersData.arrow,
						position: "absolute",
						adaptive: !1,
						roundOffsets: st,
					})
				)
			)),
		(et.attributes.popper = Object.assign({}, et.attributes.popper, { "data-popper-placement": et.placement }));
}
const computeStyles$1 = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: computeStyles, data: {} };
var passive = { passive: !0 };
function effect(_) {
	var et = _.state,
		tt = _.instance,
		nt = _.options,
		rt = nt.scroll,
		it = rt === void 0 ? !0 : rt,
		ot = nt.resize,
		at = ot === void 0 ? !0 : ot,
		st = getWindow$1(et.elements.popper),
		lt = [].concat(et.scrollParents.reference, et.scrollParents.popper);
	return (
		it &&
			lt.forEach(function (ut) {
				ut.addEventListener("scroll", tt.update, passive);
			}),
		at && st.addEventListener("resize", tt.update, passive),
		function () {
			it &&
				lt.forEach(function (ut) {
					ut.removeEventListener("scroll", tt.update, passive);
				}),
				at && st.removeEventListener("resize", tt.update, passive);
		}
	);
}
const eventListeners = { name: "eventListeners", enabled: !0, phase: "write", fn: function () {}, effect, data: {} };
var hash$1 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function getOppositePlacement(_) {
	return _.replace(/left|right|bottom|top/g, function (et) {
		return hash$1[et];
	});
}
var hash = { start: "end", end: "start" };
function getOppositeVariationPlacement(_) {
	return _.replace(/start|end/g, function (et) {
		return hash[et];
	});
}
function getWindowScroll(_) {
	var et = getWindow$1(_),
		tt = et.pageXOffset,
		nt = et.pageYOffset;
	return { scrollLeft: tt, scrollTop: nt };
}
function getWindowScrollBarX(_) {
	return getBoundingClientRect(getDocumentElement(_)).left + getWindowScroll(_).scrollLeft;
}
function getViewportRect(_, et) {
	var tt = getWindow$1(_),
		nt = getDocumentElement(_),
		rt = tt.visualViewport,
		it = nt.clientWidth,
		ot = nt.clientHeight,
		at = 0,
		st = 0;
	if (rt) {
		(it = rt.width), (ot = rt.height);
		var lt = isLayoutViewport();
		(lt || (!lt && et === "fixed")) && ((at = rt.offsetLeft), (st = rt.offsetTop));
	}
	return { width: it, height: ot, x: at + getWindowScrollBarX(_), y: st };
}
function getDocumentRect(_) {
	var et,
		tt = getDocumentElement(_),
		nt = getWindowScroll(_),
		rt = (et = _.ownerDocument) == null ? void 0 : et.body,
		it = max(tt.scrollWidth, tt.clientWidth, rt ? rt.scrollWidth : 0, rt ? rt.clientWidth : 0),
		ot = max(tt.scrollHeight, tt.clientHeight, rt ? rt.scrollHeight : 0, rt ? rt.clientHeight : 0),
		at = -nt.scrollLeft + getWindowScrollBarX(_),
		st = -nt.scrollTop;
	return (
		getComputedStyle$1(rt || tt).direction === "rtl" && (at += max(tt.clientWidth, rt ? rt.clientWidth : 0) - it),
		{ width: it, height: ot, x: at, y: st }
	);
}
function isScrollParent(_) {
	var et = getComputedStyle$1(_),
		tt = et.overflow,
		nt = et.overflowX,
		rt = et.overflowY;
	return /auto|scroll|overlay|hidden/.test(tt + rt + nt);
}
function getScrollParent(_) {
	return ["html", "body", "#document"].indexOf(getNodeName(_)) >= 0
		? _.ownerDocument.body
		: isHTMLElement$1(_) && isScrollParent(_)
		? _
		: getScrollParent(getParentNode$1(_));
}
function listScrollParents(_, et) {
	var tt;
	et === void 0 && (et = []);
	var nt = getScrollParent(_),
		rt = nt === ((tt = _.ownerDocument) == null ? void 0 : tt.body),
		it = getWindow$1(nt),
		ot = rt ? [it].concat(it.visualViewport || [], isScrollParent(nt) ? nt : []) : nt,
		at = et.concat(ot);
	return rt ? at : at.concat(listScrollParents(getParentNode$1(ot)));
}
function rectToClientRect(_) {
	return Object.assign({}, _, { left: _.x, top: _.y, right: _.x + _.width, bottom: _.y + _.height });
}
function getInnerBoundingClientRect(_, et) {
	var tt = getBoundingClientRect(_, !1, et === "fixed");
	return (
		(tt.top = tt.top + _.clientTop),
		(tt.left = tt.left + _.clientLeft),
		(tt.bottom = tt.top + _.clientHeight),
		(tt.right = tt.left + _.clientWidth),
		(tt.width = _.clientWidth),
		(tt.height = _.clientHeight),
		(tt.x = tt.left),
		(tt.y = tt.top),
		tt
	);
}
function getClientRectFromMixedType(_, et, tt) {
	return et === viewport
		? rectToClientRect(getViewportRect(_, tt))
		: isElement$3(et)
		? getInnerBoundingClientRect(et, tt)
		: rectToClientRect(getDocumentRect(getDocumentElement(_)));
}
function getClippingParents(_) {
	var et = listScrollParents(getParentNode$1(_)),
		tt = ["absolute", "fixed"].indexOf(getComputedStyle$1(_).position) >= 0,
		nt = tt && isHTMLElement$1(_) ? getOffsetParent(_) : _;
	return isElement$3(nt)
		? et.filter(function (rt) {
				return isElement$3(rt) && contains$2(rt, nt) && getNodeName(rt) !== "body";
		  })
		: [];
}
function getClippingRect(_, et, tt, nt) {
	var rt = et === "clippingParents" ? getClippingParents(_) : [].concat(et),
		it = [].concat(rt, [tt]),
		ot = it[0],
		at = it.reduce(function (st, lt) {
			var ut = getClientRectFromMixedType(_, lt, nt);
			return (
				(st.top = max(ut.top, st.top)),
				(st.right = min(ut.right, st.right)),
				(st.bottom = min(ut.bottom, st.bottom)),
				(st.left = max(ut.left, st.left)),
				st
			);
		}, getClientRectFromMixedType(_, ot, nt));
	return (at.width = at.right - at.left), (at.height = at.bottom - at.top), (at.x = at.left), (at.y = at.top), at;
}
function computeOffsets(_) {
	var et = _.reference,
		tt = _.element,
		nt = _.placement,
		rt = nt ? getBasePlacement(nt) : null,
		it = nt ? getVariation(nt) : null,
		ot = et.x + et.width / 2 - tt.width / 2,
		at = et.y + et.height / 2 - tt.height / 2,
		st;
	switch (rt) {
		case top:
			st = { x: ot, y: et.y - tt.height };
			break;
		case bottom:
			st = { x: ot, y: et.y + et.height };
			break;
		case right:
			st = { x: et.x + et.width, y: at };
			break;
		case left:
			st = { x: et.x - tt.width, y: at };
			break;
		default:
			st = { x: et.x, y: et.y };
	}
	var lt = rt ? getMainAxisFromPlacement(rt) : null;
	if (lt != null) {
		var ut = lt === "y" ? "height" : "width";
		switch (it) {
			case start:
				st[lt] = st[lt] - (et[ut] / 2 - tt[ut] / 2);
				break;
			case end:
				st[lt] = st[lt] + (et[ut] / 2 - tt[ut] / 2);
				break;
		}
	}
	return st;
}
function detectOverflow(_, et) {
	et === void 0 && (et = {});
	var tt = et,
		nt = tt.placement,
		rt = nt === void 0 ? _.placement : nt,
		it = tt.strategy,
		ot = it === void 0 ? _.strategy : it,
		at = tt.boundary,
		st = at === void 0 ? clippingParents : at,
		lt = tt.rootBoundary,
		ut = lt === void 0 ? viewport : lt,
		dt = tt.elementContext,
		ct = dt === void 0 ? popper : dt,
		ft = tt.altBoundary,
		mt = ft === void 0 ? !1 : ft,
		pt = tt.padding,
		vt = pt === void 0 ? 0 : pt,
		ht = mergePaddingObject(typeof vt != "number" ? vt : expandToHashMap(vt, basePlacements)),
		gt = ct === popper ? reference : popper,
		yt = _.rects.popper,
		xt = _.elements[mt ? gt : ct],
		St = getClippingRect(isElement$3(xt) ? xt : xt.contextElement || getDocumentElement(_.elements.popper), st, ut, ot),
		wt = getBoundingClientRect(_.elements.reference),
		Ct = computeOffsets({ reference: wt, element: yt, strategy: "absolute", placement: rt }),
		Et = rectToClientRect(Object.assign({}, yt, Ct)),
		_t = ct === popper ? Et : wt,
		$t = {
			top: St.top - _t.top + ht.top,
			bottom: _t.bottom - St.bottom + ht.bottom,
			left: St.left - _t.left + ht.left,
			right: _t.right - St.right + ht.right,
		},
		At = _.modifiersData.offset;
	if (ct === popper && At) {
		var Lt = At[rt];
		Object.keys($t).forEach(function (Nt) {
			var Ft = [right, bottom].indexOf(Nt) >= 0 ? 1 : -1,
				Gt = [top, bottom].indexOf(Nt) >= 0 ? "y" : "x";
			$t[Nt] += Lt[Gt] * Ft;
		});
	}
	return $t;
}
function computeAutoPlacement(_, et) {
	et === void 0 && (et = {});
	var tt = et,
		nt = tt.placement,
		rt = tt.boundary,
		it = tt.rootBoundary,
		ot = tt.padding,
		at = tt.flipVariations,
		st = tt.allowedAutoPlacements,
		lt = st === void 0 ? placements : st,
		ut = getVariation(nt),
		dt = ut
			? at
				? variationPlacements
				: variationPlacements.filter(function (mt) {
						return getVariation(mt) === ut;
				  })
			: basePlacements,
		ct = dt.filter(function (mt) {
			return lt.indexOf(mt) >= 0;
		});
	ct.length === 0 && (ct = dt);
	var ft = ct.reduce(function (mt, pt) {
		return (
			(mt[pt] = detectOverflow(_, { placement: pt, boundary: rt, rootBoundary: it, padding: ot })[
				getBasePlacement(pt)
			]),
			mt
		);
	}, {});
	return Object.keys(ft).sort(function (mt, pt) {
		return ft[mt] - ft[pt];
	});
}
function getExpandedFallbackPlacements(_) {
	if (getBasePlacement(_) === auto) return [];
	var et = getOppositePlacement(_);
	return [getOppositeVariationPlacement(_), et, getOppositeVariationPlacement(et)];
}
function flip(_) {
	var et = _.state,
		tt = _.options,
		nt = _.name;
	if (!et.modifiersData[nt]._skip) {
		for (
			var rt = tt.mainAxis,
				it = rt === void 0 ? !0 : rt,
				ot = tt.altAxis,
				at = ot === void 0 ? !0 : ot,
				st = tt.fallbackPlacements,
				lt = tt.padding,
				ut = tt.boundary,
				dt = tt.rootBoundary,
				ct = tt.altBoundary,
				ft = tt.flipVariations,
				mt = ft === void 0 ? !0 : ft,
				pt = tt.allowedAutoPlacements,
				vt = et.options.placement,
				ht = getBasePlacement(vt),
				gt = ht === vt,
				yt = st || (gt || !mt ? [getOppositePlacement(vt)] : getExpandedFallbackPlacements(vt)),
				xt = [vt].concat(yt).reduce(function (Vt, Yt) {
					return Vt.concat(
						getBasePlacement(Yt) === auto
							? computeAutoPlacement(et, {
									placement: Yt,
									boundary: ut,
									rootBoundary: dt,
									padding: lt,
									flipVariations: mt,
									allowedAutoPlacements: pt,
							  })
							: Yt
					);
				}, []),
				St = et.rects.reference,
				wt = et.rects.popper,
				Ct = new Map(),
				Et = !0,
				_t = xt[0],
				$t = 0;
			$t < xt.length;
			$t++
		) {
			var At = xt[$t],
				Lt = getBasePlacement(At),
				Nt = getVariation(At) === start,
				Ft = [top, bottom].indexOf(Lt) >= 0,
				Gt = Ft ? "width" : "height",
				Bt = detectOverflow(et, { placement: At, boundary: ut, rootBoundary: dt, altBoundary: ct, padding: lt }),
				jt = Ft ? (Nt ? right : left) : Nt ? bottom : top;
			St[Gt] > wt[Gt] && (jt = getOppositePlacement(jt));
			var It = getOppositePlacement(jt),
				Dt = [];
			if (
				(it && Dt.push(Bt[Lt] <= 0),
				at && Dt.push(Bt[jt] <= 0, Bt[It] <= 0),
				Dt.every(function (Vt) {
					return Vt;
				}))
			) {
				(_t = At), (Et = !1);
				break;
			}
			Ct.set(At, Dt);
		}
		if (Et)
			for (
				var Rt = mt ? 3 : 1,
					bt = function (Yt) {
						var Ut = xt.find(function (qt) {
							var Wt = Ct.get(qt);
							if (Wt)
								return Wt.slice(0, Yt).every(function (Xt) {
									return Xt;
								});
						});
						if (Ut) return (_t = Ut), "break";
					},
					kt = Rt;
				kt > 0;
				kt--
			) {
				var zt = bt(kt);
				if (zt === "break") break;
			}
		et.placement !== _t && ((et.modifiersData[nt]._skip = !0), (et.placement = _t), (et.reset = !0));
	}
}
const flip$1 = {
	name: "flip",
	enabled: !0,
	phase: "main",
	fn: flip,
	requiresIfExists: ["offset"],
	data: { _skip: !1 },
};
function getSideOffsets(_, et, tt) {
	return (
		tt === void 0 && (tt = { x: 0, y: 0 }),
		{
			top: _.top - et.height - tt.y,
			right: _.right - et.width + tt.x,
			bottom: _.bottom - et.height + tt.y,
			left: _.left - et.width - tt.x,
		}
	);
}
function isAnySideFullyClipped(_) {
	return [top, right, bottom, left].some(function (et) {
		return _[et] >= 0;
	});
}
function hide(_) {
	var et = _.state,
		tt = _.name,
		nt = et.rects.reference,
		rt = et.rects.popper,
		it = et.modifiersData.preventOverflow,
		ot = detectOverflow(et, { elementContext: "reference" }),
		at = detectOverflow(et, { altBoundary: !0 }),
		st = getSideOffsets(ot, nt),
		lt = getSideOffsets(at, rt, it),
		ut = isAnySideFullyClipped(st),
		dt = isAnySideFullyClipped(lt);
	(et.modifiersData[tt] = {
		referenceClippingOffsets: st,
		popperEscapeOffsets: lt,
		isReferenceHidden: ut,
		hasPopperEscaped: dt,
	}),
		(et.attributes.popper = Object.assign({}, et.attributes.popper, {
			"data-popper-reference-hidden": ut,
			"data-popper-escaped": dt,
		}));
}
const hide$1 = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: hide };
function distanceAndSkiddingToXY(_, et, tt) {
	var nt = getBasePlacement(_),
		rt = [left, top].indexOf(nt) >= 0 ? -1 : 1,
		it = typeof tt == "function" ? tt(Object.assign({}, et, { placement: _ })) : tt,
		ot = it[0],
		at = it[1];
	return (ot = ot || 0), (at = (at || 0) * rt), [left, right].indexOf(nt) >= 0 ? { x: at, y: ot } : { x: ot, y: at };
}
function offset(_) {
	var et = _.state,
		tt = _.options,
		nt = _.name,
		rt = tt.offset,
		it = rt === void 0 ? [0, 0] : rt,
		ot = placements.reduce(function (ut, dt) {
			return (ut[dt] = distanceAndSkiddingToXY(dt, et.rects, it)), ut;
		}, {}),
		at = ot[et.placement],
		st = at.x,
		lt = at.y;
	et.modifiersData.popperOffsets != null &&
		((et.modifiersData.popperOffsets.x += st), (et.modifiersData.popperOffsets.y += lt)),
		(et.modifiersData[nt] = ot);
}
const offset$1 = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: offset };
function popperOffsets(_) {
	var et = _.state,
		tt = _.name;
	et.modifiersData[tt] = computeOffsets({
		reference: et.rects.reference,
		element: et.rects.popper,
		strategy: "absolute",
		placement: et.placement,
	});
}
const popperOffsets$1 = { name: "popperOffsets", enabled: !0, phase: "read", fn: popperOffsets, data: {} };
function getAltAxis(_) {
	return _ === "x" ? "y" : "x";
}
function preventOverflow(_) {
	var et = _.state,
		tt = _.options,
		nt = _.name,
		rt = tt.mainAxis,
		it = rt === void 0 ? !0 : rt,
		ot = tt.altAxis,
		at = ot === void 0 ? !1 : ot,
		st = tt.boundary,
		lt = tt.rootBoundary,
		ut = tt.altBoundary,
		dt = tt.padding,
		ct = tt.tether,
		ft = ct === void 0 ? !0 : ct,
		mt = tt.tetherOffset,
		pt = mt === void 0 ? 0 : mt,
		vt = detectOverflow(et, { boundary: st, rootBoundary: lt, padding: dt, altBoundary: ut }),
		ht = getBasePlacement(et.placement),
		gt = getVariation(et.placement),
		yt = !gt,
		xt = getMainAxisFromPlacement(ht),
		St = getAltAxis(xt),
		wt = et.modifiersData.popperOffsets,
		Ct = et.rects.reference,
		Et = et.rects.popper,
		_t = typeof pt == "function" ? pt(Object.assign({}, et.rects, { placement: et.placement })) : pt,
		$t = typeof _t == "number" ? { mainAxis: _t, altAxis: _t } : Object.assign({ mainAxis: 0, altAxis: 0 }, _t),
		At = et.modifiersData.offset ? et.modifiersData.offset[et.placement] : null,
		Lt = { x: 0, y: 0 };
	if (!!wt) {
		if (it) {
			var Nt,
				Ft = xt === "y" ? top : left,
				Gt = xt === "y" ? bottom : right,
				Bt = xt === "y" ? "height" : "width",
				jt = wt[xt],
				It = jt + vt[Ft],
				Dt = jt - vt[Gt],
				Rt = ft ? -Et[Bt] / 2 : 0,
				bt = gt === start ? Ct[Bt] : Et[Bt],
				kt = gt === start ? -Et[Bt] : -Ct[Bt],
				zt = et.elements.arrow,
				Vt = ft && zt ? getLayoutRect(zt) : { width: 0, height: 0 },
				Yt = et.modifiersData["arrow#persistent"] ? et.modifiersData["arrow#persistent"].padding : getFreshSideObject(),
				Ut = Yt[Ft],
				qt = Yt[Gt],
				Wt = within(0, Ct[Bt], Vt[Bt]),
				Xt = yt ? Ct[Bt] / 2 - Rt - Wt - Ut - $t.mainAxis : bt - Wt - Ut - $t.mainAxis,
				Zt = yt ? -Ct[Bt] / 2 + Rt + Wt + qt + $t.mainAxis : kt + Wt + qt + $t.mainAxis,
				pn = et.elements.arrow && getOffsetParent(et.elements.arrow),
				Sn = pn ? (xt === "y" ? pn.clientTop || 0 : pn.clientLeft || 0) : 0,
				yn = (Nt = At == null ? void 0 : At[xt]) != null ? Nt : 0,
				Qt = jt + Xt - yn - Sn,
				Jt = jt + Zt - yn,
				tn = within(ft ? min(It, Qt) : It, jt, ft ? max(Dt, Jt) : Dt);
			(wt[xt] = tn), (Lt[xt] = tn - jt);
		}
		if (at) {
			var an,
				mn = xt === "x" ? top : left,
				xn = xt === "x" ? bottom : right,
				gn = wt[St],
				vn = St === "y" ? "height" : "width",
				kn = gn + vt[mn],
				Cn = gn - vt[xn],
				Rn = [top, left].indexOf(ht) !== -1,
				Mn = (an = At == null ? void 0 : At[St]) != null ? an : 0,
				Nn = Rn ? kn : gn - Ct[vn] - Et[vn] - Mn + $t.altAxis,
				Dn = Rn ? gn + Ct[vn] + Et[vn] - Mn - $t.altAxis : Cn,
				Ot = ft && Rn ? withinMaxClamp(Nn, gn, Dn) : within(ft ? Nn : kn, gn, ft ? Dn : Cn);
			(wt[St] = Ot), (Lt[St] = Ot - gn);
		}
		et.modifiersData[nt] = Lt;
	}
}
const preventOverflow$1 = {
	name: "preventOverflow",
	enabled: !0,
	phase: "main",
	fn: preventOverflow,
	requiresIfExists: ["offset"],
};
function getHTMLElementScroll(_) {
	return { scrollLeft: _.scrollLeft, scrollTop: _.scrollTop };
}
function getNodeScroll(_) {
	return _ === getWindow$1(_) || !isHTMLElement$1(_) ? getWindowScroll(_) : getHTMLElementScroll(_);
}
function isElementScaled(_) {
	var et = _.getBoundingClientRect(),
		tt = round$1(et.width) / _.offsetWidth || 1,
		nt = round$1(et.height) / _.offsetHeight || 1;
	return tt !== 1 || nt !== 1;
}
function getCompositeRect(_, et, tt) {
	tt === void 0 && (tt = !1);
	var nt = isHTMLElement$1(et),
		rt = isHTMLElement$1(et) && isElementScaled(et),
		it = getDocumentElement(et),
		ot = getBoundingClientRect(_, rt, tt),
		at = { scrollLeft: 0, scrollTop: 0 },
		st = { x: 0, y: 0 };
	return (
		(nt || (!nt && !tt)) &&
			((getNodeName(et) !== "body" || isScrollParent(it)) && (at = getNodeScroll(et)),
			isHTMLElement$1(et)
				? ((st = getBoundingClientRect(et, !0)), (st.x += et.clientLeft), (st.y += et.clientTop))
				: it && (st.x = getWindowScrollBarX(it))),
		{ x: ot.left + at.scrollLeft - st.x, y: ot.top + at.scrollTop - st.y, width: ot.width, height: ot.height }
	);
}
function order$1(_) {
	var et = new Map(),
		tt = new Set(),
		nt = [];
	_.forEach(function (it) {
		et.set(it.name, it);
	});
	function rt(it) {
		tt.add(it.name);
		var ot = [].concat(it.requires || [], it.requiresIfExists || []);
		ot.forEach(function (at) {
			if (!tt.has(at)) {
				var st = et.get(at);
				st && rt(st);
			}
		}),
			nt.push(it);
	}
	return (
		_.forEach(function (it) {
			tt.has(it.name) || rt(it);
		}),
		nt
	);
}
function orderModifiers(_) {
	var et = order$1(_);
	return modifierPhases.reduce(function (tt, nt) {
		return tt.concat(
			et.filter(function (rt) {
				return rt.phase === nt;
			})
		);
	}, []);
}
function debounce(_) {
	var et;
	return function () {
		return (
			et ||
				(et = new Promise(function (tt) {
					Promise.resolve().then(function () {
						(et = void 0), tt(_());
					});
				})),
			et
		);
	};
}
function mergeByName(_) {
	var et = _.reduce(function (tt, nt) {
		var rt = tt[nt.name];
		return (
			(tt[nt.name] = rt
				? Object.assign({}, rt, nt, {
						options: Object.assign({}, rt.options, nt.options),
						data: Object.assign({}, rt.data, nt.data),
				  })
				: nt),
			tt
		);
	}, {});
	return Object.keys(et).map(function (tt) {
		return et[tt];
	});
}
var DEFAULT_OPTIONS = { placement: "bottom", modifiers: [], strategy: "absolute" };
function areValidElements() {
	for (var _ = arguments.length, et = new Array(_), tt = 0; tt < _; tt++) et[tt] = arguments[tt];
	return !et.some(function (nt) {
		return !(nt && typeof nt.getBoundingClientRect == "function");
	});
}
function popperGenerator(_) {
	_ === void 0 && (_ = {});
	var et = _,
		tt = et.defaultModifiers,
		nt = tt === void 0 ? [] : tt,
		rt = et.defaultOptions,
		it = rt === void 0 ? DEFAULT_OPTIONS : rt;
	return function (at, st, lt) {
		lt === void 0 && (lt = it);
		var ut = {
				placement: "bottom",
				orderedModifiers: [],
				options: Object.assign({}, DEFAULT_OPTIONS, it),
				modifiersData: {},
				elements: { reference: at, popper: st },
				attributes: {},
				styles: {},
			},
			dt = [],
			ct = !1,
			ft = {
				state: ut,
				setOptions: function (ht) {
					var gt = typeof ht == "function" ? ht(ut.options) : ht;
					pt(),
						(ut.options = Object.assign({}, it, ut.options, gt)),
						(ut.scrollParents = {
							reference: isElement$3(at)
								? listScrollParents(at)
								: at.contextElement
								? listScrollParents(at.contextElement)
								: [],
							popper: listScrollParents(st),
						});
					var yt = orderModifiers(mergeByName([].concat(nt, ut.options.modifiers)));
					return (
						(ut.orderedModifiers = yt.filter(function (xt) {
							return xt.enabled;
						})),
						mt(),
						ft.update()
					);
				},
				forceUpdate: function () {
					if (!ct) {
						var ht = ut.elements,
							gt = ht.reference,
							yt = ht.popper;
						if (!!areValidElements(gt, yt)) {
							(ut.rects = {
								reference: getCompositeRect(gt, getOffsetParent(yt), ut.options.strategy === "fixed"),
								popper: getLayoutRect(yt),
							}),
								(ut.reset = !1),
								(ut.placement = ut.options.placement),
								ut.orderedModifiers.forEach(function ($t) {
									return (ut.modifiersData[$t.name] = Object.assign({}, $t.data));
								});
							for (var xt = 0; xt < ut.orderedModifiers.length; xt++) {
								if (ut.reset === !0) {
									(ut.reset = !1), (xt = -1);
									continue;
								}
								var St = ut.orderedModifiers[xt],
									wt = St.fn,
									Ct = St.options,
									Et = Ct === void 0 ? {} : Ct,
									_t = St.name;
								typeof wt == "function" && (ut = wt({ state: ut, options: Et, name: _t, instance: ft }) || ut);
							}
						}
					}
				},
				update: debounce(function () {
					return new Promise(function (vt) {
						ft.forceUpdate(), vt(ut);
					});
				}),
				destroy: function () {
					pt(), (ct = !0);
				},
			};
		if (!areValidElements(at, st)) return ft;
		ft.setOptions(lt).then(function (vt) {
			!ct && lt.onFirstUpdate && lt.onFirstUpdate(vt);
		});
		function mt() {
			ut.orderedModifiers.forEach(function (vt) {
				var ht = vt.name,
					gt = vt.options,
					yt = gt === void 0 ? {} : gt,
					xt = vt.effect;
				if (typeof xt == "function") {
					var St = xt({ state: ut, name: ht, instance: ft, options: yt }),
						wt = function () {};
					dt.push(St || wt);
				}
			});
		}
		function pt() {
			dt.forEach(function (vt) {
				return vt();
			}),
				(dt = []);
		}
		return ft;
	};
}
var defaultModifiers = [
		eventListeners,
		popperOffsets$1,
		computeStyles$1,
		applyStyles$1,
		offset$1,
		flip$1,
		preventOverflow$1,
		arrow$1,
		hide$1,
	],
	createPopper = popperGenerator({ defaultModifiers }),
	toVar$1 = (_, et) => ({ var: _, varRef: et ? `var(${_}, ${et})` : `var(${_})` }),
	cssVars = {
		arrowShadowColor: toVar$1("--popper-arrow-shadow-color"),
		arrowSize: toVar$1("--popper-arrow-size", "8px"),
		arrowSizeHalf: toVar$1("--popper-arrow-size-half"),
		arrowBg: toVar$1("--popper-arrow-bg"),
		transformOrigin: toVar$1("--popper-transform-origin"),
		arrowOffset: toVar$1("--popper-arrow-offset"),
	};
function getBoxShadow(_) {
	if (_.includes("top")) return "1px 1px 1px 0 var(--popper-arrow-shadow-color)";
	if (_.includes("bottom")) return "-1px -1px 1px 0 var(--popper-arrow-shadow-color)";
	if (_.includes("right")) return "-1px 1px 1px 0 var(--popper-arrow-shadow-color)";
	if (_.includes("left")) return "1px -1px 1px 0 var(--popper-arrow-shadow-color)";
}
var transforms = {
		top: "bottom center",
		"top-start": "bottom left",
		"top-end": "bottom right",
		bottom: "top center",
		"bottom-start": "top left",
		"bottom-end": "top right",
		left: "right center",
		"left-start": "right top",
		"left-end": "right bottom",
		right: "left center",
		"right-start": "left top",
		"right-end": "left bottom",
	},
	toTransformOrigin = (_) => transforms[_],
	defaultEventListeners = { scroll: !0, resize: !0 };
function getEventListenerOptions(_) {
	let et;
	return (
		typeof _ == "object"
			? (et = { enabled: !0, options: { ...defaultEventListeners, ..._ } })
			: (et = { enabled: _, options: defaultEventListeners }),
		et
	);
}
var matchWidth = {
		name: "matchWidth",
		enabled: !0,
		phase: "beforeWrite",
		requires: ["computeStyles"],
		fn: ({ state: _ }) => {
			_.styles.popper.width = `${_.rects.reference.width}px`;
		},
		effect:
			({ state: _ }) =>
			() => {
				const et = _.elements.reference;
				_.elements.popper.style.width = `${et.offsetWidth}px`;
			},
	},
	transformOrigin = {
		name: "transformOrigin",
		enabled: !0,
		phase: "write",
		fn: ({ state: _ }) => {
			setTransformOrigin(_);
		},
		effect:
			({ state: _ }) =>
			() => {
				setTransformOrigin(_);
			},
	},
	setTransformOrigin = (_) => {
		_.elements.popper.style.setProperty(cssVars.transformOrigin.var, toTransformOrigin(_.placement));
	},
	positionArrow = {
		name: "positionArrow",
		enabled: !0,
		phase: "afterWrite",
		fn: ({ state: _ }) => {
			setArrowStyles(_);
		},
	},
	setArrowStyles = (_) => {
		var et;
		if (!_.placement) return;
		const tt = getArrowStyle(_.placement);
		if (((et = _.elements) == null ? void 0 : et.arrow) && tt) {
			Object.assign(_.elements.arrow.style, {
				[tt.property]: tt.value,
				width: cssVars.arrowSize.varRef,
				height: cssVars.arrowSize.varRef,
				zIndex: -1,
			});
			const nt = {
				[cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2)`,
				[cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`,
			};
			for (const rt in nt) _.elements.arrow.style.setProperty(rt, nt[rt]);
		}
	},
	getArrowStyle = (_) => {
		if (_.startsWith("top")) return { property: "bottom", value: cssVars.arrowOffset.varRef };
		if (_.startsWith("bottom")) return { property: "top", value: cssVars.arrowOffset.varRef };
		if (_.startsWith("left")) return { property: "right", value: cssVars.arrowOffset.varRef };
		if (_.startsWith("right")) return { property: "left", value: cssVars.arrowOffset.varRef };
	},
	innerArrow = {
		name: "innerArrow",
		enabled: !0,
		phase: "main",
		requires: ["arrow"],
		fn: ({ state: _ }) => {
			setInnerArrowStyles(_);
		},
		effect:
			({ state: _ }) =>
			() => {
				setInnerArrowStyles(_);
			},
	},
	setInnerArrowStyles = (_) => {
		if (!_.elements.arrow) return;
		const et = _.elements.arrow.querySelector("[data-popper-arrow-inner]");
		!et ||
			Object.assign(et.style, {
				transform: "rotate(45deg)",
				background: cssVars.arrowBg.varRef,
				top: 0,
				left: 0,
				width: "100%",
				height: "100%",
				position: "absolute",
				zIndex: "inherit",
				boxShadow: getBoxShadow(_.placement),
			});
	},
	logicals = {
		"start-start": { ltr: "left-start", rtl: "right-start" },
		"start-end": { ltr: "left-end", rtl: "right-end" },
		"end-start": { ltr: "right-start", rtl: "left-start" },
		"end-end": { ltr: "right-end", rtl: "left-end" },
		start: { ltr: "left", rtl: "right" },
		end: { ltr: "right", rtl: "left" },
	},
	opposites = {
		"auto-start": "auto-end",
		"auto-end": "auto-start",
		"top-start": "top-end",
		"top-end": "top-start",
		"bottom-start": "bottom-end",
		"bottom-end": "bottom-start",
	};
function getPopperPlacement(_, et = "ltr") {
	var rt;
	var tt;
	const nt = ((tt = logicals[_]) == null ? void 0 : tt[et]) || _;
	return et === "ltr" ? nt : (rt = opposites[_]) != null ? rt : nt;
}
function usePopper(_ = {}) {
	const {
			enabled: et = !0,
			modifiers: tt,
			placement: nt = "bottom",
			strategy: rt = "absolute",
			arrowPadding: it = 8,
			eventListeners: ot = !0,
			offset: at,
			gutter: st = 8,
			flip: lt = !0,
			boundary: ut = "clippingParents",
			preventOverflow: dt = !0,
			matchWidth: ct,
			direction: ft = "ltr",
		} = _,
		mt = react.exports.useRef(null),
		pt = react.exports.useRef(null),
		vt = react.exports.useRef(null),
		ht = getPopperPlacement(nt, ft),
		gt = react.exports.useRef(() => {}),
		yt = react.exports.useCallback(() => {
			var $t;
			!et ||
				!mt.current ||
				!pt.current ||
				(($t = gt.current) == null || $t.call(gt),
				(vt.current = createPopper(mt.current, pt.current, {
					placement: ht,
					modifiers: [
						innerArrow,
						positionArrow,
						transformOrigin,
						{ ...matchWidth, enabled: !!ct },
						{ name: "eventListeners", ...getEventListenerOptions(ot) },
						{ name: "arrow", options: { padding: it } },
						{ name: "offset", options: { offset: at != null ? at : [0, st] } },
						{ name: "flip", enabled: !!lt, options: { padding: 8 } },
						{ name: "preventOverflow", enabled: !!dt, options: { boundary: ut } },
						...(tt != null ? tt : []),
					],
					strategy: rt,
				})),
				vt.current.forceUpdate(),
				(gt.current = vt.current.destroy));
		}, [ht, et, tt, ct, ot, it, at, st, lt, dt, ut, rt]);
	react.exports.useEffect(
		() => () => {
			var $t;
			!mt.current && !pt.current && (($t = vt.current) == null || $t.destroy(), (vt.current = null));
		},
		[]
	);
	const xt = react.exports.useCallback(
			($t) => {
				(mt.current = $t), yt();
			},
			[yt]
		),
		St = react.exports.useCallback(($t = {}, At = null) => ({ ...$t, ref: mergeRefs(xt, At) }), [xt]),
		wt = react.exports.useCallback(
			($t) => {
				(pt.current = $t), yt();
			},
			[yt]
		),
		Ct = react.exports.useCallback(
			($t = {}, At = null) => ({
				...$t,
				ref: mergeRefs(wt, At),
				style: { ...$t.style, position: rt, minWidth: ct ? void 0 : "max-content", inset: "0 auto auto 0" },
			}),
			[rt, wt, ct]
		),
		Et = react.exports.useCallback(($t = {}, At = null) => {
			const { size: Lt, shadowColor: Nt, bg: Ft, style: Gt, ...Bt } = $t;
			return { ...Bt, ref: At, "data-popper-arrow": "", style: getArrowStyle2($t) };
		}, []),
		_t = react.exports.useCallback(($t = {}, At = null) => ({ ...$t, ref: At, "data-popper-arrow-inner": "" }), []);
	return {
		update() {
			var $t;
			($t = vt.current) == null || $t.update();
		},
		forceUpdate() {
			var $t;
			($t = vt.current) == null || $t.forceUpdate();
		},
		transformOrigin: cssVars.transformOrigin.varRef,
		referenceRef: xt,
		popperRef: wt,
		getPopperProps: Ct,
		getArrowProps: Et,
		getArrowInnerProps: _t,
		getReferenceProps: St,
	};
}
function getArrowStyle2(_) {
	const { size: et, shadowColor: tt, bg: nt, style: rt } = _,
		it = { ...rt, position: "absolute" };
	return (
		et && (it["--popper-arrow-size"] = et),
		tt && (it["--popper-arrow-shadow-color"] = tt),
		nt && (it["--popper-arrow-bg"] = nt),
		it
	);
}
function useDisclosure(_ = {}) {
	const { onClose: et, onOpen: tt, isOpen: nt, id: rt } = _,
		it = useCallbackRef$2(tt),
		ot = useCallbackRef$2(et),
		[at, st] = react.exports.useState(_.defaultIsOpen || !1),
		lt = nt !== void 0 ? nt : at,
		ut = nt !== void 0,
		dt = rt != null ? rt : `disclosure-${react.exports.useId()}`,
		ct = react.exports.useCallback(() => {
			ut || st(!1), ot == null || ot();
		}, [ut, ot]),
		ft = react.exports.useCallback(() => {
			ut || st(!0), it == null || it();
		}, [ut, it]),
		mt = react.exports.useCallback(() => {
			lt ? ct() : ft();
		}, [lt, ft, ct]);
	function pt(ht = {}) {
		return {
			...ht,
			"aria-expanded": lt,
			"aria-controls": dt,
			onClick(gt) {
				var yt;
				(yt = ht.onClick) == null || yt.call(ht, gt), mt();
			},
		};
	}
	function vt(ht = {}) {
		return { ...ht, hidden: !lt, id: dt };
	}
	return {
		isOpen: lt,
		onOpen: ft,
		onClose: ct,
		onToggle: mt,
		isControlled: ut,
		getButtonProps: pt,
		getDisclosureProps: vt,
	};
}
function useOutsideClick(_) {
	const { ref: et, handler: tt, enabled: nt = !0 } = _,
		rt = useCallbackRef$2(tt),
		ot = react.exports.useRef({ isPointerDown: !1, ignoreEmulatedMouseEvents: !1 }).current;
	react.exports.useEffect(() => {
		if (!nt) return;
		const at = (dt) => {
				isValidEvent(dt, et) && (ot.isPointerDown = !0);
			},
			st = (dt) => {
				if (ot.ignoreEmulatedMouseEvents) {
					ot.ignoreEmulatedMouseEvents = !1;
					return;
				}
				ot.isPointerDown && tt && isValidEvent(dt, et) && ((ot.isPointerDown = !1), rt(dt));
			},
			lt = (dt) => {
				(ot.ignoreEmulatedMouseEvents = !0),
					tt && ot.isPointerDown && isValidEvent(dt, et) && ((ot.isPointerDown = !1), rt(dt));
			},
			ut = getOwnerDocument$1(et.current);
		return (
			ut.addEventListener("mousedown", at, !0),
			ut.addEventListener("mouseup", st, !0),
			ut.addEventListener("touchstart", at, !0),
			ut.addEventListener("touchend", lt, !0),
			() => {
				ut.removeEventListener("mousedown", at, !0),
					ut.removeEventListener("mouseup", st, !0),
					ut.removeEventListener("touchstart", at, !0),
					ut.removeEventListener("touchend", lt, !0);
			}
		);
	}, [tt, et, rt, ot, nt]);
}
function isValidEvent(_, et) {
	var tt;
	const nt = _.target;
	return _.button > 0 || (nt && !getOwnerDocument$1(nt).contains(nt))
		? !1
		: !((tt = et.current) != null && tt.contains(nt));
}
function getOwnerDocument$1(_) {
	var et;
	return (et = _ == null ? void 0 : _.ownerDocument) != null ? et : document;
}
function useAnimationState(_) {
	const { isOpen: et, ref: tt } = _,
		[nt, rt] = react.exports.useState(et),
		[it, ot] = react.exports.useState(!1);
	return (
		react.exports.useEffect(() => {
			it || (rt(et), ot(!0));
		}, [et, it, nt]),
		useEventListener$1(
			() => tt.current,
			"animationend",
			() => {
				rt(et);
			}
		),
		{
			present: !(et ? !1 : !nt),
			onComplete() {
				var st;
				const lt = getOwnerWindow(tt.current),
					ut = new lt.CustomEvent("animationend", { bubbles: !0 });
				(st = tt.current) == null || st.dispatchEvent(ut);
			},
		}
	);
}
function lazyDisclosure(_) {
	const { wasSelected: et, enabled: tt, isSelected: nt, mode: rt = "unmount" } = _;
	return !!(!tt || nt || (rt === "keepMounted" && et));
}
var cx$3 = (..._) => _.filter(Boolean).join(" ");
function runIfFn$3(_, ...et) {
	return isFunction$7(_) ? _(...et) : _;
}
var isFunction$7 = (_) => typeof _ == "function",
	dataAttr = (_) => (_ ? "" : void 0);
function callAllHandlers$2(..._) {
	return function (tt) {
		_.some((nt) => (nt == null || nt(tt), tt == null ? void 0 : tt.defaultPrevented));
	};
}
function callAll$1(..._) {
	return function (tt) {
		_.forEach((nt) => {
			nt == null || nt(tt);
		});
	};
}
function isPrintableCharacter(_) {
	const { key: et } = _;
	return et.length === 1 || (et.length > 1 && /[^a-zA-Z0-9]/.test(et));
}
function useShortcut(_ = {}) {
	const { timeout: et = 300, preventDefault: tt = () => !0 } = _,
		[nt, rt] = react.exports.useState([]),
		it = react.exports.useRef(),
		ot = () => {
			it.current && (clearTimeout(it.current), (it.current = null));
		},
		at = () => {
			ot(),
				(it.current = setTimeout(() => {
					rt([]), (it.current = null);
				}, et));
		};
	react.exports.useEffect(() => ot, []);
	function st(lt) {
		return (ut) => {
			if (ut.key === "Backspace") {
				const dt = [...nt];
				dt.pop(), rt(dt);
				return;
			}
			if (isPrintableCharacter(ut)) {
				const dt = nt.concat(ut.key);
				tt(ut) && (ut.preventDefault(), ut.stopPropagation()), rt(dt), lt(dt.join("")), at();
			}
		};
	}
	return st;
}
function getNextItemFromSearch(_, et, tt, nt) {
	if (et == null) return nt;
	if (!nt) return _.find((ot) => tt(ot).toLowerCase().startsWith(et.toLowerCase()));
	const rt = _.filter((it) => tt(it).toLowerCase().startsWith(et.toLowerCase()));
	if (rt.length > 0) {
		let it;
		return rt.includes(nt)
			? ((it = rt.indexOf(nt) + 1), it === rt.length && (it = 0), rt[it])
			: ((it = _.indexOf(rt[0])), _[it]);
	}
	return nt;
}
var [MenuDescendantsProvider, useMenuDescendantsContext, useMenuDescendants, useMenuDescendant] =
		createDescendantContext(),
	[MenuProvider, useMenuContext] = createContext({ strict: !1, name: "MenuContext" });
function useIds$1(_, ...et) {
	const tt = react.exports.useId(),
		nt = _ || tt;
	return react.exports.useMemo(() => et.map((rt) => `${rt}-${nt}`), [nt, et]);
}
function getOwnerDocument(_) {
	var et;
	return (et = _ == null ? void 0 : _.ownerDocument) != null ? et : document;
}
function isActiveElement(_) {
	return getOwnerDocument(_).activeElement === _;
}
function useMenu(_ = {}) {
	const {
			id: et,
			closeOnSelect: tt = !0,
			closeOnBlur: nt = !0,
			autoSelect: rt = !0,
			isLazy: it,
			isOpen: ot,
			defaultIsOpen: at,
			onClose: st,
			onOpen: lt,
			placement: ut = "bottom-start",
			lazyBehavior: dt = "unmount",
			direction: ct,
			computePositionOnMount: ft = !1,
			...mt
		} = _,
		pt = react.exports.useRef(null),
		vt = react.exports.useRef(null),
		ht = useMenuDescendants(),
		gt = react.exports.useCallback(() => {
			requestAnimationFrame(() => {
				var bt;
				(bt = pt.current) == null || bt.focus({ preventScroll: !1 });
			});
		}, []),
		yt = react.exports.useCallback(() => {
			const bt = setTimeout(() => {
				const kt = ht.firstEnabled();
				kt && Lt(kt.index);
			});
			jt.current.add(bt);
		}, [ht]),
		xt = react.exports.useCallback(() => {
			const bt = setTimeout(() => {
				const kt = ht.lastEnabled();
				kt && Lt(kt.index);
			});
			jt.current.add(bt);
		}, [ht]),
		St = react.exports.useCallback(() => {
			lt == null || lt(), rt ? yt() : gt();
		}, [rt, yt, gt, lt]),
		{
			isOpen: wt,
			onOpen: Ct,
			onClose: Et,
			onToggle: _t,
		} = useDisclosure({ isOpen: ot, defaultIsOpen: at, onClose: st, onOpen: St });
	useOutsideClick({
		enabled: wt && nt,
		ref: pt,
		handler: (bt) => {
			var kt;
			((kt = vt.current) != null && kt.contains(bt.target)) || Et();
		},
	});
	const $t = usePopper({ ...mt, enabled: wt || ft, placement: ut, direction: ct }),
		[At, Lt] = react.exports.useState(-1);
	useUpdateEffect$1(() => {
		wt || Lt(-1);
	}, [wt]),
		useFocusOnHide(pt, { focusRef: vt, visible: wt, shouldFocus: !0 });
	const Nt = useAnimationState({ isOpen: wt, ref: pt }),
		[Ft, Gt] = useIds$1(et, "menu-button", "menu-list"),
		Bt = react.exports.useCallback(() => {
			Ct(), gt();
		}, [Ct, gt]),
		jt = react.exports.useRef(new Set([]));
	useUnmountEffect(() => {
		jt.current.forEach((bt) => clearTimeout(bt)), jt.current.clear();
	});
	const It = react.exports.useCallback(() => {
			Ct(), yt();
		}, [yt, Ct]),
		Dt = react.exports.useCallback(() => {
			Ct(), xt();
		}, [Ct, xt]),
		Rt = react.exports.useCallback(() => {
			var bt, kt;
			const zt = getOwnerDocument(pt.current),
				Vt = (bt = pt.current) == null ? void 0 : bt.contains(zt.activeElement);
			if (!(wt && !Vt)) return;
			const Ut = (kt = ht.item(At)) == null ? void 0 : kt.node;
			Ut == null || Ut.focus();
		}, [wt, At, ht]);
	return {
		openAndFocusMenu: Bt,
		openAndFocusFirstItem: It,
		openAndFocusLastItem: Dt,
		onTransitionEnd: Rt,
		unstable__animationState: Nt,
		descendants: ht,
		popper: $t,
		buttonId: Ft,
		menuId: Gt,
		forceUpdate: $t.forceUpdate,
		orientation: "vertical",
		isOpen: wt,
		onToggle: _t,
		onOpen: Ct,
		onClose: Et,
		menuRef: pt,
		buttonRef: vt,
		focusedIndex: At,
		closeOnSelect: tt,
		closeOnBlur: nt,
		autoSelect: rt,
		setFocusedIndex: Lt,
		isLazy: it,
		lazyBehavior: dt,
	};
}
function useMenuButton(_ = {}, et = null) {
	const tt = useMenuContext(),
		{ onToggle: nt, popper: rt, openAndFocusFirstItem: it, openAndFocusLastItem: ot } = tt,
		at = react.exports.useCallback(
			(st) => {
				const lt = st.key,
					dt = { Enter: it, ArrowDown: it, ArrowUp: ot }[lt];
				dt && (st.preventDefault(), st.stopPropagation(), dt(st));
			},
			[it, ot]
		);
	return {
		..._,
		ref: mergeRefs(tt.buttonRef, et, rt.referenceRef),
		id: tt.buttonId,
		"data-active": dataAttr(tt.isOpen),
		"aria-expanded": tt.isOpen,
		"aria-haspopup": "menu",
		"aria-controls": tt.menuId,
		onClick: callAllHandlers$2(_.onClick, nt),
		onKeyDown: callAllHandlers$2(_.onKeyDown, at),
	};
}
function isTargetMenuItem(_) {
	var et;
	return (
		isHTMLElement(_) && !!((et = _ == null ? void 0 : _.getAttribute("role")) != null && et.startsWith("menuitem"))
	);
}
function useMenuList(_ = {}, et = null) {
	const tt = useMenuContext();
	if (!tt) throw new Error("useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>");
	const {
			focusedIndex: nt,
			setFocusedIndex: rt,
			menuRef: it,
			isOpen: ot,
			onClose: at,
			menuId: st,
			isLazy: lt,
			lazyBehavior: ut,
			unstable__animationState: dt,
		} = tt,
		ct = useMenuDescendantsContext(),
		ft = useShortcut({ preventDefault: (ht) => ht.key !== " " && isTargetMenuItem(ht.target) }),
		mt = react.exports.useCallback(
			(ht) => {
				const gt = ht.key,
					xt = {
						Tab: (wt) => wt.preventDefault(),
						Escape: at,
						ArrowDown: () => {
							const wt = ct.nextEnabled(nt);
							wt && rt(wt.index);
						},
						ArrowUp: () => {
							const wt = ct.prevEnabled(nt);
							wt && rt(wt.index);
						},
					}[gt];
				if (xt) {
					ht.preventDefault(), xt(ht);
					return;
				}
				const St = ft((wt) => {
					const Ct = getNextItemFromSearch(
						ct.values(),
						wt,
						(Et) => {
							var $t;
							var _t;
							return ($t = (_t = Et == null ? void 0 : Et.node) == null ? void 0 : _t.textContent) != null ? $t : "";
						},
						ct.item(nt)
					);
					if (Ct) {
						const Et = ct.indexOf(Ct.node);
						rt(Et);
					}
				});
				isTargetMenuItem(ht.target) && St(ht);
			},
			[ct, nt, ft, at, rt]
		),
		pt = react.exports.useRef(!1);
	ot && (pt.current = !0);
	const vt = lazyDisclosure({ wasSelected: pt.current, enabled: lt, mode: ut, isSelected: dt.present });
	return {
		..._,
		ref: mergeRefs(it, et),
		children: vt ? _.children : null,
		tabIndex: -1,
		role: "menu",
		id: st,
		style: { ..._.style, transformOrigin: "var(--popper-transform-origin)" },
		"aria-orientation": "vertical",
		onKeyDown: callAllHandlers$2(_.onKeyDown, mt),
	};
}
function useMenuPositioner(_ = {}) {
	const { popper: et, isOpen: tt } = useMenuContext();
	return et.getPopperProps({ ..._, style: { visibility: tt ? "visible" : "hidden", ..._.style } });
}
function useMenuItem(_ = {}, et = null) {
	const {
			onMouseEnter: tt,
			onMouseMove: nt,
			onMouseLeave: rt,
			onClick: it,
			isDisabled: ot,
			isFocusable: at,
			closeOnSelect: st,
			type: lt,
			...ut
		} = _,
		dt = useMenuContext(),
		{ setFocusedIndex: ct, focusedIndex: ft, closeOnSelect: mt, onClose: pt, menuRef: vt, isOpen: ht, menuId: gt } = dt,
		yt = react.exports.useRef(null),
		xt = `${gt}-menuitem-${react.exports.useId()}`,
		{ index: St, register: wt } = useMenuDescendant({ disabled: ot && !at }),
		Ct = react.exports.useCallback(
			(Ft) => {
				tt == null || tt(Ft), !ot && ct(St);
			},
			[ct, St, ot, tt]
		),
		Et = react.exports.useCallback(
			(Ft) => {
				nt == null || nt(Ft), yt.current && !isActiveElement(yt.current) && Ct(Ft);
			},
			[Ct, nt]
		),
		_t = react.exports.useCallback(
			(Ft) => {
				rt == null || rt(Ft), !ot && ct(-1);
			},
			[ct, ot, rt]
		),
		$t = react.exports.useCallback(
			(Ft) => {
				it == null || it(Ft), !!isTargetMenuItem(Ft.currentTarget) && (st != null ? st : mt) && pt();
			},
			[pt, it, mt, st]
		),
		At = St === ft,
		Lt = ot && !at;
	useUpdateEffect$1(() => {
		!ht ||
			(At && !Lt && yt.current
				? requestAnimationFrame(() => {
						var Ft;
						(Ft = yt.current) == null || Ft.focus();
				  })
				: vt.current && !isActiveElement(vt.current) && vt.current.focus());
	}, [At, Lt, vt, ht]);
	const Nt = useClickable({
		onClick: $t,
		onMouseEnter: Ct,
		onMouseMove: Et,
		onMouseLeave: _t,
		ref: mergeRefs(wt, yt, et),
		isDisabled: ot,
		isFocusable: at,
	});
	return { ...ut, ...Nt, type: lt != null ? lt : Nt.type, id: xt, role: "menuitem", tabIndex: At ? 0 : -1 };
}
function useMenuOption(_ = {}, et = null) {
	const { type: tt = "radio", isChecked: nt, ...rt } = _;
	return { ...useMenuItem(rt, et), role: `menuitem${tt}`, "aria-checked": nt };
}
function useMenuOptionGroup(_ = {}) {
	const { children: et, type: tt = "radio", value: nt, defaultValue: rt, onChange: it, ...ot } = _,
		st = tt === "radio" ? "" : [],
		[lt, ut] = useControllableState({ defaultValue: rt != null ? rt : st, value: nt, onChange: it }),
		dt = react.exports.useCallback(
			(mt) => {
				if ((tt === "radio" && typeof lt == "string" && ut(mt), tt === "checkbox" && Array.isArray(lt))) {
					const pt = lt.includes(mt) ? lt.filter((vt) => vt !== mt) : lt.concat(mt);
					ut(pt);
				}
			},
			[lt, ut, tt]
		),
		ft = getValidChildren(et).map((mt) => {
			if (mt.type.id !== "MenuItemOption") return mt;
			const pt = (ht) => {
					var gt, yt;
					dt(mt.props.value), (yt = (gt = mt.props).onClick) == null || yt.call(gt, ht);
				},
				vt = tt === "radio" ? mt.props.value === lt : lt.includes(mt.props.value);
			return react.exports.cloneElement(mt, { type: tt, onClick: pt, isChecked: vt });
		});
	return { ...ot, children: ft };
}
function isHTMLElement(_) {
	var tt;
	if (!isElement$2(_)) return !1;
	const et = (tt = _.ownerDocument.defaultView) != null ? tt : window;
	return _ instanceof et.HTMLElement;
}
function isElement$2(_) {
	return _ != null && typeof _ == "object" && "nodeType" in _ && _.nodeType === Node.ELEMENT_NODE;
}
function useUnmountEffect(_, et = []) {
	return react.exports.useEffect(() => () => _(), et);
}
var [MenuStylesProvider, useMenuStyles] = createContext({
		name: "MenuStylesContext",
		errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `,
	}),
	Menu = (_) => {
		const { children: et } = _,
			tt = useMultiStyleConfig("Menu", _),
			nt = omitThemingProps(_),
			{ direction: rt } = useTheme(),
			{ descendants: it, ...ot } = useMenu({ ...nt, direction: rt }),
			at = react.exports.useMemo(() => ot, [ot]),
			{ isOpen: st, onClose: lt, forceUpdate: ut } = at;
		return jsx(MenuDescendantsProvider, {
			value: it,
			children: jsx(MenuProvider, {
				value: at,
				children: jsx(MenuStylesProvider, {
					value: tt,
					children: runIfFn$3(et, { isOpen: st, onClose: lt, forceUpdate: ut }),
				}),
			}),
		});
	};
Menu.displayName = "Menu";
var StyledMenuButton = forwardRef((_, et) => {
		const tt = useMenuStyles();
		return React$1.createElement(chakra.button, {
			ref: et,
			..._,
			__css: { display: "inline-flex", appearance: "none", alignItems: "center", outline: 0, ...tt.button },
		});
	}),
	MenuButton = forwardRef((_, et) => {
		const { children: tt, as: nt, ...rt } = _,
			it = useMenuButton(rt, et),
			ot = nt || StyledMenuButton;
		return React$1.createElement(
			ot,
			{ ...it, className: cx$3("chakra-menu__menu-button", _.className) },
			React$1.createElement(chakra.span, { __css: { pointerEvents: "none", flex: "1 1 auto", minW: 0 } }, _.children)
		);
	});
MenuButton.displayName = "MenuButton";
var MenuCommand = forwardRef((_, et) => {
	const tt = useMenuStyles();
	return React$1.createElement(chakra.span, { ref: et, ..._, __css: tt.command, className: "chakra-menu__command" });
});
MenuCommand.displayName = "MenuCommand";
var MenuDivider = (_) => {
	const { className: et, ...tt } = _,
		nt = useMenuStyles();
	return React$1.createElement(chakra.hr, {
		role: "separator",
		"aria-orientation": "horizontal",
		className: cx$3("chakra-menu__divider", et),
		...tt,
		__css: nt.divider,
	});
};
MenuDivider.displayName = "MenuDivider";
var MenuGroup = forwardRef((_, et) => {
	const { title: tt, children: nt, className: rt, ...it } = _,
		ot = cx$3("chakra-menu__group__title", rt),
		at = useMenuStyles();
	return jsxs("div", {
		ref: et,
		className: "chakra-menu__group",
		role: "group",
		children: [tt && React$1.createElement(chakra.p, { className: ot, ...it, __css: at.groupTitle }, tt), nt],
	});
});
MenuGroup.displayName = "MenuGroup";
var MenuIcon = (_) => {
	const { className: et, children: tt, ...nt } = _,
		rt = react.exports.Children.only(tt),
		it = react.exports.isValidElement(rt)
			? react.exports.cloneElement(rt, {
					focusable: "false",
					"aria-hidden": !0,
					className: cx$3("chakra-menu__icon", rt.props.className),
			  })
			: null,
		ot = cx$3("chakra-menu__icon-wrapper", et);
	return React$1.createElement(chakra.span, { className: ot, ...nt, __css: { flexShrink: 0 } }, it);
};
MenuIcon.displayName = "MenuIcon";
var StyledMenuItem = forwardRef((_, et) => {
		const { type: tt, ...nt } = _,
			rt = useMenuStyles(),
			it = nt.as || tt ? (tt != null ? tt : void 0) : "button",
			ot = react.exports.useMemo(
				() => ({
					textDecoration: "none",
					color: "inherit",
					userSelect: "none",
					display: "flex",
					width: "100%",
					alignItems: "center",
					textAlign: "start",
					flex: "0 0 auto",
					outline: 0,
					...rt.item,
				}),
				[rt.item]
			);
		return React$1.createElement(chakra.button, { ref: et, type: it, ...nt, __css: ot });
	}),
	CheckIcon = (_) =>
		jsx("svg", {
			viewBox: "0 0 14 14",
			width: "1em",
			height: "1em",
			..._,
			children: jsx("polygon", {
				fill: "currentColor",
				points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039",
			}),
		}),
	MenuItemOption = forwardRef((_, et) => {
		const { icon: tt, iconSpacing: nt = "0.75rem", ...rt } = _,
			it = useMenuOption(rt, et);
		return jsxs(StyledMenuItem, {
			...it,
			className: cx$3("chakra-menu__menuitem-option", rt.className),
			children: [
				tt !== null &&
					jsx(MenuIcon, {
						fontSize: "0.8em",
						marginEnd: nt,
						opacity: _.isChecked ? 1 : 0,
						children: tt || jsx(CheckIcon, {}),
					}),
				jsx("span", { style: { flex: 1 }, children: it.children }),
			],
		});
	});
MenuItemOption.id = "MenuItemOption";
MenuItemOption.displayName = "MenuItemOption";
var MenuItem = forwardRef((_, et) => {
	const { icon: tt, iconSpacing: nt = "0.75rem", command: rt, commandSpacing: it = "0.75rem", children: ot, ...at } = _,
		st = useMenuItem(at, et),
		ut = tt || rt ? jsx("span", { style: { pointerEvents: "none", flex: 1 }, children: ot }) : ot;
	return jsxs(StyledMenuItem, {
		...st,
		className: cx$3("chakra-menu__menuitem", st.className),
		children: [
			tt && jsx(MenuIcon, { fontSize: "0.8em", marginEnd: nt, children: tt }),
			ut,
			rt && jsx(MenuCommand, { marginStart: it, children: rt }),
		],
	});
});
MenuItem.displayName = "MenuItem";
var motionVariants = {
	enter: { visibility: "visible", opacity: 1, scale: 1, transition: { duration: 0.2, ease: [0.4, 0, 0.2, 1] } },
	exit: {
		transitionEnd: { visibility: "hidden" },
		opacity: 0,
		scale: 0.8,
		transition: { duration: 0.1, easings: "easeOut" },
	},
};
function __motion(_) {
	const et = motion;
	return "custom" in et && typeof et.custom == "function" ? et.custom(_) : et(_);
}
var MenuTransition = __motion(chakra.div),
	MenuList = forwardRef((_, et) => {
		var dt;
		var tt;
		const { rootProps: nt, ...rt } = _,
			{ isOpen: it, onTransitionEnd: ot, unstable__animationState: at } = useMenuContext(),
			st = useMenuList(rt, et),
			lt = useMenuPositioner(nt),
			ut = useMenuStyles();
		return React$1.createElement(
			chakra.div,
			{ ...lt, __css: { zIndex: (dt = _.zIndex) != null ? dt : (tt = ut.list) == null ? void 0 : tt.zIndex } },
			jsx(MenuTransition, {
				...st,
				onUpdate: ot,
				onAnimationComplete: callAll$1(at.onComplete, st.onAnimationComplete),
				className: cx$3("chakra-menu__menu-list", st.className),
				variants: motionVariants,
				initial: !1,
				animate: it ? "enter" : "exit",
				__css: { outline: 0, ...ut.list },
			})
		);
	});
MenuList.displayName = "MenuList";
var MenuOptionGroup = (_) => {
	const { className: et, title: tt, ...nt } = _,
		rt = useMenuOptionGroup(nt);
	return jsx(MenuGroup, { title: tt, className: cx$3("chakra-menu__option-group", et), ...rt });
};
MenuOptionGroup.displayName = "MenuOptionGroup";
var reactDom = { exports: {} },
	reactDom_production_min = {},
	scheduler = { exports: {} },
	scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (_) {
	function et(It, Dt) {
		var Rt = It.length;
		It.push(Dt);
		e: for (; 0 < Rt; ) {
			var bt = (Rt - 1) >>> 1,
				kt = It[bt];
			if (0 < rt(kt, Dt)) (It[bt] = Dt), (It[Rt] = kt), (Rt = bt);
			else break e;
		}
	}
	function tt(It) {
		return It.length === 0 ? null : It[0];
	}
	function nt(It) {
		if (It.length === 0) return null;
		var Dt = It[0],
			Rt = It.pop();
		if (Rt !== Dt) {
			It[0] = Rt;
			e: for (var bt = 0, kt = It.length, zt = kt >>> 1; bt < zt; ) {
				var Vt = 2 * (bt + 1) - 1,
					Yt = It[Vt],
					Ut = Vt + 1,
					qt = It[Ut];
				if (0 > rt(Yt, Rt))
					Ut < kt && 0 > rt(qt, Yt)
						? ((It[bt] = qt), (It[Ut] = Rt), (bt = Ut))
						: ((It[bt] = Yt), (It[Vt] = Rt), (bt = Vt));
				else if (Ut < kt && 0 > rt(qt, Rt)) (It[bt] = qt), (It[Ut] = Rt), (bt = Ut);
				else break e;
			}
		}
		return Dt;
	}
	function rt(It, Dt) {
		var Rt = It.sortIndex - Dt.sortIndex;
		return Rt !== 0 ? Rt : It.id - Dt.id;
	}
	if (typeof performance == "object" && typeof performance.now == "function") {
		var it = performance;
		_.unstable_now = function () {
			return it.now();
		};
	} else {
		var ot = Date,
			at = ot.now();
		_.unstable_now = function () {
			return ot.now() - at;
		};
	}
	var st = [],
		lt = [],
		ut = 1,
		dt = null,
		ct = 3,
		ft = !1,
		mt = !1,
		pt = !1,
		vt = typeof setTimeout == "function" ? setTimeout : null,
		ht = typeof clearTimeout == "function" ? clearTimeout : null,
		gt = typeof setImmediate < "u" ? setImmediate : null;
	typeof navigator < "u" &&
		navigator.scheduling !== void 0 &&
		navigator.scheduling.isInputPending !== void 0 &&
		navigator.scheduling.isInputPending.bind(navigator.scheduling);
	function yt(It) {
		for (var Dt = tt(lt); Dt !== null; ) {
			if (Dt.callback === null) nt(lt);
			else if (Dt.startTime <= It) nt(lt), (Dt.sortIndex = Dt.expirationTime), et(st, Dt);
			else break;
			Dt = tt(lt);
		}
	}
	function xt(It) {
		if (((pt = !1), yt(It), !mt))
			if (tt(st) !== null) (mt = !0), Bt(St);
			else {
				var Dt = tt(lt);
				Dt !== null && jt(xt, Dt.startTime - It);
			}
	}
	function St(It, Dt) {
		(mt = !1), pt && ((pt = !1), ht(Et), (Et = -1)), (ft = !0);
		var Rt = ct;
		try {
			for (yt(Dt), dt = tt(st); dt !== null && (!(dt.expirationTime > Dt) || (It && !At())); ) {
				var bt = dt.callback;
				if (typeof bt == "function") {
					(dt.callback = null), (ct = dt.priorityLevel);
					var kt = bt(dt.expirationTime <= Dt);
					(Dt = _.unstable_now()), typeof kt == "function" ? (dt.callback = kt) : dt === tt(st) && nt(st), yt(Dt);
				} else nt(st);
				dt = tt(st);
			}
			if (dt !== null) var zt = !0;
			else {
				var Vt = tt(lt);
				Vt !== null && jt(xt, Vt.startTime - Dt), (zt = !1);
			}
			return zt;
		} finally {
			(dt = null), (ct = Rt), (ft = !1);
		}
	}
	var wt = !1,
		Ct = null,
		Et = -1,
		_t = 5,
		$t = -1;
	function At() {
		return !(_.unstable_now() - $t < _t);
	}
	function Lt() {
		if (Ct !== null) {
			var It = _.unstable_now();
			$t = It;
			var Dt = !0;
			try {
				Dt = Ct(!0, It);
			} finally {
				Dt ? Nt() : ((wt = !1), (Ct = null));
			}
		} else wt = !1;
	}
	var Nt;
	if (typeof gt == "function")
		Nt = function () {
			gt(Lt);
		};
	else if (typeof MessageChannel < "u") {
		var Ft = new MessageChannel(),
			Gt = Ft.port2;
		(Ft.port1.onmessage = Lt),
			(Nt = function () {
				Gt.postMessage(null);
			});
	} else
		Nt = function () {
			vt(Lt, 0);
		};
	function Bt(It) {
		(Ct = It), wt || ((wt = !0), Nt());
	}
	function jt(It, Dt) {
		Et = vt(function () {
			It(_.unstable_now());
		}, Dt);
	}
	(_.unstable_IdlePriority = 5),
		(_.unstable_ImmediatePriority = 1),
		(_.unstable_LowPriority = 4),
		(_.unstable_NormalPriority = 3),
		(_.unstable_Profiling = null),
		(_.unstable_UserBlockingPriority = 2),
		(_.unstable_cancelCallback = function (It) {
			It.callback = null;
		}),
		(_.unstable_continueExecution = function () {
			mt || ft || ((mt = !0), Bt(St));
		}),
		(_.unstable_forceFrameRate = function (It) {
			0 > It || 125 < It
				? console.error(
						"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
				  )
				: (_t = 0 < It ? Math.floor(1e3 / It) : 5);
		}),
		(_.unstable_getCurrentPriorityLevel = function () {
			return ct;
		}),
		(_.unstable_getFirstCallbackNode = function () {
			return tt(st);
		}),
		(_.unstable_next = function (It) {
			switch (ct) {
				case 1:
				case 2:
				case 3:
					var Dt = 3;
					break;
				default:
					Dt = ct;
			}
			var Rt = ct;
			ct = Dt;
			try {
				return It();
			} finally {
				ct = Rt;
			}
		}),
		(_.unstable_pauseExecution = function () {}),
		(_.unstable_requestPaint = function () {}),
		(_.unstable_runWithPriority = function (It, Dt) {
			switch (It) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
					break;
				default:
					It = 3;
			}
			var Rt = ct;
			ct = It;
			try {
				return Dt();
			} finally {
				ct = Rt;
			}
		}),
		(_.unstable_scheduleCallback = function (It, Dt, Rt) {
			var bt = _.unstable_now();
			switch (
				(typeof Rt == "object" && Rt !== null
					? ((Rt = Rt.delay), (Rt = typeof Rt == "number" && 0 < Rt ? bt + Rt : bt))
					: (Rt = bt),
				It)
			) {
				case 1:
					var kt = -1;
					break;
				case 2:
					kt = 250;
					break;
				case 5:
					kt = 1073741823;
					break;
				case 4:
					kt = 1e4;
					break;
				default:
					kt = 5e3;
			}
			return (
				(kt = Rt + kt),
				(It = { id: ut++, callback: Dt, priorityLevel: It, startTime: Rt, expirationTime: kt, sortIndex: -1 }),
				Rt > bt
					? ((It.sortIndex = Rt),
					  et(lt, It),
					  tt(st) === null && It === tt(lt) && (pt ? (ht(Et), (Et = -1)) : (pt = !0), jt(xt, Rt - bt)))
					: ((It.sortIndex = kt), et(st, It), mt || ft || ((mt = !0), Bt(St))),
				It
			);
		}),
		(_.unstable_shouldYield = At),
		(_.unstable_wrapCallback = function (It) {
			var Dt = ct;
			return function () {
				var Rt = ct;
				ct = Dt;
				try {
					return It.apply(this, arguments);
				} finally {
					ct = Rt;
				}
			};
		});
})(scheduler_production_min);
(function (_) {
	_.exports = scheduler_production_min;
})(scheduler);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var aa = react.exports,
	ca = scheduler.exports;
function p$3(_) {
	for (var et = "https://reactjs.org/docs/error-decoder.html?invariant=" + _, tt = 1; tt < arguments.length; tt++)
		et += "&args[]=" + encodeURIComponent(arguments[tt]);
	return (
		"Minified React error #" +
		_ +
		"; visit " +
		et +
		" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
	);
}
var da = new Set(),
	ea = {};
function fa(_, et) {
	ha(_, et), ha(_ + "Capture", et);
}
function ha(_, et) {
	for (ea[_] = et, _ = 0; _ < et.length; _++) da.add(et[_]);
}
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
	ja = Object.prototype.hasOwnProperty,
	ka =
		/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
	la = {},
	ma = {};
function oa(_) {
	return ja.call(ma, _) ? !0 : ja.call(la, _) ? !1 : ka.test(_) ? (ma[_] = !0) : ((la[_] = !0), !1);
}
function pa(_, et, tt, nt) {
	if (tt !== null && tt.type === 0) return !1;
	switch (typeof et) {
		case "function":
		case "symbol":
			return !0;
		case "boolean":
			return nt
				? !1
				: tt !== null
				? !tt.acceptsBooleans
				: ((_ = _.toLowerCase().slice(0, 5)), _ !== "data-" && _ !== "aria-");
		default:
			return !1;
	}
}
function qa(_, et, tt, nt) {
	if (et === null || typeof et > "u" || pa(_, et, tt, nt)) return !0;
	if (nt) return !1;
	if (tt !== null)
		switch (tt.type) {
			case 3:
				return !et;
			case 4:
				return et === !1;
			case 5:
				return isNaN(et);
			case 6:
				return isNaN(et) || 1 > et;
		}
	return !1;
}
function v$1(_, et, tt, nt, rt, it, ot) {
	(this.acceptsBooleans = et === 2 || et === 3 || et === 4),
		(this.attributeName = nt),
		(this.attributeNamespace = rt),
		(this.mustUseProperty = tt),
		(this.propertyName = _),
		(this.type = et),
		(this.sanitizeURL = it),
		(this.removeEmptyString = ot);
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
	.split(" ")
	.forEach(function (_) {
		z[_] = new v$1(_, 0, !1, _, null, !1, !1);
	});
[
	["acceptCharset", "accept-charset"],
	["className", "class"],
	["htmlFor", "for"],
	["httpEquiv", "http-equiv"],
].forEach(function (_) {
	var et = _[0];
	z[et] = new v$1(et, 1, !1, _[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (_) {
	z[_] = new v$1(_, 2, !1, _.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (_) {
	z[_] = new v$1(_, 2, !1, _, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
	.split(" ")
	.forEach(function (_) {
		z[_] = new v$1(_, 3, !1, _.toLowerCase(), null, !1, !1);
	});
["checked", "multiple", "muted", "selected"].forEach(function (_) {
	z[_] = new v$1(_, 3, !0, _, null, !1, !1);
});
["capture", "download"].forEach(function (_) {
	z[_] = new v$1(_, 4, !1, _, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (_) {
	z[_] = new v$1(_, 6, !1, _, null, !1, !1);
});
["rowSpan", "start"].forEach(function (_) {
	z[_] = new v$1(_, 5, !1, _.toLowerCase(), null, !1, !1);
});
var ra = /[\-:]([a-z])/g;
function sa(_) {
	return _[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
	.split(" ")
	.forEach(function (_) {
		var et = _.replace(ra, sa);
		z[et] = new v$1(et, 1, !1, _, null, !1, !1);
	});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (_) {
	var et = _.replace(ra, sa);
	z[et] = new v$1(et, 1, !1, _, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function (_) {
	var et = _.replace(ra, sa);
	z[et] = new v$1(et, 1, !1, _, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (_) {
	z[_] = new v$1(_, 1, !1, _.toLowerCase(), null, !1, !1);
});
z.xlinkHref = new v$1("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (_) {
	z[_] = new v$1(_, 1, !1, _.toLowerCase(), null, !0, !0);
});
function ta(_, et, tt, nt) {
	var rt = z.hasOwnProperty(et) ? z[et] : null;
	(rt !== null
		? rt.type !== 0
		: nt || !(2 < et.length) || (et[0] !== "o" && et[0] !== "O") || (et[1] !== "n" && et[1] !== "N")) &&
		(qa(et, tt, rt, nt) && (tt = null),
		nt || rt === null
			? oa(et) && (tt === null ? _.removeAttribute(et) : _.setAttribute(et, "" + tt))
			: rt.mustUseProperty
			? (_[rt.propertyName] = tt === null ? (rt.type === 3 ? !1 : "") : tt)
			: ((et = rt.attributeName),
			  (nt = rt.attributeNamespace),
			  tt === null
					? _.removeAttribute(et)
					: ((rt = rt.type),
					  (tt = rt === 3 || (rt === 4 && tt === !0) ? "" : "" + tt),
					  nt ? _.setAttributeNS(nt, et, tt) : _.setAttribute(et, tt))));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
	va = Symbol.for("react.element"),
	wa = Symbol.for("react.portal"),
	ya = Symbol.for("react.fragment"),
	za = Symbol.for("react.strict_mode"),
	Aa = Symbol.for("react.profiler"),
	Ba = Symbol.for("react.provider"),
	Ca = Symbol.for("react.context"),
	Da = Symbol.for("react.forward_ref"),
	Ea = Symbol.for("react.suspense"),
	Fa = Symbol.for("react.suspense_list"),
	Ga = Symbol.for("react.memo"),
	Ha = Symbol.for("react.lazy"),
	Ia = Symbol.for("react.offscreen"),
	Ja = Symbol.iterator;
function Ka(_) {
	return _ === null || typeof _ != "object"
		? null
		: ((_ = (Ja && _[Ja]) || _["@@iterator"]), typeof _ == "function" ? _ : null);
}
var A = Object.assign,
	La;
function Ma(_) {
	if (La === void 0)
		try {
			throw Error();
		} catch (tt) {
			var et = tt.stack.trim().match(/\n( *(at )?)/);
			La = (et && et[1]) || "";
		}
	return (
		`
` +
		La +
		_
	);
}
var Na = !1;
function Oa(_, et) {
	if (!_ || Na) return "";
	Na = !0;
	var tt = Error.prepareStackTrace;
	Error.prepareStackTrace = void 0;
	try {
		if (et)
			if (
				((et = function () {
					throw Error();
				}),
				Object.defineProperty(et.prototype, "props", {
					set: function () {
						throw Error();
					},
				}),
				typeof Reflect == "object" && Reflect.construct)
			) {
				try {
					Reflect.construct(et, []);
				} catch (lt) {
					var nt = lt;
				}
				Reflect.construct(_, [], et);
			} else {
				try {
					et.call();
				} catch (lt) {
					nt = lt;
				}
				_.call(et.prototype);
			}
		else {
			try {
				throw Error();
			} catch (lt) {
				nt = lt;
			}
			_();
		}
	} catch (lt) {
		if (lt && nt && typeof lt.stack == "string") {
			for (
				var rt = lt.stack.split(`
`),
					it = nt.stack.split(`
`),
					ot = rt.length - 1,
					at = it.length - 1;
				1 <= ot && 0 <= at && rt[ot] !== it[at];

			)
				at--;
			for (; 1 <= ot && 0 <= at; ot--, at--)
				if (rt[ot] !== it[at]) {
					if (ot !== 1 || at !== 1)
						do
							if ((ot--, at--, 0 > at || rt[ot] !== it[at])) {
								var st =
									`
` + rt[ot].replace(" at new ", " at ");
								return (
									_.displayName && st.includes("<anonymous>") && (st = st.replace("<anonymous>", _.displayName)), st
								);
							}
						while (1 <= ot && 0 <= at);
					break;
				}
		}
	} finally {
		(Na = !1), (Error.prepareStackTrace = tt);
	}
	return (_ = _ ? _.displayName || _.name : "") ? Ma(_) : "";
}
function Pa(_) {
	switch (_.tag) {
		case 5:
			return Ma(_.type);
		case 16:
			return Ma("Lazy");
		case 13:
			return Ma("Suspense");
		case 19:
			return Ma("SuspenseList");
		case 0:
		case 2:
		case 15:
			return (_ = Oa(_.type, !1)), _;
		case 11:
			return (_ = Oa(_.type.render, !1)), _;
		case 1:
			return (_ = Oa(_.type, !0)), _;
		default:
			return "";
	}
}
function Qa(_) {
	if (_ == null) return null;
	if (typeof _ == "function") return _.displayName || _.name || null;
	if (typeof _ == "string") return _;
	switch (_) {
		case ya:
			return "Fragment";
		case wa:
			return "Portal";
		case Aa:
			return "Profiler";
		case za:
			return "StrictMode";
		case Ea:
			return "Suspense";
		case Fa:
			return "SuspenseList";
	}
	if (typeof _ == "object")
		switch (_.$$typeof) {
			case Ca:
				return (_.displayName || "Context") + ".Consumer";
			case Ba:
				return (_._context.displayName || "Context") + ".Provider";
			case Da:
				var et = _.render;
				return (
					(_ = _.displayName),
					_ || ((_ = et.displayName || et.name || ""), (_ = _ !== "" ? "ForwardRef(" + _ + ")" : "ForwardRef")),
					_
				);
			case Ga:
				return (et = _.displayName || null), et !== null ? et : Qa(_.type) || "Memo";
			case Ha:
				(et = _._payload), (_ = _._init);
				try {
					return Qa(_(et));
				} catch {}
		}
	return null;
}
function Ra(_) {
	var et = _.type;
	switch (_.tag) {
		case 24:
			return "Cache";
		case 9:
			return (et.displayName || "Context") + ".Consumer";
		case 10:
			return (et._context.displayName || "Context") + ".Provider";
		case 18:
			return "DehydratedFragment";
		case 11:
			return (
				(_ = et.render),
				(_ = _.displayName || _.name || ""),
				et.displayName || (_ !== "" ? "ForwardRef(" + _ + ")" : "ForwardRef")
			);
		case 7:
			return "Fragment";
		case 5:
			return et;
		case 4:
			return "Portal";
		case 3:
			return "Root";
		case 6:
			return "Text";
		case 16:
			return Qa(et);
		case 8:
			return et === za ? "StrictMode" : "Mode";
		case 22:
			return "Offscreen";
		case 12:
			return "Profiler";
		case 21:
			return "Scope";
		case 13:
			return "Suspense";
		case 19:
			return "SuspenseList";
		case 25:
			return "TracingMarker";
		case 1:
		case 0:
		case 17:
		case 2:
		case 14:
		case 15:
			if (typeof et == "function") return et.displayName || et.name || null;
			if (typeof et == "string") return et;
	}
	return null;
}
function Sa(_) {
	switch (typeof _) {
		case "boolean":
		case "number":
		case "string":
		case "undefined":
			return _;
		case "object":
			return _;
		default:
			return "";
	}
}
function Ta(_) {
	var et = _.type;
	return (_ = _.nodeName) && _.toLowerCase() === "input" && (et === "checkbox" || et === "radio");
}
function Ua(_) {
	var et = Ta(_) ? "checked" : "value",
		tt = Object.getOwnPropertyDescriptor(_.constructor.prototype, et),
		nt = "" + _[et];
	if (!_.hasOwnProperty(et) && typeof tt < "u" && typeof tt.get == "function" && typeof tt.set == "function") {
		var rt = tt.get,
			it = tt.set;
		return (
			Object.defineProperty(_, et, {
				configurable: !0,
				get: function () {
					return rt.call(this);
				},
				set: function (ot) {
					(nt = "" + ot), it.call(this, ot);
				},
			}),
			Object.defineProperty(_, et, { enumerable: tt.enumerable }),
			{
				getValue: function () {
					return nt;
				},
				setValue: function (ot) {
					nt = "" + ot;
				},
				stopTracking: function () {
					(_._valueTracker = null), delete _[et];
				},
			}
		);
	}
}
function Va(_) {
	_._valueTracker || (_._valueTracker = Ua(_));
}
function Wa(_) {
	if (!_) return !1;
	var et = _._valueTracker;
	if (!et) return !0;
	var tt = et.getValue(),
		nt = "";
	return _ && (nt = Ta(_) ? (_.checked ? "true" : "false") : _.value), (_ = nt), _ !== tt ? (et.setValue(_), !0) : !1;
}
function Xa(_) {
	if (((_ = _ || (typeof document < "u" ? document : void 0)), typeof _ > "u")) return null;
	try {
		return _.activeElement || _.body;
	} catch {
		return _.body;
	}
}
function Ya(_, et) {
	var tt = et.checked;
	return A({}, et, {
		defaultChecked: void 0,
		defaultValue: void 0,
		value: void 0,
		checked: tt != null ? tt : _._wrapperState.initialChecked,
	});
}
function Za(_, et) {
	var tt = et.defaultValue == null ? "" : et.defaultValue,
		nt = et.checked != null ? et.checked : et.defaultChecked;
	(tt = Sa(et.value != null ? et.value : tt)),
		(_._wrapperState = {
			initialChecked: nt,
			initialValue: tt,
			controlled: et.type === "checkbox" || et.type === "radio" ? et.checked != null : et.value != null,
		});
}
function ab(_, et) {
	(et = et.checked), et != null && ta(_, "checked", et, !1);
}
function bb(_, et) {
	ab(_, et);
	var tt = Sa(et.value),
		nt = et.type;
	if (tt != null)
		nt === "number"
			? ((tt === 0 && _.value === "") || _.value != tt) && (_.value = "" + tt)
			: _.value !== "" + tt && (_.value = "" + tt);
	else if (nt === "submit" || nt === "reset") {
		_.removeAttribute("value");
		return;
	}
	et.hasOwnProperty("value")
		? cb(_, et.type, tt)
		: et.hasOwnProperty("defaultValue") && cb(_, et.type, Sa(et.defaultValue)),
		et.checked == null && et.defaultChecked != null && (_.defaultChecked = !!et.defaultChecked);
}
function db(_, et, tt) {
	if (et.hasOwnProperty("value") || et.hasOwnProperty("defaultValue")) {
		var nt = et.type;
		if (!((nt !== "submit" && nt !== "reset") || (et.value !== void 0 && et.value !== null))) return;
		(et = "" + _._wrapperState.initialValue), tt || et === _.value || (_.value = et), (_.defaultValue = et);
	}
	(tt = _.name),
		tt !== "" && (_.name = ""),
		(_.defaultChecked = !!_._wrapperState.initialChecked),
		tt !== "" && (_.name = tt);
}
function cb(_, et, tt) {
	(et !== "number" || Xa(_.ownerDocument) !== _) &&
		(tt == null
			? (_.defaultValue = "" + _._wrapperState.initialValue)
			: _.defaultValue !== "" + tt && (_.defaultValue = "" + tt));
}
var eb = Array.isArray;
function fb(_, et, tt, nt) {
	if (((_ = _.options), et)) {
		et = {};
		for (var rt = 0; rt < tt.length; rt++) et["$" + tt[rt]] = !0;
		for (tt = 0; tt < _.length; tt++)
			(rt = et.hasOwnProperty("$" + _[tt].value)),
				_[tt].selected !== rt && (_[tt].selected = rt),
				rt && nt && (_[tt].defaultSelected = !0);
	} else {
		for (tt = "" + Sa(tt), et = null, rt = 0; rt < _.length; rt++) {
			if (_[rt].value === tt) {
				(_[rt].selected = !0), nt && (_[rt].defaultSelected = !0);
				return;
			}
			et !== null || _[rt].disabled || (et = _[rt]);
		}
		et !== null && (et.selected = !0);
	}
}
function gb(_, et) {
	if (et.dangerouslySetInnerHTML != null) throw Error(p$3(91));
	return A({}, et, { value: void 0, defaultValue: void 0, children: "" + _._wrapperState.initialValue });
}
function hb(_, et) {
	var tt = et.value;
	if (tt == null) {
		if (((tt = et.children), (et = et.defaultValue), tt != null)) {
			if (et != null) throw Error(p$3(92));
			if (eb(tt)) {
				if (1 < tt.length) throw Error(p$3(93));
				tt = tt[0];
			}
			et = tt;
		}
		et == null && (et = ""), (tt = et);
	}
	_._wrapperState = { initialValue: Sa(tt) };
}
function ib(_, et) {
	var tt = Sa(et.value),
		nt = Sa(et.defaultValue);
	tt != null &&
		((tt = "" + tt),
		tt !== _.value && (_.value = tt),
		et.defaultValue == null && _.defaultValue !== tt && (_.defaultValue = tt)),
		nt != null && (_.defaultValue = "" + nt);
}
function jb(_) {
	var et = _.textContent;
	et === _._wrapperState.initialValue && et !== "" && et !== null && (_.value = et);
}
function kb(_) {
	switch (_) {
		case "svg":
			return "http://www.w3.org/2000/svg";
		case "math":
			return "http://www.w3.org/1998/Math/MathML";
		default:
			return "http://www.w3.org/1999/xhtml";
	}
}
function lb(_, et) {
	return _ == null || _ === "http://www.w3.org/1999/xhtml"
		? kb(et)
		: _ === "http://www.w3.org/2000/svg" && et === "foreignObject"
		? "http://www.w3.org/1999/xhtml"
		: _;
}
var mb,
	nb = (function (_) {
		return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
			? function (et, tt, nt, rt) {
					MSApp.execUnsafeLocalFunction(function () {
						return _(et, tt, nt, rt);
					});
			  }
			: _;
	})(function (_, et) {
		if (_.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in _) _.innerHTML = et;
		else {
			for (
				mb = mb || document.createElement("div"),
					mb.innerHTML = "<svg>" + et.valueOf().toString() + "</svg>",
					et = mb.firstChild;
				_.firstChild;

			)
				_.removeChild(_.firstChild);
			for (; et.firstChild; ) _.appendChild(et.firstChild);
		}
	});
function ob(_, et) {
	if (et) {
		var tt = _.firstChild;
		if (tt && tt === _.lastChild && tt.nodeType === 3) {
			tt.nodeValue = et;
			return;
		}
	}
	_.textContent = et;
}
var pb = {
		animationIterationCount: !0,
		aspectRatio: !0,
		borderImageOutset: !0,
		borderImageSlice: !0,
		borderImageWidth: !0,
		boxFlex: !0,
		boxFlexGroup: !0,
		boxOrdinalGroup: !0,
		columnCount: !0,
		columns: !0,
		flex: !0,
		flexGrow: !0,
		flexPositive: !0,
		flexShrink: !0,
		flexNegative: !0,
		flexOrder: !0,
		gridArea: !0,
		gridRow: !0,
		gridRowEnd: !0,
		gridRowSpan: !0,
		gridRowStart: !0,
		gridColumn: !0,
		gridColumnEnd: !0,
		gridColumnSpan: !0,
		gridColumnStart: !0,
		fontWeight: !0,
		lineClamp: !0,
		lineHeight: !0,
		opacity: !0,
		order: !0,
		orphans: !0,
		tabSize: !0,
		widows: !0,
		zIndex: !0,
		zoom: !0,
		fillOpacity: !0,
		floodOpacity: !0,
		stopOpacity: !0,
		strokeDasharray: !0,
		strokeDashoffset: !0,
		strokeMiterlimit: !0,
		strokeOpacity: !0,
		strokeWidth: !0,
	},
	qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function (_) {
	qb.forEach(function (et) {
		(et = et + _.charAt(0).toUpperCase() + _.substring(1)), (pb[et] = pb[_]);
	});
});
function rb(_, et, tt) {
	return et == null || typeof et == "boolean" || et === ""
		? ""
		: tt || typeof et != "number" || et === 0 || (pb.hasOwnProperty(_) && pb[_])
		? ("" + et).trim()
		: et + "px";
}
function sb(_, et) {
	_ = _.style;
	for (var tt in et)
		if (et.hasOwnProperty(tt)) {
			var nt = tt.indexOf("--") === 0,
				rt = rb(tt, et[tt], nt);
			tt === "float" && (tt = "cssFloat"), nt ? _.setProperty(tt, rt) : (_[tt] = rt);
		}
}
var tb = A(
	{ menuitem: !0 },
	{
		area: !0,
		base: !0,
		br: !0,
		col: !0,
		embed: !0,
		hr: !0,
		img: !0,
		input: !0,
		keygen: !0,
		link: !0,
		meta: !0,
		param: !0,
		source: !0,
		track: !0,
		wbr: !0,
	}
);
function ub(_, et) {
	if (et) {
		if (tb[_] && (et.children != null || et.dangerouslySetInnerHTML != null)) throw Error(p$3(137, _));
		if (et.dangerouslySetInnerHTML != null) {
			if (et.children != null) throw Error(p$3(60));
			if (typeof et.dangerouslySetInnerHTML != "object" || !("__html" in et.dangerouslySetInnerHTML))
				throw Error(p$3(61));
		}
		if (et.style != null && typeof et.style != "object") throw Error(p$3(62));
	}
}
function vb(_, et) {
	if (_.indexOf("-") === -1) return typeof et.is == "string";
	switch (_) {
		case "annotation-xml":
		case "color-profile":
		case "font-face":
		case "font-face-src":
		case "font-face-uri":
		case "font-face-format":
		case "font-face-name":
		case "missing-glyph":
			return !1;
		default:
			return !0;
	}
}
var wb = null;
function xb(_) {
	return (
		(_ = _.target || _.srcElement || window),
		_.correspondingUseElement && (_ = _.correspondingUseElement),
		_.nodeType === 3 ? _.parentNode : _
	);
}
var yb = null,
	zb = null,
	Ab = null;
function Bb(_) {
	if ((_ = Cb(_))) {
		if (typeof yb != "function") throw Error(p$3(280));
		var et = _.stateNode;
		et && ((et = Db(et)), yb(_.stateNode, _.type, et));
	}
}
function Eb(_) {
	zb ? (Ab ? Ab.push(_) : (Ab = [_])) : (zb = _);
}
function Fb() {
	if (zb) {
		var _ = zb,
			et = Ab;
		if (((Ab = zb = null), Bb(_), et)) for (_ = 0; _ < et.length; _++) Bb(et[_]);
	}
}
function Gb(_, et) {
	return _(et);
}
function Hb() {}
var Ib = !1;
function Jb(_, et, tt) {
	if (Ib) return _(et, tt);
	Ib = !0;
	try {
		return Gb(_, et, tt);
	} finally {
		(Ib = !1), (zb !== null || Ab !== null) && (Hb(), Fb());
	}
}
function Kb(_, et) {
	var tt = _.stateNode;
	if (tt === null) return null;
	var nt = Db(tt);
	if (nt === null) return null;
	tt = nt[et];
	e: switch (et) {
		case "onClick":
		case "onClickCapture":
		case "onDoubleClick":
		case "onDoubleClickCapture":
		case "onMouseDown":
		case "onMouseDownCapture":
		case "onMouseMove":
		case "onMouseMoveCapture":
		case "onMouseUp":
		case "onMouseUpCapture":
		case "onMouseEnter":
			(nt = !nt.disabled) ||
				((_ = _.type), (nt = !(_ === "button" || _ === "input" || _ === "select" || _ === "textarea"))),
				(_ = !nt);
			break e;
		default:
			_ = !1;
	}
	if (_) return null;
	if (tt && typeof tt != "function") throw Error(p$3(231, et, typeof tt));
	return tt;
}
var Lb = !1;
if (ia)
	try {
		var Mb = {};
		Object.defineProperty(Mb, "passive", {
			get: function () {
				Lb = !0;
			},
		}),
			window.addEventListener("test", Mb, Mb),
			window.removeEventListener("test", Mb, Mb);
	} catch {
		Lb = !1;
	}
function Nb(_, et, tt, nt, rt, it, ot, at, st) {
	var lt = Array.prototype.slice.call(arguments, 3);
	try {
		et.apply(tt, lt);
	} catch (ut) {
		this.onError(ut);
	}
}
var Ob = !1,
	Pb = null,
	Qb = !1,
	Rb = null,
	Sb = {
		onError: function (_) {
			(Ob = !0), (Pb = _);
		},
	};
function Tb(_, et, tt, nt, rt, it, ot, at, st) {
	(Ob = !1), (Pb = null), Nb.apply(Sb, arguments);
}
function Ub(_, et, tt, nt, rt, it, ot, at, st) {
	if ((Tb.apply(this, arguments), Ob)) {
		if (Ob) {
			var lt = Pb;
			(Ob = !1), (Pb = null);
		} else throw Error(p$3(198));
		Qb || ((Qb = !0), (Rb = lt));
	}
}
function Vb(_) {
	var et = _,
		tt = _;
	if (_.alternate) for (; et.return; ) et = et.return;
	else {
		_ = et;
		do (et = _), (et.flags & 4098) !== 0 && (tt = et.return), (_ = et.return);
		while (_);
	}
	return et.tag === 3 ? tt : null;
}
function Wb(_) {
	if (_.tag === 13) {
		var et = _.memoizedState;
		if ((et === null && ((_ = _.alternate), _ !== null && (et = _.memoizedState)), et !== null)) return et.dehydrated;
	}
	return null;
}
function Xb(_) {
	if (Vb(_) !== _) throw Error(p$3(188));
}
function Yb(_) {
	var et = _.alternate;
	if (!et) {
		if (((et = Vb(_)), et === null)) throw Error(p$3(188));
		return et !== _ ? null : _;
	}
	for (var tt = _, nt = et; ; ) {
		var rt = tt.return;
		if (rt === null) break;
		var it = rt.alternate;
		if (it === null) {
			if (((nt = rt.return), nt !== null)) {
				tt = nt;
				continue;
			}
			break;
		}
		if (rt.child === it.child) {
			for (it = rt.child; it; ) {
				if (it === tt) return Xb(rt), _;
				if (it === nt) return Xb(rt), et;
				it = it.sibling;
			}
			throw Error(p$3(188));
		}
		if (tt.return !== nt.return) (tt = rt), (nt = it);
		else {
			for (var ot = !1, at = rt.child; at; ) {
				if (at === tt) {
					(ot = !0), (tt = rt), (nt = it);
					break;
				}
				if (at === nt) {
					(ot = !0), (nt = rt), (tt = it);
					break;
				}
				at = at.sibling;
			}
			if (!ot) {
				for (at = it.child; at; ) {
					if (at === tt) {
						(ot = !0), (tt = it), (nt = rt);
						break;
					}
					if (at === nt) {
						(ot = !0), (nt = it), (tt = rt);
						break;
					}
					at = at.sibling;
				}
				if (!ot) throw Error(p$3(189));
			}
		}
		if (tt.alternate !== nt) throw Error(p$3(190));
	}
	if (tt.tag !== 3) throw Error(p$3(188));
	return tt.stateNode.current === tt ? _ : et;
}
function Zb(_) {
	return (_ = Yb(_)), _ !== null ? $b(_) : null;
}
function $b(_) {
	if (_.tag === 5 || _.tag === 6) return _;
	for (_ = _.child; _ !== null; ) {
		var et = $b(_);
		if (et !== null) return et;
		_ = _.sibling;
	}
	return null;
}
var ac = ca.unstable_scheduleCallback,
	bc = ca.unstable_cancelCallback,
	cc = ca.unstable_shouldYield,
	dc = ca.unstable_requestPaint,
	B$1 = ca.unstable_now,
	ec = ca.unstable_getCurrentPriorityLevel,
	fc = ca.unstable_ImmediatePriority,
	gc = ca.unstable_UserBlockingPriority,
	hc = ca.unstable_NormalPriority,
	ic = ca.unstable_LowPriority,
	jc = ca.unstable_IdlePriority,
	kc = null,
	lc = null;
function mc(_) {
	if (lc && typeof lc.onCommitFiberRoot == "function")
		try {
			lc.onCommitFiberRoot(kc, _, void 0, (_.current.flags & 128) === 128);
		} catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc,
	pc = Math.log,
	qc = Math.LN2;
function nc(_) {
	return (_ >>>= 0), _ === 0 ? 32 : (31 - ((pc(_) / qc) | 0)) | 0;
}
var rc = 64,
	sc = 4194304;
function tc(_) {
	switch (_ & -_) {
		case 1:
			return 1;
		case 2:
			return 2;
		case 4:
			return 4;
		case 8:
			return 8;
		case 16:
			return 16;
		case 32:
			return 32;
		case 64:
		case 128:
		case 256:
		case 512:
		case 1024:
		case 2048:
		case 4096:
		case 8192:
		case 16384:
		case 32768:
		case 65536:
		case 131072:
		case 262144:
		case 524288:
		case 1048576:
		case 2097152:
			return _ & 4194240;
		case 4194304:
		case 8388608:
		case 16777216:
		case 33554432:
		case 67108864:
			return _ & 130023424;
		case 134217728:
			return 134217728;
		case 268435456:
			return 268435456;
		case 536870912:
			return 536870912;
		case 1073741824:
			return 1073741824;
		default:
			return _;
	}
}
function uc(_, et) {
	var tt = _.pendingLanes;
	if (tt === 0) return 0;
	var nt = 0,
		rt = _.suspendedLanes,
		it = _.pingedLanes,
		ot = tt & 268435455;
	if (ot !== 0) {
		var at = ot & ~rt;
		at !== 0 ? (nt = tc(at)) : ((it &= ot), it !== 0 && (nt = tc(it)));
	} else (ot = tt & ~rt), ot !== 0 ? (nt = tc(ot)) : it !== 0 && (nt = tc(it));
	if (nt === 0) return 0;
	if (
		et !== 0 &&
		et !== nt &&
		(et & rt) === 0 &&
		((rt = nt & -nt), (it = et & -et), rt >= it || (rt === 16 && (it & 4194240) !== 0))
	)
		return et;
	if (((nt & 4) !== 0 && (nt |= tt & 16), (et = _.entangledLanes), et !== 0))
		for (_ = _.entanglements, et &= nt; 0 < et; ) (tt = 31 - oc(et)), (rt = 1 << tt), (nt |= _[tt]), (et &= ~rt);
	return nt;
}
function vc(_, et) {
	switch (_) {
		case 1:
		case 2:
		case 4:
			return et + 250;
		case 8:
		case 16:
		case 32:
		case 64:
		case 128:
		case 256:
		case 512:
		case 1024:
		case 2048:
		case 4096:
		case 8192:
		case 16384:
		case 32768:
		case 65536:
		case 131072:
		case 262144:
		case 524288:
		case 1048576:
		case 2097152:
			return et + 5e3;
		case 4194304:
		case 8388608:
		case 16777216:
		case 33554432:
		case 67108864:
			return -1;
		case 134217728:
		case 268435456:
		case 536870912:
		case 1073741824:
			return -1;
		default:
			return -1;
	}
}
function wc(_, et) {
	for (var tt = _.suspendedLanes, nt = _.pingedLanes, rt = _.expirationTimes, it = _.pendingLanes; 0 < it; ) {
		var ot = 31 - oc(it),
			at = 1 << ot,
			st = rt[ot];
		st === -1 ? ((at & tt) === 0 || (at & nt) !== 0) && (rt[ot] = vc(at, et)) : st <= et && (_.expiredLanes |= at),
			(it &= ~at);
	}
}
function xc(_) {
	return (_ = _.pendingLanes & -1073741825), _ !== 0 ? _ : _ & 1073741824 ? 1073741824 : 0;
}
function yc() {
	var _ = rc;
	return (rc <<= 1), (rc & 4194240) === 0 && (rc = 64), _;
}
function zc(_) {
	for (var et = [], tt = 0; 31 > tt; tt++) et.push(_);
	return et;
}
function Ac(_, et, tt) {
	(_.pendingLanes |= et),
		et !== 536870912 && ((_.suspendedLanes = 0), (_.pingedLanes = 0)),
		(_ = _.eventTimes),
		(et = 31 - oc(et)),
		(_[et] = tt);
}
function Bc(_, et) {
	var tt = _.pendingLanes & ~et;
	(_.pendingLanes = et),
		(_.suspendedLanes = 0),
		(_.pingedLanes = 0),
		(_.expiredLanes &= et),
		(_.mutableReadLanes &= et),
		(_.entangledLanes &= et),
		(et = _.entanglements);
	var nt = _.eventTimes;
	for (_ = _.expirationTimes; 0 < tt; ) {
		var rt = 31 - oc(tt),
			it = 1 << rt;
		(et[rt] = 0), (nt[rt] = -1), (_[rt] = -1), (tt &= ~it);
	}
}
function Cc(_, et) {
	var tt = (_.entangledLanes |= et);
	for (_ = _.entanglements; tt; ) {
		var nt = 31 - oc(tt),
			rt = 1 << nt;
		(rt & et) | (_[nt] & et) && (_[nt] |= et), (tt &= ~rt);
	}
}
var C$2 = 0;
function Dc(_) {
	return (_ &= -_), 1 < _ ? (4 < _ ? ((_ & 268435455) !== 0 ? 16 : 536870912) : 4) : 1;
}
var Ec,
	Fc,
	Gc,
	Hc,
	Ic,
	Jc = !1,
	Kc = [],
	Lc = null,
	Mc = null,
	Nc = null,
	Oc = new Map(),
	Pc = new Map(),
	Qc = [],
	Rc =
		"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
			" "
		);
function Sc(_, et) {
	switch (_) {
		case "focusin":
		case "focusout":
			Lc = null;
			break;
		case "dragenter":
		case "dragleave":
			Mc = null;
			break;
		case "mouseover":
		case "mouseout":
			Nc = null;
			break;
		case "pointerover":
		case "pointerout":
			Oc.delete(et.pointerId);
			break;
		case "gotpointercapture":
		case "lostpointercapture":
			Pc.delete(et.pointerId);
	}
}
function Tc(_, et, tt, nt, rt, it) {
	return _ === null || _.nativeEvent !== it
		? ((_ = { blockedOn: et, domEventName: tt, eventSystemFlags: nt, nativeEvent: it, targetContainers: [rt] }),
		  et !== null && ((et = Cb(et)), et !== null && Fc(et)),
		  _)
		: ((_.eventSystemFlags |= nt), (et = _.targetContainers), rt !== null && et.indexOf(rt) === -1 && et.push(rt), _);
}
function Uc(_, et, tt, nt, rt) {
	switch (et) {
		case "focusin":
			return (Lc = Tc(Lc, _, et, tt, nt, rt)), !0;
		case "dragenter":
			return (Mc = Tc(Mc, _, et, tt, nt, rt)), !0;
		case "mouseover":
			return (Nc = Tc(Nc, _, et, tt, nt, rt)), !0;
		case "pointerover":
			var it = rt.pointerId;
			return Oc.set(it, Tc(Oc.get(it) || null, _, et, tt, nt, rt)), !0;
		case "gotpointercapture":
			return (it = rt.pointerId), Pc.set(it, Tc(Pc.get(it) || null, _, et, tt, nt, rt)), !0;
	}
	return !1;
}
function Vc(_) {
	var et = Wc(_.target);
	if (et !== null) {
		var tt = Vb(et);
		if (tt !== null) {
			if (((et = tt.tag), et === 13)) {
				if (((et = Wb(tt)), et !== null)) {
					(_.blockedOn = et),
						Ic(_.priority, function () {
							Gc(tt);
						});
					return;
				}
			} else if (et === 3 && tt.stateNode.current.memoizedState.isDehydrated) {
				_.blockedOn = tt.tag === 3 ? tt.stateNode.containerInfo : null;
				return;
			}
		}
	}
	_.blockedOn = null;
}
function Xc(_) {
	if (_.blockedOn !== null) return !1;
	for (var et = _.targetContainers; 0 < et.length; ) {
		var tt = Yc(_.domEventName, _.eventSystemFlags, et[0], _.nativeEvent);
		if (tt === null) {
			tt = _.nativeEvent;
			var nt = new tt.constructor(tt.type, tt);
			(wb = nt), tt.target.dispatchEvent(nt), (wb = null);
		} else return (et = Cb(tt)), et !== null && Fc(et), (_.blockedOn = tt), !1;
		et.shift();
	}
	return !0;
}
function Zc(_, et, tt) {
	Xc(_) && tt.delete(et);
}
function $c() {
	(Jc = !1),
		Lc !== null && Xc(Lc) && (Lc = null),
		Mc !== null && Xc(Mc) && (Mc = null),
		Nc !== null && Xc(Nc) && (Nc = null),
		Oc.forEach(Zc),
		Pc.forEach(Zc);
}
function ad(_, et) {
	_.blockedOn === et &&
		((_.blockedOn = null), Jc || ((Jc = !0), ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(_) {
	function et(rt) {
		return ad(rt, _);
	}
	if (0 < Kc.length) {
		ad(Kc[0], _);
		for (var tt = 1; tt < Kc.length; tt++) {
			var nt = Kc[tt];
			nt.blockedOn === _ && (nt.blockedOn = null);
		}
	}
	for (
		Lc !== null && ad(Lc, _),
			Mc !== null && ad(Mc, _),
			Nc !== null && ad(Nc, _),
			Oc.forEach(et),
			Pc.forEach(et),
			tt = 0;
		tt < Qc.length;
		tt++
	)
		(nt = Qc[tt]), nt.blockedOn === _ && (nt.blockedOn = null);
	for (; 0 < Qc.length && ((tt = Qc[0]), tt.blockedOn === null); ) Vc(tt), tt.blockedOn === null && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig,
	dd = !0;
function ed(_, et, tt, nt) {
	var rt = C$2,
		it = cd.transition;
	cd.transition = null;
	try {
		(C$2 = 1), fd(_, et, tt, nt);
	} finally {
		(C$2 = rt), (cd.transition = it);
	}
}
function gd(_, et, tt, nt) {
	var rt = C$2,
		it = cd.transition;
	cd.transition = null;
	try {
		(C$2 = 4), fd(_, et, tt, nt);
	} finally {
		(C$2 = rt), (cd.transition = it);
	}
}
function fd(_, et, tt, nt) {
	if (dd) {
		var rt = Yc(_, et, tt, nt);
		if (rt === null) hd(_, et, nt, id, tt), Sc(_, nt);
		else if (Uc(rt, _, et, tt, nt)) nt.stopPropagation();
		else if ((Sc(_, nt), et & 4 && -1 < Rc.indexOf(_))) {
			for (; rt !== null; ) {
				var it = Cb(rt);
				if ((it !== null && Ec(it), (it = Yc(_, et, tt, nt)), it === null && hd(_, et, nt, id, tt), it === rt)) break;
				rt = it;
			}
			rt !== null && nt.stopPropagation();
		} else hd(_, et, nt, null, tt);
	}
}
var id = null;
function Yc(_, et, tt, nt) {
	if (((id = null), (_ = xb(nt)), (_ = Wc(_)), _ !== null))
		if (((et = Vb(_)), et === null)) _ = null;
		else if (((tt = et.tag), tt === 13)) {
			if (((_ = Wb(et)), _ !== null)) return _;
			_ = null;
		} else if (tt === 3) {
			if (et.stateNode.current.memoizedState.isDehydrated) return et.tag === 3 ? et.stateNode.containerInfo : null;
			_ = null;
		} else et !== _ && (_ = null);
	return (id = _), null;
}
function jd(_) {
	switch (_) {
		case "cancel":
		case "click":
		case "close":
		case "contextmenu":
		case "copy":
		case "cut":
		case "auxclick":
		case "dblclick":
		case "dragend":
		case "dragstart":
		case "drop":
		case "focusin":
		case "focusout":
		case "input":
		case "invalid":
		case "keydown":
		case "keypress":
		case "keyup":
		case "mousedown":
		case "mouseup":
		case "paste":
		case "pause":
		case "play":
		case "pointercancel":
		case "pointerdown":
		case "pointerup":
		case "ratechange":
		case "reset":
		case "resize":
		case "seeked":
		case "submit":
		case "touchcancel":
		case "touchend":
		case "touchstart":
		case "volumechange":
		case "change":
		case "selectionchange":
		case "textInput":
		case "compositionstart":
		case "compositionend":
		case "compositionupdate":
		case "beforeblur":
		case "afterblur":
		case "beforeinput":
		case "blur":
		case "fullscreenchange":
		case "focus":
		case "hashchange":
		case "popstate":
		case "select":
		case "selectstart":
			return 1;
		case "drag":
		case "dragenter":
		case "dragexit":
		case "dragleave":
		case "dragover":
		case "mousemove":
		case "mouseout":
		case "mouseover":
		case "pointermove":
		case "pointerout":
		case "pointerover":
		case "scroll":
		case "toggle":
		case "touchmove":
		case "wheel":
		case "mouseenter":
		case "mouseleave":
		case "pointerenter":
		case "pointerleave":
			return 4;
		case "message":
			switch (ec()) {
				case fc:
					return 1;
				case gc:
					return 4;
				case hc:
				case ic:
					return 16;
				case jc:
					return 536870912;
				default:
					return 16;
			}
		default:
			return 16;
	}
}
var kd = null,
	ld = null,
	md = null;
function nd() {
	if (md) return md;
	var _,
		et = ld,
		tt = et.length,
		nt,
		rt = "value" in kd ? kd.value : kd.textContent,
		it = rt.length;
	for (_ = 0; _ < tt && et[_] === rt[_]; _++);
	var ot = tt - _;
	for (nt = 1; nt <= ot && et[tt - nt] === rt[it - nt]; nt++);
	return (md = rt.slice(_, 1 < nt ? 1 - nt : void 0));
}
function od(_) {
	var et = _.keyCode;
	return (
		"charCode" in _ ? ((_ = _.charCode), _ === 0 && et === 13 && (_ = 13)) : (_ = et),
		_ === 10 && (_ = 13),
		32 <= _ || _ === 13 ? _ : 0
	);
}
function pd() {
	return !0;
}
function qd() {
	return !1;
}
function rd(_) {
	function et(tt, nt, rt, it, ot) {
		(this._reactName = tt),
			(this._targetInst = rt),
			(this.type = nt),
			(this.nativeEvent = it),
			(this.target = ot),
			(this.currentTarget = null);
		for (var at in _) _.hasOwnProperty(at) && ((tt = _[at]), (this[at] = tt ? tt(it) : it[at]));
		return (
			(this.isDefaultPrevented = (it.defaultPrevented != null ? it.defaultPrevented : it.returnValue === !1) ? pd : qd),
			(this.isPropagationStopped = qd),
			this
		);
	}
	return (
		A(et.prototype, {
			preventDefault: function () {
				this.defaultPrevented = !0;
				var tt = this.nativeEvent;
				tt &&
					(tt.preventDefault ? tt.preventDefault() : typeof tt.returnValue != "unknown" && (tt.returnValue = !1),
					(this.isDefaultPrevented = pd));
			},
			stopPropagation: function () {
				var tt = this.nativeEvent;
				tt &&
					(tt.stopPropagation ? tt.stopPropagation() : typeof tt.cancelBubble != "unknown" && (tt.cancelBubble = !0),
					(this.isPropagationStopped = pd));
			},
			persist: function () {},
			isPersistent: pd,
		}),
		et
	);
}
var sd = {
		eventPhase: 0,
		bubbles: 0,
		cancelable: 0,
		timeStamp: function (_) {
			return _.timeStamp || Date.now();
		},
		defaultPrevented: 0,
		isTrusted: 0,
	},
	td = rd(sd),
	ud = A({}, sd, { view: 0, detail: 0 }),
	vd = rd(ud),
	wd,
	xd,
	yd,
	Ad = A({}, ud, {
		screenX: 0,
		screenY: 0,
		clientX: 0,
		clientY: 0,
		pageX: 0,
		pageY: 0,
		ctrlKey: 0,
		shiftKey: 0,
		altKey: 0,
		metaKey: 0,
		getModifierState: zd,
		button: 0,
		buttons: 0,
		relatedTarget: function (_) {
			return _.relatedTarget === void 0
				? _.fromElement === _.srcElement
					? _.toElement
					: _.fromElement
				: _.relatedTarget;
		},
		movementX: function (_) {
			return "movementX" in _
				? _.movementX
				: (_ !== yd &&
						(yd && _.type === "mousemove"
							? ((wd = _.screenX - yd.screenX), (xd = _.screenY - yd.screenY))
							: (xd = wd = 0),
						(yd = _)),
				  wd);
		},
		movementY: function (_) {
			return "movementY" in _ ? _.movementY : xd;
		},
	}),
	Bd = rd(Ad),
	Cd = A({}, Ad, { dataTransfer: 0 }),
	Dd = rd(Cd),
	Ed = A({}, ud, { relatedTarget: 0 }),
	Fd = rd(Ed),
	Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
	Hd = rd(Gd),
	Id = A({}, sd, {
		clipboardData: function (_) {
			return "clipboardData" in _ ? _.clipboardData : window.clipboardData;
		},
	}),
	Jd = rd(Id),
	Kd = A({}, sd, { data: 0 }),
	Ld = rd(Kd),
	Md = {
		Esc: "Escape",
		Spacebar: " ",
		Left: "ArrowLeft",
		Up: "ArrowUp",
		Right: "ArrowRight",
		Down: "ArrowDown",
		Del: "Delete",
		Win: "OS",
		Menu: "ContextMenu",
		Apps: "ContextMenu",
		Scroll: "ScrollLock",
		MozPrintableKey: "Unidentified",
	},
	Nd = {
		8: "Backspace",
		9: "Tab",
		12: "Clear",
		13: "Enter",
		16: "Shift",
		17: "Control",
		18: "Alt",
		19: "Pause",
		20: "CapsLock",
		27: "Escape",
		32: " ",
		33: "PageUp",
		34: "PageDown",
		35: "End",
		36: "Home",
		37: "ArrowLeft",
		38: "ArrowUp",
		39: "ArrowRight",
		40: "ArrowDown",
		45: "Insert",
		46: "Delete",
		112: "F1",
		113: "F2",
		114: "F3",
		115: "F4",
		116: "F5",
		117: "F6",
		118: "F7",
		119: "F8",
		120: "F9",
		121: "F10",
		122: "F11",
		123: "F12",
		144: "NumLock",
		145: "ScrollLock",
		224: "Meta",
	},
	Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(_) {
	var et = this.nativeEvent;
	return et.getModifierState ? et.getModifierState(_) : (_ = Od[_]) ? !!et[_] : !1;
}
function zd() {
	return Pd;
}
var Qd = A({}, ud, {
		key: function (_) {
			if (_.key) {
				var et = Md[_.key] || _.key;
				if (et !== "Unidentified") return et;
			}
			return _.type === "keypress"
				? ((_ = od(_)), _ === 13 ? "Enter" : String.fromCharCode(_))
				: _.type === "keydown" || _.type === "keyup"
				? Nd[_.keyCode] || "Unidentified"
				: "";
		},
		code: 0,
		location: 0,
		ctrlKey: 0,
		shiftKey: 0,
		altKey: 0,
		metaKey: 0,
		repeat: 0,
		locale: 0,
		getModifierState: zd,
		charCode: function (_) {
			return _.type === "keypress" ? od(_) : 0;
		},
		keyCode: function (_) {
			return _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0;
		},
		which: function (_) {
			return _.type === "keypress" ? od(_) : _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0;
		},
	}),
	Rd = rd(Qd),
	Sd = A({}, Ad, {
		pointerId: 0,
		width: 0,
		height: 0,
		pressure: 0,
		tangentialPressure: 0,
		tiltX: 0,
		tiltY: 0,
		twist: 0,
		pointerType: 0,
		isPrimary: 0,
	}),
	Td$1 = rd(Sd),
	Ud = A({}, ud, {
		touches: 0,
		targetTouches: 0,
		changedTouches: 0,
		altKey: 0,
		metaKey: 0,
		ctrlKey: 0,
		shiftKey: 0,
		getModifierState: zd,
	}),
	Vd = rd(Ud),
	Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
	Xd = rd(Wd),
	Yd = A({}, Ad, {
		deltaX: function (_) {
			return "deltaX" in _ ? _.deltaX : "wheelDeltaX" in _ ? -_.wheelDeltaX : 0;
		},
		deltaY: function (_) {
			return "deltaY" in _ ? _.deltaY : "wheelDeltaY" in _ ? -_.wheelDeltaY : "wheelDelta" in _ ? -_.wheelDelta : 0;
		},
		deltaZ: 0,
		deltaMode: 0,
	}),
	Zd = rd(Yd),
	$d = [9, 13, 27, 32],
	ae = ia && "CompositionEvent" in window,
	be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be,
	de = ia && (!ae || (be && 8 < be && 11 >= be)),
	ee$1 = String.fromCharCode(32),
	fe = !1;
function ge(_, et) {
	switch (_) {
		case "keyup":
			return $d.indexOf(et.keyCode) !== -1;
		case "keydown":
			return et.keyCode !== 229;
		case "keypress":
		case "mousedown":
		case "focusout":
			return !0;
		default:
			return !1;
	}
}
function he(_) {
	return (_ = _.detail), typeof _ == "object" && "data" in _ ? _.data : null;
}
var ie = !1;
function je(_, et) {
	switch (_) {
		case "compositionend":
			return he(et);
		case "keypress":
			return et.which !== 32 ? null : ((fe = !0), ee$1);
		case "textInput":
			return (_ = et.data), _ === ee$1 && fe ? null : _;
		default:
			return null;
	}
}
function ke(_, et) {
	if (ie)
		return _ === "compositionend" || (!ae && ge(_, et)) ? ((_ = nd()), (md = ld = kd = null), (ie = !1), _) : null;
	switch (_) {
		case "paste":
			return null;
		case "keypress":
			if (!(et.ctrlKey || et.altKey || et.metaKey) || (et.ctrlKey && et.altKey)) {
				if (et.char && 1 < et.char.length) return et.char;
				if (et.which) return String.fromCharCode(et.which);
			}
			return null;
		case "compositionend":
			return de && et.locale !== "ko" ? null : et.data;
		default:
			return null;
	}
}
var le$1 = {
	color: !0,
	date: !0,
	datetime: !0,
	"datetime-local": !0,
	email: !0,
	month: !0,
	number: !0,
	password: !0,
	range: !0,
	search: !0,
	tel: !0,
	text: !0,
	time: !0,
	url: !0,
	week: !0,
};
function me(_) {
	var et = _ && _.nodeName && _.nodeName.toLowerCase();
	return et === "input" ? !!le$1[_.type] : et === "textarea";
}
function ne$1(_, et, tt, nt) {
	Eb(nt),
		(et = oe$1(et, "onChange")),
		0 < et.length && ((tt = new td("onChange", "change", null, tt, nt)), _.push({ event: tt, listeners: et }));
}
var pe = null,
	qe = null;
function re$1(_) {
	se$1(_, 0);
}
function te$1(_) {
	var et = ue(_);
	if (Wa(et)) return _;
}
function ve(_, et) {
	if (_ === "change") return et;
}
var we = !1;
if (ia) {
	var xe;
	if (ia) {
		var ye = "oninput" in document;
		if (!ye) {
			var ze = document.createElement("div");
			ze.setAttribute("oninput", "return;"), (ye = typeof ze.oninput == "function");
		}
		xe = ye;
	} else xe = !1;
	we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
	pe && (pe.detachEvent("onpropertychange", Be), (qe = pe = null));
}
function Be(_) {
	if (_.propertyName === "value" && te$1(qe)) {
		var et = [];
		ne$1(et, qe, _, xb(_)), Jb(re$1, et);
	}
}
function Ce(_, et, tt) {
	_ === "focusin" ? (Ae(), (pe = et), (qe = tt), pe.attachEvent("onpropertychange", Be)) : _ === "focusout" && Ae();
}
function De(_) {
	if (_ === "selectionchange" || _ === "keyup" || _ === "keydown") return te$1(qe);
}
function Ee(_, et) {
	if (_ === "click") return te$1(et);
}
function Fe(_, et) {
	if (_ === "input" || _ === "change") return te$1(et);
}
function Ge(_, et) {
	return (_ === et && (_ !== 0 || 1 / _ === 1 / et)) || (_ !== _ && et !== et);
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(_, et) {
	if (He(_, et)) return !0;
	if (typeof _ != "object" || _ === null || typeof et != "object" || et === null) return !1;
	var tt = Object.keys(_),
		nt = Object.keys(et);
	if (tt.length !== nt.length) return !1;
	for (nt = 0; nt < tt.length; nt++) {
		var rt = tt[nt];
		if (!ja.call(et, rt) || !He(_[rt], et[rt])) return !1;
	}
	return !0;
}
function Je(_) {
	for (; _ && _.firstChild; ) _ = _.firstChild;
	return _;
}
function Ke(_, et) {
	var tt = Je(_);
	_ = 0;
	for (var nt; tt; ) {
		if (tt.nodeType === 3) {
			if (((nt = _ + tt.textContent.length), _ <= et && nt >= et)) return { node: tt, offset: et - _ };
			_ = nt;
		}
		e: {
			for (; tt; ) {
				if (tt.nextSibling) {
					tt = tt.nextSibling;
					break e;
				}
				tt = tt.parentNode;
			}
			tt = void 0;
		}
		tt = Je(tt);
	}
}
function Le(_, et) {
	return _ && et
		? _ === et
			? !0
			: _ && _.nodeType === 3
			? !1
			: et && et.nodeType === 3
			? Le(_, et.parentNode)
			: "contains" in _
			? _.contains(et)
			: _.compareDocumentPosition
			? !!(_.compareDocumentPosition(et) & 16)
			: !1
		: !1;
}
function Me() {
	for (var _ = window, et = Xa(); et instanceof _.HTMLIFrameElement; ) {
		try {
			var tt = typeof et.contentWindow.location.href == "string";
		} catch {
			tt = !1;
		}
		if (tt) _ = et.contentWindow;
		else break;
		et = Xa(_.document);
	}
	return et;
}
function Ne(_) {
	var et = _ && _.nodeName && _.nodeName.toLowerCase();
	return (
		et &&
		((et === "input" &&
			(_.type === "text" || _.type === "search" || _.type === "tel" || _.type === "url" || _.type === "password")) ||
			et === "textarea" ||
			_.contentEditable === "true")
	);
}
function Oe$1(_) {
	var et = Me(),
		tt = _.focusedElem,
		nt = _.selectionRange;
	if (et !== tt && tt && tt.ownerDocument && Le(tt.ownerDocument.documentElement, tt)) {
		if (nt !== null && Ne(tt)) {
			if (((et = nt.start), (_ = nt.end), _ === void 0 && (_ = et), "selectionStart" in tt))
				(tt.selectionStart = et), (tt.selectionEnd = Math.min(_, tt.value.length));
			else if (((_ = ((et = tt.ownerDocument || document) && et.defaultView) || window), _.getSelection)) {
				_ = _.getSelection();
				var rt = tt.textContent.length,
					it = Math.min(nt.start, rt);
				(nt = nt.end === void 0 ? it : Math.min(nt.end, rt)),
					!_.extend && it > nt && ((rt = nt), (nt = it), (it = rt)),
					(rt = Ke(tt, it));
				var ot = Ke(tt, nt);
				rt &&
					ot &&
					(_.rangeCount !== 1 ||
						_.anchorNode !== rt.node ||
						_.anchorOffset !== rt.offset ||
						_.focusNode !== ot.node ||
						_.focusOffset !== ot.offset) &&
					((et = et.createRange()),
					et.setStart(rt.node, rt.offset),
					_.removeAllRanges(),
					it > nt ? (_.addRange(et), _.extend(ot.node, ot.offset)) : (et.setEnd(ot.node, ot.offset), _.addRange(et)));
			}
		}
		for (et = [], _ = tt; (_ = _.parentNode); )
			_.nodeType === 1 && et.push({ element: _, left: _.scrollLeft, top: _.scrollTop });
		for (typeof tt.focus == "function" && tt.focus(), tt = 0; tt < et.length; tt++)
			(_ = et[tt]), (_.element.scrollLeft = _.left), (_.element.scrollTop = _.top);
	}
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
	Qe = null,
	Re = null,
	Se = null,
	Te = !1;
function Ue(_, et, tt) {
	var nt = tt.window === tt ? tt.document : tt.nodeType === 9 ? tt : tt.ownerDocument;
	Te ||
		Qe == null ||
		Qe !== Xa(nt) ||
		((nt = Qe),
		"selectionStart" in nt && Ne(nt)
			? (nt = { start: nt.selectionStart, end: nt.selectionEnd })
			: ((nt = ((nt.ownerDocument && nt.ownerDocument.defaultView) || window).getSelection()),
			  (nt = {
					anchorNode: nt.anchorNode,
					anchorOffset: nt.anchorOffset,
					focusNode: nt.focusNode,
					focusOffset: nt.focusOffset,
			  })),
		(Se && Ie(Se, nt)) ||
			((Se = nt),
			(nt = oe$1(Re, "onSelect")),
			0 < nt.length &&
				((et = new td("onSelect", "select", null, et, tt)), _.push({ event: et, listeners: nt }), (et.target = Qe))));
}
function Ve(_, et) {
	var tt = {};
	return (tt[_.toLowerCase()] = et.toLowerCase()), (tt["Webkit" + _] = "webkit" + et), (tt["Moz" + _] = "moz" + et), tt;
}
var We = {
		animationend: Ve("Animation", "AnimationEnd"),
		animationiteration: Ve("Animation", "AnimationIteration"),
		animationstart: Ve("Animation", "AnimationStart"),
		transitionend: Ve("Transition", "TransitionEnd"),
	},
	Xe = {},
	Ye = {};
ia &&
	((Ye = document.createElement("div").style),
	"AnimationEvent" in window ||
		(delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation),
	"TransitionEvent" in window || delete We.transitionend.transition);
function Ze(_) {
	if (Xe[_]) return Xe[_];
	if (!We[_]) return _;
	var et = We[_],
		tt;
	for (tt in et) if (et.hasOwnProperty(tt) && tt in Ye) return (Xe[_] = et[tt]);
	return _;
}
var $e = Ze("animationend"),
	af = Ze("animationiteration"),
	bf = Ze("animationstart"),
	cf = Ze("transitionend"),
	df = new Map(),
	ef =
		"abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
			" "
		);
function ff(_, et) {
	df.set(_, et), fa(et, [_]);
}
for (var gf = 0; gf < ef.length; gf++) {
	var hf = ef[gf],
		jf = hf.toLowerCase(),
		kf = hf[0].toUpperCase() + hf.slice(1);
	ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf =
		"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
			" "
		),
	mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(_, et, tt) {
	var nt = _.type || "unknown-event";
	(_.currentTarget = tt), Ub(nt, et, void 0, _), (_.currentTarget = null);
}
function se$1(_, et) {
	et = (et & 4) !== 0;
	for (var tt = 0; tt < _.length; tt++) {
		var nt = _[tt],
			rt = nt.event;
		nt = nt.listeners;
		e: {
			var it = void 0;
			if (et)
				for (var ot = nt.length - 1; 0 <= ot; ot--) {
					var at = nt[ot],
						st = at.instance,
						lt = at.currentTarget;
					if (((at = at.listener), st !== it && rt.isPropagationStopped())) break e;
					nf(rt, at, lt), (it = st);
				}
			else
				for (ot = 0; ot < nt.length; ot++) {
					if (
						((at = nt[ot]),
						(st = at.instance),
						(lt = at.currentTarget),
						(at = at.listener),
						st !== it && rt.isPropagationStopped())
					)
						break e;
					nf(rt, at, lt), (it = st);
				}
		}
	}
	if (Qb) throw ((_ = Rb), (Qb = !1), (Rb = null), _);
}
function D(_, et) {
	var tt = et[of];
	tt === void 0 && (tt = et[of] = new Set());
	var nt = _ + "__bubble";
	tt.has(nt) || (pf(et, _, 2, !1), tt.add(nt));
}
function qf(_, et, tt) {
	var nt = 0;
	et && (nt |= 4), pf(tt, _, nt, et);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(_) {
	if (!_[rf]) {
		(_[rf] = !0),
			da.forEach(function (tt) {
				tt !== "selectionchange" && (mf.has(tt) || qf(tt, !1, _), qf(tt, !0, _));
			});
		var et = _.nodeType === 9 ? _ : _.ownerDocument;
		et === null || et[rf] || ((et[rf] = !0), qf("selectionchange", !1, et));
	}
}
function pf(_, et, tt, nt) {
	switch (jd(et)) {
		case 1:
			var rt = ed;
			break;
		case 4:
			rt = gd;
			break;
		default:
			rt = fd;
	}
	(tt = rt.bind(null, et, tt, _)),
		(rt = void 0),
		!Lb || (et !== "touchstart" && et !== "touchmove" && et !== "wheel") || (rt = !0),
		nt
			? rt !== void 0
				? _.addEventListener(et, tt, { capture: !0, passive: rt })
				: _.addEventListener(et, tt, !0)
			: rt !== void 0
			? _.addEventListener(et, tt, { passive: rt })
			: _.addEventListener(et, tt, !1);
}
function hd(_, et, tt, nt, rt) {
	var it = nt;
	if ((et & 1) === 0 && (et & 2) === 0 && nt !== null)
		e: for (;;) {
			if (nt === null) return;
			var ot = nt.tag;
			if (ot === 3 || ot === 4) {
				var at = nt.stateNode.containerInfo;
				if (at === rt || (at.nodeType === 8 && at.parentNode === rt)) break;
				if (ot === 4)
					for (ot = nt.return; ot !== null; ) {
						var st = ot.tag;
						if (
							(st === 3 || st === 4) &&
							((st = ot.stateNode.containerInfo), st === rt || (st.nodeType === 8 && st.parentNode === rt))
						)
							return;
						ot = ot.return;
					}
				for (; at !== null; ) {
					if (((ot = Wc(at)), ot === null)) return;
					if (((st = ot.tag), st === 5 || st === 6)) {
						nt = it = ot;
						continue e;
					}
					at = at.parentNode;
				}
			}
			nt = nt.return;
		}
	Jb(function () {
		var lt = it,
			ut = xb(tt),
			dt = [];
		e: {
			var ct = df.get(_);
			if (ct !== void 0) {
				var ft = td,
					mt = _;
				switch (_) {
					case "keypress":
						if (od(tt) === 0) break e;
					case "keydown":
					case "keyup":
						ft = Rd;
						break;
					case "focusin":
						(mt = "focus"), (ft = Fd);
						break;
					case "focusout":
						(mt = "blur"), (ft = Fd);
						break;
					case "beforeblur":
					case "afterblur":
						ft = Fd;
						break;
					case "click":
						if (tt.button === 2) break e;
					case "auxclick":
					case "dblclick":
					case "mousedown":
					case "mousemove":
					case "mouseup":
					case "mouseout":
					case "mouseover":
					case "contextmenu":
						ft = Bd;
						break;
					case "drag":
					case "dragend":
					case "dragenter":
					case "dragexit":
					case "dragleave":
					case "dragover":
					case "dragstart":
					case "drop":
						ft = Dd;
						break;
					case "touchcancel":
					case "touchend":
					case "touchmove":
					case "touchstart":
						ft = Vd;
						break;
					case $e:
					case af:
					case bf:
						ft = Hd;
						break;
					case cf:
						ft = Xd;
						break;
					case "scroll":
						ft = vd;
						break;
					case "wheel":
						ft = Zd;
						break;
					case "copy":
					case "cut":
					case "paste":
						ft = Jd;
						break;
					case "gotpointercapture":
					case "lostpointercapture":
					case "pointercancel":
					case "pointerdown":
					case "pointermove":
					case "pointerout":
					case "pointerover":
					case "pointerup":
						ft = Td$1;
				}
				var pt = (et & 4) !== 0,
					vt = !pt && _ === "scroll",
					ht = pt ? (ct !== null ? ct + "Capture" : null) : ct;
				pt = [];
				for (var gt = lt, yt; gt !== null; ) {
					yt = gt;
					var xt = yt.stateNode;
					if (
						(yt.tag === 5 &&
							xt !== null &&
							((yt = xt), ht !== null && ((xt = Kb(gt, ht)), xt != null && pt.push(tf(gt, xt, yt)))),
						vt)
					)
						break;
					gt = gt.return;
				}
				0 < pt.length && ((ct = new ft(ct, mt, null, tt, ut)), dt.push({ event: ct, listeners: pt }));
			}
		}
		if ((et & 7) === 0) {
			e: {
				if (
					((ct = _ === "mouseover" || _ === "pointerover"),
					(ft = _ === "mouseout" || _ === "pointerout"),
					ct && tt !== wb && (mt = tt.relatedTarget || tt.fromElement) && (Wc(mt) || mt[uf]))
				)
					break e;
				if (
					(ft || ct) &&
					((ct = ut.window === ut ? ut : (ct = ut.ownerDocument) ? ct.defaultView || ct.parentWindow : window),
					ft
						? ((mt = tt.relatedTarget || tt.toElement),
						  (ft = lt),
						  (mt = mt ? Wc(mt) : null),
						  mt !== null && ((vt = Vb(mt)), mt !== vt || (mt.tag !== 5 && mt.tag !== 6)) && (mt = null))
						: ((ft = null), (mt = lt)),
					ft !== mt)
				) {
					if (
						((pt = Bd),
						(xt = "onMouseLeave"),
						(ht = "onMouseEnter"),
						(gt = "mouse"),
						(_ === "pointerout" || _ === "pointerover") &&
							((pt = Td$1), (xt = "onPointerLeave"), (ht = "onPointerEnter"), (gt = "pointer")),
						(vt = ft == null ? ct : ue(ft)),
						(yt = mt == null ? ct : ue(mt)),
						(ct = new pt(xt, gt + "leave", ft, tt, ut)),
						(ct.target = vt),
						(ct.relatedTarget = yt),
						(xt = null),
						Wc(ut) === lt &&
							((pt = new pt(ht, gt + "enter", mt, tt, ut)), (pt.target = yt), (pt.relatedTarget = vt), (xt = pt)),
						(vt = xt),
						ft && mt)
					)
						t: {
							for (pt = ft, ht = mt, gt = 0, yt = pt; yt; yt = vf(yt)) gt++;
							for (yt = 0, xt = ht; xt; xt = vf(xt)) yt++;
							for (; 0 < gt - yt; ) (pt = vf(pt)), gt--;
							for (; 0 < yt - gt; ) (ht = vf(ht)), yt--;
							for (; gt--; ) {
								if (pt === ht || (ht !== null && pt === ht.alternate)) break t;
								(pt = vf(pt)), (ht = vf(ht));
							}
							pt = null;
						}
					else pt = null;
					ft !== null && wf(dt, ct, ft, pt, !1), mt !== null && vt !== null && wf(dt, vt, mt, pt, !0);
				}
			}
			e: {
				if (
					((ct = lt ? ue(lt) : window),
					(ft = ct.nodeName && ct.nodeName.toLowerCase()),
					ft === "select" || (ft === "input" && ct.type === "file"))
				)
					var St = ve;
				else if (me(ct))
					if (we) St = Fe;
					else {
						St = De;
						var wt = Ce;
					}
				else
					(ft = ct.nodeName) &&
						ft.toLowerCase() === "input" &&
						(ct.type === "checkbox" || ct.type === "radio") &&
						(St = Ee);
				if (St && (St = St(_, lt))) {
					ne$1(dt, St, tt, ut);
					break e;
				}
				wt && wt(_, ct, lt),
					_ === "focusout" &&
						(wt = ct._wrapperState) &&
						wt.controlled &&
						ct.type === "number" &&
						cb(ct, "number", ct.value);
			}
			switch (((wt = lt ? ue(lt) : window), _)) {
				case "focusin":
					(me(wt) || wt.contentEditable === "true") && ((Qe = wt), (Re = lt), (Se = null));
					break;
				case "focusout":
					Se = Re = Qe = null;
					break;
				case "mousedown":
					Te = !0;
					break;
				case "contextmenu":
				case "mouseup":
				case "dragend":
					(Te = !1), Ue(dt, tt, ut);
					break;
				case "selectionchange":
					if (Pe) break;
				case "keydown":
				case "keyup":
					Ue(dt, tt, ut);
			}
			var Ct;
			if (ae)
				e: {
					switch (_) {
						case "compositionstart":
							var Et = "onCompositionStart";
							break e;
						case "compositionend":
							Et = "onCompositionEnd";
							break e;
						case "compositionupdate":
							Et = "onCompositionUpdate";
							break e;
					}
					Et = void 0;
				}
			else
				ie
					? ge(_, tt) && (Et = "onCompositionEnd")
					: _ === "keydown" && tt.keyCode === 229 && (Et = "onCompositionStart");
			Et &&
				(de &&
					tt.locale !== "ko" &&
					(ie || Et !== "onCompositionStart"
						? Et === "onCompositionEnd" && ie && (Ct = nd())
						: ((kd = ut), (ld = "value" in kd ? kd.value : kd.textContent), (ie = !0))),
				(wt = oe$1(lt, Et)),
				0 < wt.length &&
					((Et = new Ld(Et, _, null, tt, ut)),
					dt.push({ event: Et, listeners: wt }),
					Ct ? (Et.data = Ct) : ((Ct = he(tt)), Ct !== null && (Et.data = Ct)))),
				(Ct = ce ? je(_, tt) : ke(_, tt)) &&
					((lt = oe$1(lt, "onBeforeInput")),
					0 < lt.length &&
						((ut = new Ld("onBeforeInput", "beforeinput", null, tt, ut)),
						dt.push({ event: ut, listeners: lt }),
						(ut.data = Ct)));
		}
		se$1(dt, et);
	});
}
function tf(_, et, tt) {
	return { instance: _, listener: et, currentTarget: tt };
}
function oe$1(_, et) {
	for (var tt = et + "Capture", nt = []; _ !== null; ) {
		var rt = _,
			it = rt.stateNode;
		rt.tag === 5 &&
			it !== null &&
			((rt = it),
			(it = Kb(_, tt)),
			it != null && nt.unshift(tf(_, it, rt)),
			(it = Kb(_, et)),
			it != null && nt.push(tf(_, it, rt))),
			(_ = _.return);
	}
	return nt;
}
function vf(_) {
	if (_ === null) return null;
	do _ = _.return;
	while (_ && _.tag !== 5);
	return _ || null;
}
function wf(_, et, tt, nt, rt) {
	for (var it = et._reactName, ot = []; tt !== null && tt !== nt; ) {
		var at = tt,
			st = at.alternate,
			lt = at.stateNode;
		if (st !== null && st === nt) break;
		at.tag === 5 &&
			lt !== null &&
			((at = lt),
			rt
				? ((st = Kb(tt, it)), st != null && ot.unshift(tf(tt, st, at)))
				: rt || ((st = Kb(tt, it)), st != null && ot.push(tf(tt, st, at)))),
			(tt = tt.return);
	}
	ot.length !== 0 && _.push({ event: et, listeners: ot });
}
var xf = /\r\n?/g,
	yf = /\u0000|\uFFFD/g;
function zf(_) {
	return (typeof _ == "string" ? _ : "" + _)
		.replace(
			xf,
			`
`
		)
		.replace(yf, "");
}
function Af(_, et, tt) {
	if (((et = zf(et)), zf(_) !== et && tt)) throw Error(p$3(425));
}
function Bf() {}
var Cf = null,
	Df = null;
function Ef(_, et) {
	return (
		_ === "textarea" ||
		_ === "noscript" ||
		typeof et.children == "string" ||
		typeof et.children == "number" ||
		(typeof et.dangerouslySetInnerHTML == "object" &&
			et.dangerouslySetInnerHTML !== null &&
			et.dangerouslySetInnerHTML.__html != null)
	);
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0,
	Gf = typeof clearTimeout == "function" ? clearTimeout : void 0,
	Hf = typeof Promise == "function" ? Promise : void 0,
	Jf =
		typeof queueMicrotask == "function"
			? queueMicrotask
			: typeof Hf < "u"
			? function (_) {
					return Hf.resolve(null).then(_).catch(If);
			  }
			: Ff;
function If(_) {
	setTimeout(function () {
		throw _;
	});
}
function Kf(_, et) {
	var tt = et,
		nt = 0;
	do {
		var rt = tt.nextSibling;
		if ((_.removeChild(tt), rt && rt.nodeType === 8))
			if (((tt = rt.data), tt === "/$")) {
				if (nt === 0) {
					_.removeChild(rt), bd(et);
					return;
				}
				nt--;
			} else (tt !== "$" && tt !== "$?" && tt !== "$!") || nt++;
		tt = rt;
	} while (tt);
	bd(et);
}
function Lf(_) {
	for (; _ != null; _ = _.nextSibling) {
		var et = _.nodeType;
		if (et === 1 || et === 3) break;
		if (et === 8) {
			if (((et = _.data), et === "$" || et === "$!" || et === "$?")) break;
			if (et === "/$") return null;
		}
	}
	return _;
}
function Mf(_) {
	_ = _.previousSibling;
	for (var et = 0; _; ) {
		if (_.nodeType === 8) {
			var tt = _.data;
			if (tt === "$" || tt === "$!" || tt === "$?") {
				if (et === 0) return _;
				et--;
			} else tt === "/$" && et++;
		}
		_ = _.previousSibling;
	}
	return null;
}
var Nf = Math.random().toString(36).slice(2),
	Of = "__reactFiber$" + Nf,
	Pf = "__reactProps$" + Nf,
	uf = "__reactContainer$" + Nf,
	of = "__reactEvents$" + Nf,
	Qf = "__reactListeners$" + Nf,
	Rf = "__reactHandles$" + Nf;
function Wc(_) {
	var et = _[Of];
	if (et) return et;
	for (var tt = _.parentNode; tt; ) {
		if ((et = tt[uf] || tt[Of])) {
			if (((tt = et.alternate), et.child !== null || (tt !== null && tt.child !== null)))
				for (_ = Mf(_); _ !== null; ) {
					if ((tt = _[Of])) return tt;
					_ = Mf(_);
				}
			return et;
		}
		(_ = tt), (tt = _.parentNode);
	}
	return null;
}
function Cb(_) {
	return (_ = _[Of] || _[uf]), !_ || (_.tag !== 5 && _.tag !== 6 && _.tag !== 13 && _.tag !== 3) ? null : _;
}
function ue(_) {
	if (_.tag === 5 || _.tag === 6) return _.stateNode;
	throw Error(p$3(33));
}
function Db(_) {
	return _[Pf] || null;
}
var Sf = [],
	Tf = -1;
function Uf(_) {
	return { current: _ };
}
function E(_) {
	0 > Tf || ((_.current = Sf[Tf]), (Sf[Tf] = null), Tf--);
}
function G(_, et) {
	Tf++, (Sf[Tf] = _.current), (_.current = et);
}
var Vf = {},
	H$1 = Uf(Vf),
	Wf = Uf(!1),
	Xf = Vf;
function Yf(_, et) {
	var tt = _.type.contextTypes;
	if (!tt) return Vf;
	var nt = _.stateNode;
	if (nt && nt.__reactInternalMemoizedUnmaskedChildContext === et) return nt.__reactInternalMemoizedMaskedChildContext;
	var rt = {},
		it;
	for (it in tt) rt[it] = et[it];
	return (
		nt &&
			((_ = _.stateNode),
			(_.__reactInternalMemoizedUnmaskedChildContext = et),
			(_.__reactInternalMemoizedMaskedChildContext = rt)),
		rt
	);
}
function Zf(_) {
	return (_ = _.childContextTypes), _ != null;
}
function $f() {
	E(Wf), E(H$1);
}
function ag(_, et, tt) {
	if (H$1.current !== Vf) throw Error(p$3(168));
	G(H$1, et), G(Wf, tt);
}
function bg(_, et, tt) {
	var nt = _.stateNode;
	if (((et = et.childContextTypes), typeof nt.getChildContext != "function")) return tt;
	nt = nt.getChildContext();
	for (var rt in nt) if (!(rt in et)) throw Error(p$3(108, Ra(_) || "Unknown", rt));
	return A({}, tt, nt);
}
function cg(_) {
	return (
		(_ = ((_ = _.stateNode) && _.__reactInternalMemoizedMergedChildContext) || Vf),
		(Xf = H$1.current),
		G(H$1, _),
		G(Wf, Wf.current),
		!0
	);
}
function dg(_, et, tt) {
	var nt = _.stateNode;
	if (!nt) throw Error(p$3(169));
	tt ? ((_ = bg(_, et, Xf)), (nt.__reactInternalMemoizedMergedChildContext = _), E(Wf), E(H$1), G(H$1, _)) : E(Wf),
		G(Wf, tt);
}
var eg = null,
	fg = !1,
	gg = !1;
function hg(_) {
	eg === null ? (eg = [_]) : eg.push(_);
}
function ig(_) {
	(fg = !0), hg(_);
}
function jg() {
	if (!gg && eg !== null) {
		gg = !0;
		var _ = 0,
			et = C$2;
		try {
			var tt = eg;
			for (C$2 = 1; _ < tt.length; _++) {
				var nt = tt[_];
				do nt = nt(!0);
				while (nt !== null);
			}
			(eg = null), (fg = !1);
		} catch (rt) {
			throw (eg !== null && (eg = eg.slice(_ + 1)), ac(fc, jg), rt);
		} finally {
			(C$2 = et), (gg = !1);
		}
	}
	return null;
}
var kg = [],
	lg = 0,
	mg = null,
	ng = 0,
	og = [],
	pg = 0,
	qg = null,
	rg = 1,
	sg = "";
function tg(_, et) {
	(kg[lg++] = ng), (kg[lg++] = mg), (mg = _), (ng = et);
}
function ug(_, et, tt) {
	(og[pg++] = rg), (og[pg++] = sg), (og[pg++] = qg), (qg = _);
	var nt = rg;
	_ = sg;
	var rt = 32 - oc(nt) - 1;
	(nt &= ~(1 << rt)), (tt += 1);
	var it = 32 - oc(et) + rt;
	if (30 < it) {
		var ot = rt - (rt % 5);
		(it = (nt & ((1 << ot) - 1)).toString(32)),
			(nt >>= ot),
			(rt -= ot),
			(rg = (1 << (32 - oc(et) + rt)) | (tt << rt) | nt),
			(sg = it + _);
	} else (rg = (1 << it) | (tt << rt) | nt), (sg = _);
}
function vg(_) {
	_.return !== null && (tg(_, 1), ug(_, 1, 0));
}
function wg(_) {
	for (; _ === mg; ) (mg = kg[--lg]), (kg[lg] = null), (ng = kg[--lg]), (kg[lg] = null);
	for (; _ === qg; )
		(qg = og[--pg]), (og[pg] = null), (sg = og[--pg]), (og[pg] = null), (rg = og[--pg]), (og[pg] = null);
}
var xg = null,
	yg = null,
	I$1 = !1,
	zg = null;
function Ag(_, et) {
	var tt = Bg(5, null, null, 0);
	(tt.elementType = "DELETED"),
		(tt.stateNode = et),
		(tt.return = _),
		(et = _.deletions),
		et === null ? ((_.deletions = [tt]), (_.flags |= 16)) : et.push(tt);
}
function Cg(_, et) {
	switch (_.tag) {
		case 5:
			var tt = _.type;
			return (
				(et = et.nodeType !== 1 || tt.toLowerCase() !== et.nodeName.toLowerCase() ? null : et),
				et !== null ? ((_.stateNode = et), (xg = _), (yg = Lf(et.firstChild)), !0) : !1
			);
		case 6:
			return (
				(et = _.pendingProps === "" || et.nodeType !== 3 ? null : et),
				et !== null ? ((_.stateNode = et), (xg = _), (yg = null), !0) : !1
			);
		case 13:
			return (
				(et = et.nodeType !== 8 ? null : et),
				et !== null
					? ((tt = qg !== null ? { id: rg, overflow: sg } : null),
					  (_.memoizedState = { dehydrated: et, treeContext: tt, retryLane: 1073741824 }),
					  (tt = Bg(18, null, null, 0)),
					  (tt.stateNode = et),
					  (tt.return = _),
					  (_.child = tt),
					  (xg = _),
					  (yg = null),
					  !0)
					: !1
			);
		default:
			return !1;
	}
}
function Dg(_) {
	return (_.mode & 1) !== 0 && (_.flags & 128) === 0;
}
function Eg(_) {
	if (I$1) {
		var et = yg;
		if (et) {
			var tt = et;
			if (!Cg(_, et)) {
				if (Dg(_)) throw Error(p$3(418));
				et = Lf(tt.nextSibling);
				var nt = xg;
				et && Cg(_, et) ? Ag(nt, tt) : ((_.flags = (_.flags & -4097) | 2), (I$1 = !1), (xg = _));
			}
		} else {
			if (Dg(_)) throw Error(p$3(418));
			(_.flags = (_.flags & -4097) | 2), (I$1 = !1), (xg = _);
		}
	}
}
function Fg(_) {
	for (_ = _.return; _ !== null && _.tag !== 5 && _.tag !== 3 && _.tag !== 13; ) _ = _.return;
	xg = _;
}
function Gg(_) {
	if (_ !== xg) return !1;
	if (!I$1) return Fg(_), (I$1 = !0), !1;
	var et;
	if (
		((et = _.tag !== 3) &&
			!(et = _.tag !== 5) &&
			((et = _.type), (et = et !== "head" && et !== "body" && !Ef(_.type, _.memoizedProps))),
		et && (et = yg))
	) {
		if (Dg(_)) throw (Hg(), Error(p$3(418)));
		for (; et; ) Ag(_, et), (et = Lf(et.nextSibling));
	}
	if ((Fg(_), _.tag === 13)) {
		if (((_ = _.memoizedState), (_ = _ !== null ? _.dehydrated : null), !_)) throw Error(p$3(317));
		e: {
			for (_ = _.nextSibling, et = 0; _; ) {
				if (_.nodeType === 8) {
					var tt = _.data;
					if (tt === "/$") {
						if (et === 0) {
							yg = Lf(_.nextSibling);
							break e;
						}
						et--;
					} else (tt !== "$" && tt !== "$!" && tt !== "$?") || et++;
				}
				_ = _.nextSibling;
			}
			yg = null;
		}
	} else yg = xg ? Lf(_.stateNode.nextSibling) : null;
	return !0;
}
function Hg() {
	for (var _ = yg; _; ) _ = Lf(_.nextSibling);
}
function Ig() {
	(yg = xg = null), (I$1 = !1);
}
function Jg(_) {
	zg === null ? (zg = [_]) : zg.push(_);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(_, et) {
	if (_ && _.defaultProps) {
		(et = A({}, et)), (_ = _.defaultProps);
		for (var tt in _) et[tt] === void 0 && (et[tt] = _[tt]);
		return et;
	}
	return et;
}
var Mg = Uf(null),
	Ng = null,
	Og = null,
	Pg = null;
function Qg() {
	Pg = Og = Ng = null;
}
function Rg(_) {
	var et = Mg.current;
	E(Mg), (_._currentValue = et);
}
function Sg(_, et, tt) {
	for (; _ !== null; ) {
		var nt = _.alternate;
		if (
			((_.childLanes & et) !== et
				? ((_.childLanes |= et), nt !== null && (nt.childLanes |= et))
				: nt !== null && (nt.childLanes & et) !== et && (nt.childLanes |= et),
			_ === tt)
		)
			break;
		_ = _.return;
	}
}
function Tg(_, et) {
	(Ng = _),
		(Pg = Og = null),
		(_ = _.dependencies),
		_ !== null && _.firstContext !== null && ((_.lanes & et) !== 0 && (Ug = !0), (_.firstContext = null));
}
function Vg(_) {
	var et = _._currentValue;
	if (Pg !== _)
		if (((_ = { context: _, memoizedValue: et, next: null }), Og === null)) {
			if (Ng === null) throw Error(p$3(308));
			(Og = _), (Ng.dependencies = { lanes: 0, firstContext: _ });
		} else Og = Og.next = _;
	return et;
}
var Wg = null;
function Xg(_) {
	Wg === null ? (Wg = [_]) : Wg.push(_);
}
function Yg(_, et, tt, nt) {
	var rt = et.interleaved;
	return (
		rt === null ? ((tt.next = tt), Xg(et)) : ((tt.next = rt.next), (rt.next = tt)), (et.interleaved = tt), Zg(_, nt)
	);
}
function Zg(_, et) {
	_.lanes |= et;
	var tt = _.alternate;
	for (tt !== null && (tt.lanes |= et), tt = _, _ = _.return; _ !== null; )
		(_.childLanes |= et), (tt = _.alternate), tt !== null && (tt.childLanes |= et), (tt = _), (_ = _.return);
	return tt.tag === 3 ? tt.stateNode : null;
}
var $g = !1;
function ah(_) {
	_.updateQueue = {
		baseState: _.memoizedState,
		firstBaseUpdate: null,
		lastBaseUpdate: null,
		shared: { pending: null, interleaved: null, lanes: 0 },
		effects: null,
	};
}
function bh(_, et) {
	(_ = _.updateQueue),
		et.updateQueue === _ &&
			(et.updateQueue = {
				baseState: _.baseState,
				firstBaseUpdate: _.firstBaseUpdate,
				lastBaseUpdate: _.lastBaseUpdate,
				shared: _.shared,
				effects: _.effects,
			});
}
function ch(_, et) {
	return { eventTime: _, lane: et, tag: 0, payload: null, callback: null, next: null };
}
function dh(_, et, tt) {
	var nt = _.updateQueue;
	if (nt === null) return null;
	if (((nt = nt.shared), (K & 2) !== 0)) {
		var rt = nt.pending;
		return rt === null ? (et.next = et) : ((et.next = rt.next), (rt.next = et)), (nt.pending = et), Zg(_, tt);
	}
	return (
		(rt = nt.interleaved),
		rt === null ? ((et.next = et), Xg(nt)) : ((et.next = rt.next), (rt.next = et)),
		(nt.interleaved = et),
		Zg(_, tt)
	);
}
function eh(_, et, tt) {
	if (((et = et.updateQueue), et !== null && ((et = et.shared), (tt & 4194240) !== 0))) {
		var nt = et.lanes;
		(nt &= _.pendingLanes), (tt |= nt), (et.lanes = tt), Cc(_, tt);
	}
}
function fh(_, et) {
	var tt = _.updateQueue,
		nt = _.alternate;
	if (nt !== null && ((nt = nt.updateQueue), tt === nt)) {
		var rt = null,
			it = null;
		if (((tt = tt.firstBaseUpdate), tt !== null)) {
			do {
				var ot = {
					eventTime: tt.eventTime,
					lane: tt.lane,
					tag: tt.tag,
					payload: tt.payload,
					callback: tt.callback,
					next: null,
				};
				it === null ? (rt = it = ot) : (it = it.next = ot), (tt = tt.next);
			} while (tt !== null);
			it === null ? (rt = it = et) : (it = it.next = et);
		} else rt = it = et;
		(tt = { baseState: nt.baseState, firstBaseUpdate: rt, lastBaseUpdate: it, shared: nt.shared, effects: nt.effects }),
			(_.updateQueue = tt);
		return;
	}
	(_ = tt.lastBaseUpdate), _ === null ? (tt.firstBaseUpdate = et) : (_.next = et), (tt.lastBaseUpdate = et);
}
function gh(_, et, tt, nt) {
	var rt = _.updateQueue;
	$g = !1;
	var it = rt.firstBaseUpdate,
		ot = rt.lastBaseUpdate,
		at = rt.shared.pending;
	if (at !== null) {
		rt.shared.pending = null;
		var st = at,
			lt = st.next;
		(st.next = null), ot === null ? (it = lt) : (ot.next = lt), (ot = st);
		var ut = _.alternate;
		ut !== null &&
			((ut = ut.updateQueue),
			(at = ut.lastBaseUpdate),
			at !== ot && (at === null ? (ut.firstBaseUpdate = lt) : (at.next = lt), (ut.lastBaseUpdate = st)));
	}
	if (it !== null) {
		var dt = rt.baseState;
		(ot = 0), (ut = lt = st = null), (at = it);
		do {
			var ct = at.lane,
				ft = at.eventTime;
			if ((nt & ct) === ct) {
				ut !== null &&
					(ut = ut.next =
						{ eventTime: ft, lane: 0, tag: at.tag, payload: at.payload, callback: at.callback, next: null });
				e: {
					var mt = _,
						pt = at;
					switch (((ct = et), (ft = tt), pt.tag)) {
						case 1:
							if (((mt = pt.payload), typeof mt == "function")) {
								dt = mt.call(ft, dt, ct);
								break e;
							}
							dt = mt;
							break e;
						case 3:
							mt.flags = (mt.flags & -65537) | 128;
						case 0:
							if (((mt = pt.payload), (ct = typeof mt == "function" ? mt.call(ft, dt, ct) : mt), ct == null)) break e;
							dt = A({}, dt, ct);
							break e;
						case 2:
							$g = !0;
					}
				}
				at.callback !== null &&
					at.lane !== 0 &&
					((_.flags |= 64), (ct = rt.effects), ct === null ? (rt.effects = [at]) : ct.push(at));
			} else
				(ft = { eventTime: ft, lane: ct, tag: at.tag, payload: at.payload, callback: at.callback, next: null }),
					ut === null ? ((lt = ut = ft), (st = dt)) : (ut = ut.next = ft),
					(ot |= ct);
			if (((at = at.next), at === null)) {
				if (((at = rt.shared.pending), at === null)) break;
				(ct = at), (at = ct.next), (ct.next = null), (rt.lastBaseUpdate = ct), (rt.shared.pending = null);
			}
		} while (1);
		if (
			(ut === null && (st = dt),
			(rt.baseState = st),
			(rt.firstBaseUpdate = lt),
			(rt.lastBaseUpdate = ut),
			(et = rt.shared.interleaved),
			et !== null)
		) {
			rt = et;
			do (ot |= rt.lane), (rt = rt.next);
			while (rt !== et);
		} else it === null && (rt.shared.lanes = 0);
		(hh |= ot), (_.lanes = ot), (_.memoizedState = dt);
	}
}
function ih(_, et, tt) {
	if (((_ = et.effects), (et.effects = null), _ !== null))
		for (et = 0; et < _.length; et++) {
			var nt = _[et],
				rt = nt.callback;
			if (rt !== null) {
				if (((nt.callback = null), (nt = tt), typeof rt != "function")) throw Error(p$3(191, rt));
				rt.call(nt);
			}
		}
}
var jh = new aa.Component().refs;
function kh(_, et, tt, nt) {
	(et = _.memoizedState),
		(tt = tt(nt, et)),
		(tt = tt == null ? et : A({}, et, tt)),
		(_.memoizedState = tt),
		_.lanes === 0 && (_.updateQueue.baseState = tt);
}
var nh = {
	isMounted: function (_) {
		return (_ = _._reactInternals) ? Vb(_) === _ : !1;
	},
	enqueueSetState: function (_, et, tt) {
		_ = _._reactInternals;
		var nt = L(),
			rt = lh(_),
			it = ch(nt, rt);
		(it.payload = et),
			tt != null && (it.callback = tt),
			(et = dh(_, it, rt)),
			et !== null && (mh(et, _, rt, nt), eh(et, _, rt));
	},
	enqueueReplaceState: function (_, et, tt) {
		_ = _._reactInternals;
		var nt = L(),
			rt = lh(_),
			it = ch(nt, rt);
		(it.tag = 1),
			(it.payload = et),
			tt != null && (it.callback = tt),
			(et = dh(_, it, rt)),
			et !== null && (mh(et, _, rt, nt), eh(et, _, rt));
	},
	enqueueForceUpdate: function (_, et) {
		_ = _._reactInternals;
		var tt = L(),
			nt = lh(_),
			rt = ch(tt, nt);
		(rt.tag = 2),
			et != null && (rt.callback = et),
			(et = dh(_, rt, nt)),
			et !== null && (mh(et, _, nt, tt), eh(et, _, nt));
	},
};
function oh(_, et, tt, nt, rt, it, ot) {
	return (
		(_ = _.stateNode),
		typeof _.shouldComponentUpdate == "function"
			? _.shouldComponentUpdate(nt, it, ot)
			: et.prototype && et.prototype.isPureReactComponent
			? !Ie(tt, nt) || !Ie(rt, it)
			: !0
	);
}
function ph(_, et, tt) {
	var nt = !1,
		rt = Vf,
		it = et.contextType;
	return (
		typeof it == "object" && it !== null
			? (it = Vg(it))
			: ((rt = Zf(et) ? Xf : H$1.current), (nt = et.contextTypes), (it = (nt = nt != null) ? Yf(_, rt) : Vf)),
		(et = new et(tt, it)),
		(_.memoizedState = et.state !== null && et.state !== void 0 ? et.state : null),
		(et.updater = nh),
		(_.stateNode = et),
		(et._reactInternals = _),
		nt &&
			((_ = _.stateNode),
			(_.__reactInternalMemoizedUnmaskedChildContext = rt),
			(_.__reactInternalMemoizedMaskedChildContext = it)),
		et
	);
}
function qh(_, et, tt, nt) {
	(_ = et.state),
		typeof et.componentWillReceiveProps == "function" && et.componentWillReceiveProps(tt, nt),
		typeof et.UNSAFE_componentWillReceiveProps == "function" && et.UNSAFE_componentWillReceiveProps(tt, nt),
		et.state !== _ && nh.enqueueReplaceState(et, et.state, null);
}
function rh(_, et, tt, nt) {
	var rt = _.stateNode;
	(rt.props = tt), (rt.state = _.memoizedState), (rt.refs = jh), ah(_);
	var it = et.contextType;
	typeof it == "object" && it !== null
		? (rt.context = Vg(it))
		: ((it = Zf(et) ? Xf : H$1.current), (rt.context = Yf(_, it))),
		(rt.state = _.memoizedState),
		(it = et.getDerivedStateFromProps),
		typeof it == "function" && (kh(_, et, it, tt), (rt.state = _.memoizedState)),
		typeof et.getDerivedStateFromProps == "function" ||
			typeof rt.getSnapshotBeforeUpdate == "function" ||
			(typeof rt.UNSAFE_componentWillMount != "function" && typeof rt.componentWillMount != "function") ||
			((et = rt.state),
			typeof rt.componentWillMount == "function" && rt.componentWillMount(),
			typeof rt.UNSAFE_componentWillMount == "function" && rt.UNSAFE_componentWillMount(),
			et !== rt.state && nh.enqueueReplaceState(rt, rt.state, null),
			gh(_, tt, rt, nt),
			(rt.state = _.memoizedState)),
		typeof rt.componentDidMount == "function" && (_.flags |= 4194308);
}
function sh(_, et, tt) {
	if (((_ = tt.ref), _ !== null && typeof _ != "function" && typeof _ != "object")) {
		if (tt._owner) {
			if (((tt = tt._owner), tt)) {
				if (tt.tag !== 1) throw Error(p$3(309));
				var nt = tt.stateNode;
			}
			if (!nt) throw Error(p$3(147, _));
			var rt = nt,
				it = "" + _;
			return et !== null && et.ref !== null && typeof et.ref == "function" && et.ref._stringRef === it
				? et.ref
				: ((et = function (ot) {
						var at = rt.refs;
						at === jh && (at = rt.refs = {}), ot === null ? delete at[it] : (at[it] = ot);
				  }),
				  (et._stringRef = it),
				  et);
		}
		if (typeof _ != "string") throw Error(p$3(284));
		if (!tt._owner) throw Error(p$3(290, _));
	}
	return _;
}
function th(_, et) {
	throw (
		((_ = Object.prototype.toString.call(et)),
		Error(p$3(31, _ === "[object Object]" ? "object with keys {" + Object.keys(et).join(", ") + "}" : _)))
	);
}
function uh(_) {
	var et = _._init;
	return et(_._payload);
}
function vh(_) {
	function et(ht, gt) {
		if (_) {
			var yt = ht.deletions;
			yt === null ? ((ht.deletions = [gt]), (ht.flags |= 16)) : yt.push(gt);
		}
	}
	function tt(ht, gt) {
		if (!_) return null;
		for (; gt !== null; ) et(ht, gt), (gt = gt.sibling);
		return null;
	}
	function nt(ht, gt) {
		for (ht = new Map(); gt !== null; ) gt.key !== null ? ht.set(gt.key, gt) : ht.set(gt.index, gt), (gt = gt.sibling);
		return ht;
	}
	function rt(ht, gt) {
		return (ht = wh(ht, gt)), (ht.index = 0), (ht.sibling = null), ht;
	}
	function it(ht, gt, yt) {
		return (
			(ht.index = yt),
			_
				? ((yt = ht.alternate),
				  yt !== null ? ((yt = yt.index), yt < gt ? ((ht.flags |= 2), gt) : yt) : ((ht.flags |= 2), gt))
				: ((ht.flags |= 1048576), gt)
		);
	}
	function ot(ht) {
		return _ && ht.alternate === null && (ht.flags |= 2), ht;
	}
	function at(ht, gt, yt, xt) {
		return gt === null || gt.tag !== 6
			? ((gt = xh(yt, ht.mode, xt)), (gt.return = ht), gt)
			: ((gt = rt(gt, yt)), (gt.return = ht), gt);
	}
	function st(ht, gt, yt, xt) {
		var St = yt.type;
		return St === ya
			? ut(ht, gt, yt.props.children, xt, yt.key)
			: gt !== null &&
			  (gt.elementType === St || (typeof St == "object" && St !== null && St.$$typeof === Ha && uh(St) === gt.type))
			? ((xt = rt(gt, yt.props)), (xt.ref = sh(ht, gt, yt)), (xt.return = ht), xt)
			: ((xt = yh(yt.type, yt.key, yt.props, null, ht.mode, xt)), (xt.ref = sh(ht, gt, yt)), (xt.return = ht), xt);
	}
	function lt(ht, gt, yt, xt) {
		return gt === null ||
			gt.tag !== 4 ||
			gt.stateNode.containerInfo !== yt.containerInfo ||
			gt.stateNode.implementation !== yt.implementation
			? ((gt = zh(yt, ht.mode, xt)), (gt.return = ht), gt)
			: ((gt = rt(gt, yt.children || [])), (gt.return = ht), gt);
	}
	function ut(ht, gt, yt, xt, St) {
		return gt === null || gt.tag !== 7
			? ((gt = Ah(yt, ht.mode, xt, St)), (gt.return = ht), gt)
			: ((gt = rt(gt, yt)), (gt.return = ht), gt);
	}
	function dt(ht, gt, yt) {
		if ((typeof gt == "string" && gt !== "") || typeof gt == "number")
			return (gt = xh("" + gt, ht.mode, yt)), (gt.return = ht), gt;
		if (typeof gt == "object" && gt !== null) {
			switch (gt.$$typeof) {
				case va:
					return (
						(yt = yh(gt.type, gt.key, gt.props, null, ht.mode, yt)), (yt.ref = sh(ht, null, gt)), (yt.return = ht), yt
					);
				case wa:
					return (gt = zh(gt, ht.mode, yt)), (gt.return = ht), gt;
				case Ha:
					var xt = gt._init;
					return dt(ht, xt(gt._payload), yt);
			}
			if (eb(gt) || Ka(gt)) return (gt = Ah(gt, ht.mode, yt, null)), (gt.return = ht), gt;
			th(ht, gt);
		}
		return null;
	}
	function ct(ht, gt, yt, xt) {
		var St = gt !== null ? gt.key : null;
		if ((typeof yt == "string" && yt !== "") || typeof yt == "number")
			return St !== null ? null : at(ht, gt, "" + yt, xt);
		if (typeof yt == "object" && yt !== null) {
			switch (yt.$$typeof) {
				case va:
					return yt.key === St ? st(ht, gt, yt, xt) : null;
				case wa:
					return yt.key === St ? lt(ht, gt, yt, xt) : null;
				case Ha:
					return (St = yt._init), ct(ht, gt, St(yt._payload), xt);
			}
			if (eb(yt) || Ka(yt)) return St !== null ? null : ut(ht, gt, yt, xt, null);
			th(ht, yt);
		}
		return null;
	}
	function ft(ht, gt, yt, xt, St) {
		if ((typeof xt == "string" && xt !== "") || typeof xt == "number")
			return (ht = ht.get(yt) || null), at(gt, ht, "" + xt, St);
		if (typeof xt == "object" && xt !== null) {
			switch (xt.$$typeof) {
				case va:
					return (ht = ht.get(xt.key === null ? yt : xt.key) || null), st(gt, ht, xt, St);
				case wa:
					return (ht = ht.get(xt.key === null ? yt : xt.key) || null), lt(gt, ht, xt, St);
				case Ha:
					var wt = xt._init;
					return ft(ht, gt, yt, wt(xt._payload), St);
			}
			if (eb(xt) || Ka(xt)) return (ht = ht.get(yt) || null), ut(gt, ht, xt, St, null);
			th(gt, xt);
		}
		return null;
	}
	function mt(ht, gt, yt, xt) {
		for (var St = null, wt = null, Ct = gt, Et = (gt = 0), _t = null; Ct !== null && Et < yt.length; Et++) {
			Ct.index > Et ? ((_t = Ct), (Ct = null)) : (_t = Ct.sibling);
			var $t = ct(ht, Ct, yt[Et], xt);
			if ($t === null) {
				Ct === null && (Ct = _t);
				break;
			}
			_ && Ct && $t.alternate === null && et(ht, Ct),
				(gt = it($t, gt, Et)),
				wt === null ? (St = $t) : (wt.sibling = $t),
				(wt = $t),
				(Ct = _t);
		}
		if (Et === yt.length) return tt(ht, Ct), I$1 && tg(ht, Et), St;
		if (Ct === null) {
			for (; Et < yt.length; Et++)
				(Ct = dt(ht, yt[Et], xt)),
					Ct !== null && ((gt = it(Ct, gt, Et)), wt === null ? (St = Ct) : (wt.sibling = Ct), (wt = Ct));
			return I$1 && tg(ht, Et), St;
		}
		for (Ct = nt(ht, Ct); Et < yt.length; Et++)
			(_t = ft(Ct, ht, Et, yt[Et], xt)),
				_t !== null &&
					(_ && _t.alternate !== null && Ct.delete(_t.key === null ? Et : _t.key),
					(gt = it(_t, gt, Et)),
					wt === null ? (St = _t) : (wt.sibling = _t),
					(wt = _t));
		return (
			_ &&
				Ct.forEach(function (At) {
					return et(ht, At);
				}),
			I$1 && tg(ht, Et),
			St
		);
	}
	function pt(ht, gt, yt, xt) {
		var St = Ka(yt);
		if (typeof St != "function") throw Error(p$3(150));
		if (((yt = St.call(yt)), yt == null)) throw Error(p$3(151));
		for (
			var wt = (St = null), Ct = gt, Et = (gt = 0), _t = null, $t = yt.next();
			Ct !== null && !$t.done;
			Et++, $t = yt.next()
		) {
			Ct.index > Et ? ((_t = Ct), (Ct = null)) : (_t = Ct.sibling);
			var At = ct(ht, Ct, $t.value, xt);
			if (At === null) {
				Ct === null && (Ct = _t);
				break;
			}
			_ && Ct && At.alternate === null && et(ht, Ct),
				(gt = it(At, gt, Et)),
				wt === null ? (St = At) : (wt.sibling = At),
				(wt = At),
				(Ct = _t);
		}
		if ($t.done) return tt(ht, Ct), I$1 && tg(ht, Et), St;
		if (Ct === null) {
			for (; !$t.done; Et++, $t = yt.next())
				($t = dt(ht, $t.value, xt)),
					$t !== null && ((gt = it($t, gt, Et)), wt === null ? (St = $t) : (wt.sibling = $t), (wt = $t));
			return I$1 && tg(ht, Et), St;
		}
		for (Ct = nt(ht, Ct); !$t.done; Et++, $t = yt.next())
			($t = ft(Ct, ht, Et, $t.value, xt)),
				$t !== null &&
					(_ && $t.alternate !== null && Ct.delete($t.key === null ? Et : $t.key),
					(gt = it($t, gt, Et)),
					wt === null ? (St = $t) : (wt.sibling = $t),
					(wt = $t));
		return (
			_ &&
				Ct.forEach(function (Lt) {
					return et(ht, Lt);
				}),
			I$1 && tg(ht, Et),
			St
		);
	}
	function vt(ht, gt, yt, xt) {
		if (
			(typeof yt == "object" && yt !== null && yt.type === ya && yt.key === null && (yt = yt.props.children),
			typeof yt == "object" && yt !== null)
		) {
			switch (yt.$$typeof) {
				case va:
					e: {
						for (var St = yt.key, wt = gt; wt !== null; ) {
							if (wt.key === St) {
								if (((St = yt.type), St === ya)) {
									if (wt.tag === 7) {
										tt(ht, wt.sibling), (gt = rt(wt, yt.props.children)), (gt.return = ht), (ht = gt);
										break e;
									}
								} else if (
									wt.elementType === St ||
									(typeof St == "object" && St !== null && St.$$typeof === Ha && uh(St) === wt.type)
								) {
									tt(ht, wt.sibling), (gt = rt(wt, yt.props)), (gt.ref = sh(ht, wt, yt)), (gt.return = ht), (ht = gt);
									break e;
								}
								tt(ht, wt);
								break;
							} else et(ht, wt);
							wt = wt.sibling;
						}
						yt.type === ya
							? ((gt = Ah(yt.props.children, ht.mode, xt, yt.key)), (gt.return = ht), (ht = gt))
							: ((xt = yh(yt.type, yt.key, yt.props, null, ht.mode, xt)),
							  (xt.ref = sh(ht, gt, yt)),
							  (xt.return = ht),
							  (ht = xt));
					}
					return ot(ht);
				case wa:
					e: {
						for (wt = yt.key; gt !== null; ) {
							if (gt.key === wt)
								if (
									gt.tag === 4 &&
									gt.stateNode.containerInfo === yt.containerInfo &&
									gt.stateNode.implementation === yt.implementation
								) {
									tt(ht, gt.sibling), (gt = rt(gt, yt.children || [])), (gt.return = ht), (ht = gt);
									break e;
								} else {
									tt(ht, gt);
									break;
								}
							else et(ht, gt);
							gt = gt.sibling;
						}
						(gt = zh(yt, ht.mode, xt)), (gt.return = ht), (ht = gt);
					}
					return ot(ht);
				case Ha:
					return (wt = yt._init), vt(ht, gt, wt(yt._payload), xt);
			}
			if (eb(yt)) return mt(ht, gt, yt, xt);
			if (Ka(yt)) return pt(ht, gt, yt, xt);
			th(ht, yt);
		}
		return (typeof yt == "string" && yt !== "") || typeof yt == "number"
			? ((yt = "" + yt),
			  gt !== null && gt.tag === 6
					? (tt(ht, gt.sibling), (gt = rt(gt, yt)), (gt.return = ht), (ht = gt))
					: (tt(ht, gt), (gt = xh(yt, ht.mode, xt)), (gt.return = ht), (ht = gt)),
			  ot(ht))
			: tt(ht, gt);
	}
	return vt;
}
var Bh = vh(!0),
	Ch = vh(!1),
	Dh = {},
	Eh = Uf(Dh),
	Fh = Uf(Dh),
	Gh = Uf(Dh);
function Hh(_) {
	if (_ === Dh) throw Error(p$3(174));
	return _;
}
function Ih(_, et) {
	switch ((G(Gh, et), G(Fh, _), G(Eh, Dh), (_ = et.nodeType), _)) {
		case 9:
		case 11:
			et = (et = et.documentElement) ? et.namespaceURI : lb(null, "");
			break;
		default:
			(_ = _ === 8 ? et.parentNode : et), (et = _.namespaceURI || null), (_ = _.tagName), (et = lb(et, _));
	}
	E(Eh), G(Eh, et);
}
function Jh() {
	E(Eh), E(Fh), E(Gh);
}
function Kh(_) {
	Hh(Gh.current);
	var et = Hh(Eh.current),
		tt = lb(et, _.type);
	et !== tt && (G(Fh, _), G(Eh, tt));
}
function Lh(_) {
	Fh.current === _ && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(_) {
	for (var et = _; et !== null; ) {
		if (et.tag === 13) {
			var tt = et.memoizedState;
			if (tt !== null && ((tt = tt.dehydrated), tt === null || tt.data === "$?" || tt.data === "$!")) return et;
		} else if (et.tag === 19 && et.memoizedProps.revealOrder !== void 0) {
			if ((et.flags & 128) !== 0) return et;
		} else if (et.child !== null) {
			(et.child.return = et), (et = et.child);
			continue;
		}
		if (et === _) break;
		for (; et.sibling === null; ) {
			if (et.return === null || et.return === _) return null;
			et = et.return;
		}
		(et.sibling.return = et.return), (et = et.sibling);
	}
	return null;
}
var Nh = [];
function Oh() {
	for (var _ = 0; _ < Nh.length; _++) Nh[_]._workInProgressVersionPrimary = null;
	Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher,
	Qh = ua.ReactCurrentBatchConfig,
	Rh = 0,
	N = null,
	O = null,
	P = null,
	Sh = !1,
	Th$1 = !1,
	Uh = 0,
	Vh = 0;
function Q$1() {
	throw Error(p$3(321));
}
function Wh(_, et) {
	if (et === null) return !1;
	for (var tt = 0; tt < et.length && tt < _.length; tt++) if (!He(_[tt], et[tt])) return !1;
	return !0;
}
function Xh(_, et, tt, nt, rt, it) {
	if (
		((Rh = it),
		(N = et),
		(et.memoizedState = null),
		(et.updateQueue = null),
		(et.lanes = 0),
		(Ph.current = _ === null || _.memoizedState === null ? Yh : Zh),
		(_ = tt(nt, rt)),
		Th$1)
	) {
		it = 0;
		do {
			if (((Th$1 = !1), (Uh = 0), 25 <= it)) throw Error(p$3(301));
			(it += 1), (P = O = null), (et.updateQueue = null), (Ph.current = $h), (_ = tt(nt, rt));
		} while (Th$1);
	}
	if (((Ph.current = ai), (et = O !== null && O.next !== null), (Rh = 0), (P = O = N = null), (Sh = !1), et))
		throw Error(p$3(300));
	return _;
}
function bi() {
	var _ = Uh !== 0;
	return (Uh = 0), _;
}
function ci() {
	var _ = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
	return P === null ? (N.memoizedState = P = _) : (P = P.next = _), P;
}
function di() {
	if (O === null) {
		var _ = N.alternate;
		_ = _ !== null ? _.memoizedState : null;
	} else _ = O.next;
	var et = P === null ? N.memoizedState : P.next;
	if (et !== null) (P = et), (O = _);
	else {
		if (_ === null) throw Error(p$3(310));
		(O = _),
			(_ = {
				memoizedState: O.memoizedState,
				baseState: O.baseState,
				baseQueue: O.baseQueue,
				queue: O.queue,
				next: null,
			}),
			P === null ? (N.memoizedState = P = _) : (P = P.next = _);
	}
	return P;
}
function ei(_, et) {
	return typeof et == "function" ? et(_) : et;
}
function fi(_) {
	var et = di(),
		tt = et.queue;
	if (tt === null) throw Error(p$3(311));
	tt.lastRenderedReducer = _;
	var nt = O,
		rt = nt.baseQueue,
		it = tt.pending;
	if (it !== null) {
		if (rt !== null) {
			var ot = rt.next;
			(rt.next = it.next), (it.next = ot);
		}
		(nt.baseQueue = rt = it), (tt.pending = null);
	}
	if (rt !== null) {
		(it = rt.next), (nt = nt.baseState);
		var at = (ot = null),
			st = null,
			lt = it;
		do {
			var ut = lt.lane;
			if ((Rh & ut) === ut)
				st !== null &&
					(st = st.next =
						{ lane: 0, action: lt.action, hasEagerState: lt.hasEagerState, eagerState: lt.eagerState, next: null }),
					(nt = lt.hasEagerState ? lt.eagerState : _(nt, lt.action));
			else {
				var dt = {
					lane: ut,
					action: lt.action,
					hasEagerState: lt.hasEagerState,
					eagerState: lt.eagerState,
					next: null,
				};
				st === null ? ((at = st = dt), (ot = nt)) : (st = st.next = dt), (N.lanes |= ut), (hh |= ut);
			}
			lt = lt.next;
		} while (lt !== null && lt !== it);
		st === null ? (ot = nt) : (st.next = at),
			He(nt, et.memoizedState) || (Ug = !0),
			(et.memoizedState = nt),
			(et.baseState = ot),
			(et.baseQueue = st),
			(tt.lastRenderedState = nt);
	}
	if (((_ = tt.interleaved), _ !== null)) {
		rt = _;
		do (it = rt.lane), (N.lanes |= it), (hh |= it), (rt = rt.next);
		while (rt !== _);
	} else rt === null && (tt.lanes = 0);
	return [et.memoizedState, tt.dispatch];
}
function gi(_) {
	var et = di(),
		tt = et.queue;
	if (tt === null) throw Error(p$3(311));
	tt.lastRenderedReducer = _;
	var nt = tt.dispatch,
		rt = tt.pending,
		it = et.memoizedState;
	if (rt !== null) {
		tt.pending = null;
		var ot = (rt = rt.next);
		do (it = _(it, ot.action)), (ot = ot.next);
		while (ot !== rt);
		He(it, et.memoizedState) || (Ug = !0),
			(et.memoizedState = it),
			et.baseQueue === null && (et.baseState = it),
			(tt.lastRenderedState = it);
	}
	return [it, nt];
}
function hi() {}
function ii(_, et) {
	var tt = N,
		nt = di(),
		rt = et(),
		it = !He(nt.memoizedState, rt);
	if (
		(it && ((nt.memoizedState = rt), (Ug = !0)),
		(nt = nt.queue),
		ji(ki.bind(null, tt, nt, _), [_]),
		nt.getSnapshot !== et || it || (P !== null && P.memoizedState.tag & 1))
	) {
		if (((tt.flags |= 2048), li(9, mi.bind(null, tt, nt, rt, et), void 0, null), R === null)) throw Error(p$3(349));
		(Rh & 30) !== 0 || ni(tt, et, rt);
	}
	return rt;
}
function ni(_, et, tt) {
	(_.flags |= 16384),
		(_ = { getSnapshot: et, value: tt }),
		(et = N.updateQueue),
		et === null
			? ((et = { lastEffect: null, stores: null }), (N.updateQueue = et), (et.stores = [_]))
			: ((tt = et.stores), tt === null ? (et.stores = [_]) : tt.push(_));
}
function mi(_, et, tt, nt) {
	(et.value = tt), (et.getSnapshot = nt), oi(et) && pi(_);
}
function ki(_, et, tt) {
	return tt(function () {
		oi(et) && pi(_);
	});
}
function oi(_) {
	var et = _.getSnapshot;
	_ = _.value;
	try {
		var tt = et();
		return !He(_, tt);
	} catch {
		return !0;
	}
}
function pi(_) {
	var et = Zg(_, 1);
	et !== null && mh(et, _, 1, -1);
}
function qi(_) {
	var et = ci();
	return (
		typeof _ == "function" && (_ = _()),
		(et.memoizedState = et.baseState = _),
		(_ = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: _ }),
		(et.queue = _),
		(_ = _.dispatch = ri.bind(null, N, _)),
		[et.memoizedState, _]
	);
}
function li(_, et, tt, nt) {
	return (
		(_ = { tag: _, create: et, destroy: tt, deps: nt, next: null }),
		(et = N.updateQueue),
		et === null
			? ((et = { lastEffect: null, stores: null }), (N.updateQueue = et), (et.lastEffect = _.next = _))
			: ((tt = et.lastEffect),
			  tt === null
					? (et.lastEffect = _.next = _)
					: ((nt = tt.next), (tt.next = _), (_.next = nt), (et.lastEffect = _))),
		_
	);
}
function si() {
	return di().memoizedState;
}
function ti(_, et, tt, nt) {
	var rt = ci();
	(N.flags |= _), (rt.memoizedState = li(1 | et, tt, void 0, nt === void 0 ? null : nt));
}
function ui$1(_, et, tt, nt) {
	var rt = di();
	nt = nt === void 0 ? null : nt;
	var it = void 0;
	if (O !== null) {
		var ot = O.memoizedState;
		if (((it = ot.destroy), nt !== null && Wh(nt, ot.deps))) {
			rt.memoizedState = li(et, tt, it, nt);
			return;
		}
	}
	(N.flags |= _), (rt.memoizedState = li(1 | et, tt, it, nt));
}
function vi(_, et) {
	return ti(8390656, 8, _, et);
}
function ji(_, et) {
	return ui$1(2048, 8, _, et);
}
function wi(_, et) {
	return ui$1(4, 2, _, et);
}
function xi(_, et) {
	return ui$1(4, 4, _, et);
}
function yi(_, et) {
	if (typeof et == "function")
		return (
			(_ = _()),
			et(_),
			function () {
				et(null);
			}
		);
	if (et != null)
		return (
			(_ = _()),
			(et.current = _),
			function () {
				et.current = null;
			}
		);
}
function zi(_, et, tt) {
	return (tt = tt != null ? tt.concat([_]) : null), ui$1(4, 4, yi.bind(null, et, _), tt);
}
function Ai() {}
function Bi(_, et) {
	var tt = di();
	et = et === void 0 ? null : et;
	var nt = tt.memoizedState;
	return nt !== null && et !== null && Wh(et, nt[1]) ? nt[0] : ((tt.memoizedState = [_, et]), _);
}
function Ci(_, et) {
	var tt = di();
	et = et === void 0 ? null : et;
	var nt = tt.memoizedState;
	return nt !== null && et !== null && Wh(et, nt[1]) ? nt[0] : ((_ = _()), (tt.memoizedState = [_, et]), _);
}
function Di(_, et, tt) {
	return (Rh & 21) === 0
		? (_.baseState && ((_.baseState = !1), (Ug = !0)), (_.memoizedState = tt))
		: (He(tt, et) || ((tt = yc()), (N.lanes |= tt), (hh |= tt), (_.baseState = !0)), et);
}
function Ei(_, et) {
	var tt = C$2;
	(C$2 = tt !== 0 && 4 > tt ? tt : 4), _(!0);
	var nt = Qh.transition;
	Qh.transition = {};
	try {
		_(!1), et();
	} finally {
		(C$2 = tt), (Qh.transition = nt);
	}
}
function Fi() {
	return di().memoizedState;
}
function Gi(_, et, tt) {
	var nt = lh(_);
	if (((tt = { lane: nt, action: tt, hasEagerState: !1, eagerState: null, next: null }), Hi(_))) Ii(et, tt);
	else if (((tt = Yg(_, et, tt, nt)), tt !== null)) {
		var rt = L();
		mh(tt, _, nt, rt), Ji(tt, et, nt);
	}
}
function ri(_, et, tt) {
	var nt = lh(_),
		rt = { lane: nt, action: tt, hasEagerState: !1, eagerState: null, next: null };
	if (Hi(_)) Ii(et, rt);
	else {
		var it = _.alternate;
		if (_.lanes === 0 && (it === null || it.lanes === 0) && ((it = et.lastRenderedReducer), it !== null))
			try {
				var ot = et.lastRenderedState,
					at = it(ot, tt);
				if (((rt.hasEagerState = !0), (rt.eagerState = at), He(at, ot))) {
					var st = et.interleaved;
					st === null ? ((rt.next = rt), Xg(et)) : ((rt.next = st.next), (st.next = rt)), (et.interleaved = rt);
					return;
				}
			} catch {
			} finally {
			}
		(tt = Yg(_, et, rt, nt)), tt !== null && ((rt = L()), mh(tt, _, nt, rt), Ji(tt, et, nt));
	}
}
function Hi(_) {
	var et = _.alternate;
	return _ === N || (et !== null && et === N);
}
function Ii(_, et) {
	Th$1 = Sh = !0;
	var tt = _.pending;
	tt === null ? (et.next = et) : ((et.next = tt.next), (tt.next = et)), (_.pending = et);
}
function Ji(_, et, tt) {
	if ((tt & 4194240) !== 0) {
		var nt = et.lanes;
		(nt &= _.pendingLanes), (tt |= nt), (et.lanes = tt), Cc(_, tt);
	}
}
var ai = {
		readContext: Vg,
		useCallback: Q$1,
		useContext: Q$1,
		useEffect: Q$1,
		useImperativeHandle: Q$1,
		useInsertionEffect: Q$1,
		useLayoutEffect: Q$1,
		useMemo: Q$1,
		useReducer: Q$1,
		useRef: Q$1,
		useState: Q$1,
		useDebugValue: Q$1,
		useDeferredValue: Q$1,
		useTransition: Q$1,
		useMutableSource: Q$1,
		useSyncExternalStore: Q$1,
		useId: Q$1,
		unstable_isNewReconciler: !1,
	},
	Yh = {
		readContext: Vg,
		useCallback: function (_, et) {
			return (ci().memoizedState = [_, et === void 0 ? null : et]), _;
		},
		useContext: Vg,
		useEffect: vi,
		useImperativeHandle: function (_, et, tt) {
			return (tt = tt != null ? tt.concat([_]) : null), ti(4194308, 4, yi.bind(null, et, _), tt);
		},
		useLayoutEffect: function (_, et) {
			return ti(4194308, 4, _, et);
		},
		useInsertionEffect: function (_, et) {
			return ti(4, 2, _, et);
		},
		useMemo: function (_, et) {
			var tt = ci();
			return (et = et === void 0 ? null : et), (_ = _()), (tt.memoizedState = [_, et]), _;
		},
		useReducer: function (_, et, tt) {
			var nt = ci();
			return (
				(et = tt !== void 0 ? tt(et) : et),
				(nt.memoizedState = nt.baseState = et),
				(_ = {
					pending: null,
					interleaved: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: _,
					lastRenderedState: et,
				}),
				(nt.queue = _),
				(_ = _.dispatch = Gi.bind(null, N, _)),
				[nt.memoizedState, _]
			);
		},
		useRef: function (_) {
			var et = ci();
			return (_ = { current: _ }), (et.memoizedState = _);
		},
		useState: qi,
		useDebugValue: Ai,
		useDeferredValue: function (_) {
			return (ci().memoizedState = _);
		},
		useTransition: function () {
			var _ = qi(!1),
				et = _[0];
			return (_ = Ei.bind(null, _[1])), (ci().memoizedState = _), [et, _];
		},
		useMutableSource: function () {},
		useSyncExternalStore: function (_, et, tt) {
			var nt = N,
				rt = ci();
			if (I$1) {
				if (tt === void 0) throw Error(p$3(407));
				tt = tt();
			} else {
				if (((tt = et()), R === null)) throw Error(p$3(349));
				(Rh & 30) !== 0 || ni(nt, et, tt);
			}
			rt.memoizedState = tt;
			var it = { value: tt, getSnapshot: et };
			return (
				(rt.queue = it),
				vi(ki.bind(null, nt, it, _), [_]),
				(nt.flags |= 2048),
				li(9, mi.bind(null, nt, it, tt, et), void 0, null),
				tt
			);
		},
		useId: function () {
			var _ = ci(),
				et = R.identifierPrefix;
			if (I$1) {
				var tt = sg,
					nt = rg;
				(tt = (nt & ~(1 << (32 - oc(nt) - 1))).toString(32) + tt),
					(et = ":" + et + "R" + tt),
					(tt = Uh++),
					0 < tt && (et += "H" + tt.toString(32)),
					(et += ":");
			} else (tt = Vh++), (et = ":" + et + "r" + tt.toString(32) + ":");
			return (_.memoizedState = et);
		},
		unstable_isNewReconciler: !1,
	},
	Zh = {
		readContext: Vg,
		useCallback: Bi,
		useContext: Vg,
		useEffect: ji,
		useImperativeHandle: zi,
		useInsertionEffect: wi,
		useLayoutEffect: xi,
		useMemo: Ci,
		useReducer: fi,
		useRef: si,
		useState: function () {
			return fi(ei);
		},
		useDebugValue: Ai,
		useDeferredValue: function (_) {
			var et = di();
			return Di(et, O.memoizedState, _);
		},
		useTransition: function () {
			var _ = fi(ei)[0],
				et = di().memoizedState;
			return [_, et];
		},
		useMutableSource: hi,
		useSyncExternalStore: ii,
		useId: Fi,
		unstable_isNewReconciler: !1,
	},
	$h = {
		readContext: Vg,
		useCallback: Bi,
		useContext: Vg,
		useEffect: ji,
		useImperativeHandle: zi,
		useInsertionEffect: wi,
		useLayoutEffect: xi,
		useMemo: Ci,
		useReducer: gi,
		useRef: si,
		useState: function () {
			return gi(ei);
		},
		useDebugValue: Ai,
		useDeferredValue: function (_) {
			var et = di();
			return O === null ? (et.memoizedState = _) : Di(et, O.memoizedState, _);
		},
		useTransition: function () {
			var _ = gi(ei)[0],
				et = di().memoizedState;
			return [_, et];
		},
		useMutableSource: hi,
		useSyncExternalStore: ii,
		useId: Fi,
		unstable_isNewReconciler: !1,
	};
function Ki(_, et) {
	try {
		var tt = "",
			nt = et;
		do (tt += Pa(nt)), (nt = nt.return);
		while (nt);
		var rt = tt;
	} catch (it) {
		rt =
			`
Error generating stack: ` +
			it.message +
			`
` +
			it.stack;
	}
	return { value: _, source: et, stack: rt, digest: null };
}
function Li(_, et, tt) {
	return { value: _, source: null, stack: tt != null ? tt : null, digest: et != null ? et : null };
}
function Mi(_, et) {
	try {
		console.error(et.value);
	} catch (tt) {
		setTimeout(function () {
			throw tt;
		});
	}
}
var Ni = typeof WeakMap == "function" ? WeakMap : Map;
function Oi(_, et, tt) {
	(tt = ch(-1, tt)), (tt.tag = 3), (tt.payload = { element: null });
	var nt = et.value;
	return (
		(tt.callback = function () {
			Pi || ((Pi = !0), (Qi = nt)), Mi(_, et);
		}),
		tt
	);
}
function Ri(_, et, tt) {
	(tt = ch(-1, tt)), (tt.tag = 3);
	var nt = _.type.getDerivedStateFromError;
	if (typeof nt == "function") {
		var rt = et.value;
		(tt.payload = function () {
			return nt(rt);
		}),
			(tt.callback = function () {
				Mi(_, et);
			});
	}
	var it = _.stateNode;
	return (
		it !== null &&
			typeof it.componentDidCatch == "function" &&
			(tt.callback = function () {
				Mi(_, et), typeof nt != "function" && (Si === null ? (Si = new Set([this])) : Si.add(this));
				var ot = et.stack;
				this.componentDidCatch(et.value, { componentStack: ot !== null ? ot : "" });
			}),
		tt
	);
}
function Ti(_, et, tt) {
	var nt = _.pingCache;
	if (nt === null) {
		nt = _.pingCache = new Ni();
		var rt = new Set();
		nt.set(et, rt);
	} else (rt = nt.get(et)), rt === void 0 && ((rt = new Set()), nt.set(et, rt));
	rt.has(tt) || (rt.add(tt), (_ = Ui.bind(null, _, et, tt)), et.then(_, _));
}
function Vi(_) {
	do {
		var et;
		if (((et = _.tag === 13) && ((et = _.memoizedState), (et = et !== null ? et.dehydrated !== null : !0)), et))
			return _;
		_ = _.return;
	} while (_ !== null);
	return null;
}
function Wi(_, et, tt, nt, rt) {
	return (_.mode & 1) === 0
		? (_ === et
				? (_.flags |= 65536)
				: ((_.flags |= 128),
				  (tt.flags |= 131072),
				  (tt.flags &= -52805),
				  tt.tag === 1 && (tt.alternate === null ? (tt.tag = 17) : ((et = ch(-1, 1)), (et.tag = 2), dh(tt, et, 1))),
				  (tt.lanes |= 1)),
		  _)
		: ((_.flags |= 65536), (_.lanes = rt), _);
}
var Xi = ua.ReactCurrentOwner,
	Ug = !1;
function Yi(_, et, tt, nt) {
	et.child = _ === null ? Ch(et, null, tt, nt) : Bh(et, _.child, tt, nt);
}
function Zi(_, et, tt, nt, rt) {
	tt = tt.render;
	var it = et.ref;
	return (
		Tg(et, rt),
		(nt = Xh(_, et, tt, nt, it, rt)),
		(tt = bi()),
		_ !== null && !Ug
			? ((et.updateQueue = _.updateQueue), (et.flags &= -2053), (_.lanes &= ~rt), $i(_, et, rt))
			: (I$1 && tt && vg(et), (et.flags |= 1), Yi(_, et, nt, rt), et.child)
	);
}
function aj(_, et, tt, nt, rt) {
	if (_ === null) {
		var it = tt.type;
		return typeof it == "function" &&
			!bj(it) &&
			it.defaultProps === void 0 &&
			tt.compare === null &&
			tt.defaultProps === void 0
			? ((et.tag = 15), (et.type = it), cj(_, et, it, nt, rt))
			: ((_ = yh(tt.type, null, nt, et, et.mode, rt)), (_.ref = et.ref), (_.return = et), (et.child = _));
	}
	if (((it = _.child), (_.lanes & rt) === 0)) {
		var ot = it.memoizedProps;
		if (((tt = tt.compare), (tt = tt !== null ? tt : Ie), tt(ot, nt) && _.ref === et.ref)) return $i(_, et, rt);
	}
	return (et.flags |= 1), (_ = wh(it, nt)), (_.ref = et.ref), (_.return = et), (et.child = _);
}
function cj(_, et, tt, nt, rt) {
	if (_ !== null) {
		var it = _.memoizedProps;
		if (Ie(it, nt) && _.ref === et.ref)
			if (((Ug = !1), (et.pendingProps = nt = it), (_.lanes & rt) !== 0)) (_.flags & 131072) !== 0 && (Ug = !0);
			else return (et.lanes = _.lanes), $i(_, et, rt);
	}
	return dj(_, et, tt, nt, rt);
}
function ej(_, et, tt) {
	var nt = et.pendingProps,
		rt = nt.children,
		it = _ !== null ? _.memoizedState : null;
	if (nt.mode === "hidden")
		if ((et.mode & 1) === 0)
			(et.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }), G(fj, gj), (gj |= tt);
		else {
			if ((tt & 1073741824) === 0)
				return (
					(_ = it !== null ? it.baseLanes | tt : tt),
					(et.lanes = et.childLanes = 1073741824),
					(et.memoizedState = { baseLanes: _, cachePool: null, transitions: null }),
					(et.updateQueue = null),
					G(fj, gj),
					(gj |= _),
					null
				);
			(et.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
				(nt = it !== null ? it.baseLanes : tt),
				G(fj, gj),
				(gj |= nt);
		}
	else it !== null ? ((nt = it.baseLanes | tt), (et.memoizedState = null)) : (nt = tt), G(fj, gj), (gj |= nt);
	return Yi(_, et, rt, tt), et.child;
}
function hj(_, et) {
	var tt = et.ref;
	((_ === null && tt !== null) || (_ !== null && _.ref !== tt)) && ((et.flags |= 512), (et.flags |= 2097152));
}
function dj(_, et, tt, nt, rt) {
	var it = Zf(tt) ? Xf : H$1.current;
	return (
		(it = Yf(et, it)),
		Tg(et, rt),
		(tt = Xh(_, et, tt, nt, it, rt)),
		(nt = bi()),
		_ !== null && !Ug
			? ((et.updateQueue = _.updateQueue), (et.flags &= -2053), (_.lanes &= ~rt), $i(_, et, rt))
			: (I$1 && nt && vg(et), (et.flags |= 1), Yi(_, et, tt, rt), et.child)
	);
}
function ij(_, et, tt, nt, rt) {
	if (Zf(tt)) {
		var it = !0;
		cg(et);
	} else it = !1;
	if ((Tg(et, rt), et.stateNode === null)) jj(_, et), ph(et, tt, nt), rh(et, tt, nt, rt), (nt = !0);
	else if (_ === null) {
		var ot = et.stateNode,
			at = et.memoizedProps;
		ot.props = at;
		var st = ot.context,
			lt = tt.contextType;
		typeof lt == "object" && lt !== null ? (lt = Vg(lt)) : ((lt = Zf(tt) ? Xf : H$1.current), (lt = Yf(et, lt)));
		var ut = tt.getDerivedStateFromProps,
			dt = typeof ut == "function" || typeof ot.getSnapshotBeforeUpdate == "function";
		dt ||
			(typeof ot.UNSAFE_componentWillReceiveProps != "function" && typeof ot.componentWillReceiveProps != "function") ||
			((at !== nt || st !== lt) && qh(et, ot, nt, lt)),
			($g = !1);
		var ct = et.memoizedState;
		(ot.state = ct),
			gh(et, nt, ot, rt),
			(st = et.memoizedState),
			at !== nt || ct !== st || Wf.current || $g
				? (typeof ut == "function" && (kh(et, tt, ut, nt), (st = et.memoizedState)),
				  (at = $g || oh(et, tt, at, nt, ct, st, lt))
						? (dt ||
								(typeof ot.UNSAFE_componentWillMount != "function" && typeof ot.componentWillMount != "function") ||
								(typeof ot.componentWillMount == "function" && ot.componentWillMount(),
								typeof ot.UNSAFE_componentWillMount == "function" && ot.UNSAFE_componentWillMount()),
						  typeof ot.componentDidMount == "function" && (et.flags |= 4194308))
						: (typeof ot.componentDidMount == "function" && (et.flags |= 4194308),
						  (et.memoizedProps = nt),
						  (et.memoizedState = st)),
				  (ot.props = nt),
				  (ot.state = st),
				  (ot.context = lt),
				  (nt = at))
				: (typeof ot.componentDidMount == "function" && (et.flags |= 4194308), (nt = !1));
	} else {
		(ot = et.stateNode),
			bh(_, et),
			(at = et.memoizedProps),
			(lt = et.type === et.elementType ? at : Lg(et.type, at)),
			(ot.props = lt),
			(dt = et.pendingProps),
			(ct = ot.context),
			(st = tt.contextType),
			typeof st == "object" && st !== null ? (st = Vg(st)) : ((st = Zf(tt) ? Xf : H$1.current), (st = Yf(et, st)));
		var ft = tt.getDerivedStateFromProps;
		(ut = typeof ft == "function" || typeof ot.getSnapshotBeforeUpdate == "function") ||
			(typeof ot.UNSAFE_componentWillReceiveProps != "function" && typeof ot.componentWillReceiveProps != "function") ||
			((at !== dt || ct !== st) && qh(et, ot, nt, st)),
			($g = !1),
			(ct = et.memoizedState),
			(ot.state = ct),
			gh(et, nt, ot, rt);
		var mt = et.memoizedState;
		at !== dt || ct !== mt || Wf.current || $g
			? (typeof ft == "function" && (kh(et, tt, ft, nt), (mt = et.memoizedState)),
			  (lt = $g || oh(et, tt, lt, nt, ct, mt, st) || !1)
					? (ut ||
							(typeof ot.UNSAFE_componentWillUpdate != "function" && typeof ot.componentWillUpdate != "function") ||
							(typeof ot.componentWillUpdate == "function" && ot.componentWillUpdate(nt, mt, st),
							typeof ot.UNSAFE_componentWillUpdate == "function" && ot.UNSAFE_componentWillUpdate(nt, mt, st)),
					  typeof ot.componentDidUpdate == "function" && (et.flags |= 4),
					  typeof ot.getSnapshotBeforeUpdate == "function" && (et.flags |= 1024))
					: (typeof ot.componentDidUpdate != "function" ||
							(at === _.memoizedProps && ct === _.memoizedState) ||
							(et.flags |= 4),
					  typeof ot.getSnapshotBeforeUpdate != "function" ||
							(at === _.memoizedProps && ct === _.memoizedState) ||
							(et.flags |= 1024),
					  (et.memoizedProps = nt),
					  (et.memoizedState = mt)),
			  (ot.props = nt),
			  (ot.state = mt),
			  (ot.context = st),
			  (nt = lt))
			: (typeof ot.componentDidUpdate != "function" ||
					(at === _.memoizedProps && ct === _.memoizedState) ||
					(et.flags |= 4),
			  typeof ot.getSnapshotBeforeUpdate != "function" ||
					(at === _.memoizedProps && ct === _.memoizedState) ||
					(et.flags |= 1024),
			  (nt = !1));
	}
	return kj(_, et, tt, nt, it, rt);
}
function kj(_, et, tt, nt, rt, it) {
	hj(_, et);
	var ot = (et.flags & 128) !== 0;
	if (!nt && !ot) return rt && dg(et, tt, !1), $i(_, et, it);
	(nt = et.stateNode), (Xi.current = et);
	var at = ot && typeof tt.getDerivedStateFromError != "function" ? null : nt.render();
	return (
		(et.flags |= 1),
		_ !== null && ot ? ((et.child = Bh(et, _.child, null, it)), (et.child = Bh(et, null, at, it))) : Yi(_, et, at, it),
		(et.memoizedState = nt.state),
		rt && dg(et, tt, !0),
		et.child
	);
}
function lj(_) {
	var et = _.stateNode;
	et.pendingContext ? ag(_, et.pendingContext, et.pendingContext !== et.context) : et.context && ag(_, et.context, !1),
		Ih(_, et.containerInfo);
}
function mj(_, et, tt, nt, rt) {
	return Ig(), Jg(rt), (et.flags |= 256), Yi(_, et, tt, nt), et.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(_) {
	return { baseLanes: _, cachePool: null, transitions: null };
}
function pj(_, et, tt) {
	var nt = et.pendingProps,
		rt = M.current,
		it = !1,
		ot = (et.flags & 128) !== 0,
		at;
	if (
		((at = ot) || (at = _ !== null && _.memoizedState === null ? !1 : (rt & 2) !== 0),
		at ? ((it = !0), (et.flags &= -129)) : (_ === null || _.memoizedState !== null) && (rt |= 1),
		G(M, rt & 1),
		_ === null)
	)
		return (
			Eg(et),
			(_ = et.memoizedState),
			_ !== null && ((_ = _.dehydrated), _ !== null)
				? ((et.mode & 1) === 0 ? (et.lanes = 1) : _.data === "$!" ? (et.lanes = 8) : (et.lanes = 1073741824), null)
				: ((ot = nt.children),
				  (_ = nt.fallback),
				  it
						? ((nt = et.mode),
						  (it = et.child),
						  (ot = { mode: "hidden", children: ot }),
						  (nt & 1) === 0 && it !== null
								? ((it.childLanes = 0), (it.pendingProps = ot))
								: (it = qj(ot, nt, 0, null)),
						  (_ = Ah(_, nt, tt, null)),
						  (it.return = et),
						  (_.return = et),
						  (it.sibling = _),
						  (et.child = it),
						  (et.child.memoizedState = oj(tt)),
						  (et.memoizedState = nj),
						  _)
						: rj(et, ot))
		);
	if (((rt = _.memoizedState), rt !== null && ((at = rt.dehydrated), at !== null)))
		return sj(_, et, ot, nt, at, rt, tt);
	if (it) {
		(it = nt.fallback), (ot = et.mode), (rt = _.child), (at = rt.sibling);
		var st = { mode: "hidden", children: nt.children };
		return (
			(ot & 1) === 0 && et.child !== rt
				? ((nt = et.child), (nt.childLanes = 0), (nt.pendingProps = st), (et.deletions = null))
				: ((nt = wh(rt, st)), (nt.subtreeFlags = rt.subtreeFlags & 14680064)),
			at !== null ? (it = wh(at, it)) : ((it = Ah(it, ot, tt, null)), (it.flags |= 2)),
			(it.return = et),
			(nt.return = et),
			(nt.sibling = it),
			(et.child = nt),
			(nt = it),
			(it = et.child),
			(ot = _.child.memoizedState),
			(ot = ot === null ? oj(tt) : { baseLanes: ot.baseLanes | tt, cachePool: null, transitions: ot.transitions }),
			(it.memoizedState = ot),
			(it.childLanes = _.childLanes & ~tt),
			(et.memoizedState = nj),
			nt
		);
	}
	return (
		(it = _.child),
		(_ = it.sibling),
		(nt = wh(it, { mode: "visible", children: nt.children })),
		(et.mode & 1) === 0 && (nt.lanes = tt),
		(nt.return = et),
		(nt.sibling = null),
		_ !== null && ((tt = et.deletions), tt === null ? ((et.deletions = [_]), (et.flags |= 16)) : tt.push(_)),
		(et.child = nt),
		(et.memoizedState = null),
		nt
	);
}
function rj(_, et) {
	return (et = qj({ mode: "visible", children: et }, _.mode, 0, null)), (et.return = _), (_.child = et);
}
function tj(_, et, tt, nt) {
	return (
		nt !== null && Jg(nt),
		Bh(et, _.child, null, tt),
		(_ = rj(et, et.pendingProps.children)),
		(_.flags |= 2),
		(et.memoizedState = null),
		_
	);
}
function sj(_, et, tt, nt, rt, it, ot) {
	if (tt)
		return et.flags & 256
			? ((et.flags &= -257), (nt = Li(Error(p$3(422)))), tj(_, et, ot, nt))
			: et.memoizedState !== null
			? ((et.child = _.child), (et.flags |= 128), null)
			: ((it = nt.fallback),
			  (rt = et.mode),
			  (nt = qj({ mode: "visible", children: nt.children }, rt, 0, null)),
			  (it = Ah(it, rt, ot, null)),
			  (it.flags |= 2),
			  (nt.return = et),
			  (it.return = et),
			  (nt.sibling = it),
			  (et.child = nt),
			  (et.mode & 1) !== 0 && Bh(et, _.child, null, ot),
			  (et.child.memoizedState = oj(ot)),
			  (et.memoizedState = nj),
			  it);
	if ((et.mode & 1) === 0) return tj(_, et, ot, null);
	if (rt.data === "$!") {
		if (((nt = rt.nextSibling && rt.nextSibling.dataset), nt)) var at = nt.dgst;
		return (nt = at), (it = Error(p$3(419))), (nt = Li(it, nt, void 0)), tj(_, et, ot, nt);
	}
	if (((at = (ot & _.childLanes) !== 0), Ug || at)) {
		if (((nt = R), nt !== null)) {
			switch (ot & -ot) {
				case 4:
					rt = 2;
					break;
				case 16:
					rt = 8;
					break;
				case 64:
				case 128:
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152:
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432:
				case 67108864:
					rt = 32;
					break;
				case 536870912:
					rt = 268435456;
					break;
				default:
					rt = 0;
			}
			(rt = (rt & (nt.suspendedLanes | ot)) !== 0 ? 0 : rt),
				rt !== 0 && rt !== it.retryLane && ((it.retryLane = rt), Zg(_, rt), mh(nt, _, rt, -1));
		}
		return uj(), (nt = Li(Error(p$3(421)))), tj(_, et, ot, nt);
	}
	return rt.data === "$?"
		? ((et.flags |= 128), (et.child = _.child), (et = vj.bind(null, _)), (rt._reactRetry = et), null)
		: ((_ = it.treeContext),
		  (yg = Lf(rt.nextSibling)),
		  (xg = et),
		  (I$1 = !0),
		  (zg = null),
		  _ !== null && ((og[pg++] = rg), (og[pg++] = sg), (og[pg++] = qg), (rg = _.id), (sg = _.overflow), (qg = et)),
		  (et = rj(et, nt.children)),
		  (et.flags |= 4096),
		  et);
}
function wj(_, et, tt) {
	_.lanes |= et;
	var nt = _.alternate;
	nt !== null && (nt.lanes |= et), Sg(_.return, et, tt);
}
function xj(_, et, tt, nt, rt) {
	var it = _.memoizedState;
	it === null
		? (_.memoizedState = { isBackwards: et, rendering: null, renderingStartTime: 0, last: nt, tail: tt, tailMode: rt })
		: ((it.isBackwards = et),
		  (it.rendering = null),
		  (it.renderingStartTime = 0),
		  (it.last = nt),
		  (it.tail = tt),
		  (it.tailMode = rt));
}
function yj(_, et, tt) {
	var nt = et.pendingProps,
		rt = nt.revealOrder,
		it = nt.tail;
	if ((Yi(_, et, nt.children, tt), (nt = M.current), (nt & 2) !== 0)) (nt = (nt & 1) | 2), (et.flags |= 128);
	else {
		if (_ !== null && (_.flags & 128) !== 0)
			e: for (_ = et.child; _ !== null; ) {
				if (_.tag === 13) _.memoizedState !== null && wj(_, tt, et);
				else if (_.tag === 19) wj(_, tt, et);
				else if (_.child !== null) {
					(_.child.return = _), (_ = _.child);
					continue;
				}
				if (_ === et) break e;
				for (; _.sibling === null; ) {
					if (_.return === null || _.return === et) break e;
					_ = _.return;
				}
				(_.sibling.return = _.return), (_ = _.sibling);
			}
		nt &= 1;
	}
	if ((G(M, nt), (et.mode & 1) === 0)) et.memoizedState = null;
	else
		switch (rt) {
			case "forwards":
				for (tt = et.child, rt = null; tt !== null; )
					(_ = tt.alternate), _ !== null && Mh(_) === null && (rt = tt), (tt = tt.sibling);
				(tt = rt),
					tt === null ? ((rt = et.child), (et.child = null)) : ((rt = tt.sibling), (tt.sibling = null)),
					xj(et, !1, rt, tt, it);
				break;
			case "backwards":
				for (tt = null, rt = et.child, et.child = null; rt !== null; ) {
					if (((_ = rt.alternate), _ !== null && Mh(_) === null)) {
						et.child = rt;
						break;
					}
					(_ = rt.sibling), (rt.sibling = tt), (tt = rt), (rt = _);
				}
				xj(et, !0, tt, null, it);
				break;
			case "together":
				xj(et, !1, null, null, void 0);
				break;
			default:
				et.memoizedState = null;
		}
	return et.child;
}
function jj(_, et) {
	(et.mode & 1) === 0 && _ !== null && ((_.alternate = null), (et.alternate = null), (et.flags |= 2));
}
function $i(_, et, tt) {
	if ((_ !== null && (et.dependencies = _.dependencies), (hh |= et.lanes), (tt & et.childLanes) === 0)) return null;
	if (_ !== null && et.child !== _.child) throw Error(p$3(153));
	if (et.child !== null) {
		for (_ = et.child, tt = wh(_, _.pendingProps), et.child = tt, tt.return = et; _.sibling !== null; )
			(_ = _.sibling), (tt = tt.sibling = wh(_, _.pendingProps)), (tt.return = et);
		tt.sibling = null;
	}
	return et.child;
}
function zj(_, et, tt) {
	switch (et.tag) {
		case 3:
			lj(et), Ig();
			break;
		case 5:
			Kh(et);
			break;
		case 1:
			Zf(et.type) && cg(et);
			break;
		case 4:
			Ih(et, et.stateNode.containerInfo);
			break;
		case 10:
			var nt = et.type._context,
				rt = et.memoizedProps.value;
			G(Mg, nt._currentValue), (nt._currentValue = rt);
			break;
		case 13:
			if (((nt = et.memoizedState), nt !== null))
				return nt.dehydrated !== null
					? (G(M, M.current & 1), (et.flags |= 128), null)
					: (tt & et.child.childLanes) !== 0
					? pj(_, et, tt)
					: (G(M, M.current & 1), (_ = $i(_, et, tt)), _ !== null ? _.sibling : null);
			G(M, M.current & 1);
			break;
		case 19:
			if (((nt = (tt & et.childLanes) !== 0), (_.flags & 128) !== 0)) {
				if (nt) return yj(_, et, tt);
				et.flags |= 128;
			}
			if (
				((rt = et.memoizedState),
				rt !== null && ((rt.rendering = null), (rt.tail = null), (rt.lastEffect = null)),
				G(M, M.current),
				nt)
			)
				break;
			return null;
		case 22:
		case 23:
			return (et.lanes = 0), ej(_, et, tt);
	}
	return $i(_, et, tt);
}
var Aj, Bj, Cj, Dj;
Aj = function (_, et) {
	for (var tt = et.child; tt !== null; ) {
		if (tt.tag === 5 || tt.tag === 6) _.appendChild(tt.stateNode);
		else if (tt.tag !== 4 && tt.child !== null) {
			(tt.child.return = tt), (tt = tt.child);
			continue;
		}
		if (tt === et) break;
		for (; tt.sibling === null; ) {
			if (tt.return === null || tt.return === et) return;
			tt = tt.return;
		}
		(tt.sibling.return = tt.return), (tt = tt.sibling);
	}
};
Bj = function () {};
Cj = function (_, et, tt, nt) {
	var rt = _.memoizedProps;
	if (rt !== nt) {
		(_ = et.stateNode), Hh(Eh.current);
		var it = null;
		switch (tt) {
			case "input":
				(rt = Ya(_, rt)), (nt = Ya(_, nt)), (it = []);
				break;
			case "select":
				(rt = A({}, rt, { value: void 0 })), (nt = A({}, nt, { value: void 0 })), (it = []);
				break;
			case "textarea":
				(rt = gb(_, rt)), (nt = gb(_, nt)), (it = []);
				break;
			default:
				typeof rt.onClick != "function" && typeof nt.onClick == "function" && (_.onclick = Bf);
		}
		ub(tt, nt);
		var ot;
		tt = null;
		for (lt in rt)
			if (!nt.hasOwnProperty(lt) && rt.hasOwnProperty(lt) && rt[lt] != null)
				if (lt === "style") {
					var at = rt[lt];
					for (ot in at) at.hasOwnProperty(ot) && (tt || (tt = {}), (tt[ot] = ""));
				} else
					lt !== "dangerouslySetInnerHTML" &&
						lt !== "children" &&
						lt !== "suppressContentEditableWarning" &&
						lt !== "suppressHydrationWarning" &&
						lt !== "autoFocus" &&
						(ea.hasOwnProperty(lt) ? it || (it = []) : (it = it || []).push(lt, null));
		for (lt in nt) {
			var st = nt[lt];
			if (((at = rt != null ? rt[lt] : void 0), nt.hasOwnProperty(lt) && st !== at && (st != null || at != null)))
				if (lt === "style")
					if (at) {
						for (ot in at) !at.hasOwnProperty(ot) || (st && st.hasOwnProperty(ot)) || (tt || (tt = {}), (tt[ot] = ""));
						for (ot in st) st.hasOwnProperty(ot) && at[ot] !== st[ot] && (tt || (tt = {}), (tt[ot] = st[ot]));
					} else tt || (it || (it = []), it.push(lt, tt)), (tt = st);
				else
					lt === "dangerouslySetInnerHTML"
						? ((st = st ? st.__html : void 0),
						  (at = at ? at.__html : void 0),
						  st != null && at !== st && (it = it || []).push(lt, st))
						: lt === "children"
						? (typeof st != "string" && typeof st != "number") || (it = it || []).push(lt, "" + st)
						: lt !== "suppressContentEditableWarning" &&
						  lt !== "suppressHydrationWarning" &&
						  (ea.hasOwnProperty(lt)
								? (st != null && lt === "onScroll" && D("scroll", _), it || at === st || (it = []))
								: (it = it || []).push(lt, st));
		}
		tt && (it = it || []).push("style", tt);
		var lt = it;
		(et.updateQueue = lt) && (et.flags |= 4);
	}
};
Dj = function (_, et, tt, nt) {
	tt !== nt && (et.flags |= 4);
};
function Ej(_, et) {
	if (!I$1)
		switch (_.tailMode) {
			case "hidden":
				et = _.tail;
				for (var tt = null; et !== null; ) et.alternate !== null && (tt = et), (et = et.sibling);
				tt === null ? (_.tail = null) : (tt.sibling = null);
				break;
			case "collapsed":
				tt = _.tail;
				for (var nt = null; tt !== null; ) tt.alternate !== null && (nt = tt), (tt = tt.sibling);
				nt === null ? (et || _.tail === null ? (_.tail = null) : (_.tail.sibling = null)) : (nt.sibling = null);
		}
}
function S$1(_) {
	var et = _.alternate !== null && _.alternate.child === _.child,
		tt = 0,
		nt = 0;
	if (et)
		for (var rt = _.child; rt !== null; )
			(tt |= rt.lanes | rt.childLanes),
				(nt |= rt.subtreeFlags & 14680064),
				(nt |= rt.flags & 14680064),
				(rt.return = _),
				(rt = rt.sibling);
	else
		for (rt = _.child; rt !== null; )
			(tt |= rt.lanes | rt.childLanes), (nt |= rt.subtreeFlags), (nt |= rt.flags), (rt.return = _), (rt = rt.sibling);
	return (_.subtreeFlags |= nt), (_.childLanes = tt), et;
}
function Fj(_, et, tt) {
	var nt = et.pendingProps;
	switch ((wg(et), et.tag)) {
		case 2:
		case 16:
		case 15:
		case 0:
		case 11:
		case 7:
		case 8:
		case 12:
		case 9:
		case 14:
			return S$1(et), null;
		case 1:
			return Zf(et.type) && $f(), S$1(et), null;
		case 3:
			return (
				(nt = et.stateNode),
				Jh(),
				E(Wf),
				E(H$1),
				Oh(),
				nt.pendingContext && ((nt.context = nt.pendingContext), (nt.pendingContext = null)),
				(_ === null || _.child === null) &&
					(Gg(et)
						? (et.flags |= 4)
						: _ === null ||
						  (_.memoizedState.isDehydrated && (et.flags & 256) === 0) ||
						  ((et.flags |= 1024), zg !== null && (Gj(zg), (zg = null)))),
				Bj(_, et),
				S$1(et),
				null
			);
		case 5:
			Lh(et);
			var rt = Hh(Gh.current);
			if (((tt = et.type), _ !== null && et.stateNode != null))
				Cj(_, et, tt, nt, rt), _.ref !== et.ref && ((et.flags |= 512), (et.flags |= 2097152));
			else {
				if (!nt) {
					if (et.stateNode === null) throw Error(p$3(166));
					return S$1(et), null;
				}
				if (((_ = Hh(Eh.current)), Gg(et))) {
					(nt = et.stateNode), (tt = et.type);
					var it = et.memoizedProps;
					switch (((nt[Of] = et), (nt[Pf] = it), (_ = (et.mode & 1) !== 0), tt)) {
						case "dialog":
							D("cancel", nt), D("close", nt);
							break;
						case "iframe":
						case "object":
						case "embed":
							D("load", nt);
							break;
						case "video":
						case "audio":
							for (rt = 0; rt < lf.length; rt++) D(lf[rt], nt);
							break;
						case "source":
							D("error", nt);
							break;
						case "img":
						case "image":
						case "link":
							D("error", nt), D("load", nt);
							break;
						case "details":
							D("toggle", nt);
							break;
						case "input":
							Za(nt, it), D("invalid", nt);
							break;
						case "select":
							(nt._wrapperState = { wasMultiple: !!it.multiple }), D("invalid", nt);
							break;
						case "textarea":
							hb(nt, it), D("invalid", nt);
					}
					ub(tt, it), (rt = null);
					for (var ot in it)
						if (it.hasOwnProperty(ot)) {
							var at = it[ot];
							ot === "children"
								? typeof at == "string"
									? nt.textContent !== at &&
									  (it.suppressHydrationWarning !== !0 && Af(nt.textContent, at, _), (rt = ["children", at]))
									: typeof at == "number" &&
									  nt.textContent !== "" + at &&
									  (it.suppressHydrationWarning !== !0 && Af(nt.textContent, at, _), (rt = ["children", "" + at]))
								: ea.hasOwnProperty(ot) && at != null && ot === "onScroll" && D("scroll", nt);
						}
					switch (tt) {
						case "input":
							Va(nt), db(nt, it, !0);
							break;
						case "textarea":
							Va(nt), jb(nt);
							break;
						case "select":
						case "option":
							break;
						default:
							typeof it.onClick == "function" && (nt.onclick = Bf);
					}
					(nt = rt), (et.updateQueue = nt), nt !== null && (et.flags |= 4);
				} else {
					(ot = rt.nodeType === 9 ? rt : rt.ownerDocument),
						_ === "http://www.w3.org/1999/xhtml" && (_ = kb(tt)),
						_ === "http://www.w3.org/1999/xhtml"
							? tt === "script"
								? ((_ = ot.createElement("div")),
								  (_.innerHTML = "<script></script>"),
								  (_ = _.removeChild(_.firstChild)))
								: typeof nt.is == "string"
								? (_ = ot.createElement(tt, { is: nt.is }))
								: ((_ = ot.createElement(tt)),
								  tt === "select" && ((ot = _), nt.multiple ? (ot.multiple = !0) : nt.size && (ot.size = nt.size)))
							: (_ = ot.createElementNS(_, tt)),
						(_[Of] = et),
						(_[Pf] = nt),
						Aj(_, et, !1, !1),
						(et.stateNode = _);
					e: {
						switch (((ot = vb(tt, nt)), tt)) {
							case "dialog":
								D("cancel", _), D("close", _), (rt = nt);
								break;
							case "iframe":
							case "object":
							case "embed":
								D("load", _), (rt = nt);
								break;
							case "video":
							case "audio":
								for (rt = 0; rt < lf.length; rt++) D(lf[rt], _);
								rt = nt;
								break;
							case "source":
								D("error", _), (rt = nt);
								break;
							case "img":
							case "image":
							case "link":
								D("error", _), D("load", _), (rt = nt);
								break;
							case "details":
								D("toggle", _), (rt = nt);
								break;
							case "input":
								Za(_, nt), (rt = Ya(_, nt)), D("invalid", _);
								break;
							case "option":
								rt = nt;
								break;
							case "select":
								(_._wrapperState = { wasMultiple: !!nt.multiple }),
									(rt = A({}, nt, { value: void 0 })),
									D("invalid", _);
								break;
							case "textarea":
								hb(_, nt), (rt = gb(_, nt)), D("invalid", _);
								break;
							default:
								rt = nt;
						}
						ub(tt, rt), (at = rt);
						for (it in at)
							if (at.hasOwnProperty(it)) {
								var st = at[it];
								it === "style"
									? sb(_, st)
									: it === "dangerouslySetInnerHTML"
									? ((st = st ? st.__html : void 0), st != null && nb(_, st))
									: it === "children"
									? typeof st == "string"
										? (tt !== "textarea" || st !== "") && ob(_, st)
										: typeof st == "number" && ob(_, "" + st)
									: it !== "suppressContentEditableWarning" &&
									  it !== "suppressHydrationWarning" &&
									  it !== "autoFocus" &&
									  (ea.hasOwnProperty(it)
											? st != null && it === "onScroll" && D("scroll", _)
											: st != null && ta(_, it, st, ot));
							}
						switch (tt) {
							case "input":
								Va(_), db(_, nt, !1);
								break;
							case "textarea":
								Va(_), jb(_);
								break;
							case "option":
								nt.value != null && _.setAttribute("value", "" + Sa(nt.value));
								break;
							case "select":
								(_.multiple = !!nt.multiple),
									(it = nt.value),
									it != null
										? fb(_, !!nt.multiple, it, !1)
										: nt.defaultValue != null && fb(_, !!nt.multiple, nt.defaultValue, !0);
								break;
							default:
								typeof rt.onClick == "function" && (_.onclick = Bf);
						}
						switch (tt) {
							case "button":
							case "input":
							case "select":
							case "textarea":
								nt = !!nt.autoFocus;
								break e;
							case "img":
								nt = !0;
								break e;
							default:
								nt = !1;
						}
					}
					nt && (et.flags |= 4);
				}
				et.ref !== null && ((et.flags |= 512), (et.flags |= 2097152));
			}
			return S$1(et), null;
		case 6:
			if (_ && et.stateNode != null) Dj(_, et, _.memoizedProps, nt);
			else {
				if (typeof nt != "string" && et.stateNode === null) throw Error(p$3(166));
				if (((tt = Hh(Gh.current)), Hh(Eh.current), Gg(et))) {
					if (
						((nt = et.stateNode),
						(tt = et.memoizedProps),
						(nt[Of] = et),
						(it = nt.nodeValue !== tt) && ((_ = xg), _ !== null))
					)
						switch (_.tag) {
							case 3:
								Af(nt.nodeValue, tt, (_.mode & 1) !== 0);
								break;
							case 5:
								_.memoizedProps.suppressHydrationWarning !== !0 && Af(nt.nodeValue, tt, (_.mode & 1) !== 0);
						}
					it && (et.flags |= 4);
				} else
					(nt = (tt.nodeType === 9 ? tt : tt.ownerDocument).createTextNode(nt)), (nt[Of] = et), (et.stateNode = nt);
			}
			return S$1(et), null;
		case 13:
			if (
				(E(M), (nt = et.memoizedState), _ === null || (_.memoizedState !== null && _.memoizedState.dehydrated !== null))
			) {
				if (I$1 && yg !== null && (et.mode & 1) !== 0 && (et.flags & 128) === 0)
					Hg(), Ig(), (et.flags |= 98560), (it = !1);
				else if (((it = Gg(et)), nt !== null && nt.dehydrated !== null)) {
					if (_ === null) {
						if (!it) throw Error(p$3(318));
						if (((it = et.memoizedState), (it = it !== null ? it.dehydrated : null), !it)) throw Error(p$3(317));
						it[Of] = et;
					} else Ig(), (et.flags & 128) === 0 && (et.memoizedState = null), (et.flags |= 4);
					S$1(et), (it = !1);
				} else zg !== null && (Gj(zg), (zg = null)), (it = !0);
				if (!it) return et.flags & 65536 ? et : null;
			}
			return (et.flags & 128) !== 0
				? ((et.lanes = tt), et)
				: ((nt = nt !== null),
				  nt !== (_ !== null && _.memoizedState !== null) &&
						nt &&
						((et.child.flags |= 8192),
						(et.mode & 1) !== 0 && (_ === null || (M.current & 1) !== 0 ? T$2 === 0 && (T$2 = 3) : uj())),
				  et.updateQueue !== null && (et.flags |= 4),
				  S$1(et),
				  null);
		case 4:
			return Jh(), Bj(_, et), _ === null && sf(et.stateNode.containerInfo), S$1(et), null;
		case 10:
			return Rg(et.type._context), S$1(et), null;
		case 17:
			return Zf(et.type) && $f(), S$1(et), null;
		case 19:
			if ((E(M), (it = et.memoizedState), it === null)) return S$1(et), null;
			if (((nt = (et.flags & 128) !== 0), (ot = it.rendering), ot === null))
				if (nt) Ej(it, !1);
				else {
					if (T$2 !== 0 || (_ !== null && (_.flags & 128) !== 0))
						for (_ = et.child; _ !== null; ) {
							if (((ot = Mh(_)), ot !== null)) {
								for (
									et.flags |= 128,
										Ej(it, !1),
										nt = ot.updateQueue,
										nt !== null && ((et.updateQueue = nt), (et.flags |= 4)),
										et.subtreeFlags = 0,
										nt = tt,
										tt = et.child;
									tt !== null;

								)
									(it = tt),
										(_ = nt),
										(it.flags &= 14680066),
										(ot = it.alternate),
										ot === null
											? ((it.childLanes = 0),
											  (it.lanes = _),
											  (it.child = null),
											  (it.subtreeFlags = 0),
											  (it.memoizedProps = null),
											  (it.memoizedState = null),
											  (it.updateQueue = null),
											  (it.dependencies = null),
											  (it.stateNode = null))
											: ((it.childLanes = ot.childLanes),
											  (it.lanes = ot.lanes),
											  (it.child = ot.child),
											  (it.subtreeFlags = 0),
											  (it.deletions = null),
											  (it.memoizedProps = ot.memoizedProps),
											  (it.memoizedState = ot.memoizedState),
											  (it.updateQueue = ot.updateQueue),
											  (it.type = ot.type),
											  (_ = ot.dependencies),
											  (it.dependencies = _ === null ? null : { lanes: _.lanes, firstContext: _.firstContext })),
										(tt = tt.sibling);
								return G(M, (M.current & 1) | 2), et.child;
							}
							_ = _.sibling;
						}
					it.tail !== null && B$1() > Hj && ((et.flags |= 128), (nt = !0), Ej(it, !1), (et.lanes = 4194304));
				}
			else {
				if (!nt)
					if (((_ = Mh(ot)), _ !== null)) {
						if (
							((et.flags |= 128),
							(nt = !0),
							(tt = _.updateQueue),
							tt !== null && ((et.updateQueue = tt), (et.flags |= 4)),
							Ej(it, !0),
							it.tail === null && it.tailMode === "hidden" && !ot.alternate && !I$1)
						)
							return S$1(et), null;
					} else
						2 * B$1() - it.renderingStartTime > Hj &&
							tt !== 1073741824 &&
							((et.flags |= 128), (nt = !0), Ej(it, !1), (et.lanes = 4194304));
				it.isBackwards
					? ((ot.sibling = et.child), (et.child = ot))
					: ((tt = it.last), tt !== null ? (tt.sibling = ot) : (et.child = ot), (it.last = ot));
			}
			return it.tail !== null
				? ((et = it.tail),
				  (it.rendering = et),
				  (it.tail = et.sibling),
				  (it.renderingStartTime = B$1()),
				  (et.sibling = null),
				  (tt = M.current),
				  G(M, nt ? (tt & 1) | 2 : tt & 1),
				  et)
				: (S$1(et), null);
		case 22:
		case 23:
			return (
				Ij(),
				(nt = et.memoizedState !== null),
				_ !== null && (_.memoizedState !== null) !== nt && (et.flags |= 8192),
				nt && (et.mode & 1) !== 0
					? (gj & 1073741824) !== 0 && (S$1(et), et.subtreeFlags & 6 && (et.flags |= 8192))
					: S$1(et),
				null
			);
		case 24:
			return null;
		case 25:
			return null;
	}
	throw Error(p$3(156, et.tag));
}
function Jj(_, et) {
	switch ((wg(et), et.tag)) {
		case 1:
			return Zf(et.type) && $f(), (_ = et.flags), _ & 65536 ? ((et.flags = (_ & -65537) | 128), et) : null;
		case 3:
			return (
				Jh(),
				E(Wf),
				E(H$1),
				Oh(),
				(_ = et.flags),
				(_ & 65536) !== 0 && (_ & 128) === 0 ? ((et.flags = (_ & -65537) | 128), et) : null
			);
		case 5:
			return Lh(et), null;
		case 13:
			if ((E(M), (_ = et.memoizedState), _ !== null && _.dehydrated !== null)) {
				if (et.alternate === null) throw Error(p$3(340));
				Ig();
			}
			return (_ = et.flags), _ & 65536 ? ((et.flags = (_ & -65537) | 128), et) : null;
		case 19:
			return E(M), null;
		case 4:
			return Jh(), null;
		case 10:
			return Rg(et.type._context), null;
		case 22:
		case 23:
			return Ij(), null;
		case 24:
			return null;
		default:
			return null;
	}
}
var Kj = !1,
	U$1 = !1,
	Lj = typeof WeakSet == "function" ? WeakSet : Set,
	V$1 = null;
function Mj(_, et) {
	var tt = _.ref;
	if (tt !== null)
		if (typeof tt == "function")
			try {
				tt(null);
			} catch (nt) {
				W(_, et, nt);
			}
		else tt.current = null;
}
function Nj(_, et, tt) {
	try {
		tt();
	} catch (nt) {
		W(_, et, nt);
	}
}
var Oj = !1;
function Pj(_, et) {
	if (((Cf = dd), (_ = Me()), Ne(_))) {
		if ("selectionStart" in _) var tt = { start: _.selectionStart, end: _.selectionEnd };
		else
			e: {
				tt = ((tt = _.ownerDocument) && tt.defaultView) || window;
				var nt = tt.getSelection && tt.getSelection();
				if (nt && nt.rangeCount !== 0) {
					tt = nt.anchorNode;
					var rt = nt.anchorOffset,
						it = nt.focusNode;
					nt = nt.focusOffset;
					try {
						tt.nodeType, it.nodeType;
					} catch {
						tt = null;
						break e;
					}
					var ot = 0,
						at = -1,
						st = -1,
						lt = 0,
						ut = 0,
						dt = _,
						ct = null;
					t: for (;;) {
						for (
							var ft;
							dt !== tt || (rt !== 0 && dt.nodeType !== 3) || (at = ot + rt),
								dt !== it || (nt !== 0 && dt.nodeType !== 3) || (st = ot + nt),
								dt.nodeType === 3 && (ot += dt.nodeValue.length),
								(ft = dt.firstChild) !== null;

						)
							(ct = dt), (dt = ft);
						for (;;) {
							if (dt === _) break t;
							if (
								(ct === tt && ++lt === rt && (at = ot),
								ct === it && ++ut === nt && (st = ot),
								(ft = dt.nextSibling) !== null)
							)
								break;
							(dt = ct), (ct = dt.parentNode);
						}
						dt = ft;
					}
					tt = at === -1 || st === -1 ? null : { start: at, end: st };
				} else tt = null;
			}
		tt = tt || { start: 0, end: 0 };
	} else tt = null;
	for (Df = { focusedElem: _, selectionRange: tt }, dd = !1, V$1 = et; V$1 !== null; )
		if (((et = V$1), (_ = et.child), (et.subtreeFlags & 1028) !== 0 && _ !== null)) (_.return = et), (V$1 = _);
		else
			for (; V$1 !== null; ) {
				et = V$1;
				try {
					var mt = et.alternate;
					if ((et.flags & 1024) !== 0)
						switch (et.tag) {
							case 0:
							case 11:
							case 15:
								break;
							case 1:
								if (mt !== null) {
									var pt = mt.memoizedProps,
										vt = mt.memoizedState,
										ht = et.stateNode,
										gt = ht.getSnapshotBeforeUpdate(et.elementType === et.type ? pt : Lg(et.type, pt), vt);
									ht.__reactInternalSnapshotBeforeUpdate = gt;
								}
								break;
							case 3:
								var yt = et.stateNode.containerInfo;
								yt.nodeType === 1
									? (yt.textContent = "")
									: yt.nodeType === 9 && yt.documentElement && yt.removeChild(yt.documentElement);
								break;
							case 5:
							case 6:
							case 4:
							case 17:
								break;
							default:
								throw Error(p$3(163));
						}
				} catch (xt) {
					W(et, et.return, xt);
				}
				if (((_ = et.sibling), _ !== null)) {
					(_.return = et.return), (V$1 = _);
					break;
				}
				V$1 = et.return;
			}
	return (mt = Oj), (Oj = !1), mt;
}
function Qj(_, et, tt) {
	var nt = et.updateQueue;
	if (((nt = nt !== null ? nt.lastEffect : null), nt !== null)) {
		var rt = (nt = nt.next);
		do {
			if ((rt.tag & _) === _) {
				var it = rt.destroy;
				(rt.destroy = void 0), it !== void 0 && Nj(et, tt, it);
			}
			rt = rt.next;
		} while (rt !== nt);
	}
}
function Rj(_, et) {
	if (((et = et.updateQueue), (et = et !== null ? et.lastEffect : null), et !== null)) {
		var tt = (et = et.next);
		do {
			if ((tt.tag & _) === _) {
				var nt = tt.create;
				tt.destroy = nt();
			}
			tt = tt.next;
		} while (tt !== et);
	}
}
function Sj(_) {
	var et = _.ref;
	if (et !== null) {
		var tt = _.stateNode;
		switch (_.tag) {
			case 5:
				_ = tt;
				break;
			default:
				_ = tt;
		}
		typeof et == "function" ? et(_) : (et.current = _);
	}
}
function Tj(_) {
	var et = _.alternate;
	et !== null && ((_.alternate = null), Tj(et)),
		(_.child = null),
		(_.deletions = null),
		(_.sibling = null),
		_.tag === 5 &&
			((et = _.stateNode), et !== null && (delete et[Of], delete et[Pf], delete et[of], delete et[Qf], delete et[Rf])),
		(_.stateNode = null),
		(_.return = null),
		(_.dependencies = null),
		(_.memoizedProps = null),
		(_.memoizedState = null),
		(_.pendingProps = null),
		(_.stateNode = null),
		(_.updateQueue = null);
}
function Uj(_) {
	return _.tag === 5 || _.tag === 3 || _.tag === 4;
}
function Vj(_) {
	e: for (;;) {
		for (; _.sibling === null; ) {
			if (_.return === null || Uj(_.return)) return null;
			_ = _.return;
		}
		for (_.sibling.return = _.return, _ = _.sibling; _.tag !== 5 && _.tag !== 6 && _.tag !== 18; ) {
			if (_.flags & 2 || _.child === null || _.tag === 4) continue e;
			(_.child.return = _), (_ = _.child);
		}
		if (!(_.flags & 2)) return _.stateNode;
	}
}
function Wj(_, et, tt) {
	var nt = _.tag;
	if (nt === 5 || nt === 6)
		(_ = _.stateNode),
			et
				? tt.nodeType === 8
					? tt.parentNode.insertBefore(_, et)
					: tt.insertBefore(_, et)
				: (tt.nodeType === 8 ? ((et = tt.parentNode), et.insertBefore(_, tt)) : ((et = tt), et.appendChild(_)),
				  (tt = tt._reactRootContainer),
				  tt != null || et.onclick !== null || (et.onclick = Bf));
	else if (nt !== 4 && ((_ = _.child), _ !== null))
		for (Wj(_, et, tt), _ = _.sibling; _ !== null; ) Wj(_, et, tt), (_ = _.sibling);
}
function Xj(_, et, tt) {
	var nt = _.tag;
	if (nt === 5 || nt === 6) (_ = _.stateNode), et ? tt.insertBefore(_, et) : tt.appendChild(_);
	else if (nt !== 4 && ((_ = _.child), _ !== null))
		for (Xj(_, et, tt), _ = _.sibling; _ !== null; ) Xj(_, et, tt), (_ = _.sibling);
}
var X$1 = null,
	Yj = !1;
function Zj(_, et, tt) {
	for (tt = tt.child; tt !== null; ) ak(_, et, tt), (tt = tt.sibling);
}
function ak(_, et, tt) {
	if (lc && typeof lc.onCommitFiberUnmount == "function")
		try {
			lc.onCommitFiberUnmount(kc, tt);
		} catch {}
	switch (tt.tag) {
		case 5:
			U$1 || Mj(tt, et);
		case 6:
			var nt = X$1,
				rt = Yj;
			(X$1 = null),
				Zj(_, et, tt),
				(X$1 = nt),
				(Yj = rt),
				X$1 !== null &&
					(Yj
						? ((_ = X$1), (tt = tt.stateNode), _.nodeType === 8 ? _.parentNode.removeChild(tt) : _.removeChild(tt))
						: X$1.removeChild(tt.stateNode));
			break;
		case 18:
			X$1 !== null &&
				(Yj
					? ((_ = X$1),
					  (tt = tt.stateNode),
					  _.nodeType === 8 ? Kf(_.parentNode, tt) : _.nodeType === 1 && Kf(_, tt),
					  bd(_))
					: Kf(X$1, tt.stateNode));
			break;
		case 4:
			(nt = X$1), (rt = Yj), (X$1 = tt.stateNode.containerInfo), (Yj = !0), Zj(_, et, tt), (X$1 = nt), (Yj = rt);
			break;
		case 0:
		case 11:
		case 14:
		case 15:
			if (!U$1 && ((nt = tt.updateQueue), nt !== null && ((nt = nt.lastEffect), nt !== null))) {
				rt = nt = nt.next;
				do {
					var it = rt,
						ot = it.destroy;
					(it = it.tag), ot !== void 0 && ((it & 2) !== 0 || (it & 4) !== 0) && Nj(tt, et, ot), (rt = rt.next);
				} while (rt !== nt);
			}
			Zj(_, et, tt);
			break;
		case 1:
			if (!U$1 && (Mj(tt, et), (nt = tt.stateNode), typeof nt.componentWillUnmount == "function"))
				try {
					(nt.props = tt.memoizedProps), (nt.state = tt.memoizedState), nt.componentWillUnmount();
				} catch (at) {
					W(tt, et, at);
				}
			Zj(_, et, tt);
			break;
		case 21:
			Zj(_, et, tt);
			break;
		case 22:
			tt.mode & 1 ? ((U$1 = (nt = U$1) || tt.memoizedState !== null), Zj(_, et, tt), (U$1 = nt)) : Zj(_, et, tt);
			break;
		default:
			Zj(_, et, tt);
	}
}
function bk(_) {
	var et = _.updateQueue;
	if (et !== null) {
		_.updateQueue = null;
		var tt = _.stateNode;
		tt === null && (tt = _.stateNode = new Lj()),
			et.forEach(function (nt) {
				var rt = ck.bind(null, _, nt);
				tt.has(nt) || (tt.add(nt), nt.then(rt, rt));
			});
	}
}
function dk(_, et) {
	var tt = et.deletions;
	if (tt !== null)
		for (var nt = 0; nt < tt.length; nt++) {
			var rt = tt[nt];
			try {
				var it = _,
					ot = et,
					at = ot;
				e: for (; at !== null; ) {
					switch (at.tag) {
						case 5:
							(X$1 = at.stateNode), (Yj = !1);
							break e;
						case 3:
							(X$1 = at.stateNode.containerInfo), (Yj = !0);
							break e;
						case 4:
							(X$1 = at.stateNode.containerInfo), (Yj = !0);
							break e;
					}
					at = at.return;
				}
				if (X$1 === null) throw Error(p$3(160));
				ak(it, ot, rt), (X$1 = null), (Yj = !1);
				var st = rt.alternate;
				st !== null && (st.return = null), (rt.return = null);
			} catch (lt) {
				W(rt, et, lt);
			}
		}
	if (et.subtreeFlags & 12854) for (et = et.child; et !== null; ) ek(et, _), (et = et.sibling);
}
function ek(_, et) {
	var tt = _.alternate,
		nt = _.flags;
	switch (_.tag) {
		case 0:
		case 11:
		case 14:
		case 15:
			if ((dk(et, _), fk(_), nt & 4)) {
				try {
					Qj(3, _, _.return), Rj(3, _);
				} catch (pt) {
					W(_, _.return, pt);
				}
				try {
					Qj(5, _, _.return);
				} catch (pt) {
					W(_, _.return, pt);
				}
			}
			break;
		case 1:
			dk(et, _), fk(_), nt & 512 && tt !== null && Mj(tt, tt.return);
			break;
		case 5:
			if ((dk(et, _), fk(_), nt & 512 && tt !== null && Mj(tt, tt.return), _.flags & 32)) {
				var rt = _.stateNode;
				try {
					ob(rt, "");
				} catch (pt) {
					W(_, _.return, pt);
				}
			}
			if (nt & 4 && ((rt = _.stateNode), rt != null)) {
				var it = _.memoizedProps,
					ot = tt !== null ? tt.memoizedProps : it,
					at = _.type,
					st = _.updateQueue;
				if (((_.updateQueue = null), st !== null))
					try {
						at === "input" && it.type === "radio" && it.name != null && ab(rt, it), vb(at, ot);
						var lt = vb(at, it);
						for (ot = 0; ot < st.length; ot += 2) {
							var ut = st[ot],
								dt = st[ot + 1];
							ut === "style"
								? sb(rt, dt)
								: ut === "dangerouslySetInnerHTML"
								? nb(rt, dt)
								: ut === "children"
								? ob(rt, dt)
								: ta(rt, ut, dt, lt);
						}
						switch (at) {
							case "input":
								bb(rt, it);
								break;
							case "textarea":
								ib(rt, it);
								break;
							case "select":
								var ct = rt._wrapperState.wasMultiple;
								rt._wrapperState.wasMultiple = !!it.multiple;
								var ft = it.value;
								ft != null
									? fb(rt, !!it.multiple, ft, !1)
									: ct !== !!it.multiple &&
									  (it.defaultValue != null
											? fb(rt, !!it.multiple, it.defaultValue, !0)
											: fb(rt, !!it.multiple, it.multiple ? [] : "", !1));
						}
						rt[Pf] = it;
					} catch (pt) {
						W(_, _.return, pt);
					}
			}
			break;
		case 6:
			if ((dk(et, _), fk(_), nt & 4)) {
				if (_.stateNode === null) throw Error(p$3(162));
				(rt = _.stateNode), (it = _.memoizedProps);
				try {
					rt.nodeValue = it;
				} catch (pt) {
					W(_, _.return, pt);
				}
			}
			break;
		case 3:
			if ((dk(et, _), fk(_), nt & 4 && tt !== null && tt.memoizedState.isDehydrated))
				try {
					bd(et.containerInfo);
				} catch (pt) {
					W(_, _.return, pt);
				}
			break;
		case 4:
			dk(et, _), fk(_);
			break;
		case 13:
			dk(et, _),
				fk(_),
				(rt = _.child),
				rt.flags & 8192 &&
					((it = rt.memoizedState !== null),
					(rt.stateNode.isHidden = it),
					!it || (rt.alternate !== null && rt.alternate.memoizedState !== null) || (gk = B$1())),
				nt & 4 && bk(_);
			break;
		case 22:
			if (
				((ut = tt !== null && tt.memoizedState !== null),
				_.mode & 1 ? ((U$1 = (lt = U$1) || ut), dk(et, _), (U$1 = lt)) : dk(et, _),
				fk(_),
				nt & 8192)
			) {
				if (((lt = _.memoizedState !== null), (_.stateNode.isHidden = lt) && !ut && (_.mode & 1) !== 0))
					for (V$1 = _, ut = _.child; ut !== null; ) {
						for (dt = V$1 = ut; V$1 !== null; ) {
							switch (((ct = V$1), (ft = ct.child), ct.tag)) {
								case 0:
								case 11:
								case 14:
								case 15:
									Qj(4, ct, ct.return);
									break;
								case 1:
									Mj(ct, ct.return);
									var mt = ct.stateNode;
									if (typeof mt.componentWillUnmount == "function") {
										(nt = ct), (tt = ct.return);
										try {
											(et = nt),
												(mt.props = et.memoizedProps),
												(mt.state = et.memoizedState),
												mt.componentWillUnmount();
										} catch (pt) {
											W(nt, tt, pt);
										}
									}
									break;
								case 5:
									Mj(ct, ct.return);
									break;
								case 22:
									if (ct.memoizedState !== null) {
										hk(dt);
										continue;
									}
							}
							ft !== null ? ((ft.return = ct), (V$1 = ft)) : hk(dt);
						}
						ut = ut.sibling;
					}
				e: for (ut = null, dt = _; ; ) {
					if (dt.tag === 5) {
						if (ut === null) {
							ut = dt;
							try {
								(rt = dt.stateNode),
									lt
										? ((it = rt.style),
										  typeof it.setProperty == "function"
												? it.setProperty("display", "none", "important")
												: (it.display = "none"))
										: ((at = dt.stateNode),
										  (st = dt.memoizedProps.style),
										  (ot = st != null && st.hasOwnProperty("display") ? st.display : null),
										  (at.style.display = rb("display", ot)));
							} catch (pt) {
								W(_, _.return, pt);
							}
						}
					} else if (dt.tag === 6) {
						if (ut === null)
							try {
								dt.stateNode.nodeValue = lt ? "" : dt.memoizedProps;
							} catch (pt) {
								W(_, _.return, pt);
							}
					} else if (((dt.tag !== 22 && dt.tag !== 23) || dt.memoizedState === null || dt === _) && dt.child !== null) {
						(dt.child.return = dt), (dt = dt.child);
						continue;
					}
					if (dt === _) break e;
					for (; dt.sibling === null; ) {
						if (dt.return === null || dt.return === _) break e;
						ut === dt && (ut = null), (dt = dt.return);
					}
					ut === dt && (ut = null), (dt.sibling.return = dt.return), (dt = dt.sibling);
				}
			}
			break;
		case 19:
			dk(et, _), fk(_), nt & 4 && bk(_);
			break;
		case 21:
			break;
		default:
			dk(et, _), fk(_);
	}
}
function fk(_) {
	var et = _.flags;
	if (et & 2) {
		try {
			e: {
				for (var tt = _.return; tt !== null; ) {
					if (Uj(tt)) {
						var nt = tt;
						break e;
					}
					tt = tt.return;
				}
				throw Error(p$3(160));
			}
			switch (nt.tag) {
				case 5:
					var rt = nt.stateNode;
					nt.flags & 32 && (ob(rt, ""), (nt.flags &= -33));
					var it = Vj(_);
					Xj(_, it, rt);
					break;
				case 3:
				case 4:
					var ot = nt.stateNode.containerInfo,
						at = Vj(_);
					Wj(_, at, ot);
					break;
				default:
					throw Error(p$3(161));
			}
		} catch (st) {
			W(_, _.return, st);
		}
		_.flags &= -3;
	}
	et & 4096 && (_.flags &= -4097);
}
function ik(_, et, tt) {
	(V$1 = _), jk(_);
}
function jk(_, et, tt) {
	for (var nt = (_.mode & 1) !== 0; V$1 !== null; ) {
		var rt = V$1,
			it = rt.child;
		if (rt.tag === 22 && nt) {
			var ot = rt.memoizedState !== null || Kj;
			if (!ot) {
				var at = rt.alternate,
					st = (at !== null && at.memoizedState !== null) || U$1;
				at = Kj;
				var lt = U$1;
				if (((Kj = ot), (U$1 = st) && !lt))
					for (V$1 = rt; V$1 !== null; )
						(ot = V$1),
							(st = ot.child),
							ot.tag === 22 && ot.memoizedState !== null
								? kk(rt)
								: st !== null
								? ((st.return = ot), (V$1 = st))
								: kk(rt);
				for (; it !== null; ) (V$1 = it), jk(it), (it = it.sibling);
				(V$1 = rt), (Kj = at), (U$1 = lt);
			}
			lk(_);
		} else (rt.subtreeFlags & 8772) !== 0 && it !== null ? ((it.return = rt), (V$1 = it)) : lk(_);
	}
}
function lk(_) {
	for (; V$1 !== null; ) {
		var et = V$1;
		if ((et.flags & 8772) !== 0) {
			var tt = et.alternate;
			try {
				if ((et.flags & 8772) !== 0)
					switch (et.tag) {
						case 0:
						case 11:
						case 15:
							U$1 || Rj(5, et);
							break;
						case 1:
							var nt = et.stateNode;
							if (et.flags & 4 && !U$1)
								if (tt === null) nt.componentDidMount();
								else {
									var rt = et.elementType === et.type ? tt.memoizedProps : Lg(et.type, tt.memoizedProps);
									nt.componentDidUpdate(rt, tt.memoizedState, nt.__reactInternalSnapshotBeforeUpdate);
								}
							var it = et.updateQueue;
							it !== null && ih(et, it, nt);
							break;
						case 3:
							var ot = et.updateQueue;
							if (ot !== null) {
								if (((tt = null), et.child !== null))
									switch (et.child.tag) {
										case 5:
											tt = et.child.stateNode;
											break;
										case 1:
											tt = et.child.stateNode;
									}
								ih(et, ot, tt);
							}
							break;
						case 5:
							var at = et.stateNode;
							if (tt === null && et.flags & 4) {
								tt = at;
								var st = et.memoizedProps;
								switch (et.type) {
									case "button":
									case "input":
									case "select":
									case "textarea":
										st.autoFocus && tt.focus();
										break;
									case "img":
										st.src && (tt.src = st.src);
								}
							}
							break;
						case 6:
							break;
						case 4:
							break;
						case 12:
							break;
						case 13:
							if (et.memoizedState === null) {
								var lt = et.alternate;
								if (lt !== null) {
									var ut = lt.memoizedState;
									if (ut !== null) {
										var dt = ut.dehydrated;
										dt !== null && bd(dt);
									}
								}
							}
							break;
						case 19:
						case 17:
						case 21:
						case 22:
						case 23:
						case 25:
							break;
						default:
							throw Error(p$3(163));
					}
				U$1 || (et.flags & 512 && Sj(et));
			} catch (ct) {
				W(et, et.return, ct);
			}
		}
		if (et === _) {
			V$1 = null;
			break;
		}
		if (((tt = et.sibling), tt !== null)) {
			(tt.return = et.return), (V$1 = tt);
			break;
		}
		V$1 = et.return;
	}
}
function hk(_) {
	for (; V$1 !== null; ) {
		var et = V$1;
		if (et === _) {
			V$1 = null;
			break;
		}
		var tt = et.sibling;
		if (tt !== null) {
			(tt.return = et.return), (V$1 = tt);
			break;
		}
		V$1 = et.return;
	}
}
function kk(_) {
	for (; V$1 !== null; ) {
		var et = V$1;
		try {
			switch (et.tag) {
				case 0:
				case 11:
				case 15:
					var tt = et.return;
					try {
						Rj(4, et);
					} catch (st) {
						W(et, tt, st);
					}
					break;
				case 1:
					var nt = et.stateNode;
					if (typeof nt.componentDidMount == "function") {
						var rt = et.return;
						try {
							nt.componentDidMount();
						} catch (st) {
							W(et, rt, st);
						}
					}
					var it = et.return;
					try {
						Sj(et);
					} catch (st) {
						W(et, it, st);
					}
					break;
				case 5:
					var ot = et.return;
					try {
						Sj(et);
					} catch (st) {
						W(et, ot, st);
					}
			}
		} catch (st) {
			W(et, et.return, st);
		}
		if (et === _) {
			V$1 = null;
			break;
		}
		var at = et.sibling;
		if (at !== null) {
			(at.return = et.return), (V$1 = at);
			break;
		}
		V$1 = et.return;
	}
}
var mk = Math.ceil,
	nk = ua.ReactCurrentDispatcher,
	ok$1 = ua.ReactCurrentOwner,
	pk = ua.ReactCurrentBatchConfig,
	K = 0,
	R = null,
	Y$1 = null,
	Z$1 = 0,
	gj = 0,
	fj = Uf(0),
	T$2 = 0,
	qk = null,
	hh = 0,
	rk = 0,
	sk = 0,
	tk = null,
	uk = null,
	gk = 0,
	Hj = 1 / 0,
	vk = null,
	Pi = !1,
	Qi = null,
	Si = null,
	wk = !1,
	xk = null,
	yk = 0,
	zk = 0,
	Ak = null,
	Bk = -1,
	Ck = 0;
function L() {
	return (K & 6) !== 0 ? B$1() : Bk !== -1 ? Bk : (Bk = B$1());
}
function lh(_) {
	return (_.mode & 1) === 0
		? 1
		: (K & 2) !== 0 && Z$1 !== 0
		? Z$1 & -Z$1
		: Kg.transition !== null
		? (Ck === 0 && (Ck = yc()), Ck)
		: ((_ = C$2), _ !== 0 || ((_ = window.event), (_ = _ === void 0 ? 16 : jd(_.type))), _);
}
function mh(_, et, tt, nt) {
	if (50 < zk) throw ((zk = 0), (Ak = null), Error(p$3(185)));
	Ac(_, tt, nt),
		((K & 2) === 0 || _ !== R) &&
			(_ === R && ((K & 2) === 0 && (rk |= tt), T$2 === 4 && Dk(_, Z$1)),
			Ek(_, nt),
			tt === 1 && K === 0 && (et.mode & 1) === 0 && ((Hj = B$1() + 500), fg && jg()));
}
function Ek(_, et) {
	var tt = _.callbackNode;
	wc(_, et);
	var nt = uc(_, _ === R ? Z$1 : 0);
	if (nt === 0) tt !== null && bc(tt), (_.callbackNode = null), (_.callbackPriority = 0);
	else if (((et = nt & -nt), _.callbackPriority !== et)) {
		if ((tt != null && bc(tt), et === 1))
			_.tag === 0 ? ig(Fk.bind(null, _)) : hg(Fk.bind(null, _)),
				Jf(function () {
					(K & 6) === 0 && jg();
				}),
				(tt = null);
		else {
			switch (Dc(nt)) {
				case 1:
					tt = fc;
					break;
				case 4:
					tt = gc;
					break;
				case 16:
					tt = hc;
					break;
				case 536870912:
					tt = jc;
					break;
				default:
					tt = hc;
			}
			tt = Gk(tt, Hk.bind(null, _));
		}
		(_.callbackPriority = et), (_.callbackNode = tt);
	}
}
function Hk(_, et) {
	if (((Bk = -1), (Ck = 0), (K & 6) !== 0)) throw Error(p$3(327));
	var tt = _.callbackNode;
	if (Ik() && _.callbackNode !== tt) return null;
	var nt = uc(_, _ === R ? Z$1 : 0);
	if (nt === 0) return null;
	if ((nt & 30) !== 0 || (nt & _.expiredLanes) !== 0 || et) et = Jk(_, nt);
	else {
		et = nt;
		var rt = K;
		K |= 2;
		var it = Kk();
		(R !== _ || Z$1 !== et) && ((vk = null), (Hj = B$1() + 500), Lk(_, et));
		do
			try {
				Mk();
				break;
			} catch (at) {
				Nk(_, at);
			}
		while (1);
		Qg(), (nk.current = it), (K = rt), Y$1 !== null ? (et = 0) : ((R = null), (Z$1 = 0), (et = T$2));
	}
	if (et !== 0) {
		if ((et === 2 && ((rt = xc(_)), rt !== 0 && ((nt = rt), (et = Ok(_, rt)))), et === 1))
			throw ((tt = qk), Lk(_, 0), Dk(_, nt), Ek(_, B$1()), tt);
		if (et === 6) Dk(_, nt);
		else {
			if (
				((rt = _.current.alternate),
				(nt & 30) === 0 &&
					!Pk(rt) &&
					((et = Jk(_, nt)), et === 2 && ((it = xc(_)), it !== 0 && ((nt = it), (et = Ok(_, it)))), et === 1))
			)
				throw ((tt = qk), Lk(_, 0), Dk(_, nt), Ek(_, B$1()), tt);
			switch (((_.finishedWork = rt), (_.finishedLanes = nt), et)) {
				case 0:
				case 1:
					throw Error(p$3(345));
				case 2:
					Qk(_, uk, vk);
					break;
				case 3:
					if ((Dk(_, nt), (nt & 130023424) === nt && ((et = gk + 500 - B$1()), 10 < et))) {
						if (uc(_, 0) !== 0) break;
						if (((rt = _.suspendedLanes), (rt & nt) !== nt)) {
							L(), (_.pingedLanes |= _.suspendedLanes & rt);
							break;
						}
						_.timeoutHandle = Ff(Qk.bind(null, _, uk, vk), et);
						break;
					}
					Qk(_, uk, vk);
					break;
				case 4:
					if ((Dk(_, nt), (nt & 4194240) === nt)) break;
					for (et = _.eventTimes, rt = -1; 0 < nt; ) {
						var ot = 31 - oc(nt);
						(it = 1 << ot), (ot = et[ot]), ot > rt && (rt = ot), (nt &= ~it);
					}
					if (
						((nt = rt),
						(nt = B$1() - nt),
						(nt =
							(120 > nt
								? 120
								: 480 > nt
								? 480
								: 1080 > nt
								? 1080
								: 1920 > nt
								? 1920
								: 3e3 > nt
								? 3e3
								: 4320 > nt
								? 4320
								: 1960 * mk(nt / 1960)) - nt),
						10 < nt)
					) {
						_.timeoutHandle = Ff(Qk.bind(null, _, uk, vk), nt);
						break;
					}
					Qk(_, uk, vk);
					break;
				case 5:
					Qk(_, uk, vk);
					break;
				default:
					throw Error(p$3(329));
			}
		}
	}
	return Ek(_, B$1()), _.callbackNode === tt ? Hk.bind(null, _) : null;
}
function Ok(_, et) {
	var tt = tk;
	return (
		_.current.memoizedState.isDehydrated && (Lk(_, et).flags |= 256),
		(_ = Jk(_, et)),
		_ !== 2 && ((et = uk), (uk = tt), et !== null && Gj(et)),
		_
	);
}
function Gj(_) {
	uk === null ? (uk = _) : uk.push.apply(uk, _);
}
function Pk(_) {
	for (var et = _; ; ) {
		if (et.flags & 16384) {
			var tt = et.updateQueue;
			if (tt !== null && ((tt = tt.stores), tt !== null))
				for (var nt = 0; nt < tt.length; nt++) {
					var rt = tt[nt],
						it = rt.getSnapshot;
					rt = rt.value;
					try {
						if (!He(it(), rt)) return !1;
					} catch {
						return !1;
					}
				}
		}
		if (((tt = et.child), et.subtreeFlags & 16384 && tt !== null)) (tt.return = et), (et = tt);
		else {
			if (et === _) break;
			for (; et.sibling === null; ) {
				if (et.return === null || et.return === _) return !0;
				et = et.return;
			}
			(et.sibling.return = et.return), (et = et.sibling);
		}
	}
	return !0;
}
function Dk(_, et) {
	for (et &= ~sk, et &= ~rk, _.suspendedLanes |= et, _.pingedLanes &= ~et, _ = _.expirationTimes; 0 < et; ) {
		var tt = 31 - oc(et),
			nt = 1 << tt;
		(_[tt] = -1), (et &= ~nt);
	}
}
function Fk(_) {
	if ((K & 6) !== 0) throw Error(p$3(327));
	Ik();
	var et = uc(_, 0);
	if ((et & 1) === 0) return Ek(_, B$1()), null;
	var tt = Jk(_, et);
	if (_.tag !== 0 && tt === 2) {
		var nt = xc(_);
		nt !== 0 && ((et = nt), (tt = Ok(_, nt)));
	}
	if (tt === 1) throw ((tt = qk), Lk(_, 0), Dk(_, et), Ek(_, B$1()), tt);
	if (tt === 6) throw Error(p$3(345));
	return (_.finishedWork = _.current.alternate), (_.finishedLanes = et), Qk(_, uk, vk), Ek(_, B$1()), null;
}
function Rk(_, et) {
	var tt = K;
	K |= 1;
	try {
		return _(et);
	} finally {
		(K = tt), K === 0 && ((Hj = B$1() + 500), fg && jg());
	}
}
function Sk(_) {
	xk !== null && xk.tag === 0 && (K & 6) === 0 && Ik();
	var et = K;
	K |= 1;
	var tt = pk.transition,
		nt = C$2;
	try {
		if (((pk.transition = null), (C$2 = 1), _)) return _();
	} finally {
		(C$2 = nt), (pk.transition = tt), (K = et), (K & 6) === 0 && jg();
	}
}
function Ij() {
	(gj = fj.current), E(fj);
}
function Lk(_, et) {
	(_.finishedWork = null), (_.finishedLanes = 0);
	var tt = _.timeoutHandle;
	if ((tt !== -1 && ((_.timeoutHandle = -1), Gf(tt)), Y$1 !== null))
		for (tt = Y$1.return; tt !== null; ) {
			var nt = tt;
			switch ((wg(nt), nt.tag)) {
				case 1:
					(nt = nt.type.childContextTypes), nt != null && $f();
					break;
				case 3:
					Jh(), E(Wf), E(H$1), Oh();
					break;
				case 5:
					Lh(nt);
					break;
				case 4:
					Jh();
					break;
				case 13:
					E(M);
					break;
				case 19:
					E(M);
					break;
				case 10:
					Rg(nt.type._context);
					break;
				case 22:
				case 23:
					Ij();
			}
			tt = tt.return;
		}
	if (
		((R = _),
		(Y$1 = _ = wh(_.current, null)),
		(Z$1 = gj = et),
		(T$2 = 0),
		(qk = null),
		(sk = rk = hh = 0),
		(uk = tk = null),
		Wg !== null)
	) {
		for (et = 0; et < Wg.length; et++)
			if (((tt = Wg[et]), (nt = tt.interleaved), nt !== null)) {
				tt.interleaved = null;
				var rt = nt.next,
					it = tt.pending;
				if (it !== null) {
					var ot = it.next;
					(it.next = rt), (nt.next = ot);
				}
				tt.pending = nt;
			}
		Wg = null;
	}
	return _;
}
function Nk(_, et) {
	do {
		var tt = Y$1;
		try {
			if ((Qg(), (Ph.current = ai), Sh)) {
				for (var nt = N.memoizedState; nt !== null; ) {
					var rt = nt.queue;
					rt !== null && (rt.pending = null), (nt = nt.next);
				}
				Sh = !1;
			}
			if (
				((Rh = 0), (P = O = N = null), (Th$1 = !1), (Uh = 0), (ok$1.current = null), tt === null || tt.return === null)
			) {
				(T$2 = 1), (qk = et), (Y$1 = null);
				break;
			}
			e: {
				var it = _,
					ot = tt.return,
					at = tt,
					st = et;
				if (((et = Z$1), (at.flags |= 32768), st !== null && typeof st == "object" && typeof st.then == "function")) {
					var lt = st,
						ut = at,
						dt = ut.tag;
					if ((ut.mode & 1) === 0 && (dt === 0 || dt === 11 || dt === 15)) {
						var ct = ut.alternate;
						ct
							? ((ut.updateQueue = ct.updateQueue), (ut.memoizedState = ct.memoizedState), (ut.lanes = ct.lanes))
							: ((ut.updateQueue = null), (ut.memoizedState = null));
					}
					var ft = Vi(ot);
					if (ft !== null) {
						(ft.flags &= -257), Wi(ft, ot, at, it, et), ft.mode & 1 && Ti(it, lt, et), (et = ft), (st = lt);
						var mt = et.updateQueue;
						if (mt === null) {
							var pt = new Set();
							pt.add(st), (et.updateQueue = pt);
						} else mt.add(st);
						break e;
					} else {
						if ((et & 1) === 0) {
							Ti(it, lt, et), uj();
							break e;
						}
						st = Error(p$3(426));
					}
				} else if (I$1 && at.mode & 1) {
					var vt = Vi(ot);
					if (vt !== null) {
						(vt.flags & 65536) === 0 && (vt.flags |= 256), Wi(vt, ot, at, it, et), Jg(Ki(st, at));
						break e;
					}
				}
				(it = st = Ki(st, at)), T$2 !== 4 && (T$2 = 2), tk === null ? (tk = [it]) : tk.push(it), (it = ot);
				do {
					switch (it.tag) {
						case 3:
							(it.flags |= 65536), (et &= -et), (it.lanes |= et);
							var ht = Oi(it, st, et);
							fh(it, ht);
							break e;
						case 1:
							at = st;
							var gt = it.type,
								yt = it.stateNode;
							if (
								(it.flags & 128) === 0 &&
								(typeof gt.getDerivedStateFromError == "function" ||
									(yt !== null && typeof yt.componentDidCatch == "function" && (Si === null || !Si.has(yt))))
							) {
								(it.flags |= 65536), (et &= -et), (it.lanes |= et);
								var xt = Ri(it, at, et);
								fh(it, xt);
								break e;
							}
					}
					it = it.return;
				} while (it !== null);
			}
			Tk(tt);
		} catch (St) {
			(et = St), Y$1 === tt && tt !== null && (Y$1 = tt = tt.return);
			continue;
		}
		break;
	} while (1);
}
function Kk() {
	var _ = nk.current;
	return (nk.current = ai), _ === null ? ai : _;
}
function uj() {
	(T$2 === 0 || T$2 === 3 || T$2 === 2) && (T$2 = 4),
		R === null || ((hh & 268435455) === 0 && (rk & 268435455) === 0) || Dk(R, Z$1);
}
function Jk(_, et) {
	var tt = K;
	K |= 2;
	var nt = Kk();
	(R !== _ || Z$1 !== et) && ((vk = null), Lk(_, et));
	do
		try {
			Uk();
			break;
		} catch (rt) {
			Nk(_, rt);
		}
	while (1);
	if ((Qg(), (K = tt), (nk.current = nt), Y$1 !== null)) throw Error(p$3(261));
	return (R = null), (Z$1 = 0), T$2;
}
function Uk() {
	for (; Y$1 !== null; ) Vk(Y$1);
}
function Mk() {
	for (; Y$1 !== null && !cc(); ) Vk(Y$1);
}
function Vk(_) {
	var et = Wk(_.alternate, _, gj);
	(_.memoizedProps = _.pendingProps), et === null ? Tk(_) : (Y$1 = et), (ok$1.current = null);
}
function Tk(_) {
	var et = _;
	do {
		var tt = et.alternate;
		if (((_ = et.return), (et.flags & 32768) === 0)) {
			if (((tt = Fj(tt, et, gj)), tt !== null)) {
				Y$1 = tt;
				return;
			}
		} else {
			if (((tt = Jj(tt, et)), tt !== null)) {
				(tt.flags &= 32767), (Y$1 = tt);
				return;
			}
			if (_ !== null) (_.flags |= 32768), (_.subtreeFlags = 0), (_.deletions = null);
			else {
				(T$2 = 6), (Y$1 = null);
				return;
			}
		}
		if (((et = et.sibling), et !== null)) {
			Y$1 = et;
			return;
		}
		Y$1 = et = _;
	} while (et !== null);
	T$2 === 0 && (T$2 = 5);
}
function Qk(_, et, tt) {
	var nt = C$2,
		rt = pk.transition;
	try {
		(pk.transition = null), (C$2 = 1), Xk(_, et, tt, nt);
	} finally {
		(pk.transition = rt), (C$2 = nt);
	}
	return null;
}
function Xk(_, et, tt, nt) {
	do Ik();
	while (xk !== null);
	if ((K & 6) !== 0) throw Error(p$3(327));
	tt = _.finishedWork;
	var rt = _.finishedLanes;
	if (tt === null) return null;
	if (((_.finishedWork = null), (_.finishedLanes = 0), tt === _.current)) throw Error(p$3(177));
	(_.callbackNode = null), (_.callbackPriority = 0);
	var it = tt.lanes | tt.childLanes;
	if (
		(Bc(_, it),
		_ === R && ((Y$1 = R = null), (Z$1 = 0)),
		((tt.subtreeFlags & 2064) === 0 && (tt.flags & 2064) === 0) ||
			wk ||
			((wk = !0),
			Gk(hc, function () {
				return Ik(), null;
			})),
		(it = (tt.flags & 15990) !== 0),
		(tt.subtreeFlags & 15990) !== 0 || it)
	) {
		(it = pk.transition), (pk.transition = null);
		var ot = C$2;
		C$2 = 1;
		var at = K;
		(K |= 4),
			(ok$1.current = null),
			Pj(_, tt),
			ek(tt, _),
			Oe$1(Df),
			(dd = !!Cf),
			(Df = Cf = null),
			(_.current = tt),
			ik(tt),
			dc(),
			(K = at),
			(C$2 = ot),
			(pk.transition = it);
	} else _.current = tt;
	if (
		(wk && ((wk = !1), (xk = _), (yk = rt)),
		(it = _.pendingLanes),
		it === 0 && (Si = null),
		mc(tt.stateNode),
		Ek(_, B$1()),
		et !== null)
	)
		for (nt = _.onRecoverableError, tt = 0; tt < et.length; tt++)
			(rt = et[tt]), nt(rt.value, { componentStack: rt.stack, digest: rt.digest });
	if (Pi) throw ((Pi = !1), (_ = Qi), (Qi = null), _);
	return (
		(yk & 1) !== 0 && _.tag !== 0 && Ik(),
		(it = _.pendingLanes),
		(it & 1) !== 0 ? (_ === Ak ? zk++ : ((zk = 0), (Ak = _))) : (zk = 0),
		jg(),
		null
	);
}
function Ik() {
	if (xk !== null) {
		var _ = Dc(yk),
			et = pk.transition,
			tt = C$2;
		try {
			if (((pk.transition = null), (C$2 = 16 > _ ? 16 : _), xk === null)) var nt = !1;
			else {
				if (((_ = xk), (xk = null), (yk = 0), (K & 6) !== 0)) throw Error(p$3(331));
				var rt = K;
				for (K |= 4, V$1 = _.current; V$1 !== null; ) {
					var it = V$1,
						ot = it.child;
					if ((V$1.flags & 16) !== 0) {
						var at = it.deletions;
						if (at !== null) {
							for (var st = 0; st < at.length; st++) {
								var lt = at[st];
								for (V$1 = lt; V$1 !== null; ) {
									var ut = V$1;
									switch (ut.tag) {
										case 0:
										case 11:
										case 15:
											Qj(8, ut, it);
									}
									var dt = ut.child;
									if (dt !== null) (dt.return = ut), (V$1 = dt);
									else
										for (; V$1 !== null; ) {
											ut = V$1;
											var ct = ut.sibling,
												ft = ut.return;
											if ((Tj(ut), ut === lt)) {
												V$1 = null;
												break;
											}
											if (ct !== null) {
												(ct.return = ft), (V$1 = ct);
												break;
											}
											V$1 = ft;
										}
								}
							}
							var mt = it.alternate;
							if (mt !== null) {
								var pt = mt.child;
								if (pt !== null) {
									mt.child = null;
									do {
										var vt = pt.sibling;
										(pt.sibling = null), (pt = vt);
									} while (pt !== null);
								}
							}
							V$1 = it;
						}
					}
					if ((it.subtreeFlags & 2064) !== 0 && ot !== null) (ot.return = it), (V$1 = ot);
					else
						e: for (; V$1 !== null; ) {
							if (((it = V$1), (it.flags & 2048) !== 0))
								switch (it.tag) {
									case 0:
									case 11:
									case 15:
										Qj(9, it, it.return);
								}
							var ht = it.sibling;
							if (ht !== null) {
								(ht.return = it.return), (V$1 = ht);
								break e;
							}
							V$1 = it.return;
						}
				}
				var gt = _.current;
				for (V$1 = gt; V$1 !== null; ) {
					ot = V$1;
					var yt = ot.child;
					if ((ot.subtreeFlags & 2064) !== 0 && yt !== null) (yt.return = ot), (V$1 = yt);
					else
						e: for (ot = gt; V$1 !== null; ) {
							if (((at = V$1), (at.flags & 2048) !== 0))
								try {
									switch (at.tag) {
										case 0:
										case 11:
										case 15:
											Rj(9, at);
									}
								} catch (St) {
									W(at, at.return, St);
								}
							if (at === ot) {
								V$1 = null;
								break e;
							}
							var xt = at.sibling;
							if (xt !== null) {
								(xt.return = at.return), (V$1 = xt);
								break e;
							}
							V$1 = at.return;
						}
				}
				if (((K = rt), jg(), lc && typeof lc.onPostCommitFiberRoot == "function"))
					try {
						lc.onPostCommitFiberRoot(kc, _);
					} catch {}
				nt = !0;
			}
			return nt;
		} finally {
			(C$2 = tt), (pk.transition = et);
		}
	}
	return !1;
}
function Yk(_, et, tt) {
	(et = Ki(tt, et)), (et = Oi(_, et, 1)), (_ = dh(_, et, 1)), (et = L()), _ !== null && (Ac(_, 1, et), Ek(_, et));
}
function W(_, et, tt) {
	if (_.tag === 3) Yk(_, _, tt);
	else
		for (; et !== null; ) {
			if (et.tag === 3) {
				Yk(et, _, tt);
				break;
			} else if (et.tag === 1) {
				var nt = et.stateNode;
				if (
					typeof et.type.getDerivedStateFromError == "function" ||
					(typeof nt.componentDidCatch == "function" && (Si === null || !Si.has(nt)))
				) {
					(_ = Ki(tt, _)), (_ = Ri(et, _, 1)), (et = dh(et, _, 1)), (_ = L()), et !== null && (Ac(et, 1, _), Ek(et, _));
					break;
				}
			}
			et = et.return;
		}
}
function Ui(_, et, tt) {
	var nt = _.pingCache;
	nt !== null && nt.delete(et),
		(et = L()),
		(_.pingedLanes |= _.suspendedLanes & tt),
		R === _ &&
			(Z$1 & tt) === tt &&
			(T$2 === 4 || (T$2 === 3 && (Z$1 & 130023424) === Z$1 && 500 > B$1() - gk) ? Lk(_, 0) : (sk |= tt)),
		Ek(_, et);
}
function Zk(_, et) {
	et === 0 && ((_.mode & 1) === 0 ? (et = 1) : ((et = sc), (sc <<= 1), (sc & 130023424) === 0 && (sc = 4194304)));
	var tt = L();
	(_ = Zg(_, et)), _ !== null && (Ac(_, et, tt), Ek(_, tt));
}
function vj(_) {
	var et = _.memoizedState,
		tt = 0;
	et !== null && (tt = et.retryLane), Zk(_, tt);
}
function ck(_, et) {
	var tt = 0;
	switch (_.tag) {
		case 13:
			var nt = _.stateNode,
				rt = _.memoizedState;
			rt !== null && (tt = rt.retryLane);
			break;
		case 19:
			nt = _.stateNode;
			break;
		default:
			throw Error(p$3(314));
	}
	nt !== null && nt.delete(et), Zk(_, tt);
}
var Wk;
Wk = function (_, et, tt) {
	if (_ !== null)
		if (_.memoizedProps !== et.pendingProps || Wf.current) Ug = !0;
		else {
			if ((_.lanes & tt) === 0 && (et.flags & 128) === 0) return (Ug = !1), zj(_, et, tt);
			Ug = (_.flags & 131072) !== 0;
		}
	else (Ug = !1), I$1 && (et.flags & 1048576) !== 0 && ug(et, ng, et.index);
	switch (((et.lanes = 0), et.tag)) {
		case 2:
			var nt = et.type;
			jj(_, et), (_ = et.pendingProps);
			var rt = Yf(et, H$1.current);
			Tg(et, tt), (rt = Xh(null, et, nt, _, rt, tt));
			var it = bi();
			return (
				(et.flags |= 1),
				typeof rt == "object" && rt !== null && typeof rt.render == "function" && rt.$$typeof === void 0
					? ((et.tag = 1),
					  (et.memoizedState = null),
					  (et.updateQueue = null),
					  Zf(nt) ? ((it = !0), cg(et)) : (it = !1),
					  (et.memoizedState = rt.state !== null && rt.state !== void 0 ? rt.state : null),
					  ah(et),
					  (rt.updater = nh),
					  (et.stateNode = rt),
					  (rt._reactInternals = et),
					  rh(et, nt, _, tt),
					  (et = kj(null, et, nt, !0, it, tt)))
					: ((et.tag = 0), I$1 && it && vg(et), Yi(null, et, rt, tt), (et = et.child)),
				et
			);
		case 16:
			nt = et.elementType;
			e: {
				switch (
					(jj(_, et),
					(_ = et.pendingProps),
					(rt = nt._init),
					(nt = rt(nt._payload)),
					(et.type = nt),
					(rt = et.tag = $k(nt)),
					(_ = Lg(nt, _)),
					rt)
				) {
					case 0:
						et = dj(null, et, nt, _, tt);
						break e;
					case 1:
						et = ij(null, et, nt, _, tt);
						break e;
					case 11:
						et = Zi(null, et, nt, _, tt);
						break e;
					case 14:
						et = aj(null, et, nt, Lg(nt.type, _), tt);
						break e;
				}
				throw Error(p$3(306, nt, ""));
			}
			return et;
		case 0:
			return (
				(nt = et.type), (rt = et.pendingProps), (rt = et.elementType === nt ? rt : Lg(nt, rt)), dj(_, et, nt, rt, tt)
			);
		case 1:
			return (
				(nt = et.type), (rt = et.pendingProps), (rt = et.elementType === nt ? rt : Lg(nt, rt)), ij(_, et, nt, rt, tt)
			);
		case 3:
			e: {
				if ((lj(et), _ === null)) throw Error(p$3(387));
				(nt = et.pendingProps), (it = et.memoizedState), (rt = it.element), bh(_, et), gh(et, nt, null, tt);
				var ot = et.memoizedState;
				if (((nt = ot.element), it.isDehydrated))
					if (
						((it = {
							element: nt,
							isDehydrated: !1,
							cache: ot.cache,
							pendingSuspenseBoundaries: ot.pendingSuspenseBoundaries,
							transitions: ot.transitions,
						}),
						(et.updateQueue.baseState = it),
						(et.memoizedState = it),
						et.flags & 256)
					) {
						(rt = Ki(Error(p$3(423)), et)), (et = mj(_, et, nt, tt, rt));
						break e;
					} else if (nt !== rt) {
						(rt = Ki(Error(p$3(424)), et)), (et = mj(_, et, nt, tt, rt));
						break e;
					} else
						for (
							yg = Lf(et.stateNode.containerInfo.firstChild),
								xg = et,
								I$1 = !0,
								zg = null,
								tt = Ch(et, null, nt, tt),
								et.child = tt;
							tt;

						)
							(tt.flags = (tt.flags & -3) | 4096), (tt = tt.sibling);
				else {
					if ((Ig(), nt === rt)) {
						et = $i(_, et, tt);
						break e;
					}
					Yi(_, et, nt, tt);
				}
				et = et.child;
			}
			return et;
		case 5:
			return (
				Kh(et),
				_ === null && Eg(et),
				(nt = et.type),
				(rt = et.pendingProps),
				(it = _ !== null ? _.memoizedProps : null),
				(ot = rt.children),
				Ef(nt, rt) ? (ot = null) : it !== null && Ef(nt, it) && (et.flags |= 32),
				hj(_, et),
				Yi(_, et, ot, tt),
				et.child
			);
		case 6:
			return _ === null && Eg(et), null;
		case 13:
			return pj(_, et, tt);
		case 4:
			return (
				Ih(et, et.stateNode.containerInfo),
				(nt = et.pendingProps),
				_ === null ? (et.child = Bh(et, null, nt, tt)) : Yi(_, et, nt, tt),
				et.child
			);
		case 11:
			return (
				(nt = et.type), (rt = et.pendingProps), (rt = et.elementType === nt ? rt : Lg(nt, rt)), Zi(_, et, nt, rt, tt)
			);
		case 7:
			return Yi(_, et, et.pendingProps, tt), et.child;
		case 8:
			return Yi(_, et, et.pendingProps.children, tt), et.child;
		case 12:
			return Yi(_, et, et.pendingProps.children, tt), et.child;
		case 10:
			e: {
				if (
					((nt = et.type._context),
					(rt = et.pendingProps),
					(it = et.memoizedProps),
					(ot = rt.value),
					G(Mg, nt._currentValue),
					(nt._currentValue = ot),
					it !== null)
				)
					if (He(it.value, ot)) {
						if (it.children === rt.children && !Wf.current) {
							et = $i(_, et, tt);
							break e;
						}
					} else
						for (it = et.child, it !== null && (it.return = et); it !== null; ) {
							var at = it.dependencies;
							if (at !== null) {
								ot = it.child;
								for (var st = at.firstContext; st !== null; ) {
									if (st.context === nt) {
										if (it.tag === 1) {
											(st = ch(-1, tt & -tt)), (st.tag = 2);
											var lt = it.updateQueue;
											if (lt !== null) {
												lt = lt.shared;
												var ut = lt.pending;
												ut === null ? (st.next = st) : ((st.next = ut.next), (ut.next = st)), (lt.pending = st);
											}
										}
										(it.lanes |= tt),
											(st = it.alternate),
											st !== null && (st.lanes |= tt),
											Sg(it.return, tt, et),
											(at.lanes |= tt);
										break;
									}
									st = st.next;
								}
							} else if (it.tag === 10) ot = it.type === et.type ? null : it.child;
							else if (it.tag === 18) {
								if (((ot = it.return), ot === null)) throw Error(p$3(341));
								(ot.lanes |= tt),
									(at = ot.alternate),
									at !== null && (at.lanes |= tt),
									Sg(ot, tt, et),
									(ot = it.sibling);
							} else ot = it.child;
							if (ot !== null) ot.return = it;
							else
								for (ot = it; ot !== null; ) {
									if (ot === et) {
										ot = null;
										break;
									}
									if (((it = ot.sibling), it !== null)) {
										(it.return = ot.return), (ot = it);
										break;
									}
									ot = ot.return;
								}
							it = ot;
						}
				Yi(_, et, rt.children, tt), (et = et.child);
			}
			return et;
		case 9:
			return (
				(rt = et.type),
				(nt = et.pendingProps.children),
				Tg(et, tt),
				(rt = Vg(rt)),
				(nt = nt(rt)),
				(et.flags |= 1),
				Yi(_, et, nt, tt),
				et.child
			);
		case 14:
			return (nt = et.type), (rt = Lg(nt, et.pendingProps)), (rt = Lg(nt.type, rt)), aj(_, et, nt, rt, tt);
		case 15:
			return cj(_, et, et.type, et.pendingProps, tt);
		case 17:
			return (
				(nt = et.type),
				(rt = et.pendingProps),
				(rt = et.elementType === nt ? rt : Lg(nt, rt)),
				jj(_, et),
				(et.tag = 1),
				Zf(nt) ? ((_ = !0), cg(et)) : (_ = !1),
				Tg(et, tt),
				ph(et, nt, rt),
				rh(et, nt, rt, tt),
				kj(null, et, nt, !0, _, tt)
			);
		case 19:
			return yj(_, et, tt);
		case 22:
			return ej(_, et, tt);
	}
	throw Error(p$3(156, et.tag));
};
function Gk(_, et) {
	return ac(_, et);
}
function al(_, et, tt, nt) {
	(this.tag = _),
		(this.key = tt),
		(this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null),
		(this.index = 0),
		(this.ref = null),
		(this.pendingProps = et),
		(this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
		(this.mode = nt),
		(this.subtreeFlags = this.flags = 0),
		(this.deletions = null),
		(this.childLanes = this.lanes = 0),
		(this.alternate = null);
}
function Bg(_, et, tt, nt) {
	return new al(_, et, tt, nt);
}
function bj(_) {
	return (_ = _.prototype), !(!_ || !_.isReactComponent);
}
function $k(_) {
	if (typeof _ == "function") return bj(_) ? 1 : 0;
	if (_ != null) {
		if (((_ = _.$$typeof), _ === Da)) return 11;
		if (_ === Ga) return 14;
	}
	return 2;
}
function wh(_, et) {
	var tt = _.alternate;
	return (
		tt === null
			? ((tt = Bg(_.tag, et, _.key, _.mode)),
			  (tt.elementType = _.elementType),
			  (tt.type = _.type),
			  (tt.stateNode = _.stateNode),
			  (tt.alternate = _),
			  (_.alternate = tt))
			: ((tt.pendingProps = et), (tt.type = _.type), (tt.flags = 0), (tt.subtreeFlags = 0), (tt.deletions = null)),
		(tt.flags = _.flags & 14680064),
		(tt.childLanes = _.childLanes),
		(tt.lanes = _.lanes),
		(tt.child = _.child),
		(tt.memoizedProps = _.memoizedProps),
		(tt.memoizedState = _.memoizedState),
		(tt.updateQueue = _.updateQueue),
		(et = _.dependencies),
		(tt.dependencies = et === null ? null : { lanes: et.lanes, firstContext: et.firstContext }),
		(tt.sibling = _.sibling),
		(tt.index = _.index),
		(tt.ref = _.ref),
		tt
	);
}
function yh(_, et, tt, nt, rt, it) {
	var ot = 2;
	if (((nt = _), typeof _ == "function")) bj(_) && (ot = 1);
	else if (typeof _ == "string") ot = 5;
	else
		e: switch (_) {
			case ya:
				return Ah(tt.children, rt, it, et);
			case za:
				(ot = 8), (rt |= 8);
				break;
			case Aa:
				return (_ = Bg(12, tt, et, rt | 2)), (_.elementType = Aa), (_.lanes = it), _;
			case Ea:
				return (_ = Bg(13, tt, et, rt)), (_.elementType = Ea), (_.lanes = it), _;
			case Fa:
				return (_ = Bg(19, tt, et, rt)), (_.elementType = Fa), (_.lanes = it), _;
			case Ia:
				return qj(tt, rt, it, et);
			default:
				if (typeof _ == "object" && _ !== null)
					switch (_.$$typeof) {
						case Ba:
							ot = 10;
							break e;
						case Ca:
							ot = 9;
							break e;
						case Da:
							ot = 11;
							break e;
						case Ga:
							ot = 14;
							break e;
						case Ha:
							(ot = 16), (nt = null);
							break e;
					}
				throw Error(p$3(130, _ == null ? _ : typeof _, ""));
		}
	return (et = Bg(ot, tt, et, rt)), (et.elementType = _), (et.type = nt), (et.lanes = it), et;
}
function Ah(_, et, tt, nt) {
	return (_ = Bg(7, _, nt, et)), (_.lanes = tt), _;
}
function qj(_, et, tt, nt) {
	return (_ = Bg(22, _, nt, et)), (_.elementType = Ia), (_.lanes = tt), (_.stateNode = { isHidden: !1 }), _;
}
function xh(_, et, tt) {
	return (_ = Bg(6, _, null, et)), (_.lanes = tt), _;
}
function zh(_, et, tt) {
	return (
		(et = Bg(4, _.children !== null ? _.children : [], _.key, et)),
		(et.lanes = tt),
		(et.stateNode = { containerInfo: _.containerInfo, pendingChildren: null, implementation: _.implementation }),
		et
	);
}
function bl(_, et, tt, nt, rt) {
	(this.tag = et),
		(this.containerInfo = _),
		(this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
		(this.timeoutHandle = -1),
		(this.callbackNode = this.pendingContext = this.context = null),
		(this.callbackPriority = 0),
		(this.eventTimes = zc(0)),
		(this.expirationTimes = zc(-1)),
		(this.entangledLanes =
			this.finishedLanes =
			this.mutableReadLanes =
			this.expiredLanes =
			this.pingedLanes =
			this.suspendedLanes =
			this.pendingLanes =
				0),
		(this.entanglements = zc(0)),
		(this.identifierPrefix = nt),
		(this.onRecoverableError = rt),
		(this.mutableSourceEagerHydrationData = null);
}
function cl(_, et, tt, nt, rt, it, ot, at, st) {
	return (
		(_ = new bl(_, et, tt, at, st)),
		et === 1 ? ((et = 1), it === !0 && (et |= 8)) : (et = 0),
		(it = Bg(3, null, null, et)),
		(_.current = it),
		(it.stateNode = _),
		(it.memoizedState = {
			element: nt,
			isDehydrated: tt,
			cache: null,
			transitions: null,
			pendingSuspenseBoundaries: null,
		}),
		ah(it),
		_
	);
}
function dl(_, et, tt) {
	var nt = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
	return { $$typeof: wa, key: nt == null ? null : "" + nt, children: _, containerInfo: et, implementation: tt };
}
function el(_) {
	if (!_) return Vf;
	_ = _._reactInternals;
	e: {
		if (Vb(_) !== _ || _.tag !== 1) throw Error(p$3(170));
		var et = _;
		do {
			switch (et.tag) {
				case 3:
					et = et.stateNode.context;
					break e;
				case 1:
					if (Zf(et.type)) {
						et = et.stateNode.__reactInternalMemoizedMergedChildContext;
						break e;
					}
			}
			et = et.return;
		} while (et !== null);
		throw Error(p$3(171));
	}
	if (_.tag === 1) {
		var tt = _.type;
		if (Zf(tt)) return bg(_, tt, et);
	}
	return et;
}
function fl(_, et, tt, nt, rt, it, ot, at, st) {
	return (
		(_ = cl(tt, nt, !0, _, rt, it, ot, at, st)),
		(_.context = el(null)),
		(tt = _.current),
		(nt = L()),
		(rt = lh(tt)),
		(it = ch(nt, rt)),
		(it.callback = et != null ? et : null),
		dh(tt, it, rt),
		(_.current.lanes = rt),
		Ac(_, rt, nt),
		Ek(_, nt),
		_
	);
}
function gl(_, et, tt, nt) {
	var rt = et.current,
		it = L(),
		ot = lh(rt);
	return (
		(tt = el(tt)),
		et.context === null ? (et.context = tt) : (et.pendingContext = tt),
		(et = ch(it, ot)),
		(et.payload = { element: _ }),
		(nt = nt === void 0 ? null : nt),
		nt !== null && (et.callback = nt),
		(_ = dh(rt, et, ot)),
		_ !== null && (mh(_, rt, ot, it), eh(_, rt, ot)),
		ot
	);
}
function hl(_) {
	if (((_ = _.current), !_.child)) return null;
	switch (_.child.tag) {
		case 5:
			return _.child.stateNode;
		default:
			return _.child.stateNode;
	}
}
function il(_, et) {
	if (((_ = _.memoizedState), _ !== null && _.dehydrated !== null)) {
		var tt = _.retryLane;
		_.retryLane = tt !== 0 && tt < et ? tt : et;
	}
}
function jl(_, et) {
	il(_, et), (_ = _.alternate) && il(_, et);
}
function kl() {
	return null;
}
var ll =
	typeof reportError == "function"
		? reportError
		: function (_) {
				console.error(_);
		  };
function ml(_) {
	this._internalRoot = _;
}
nl.prototype.render = ml.prototype.render = function (_) {
	var et = this._internalRoot;
	if (et === null) throw Error(p$3(409));
	gl(_, et, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function () {
	var _ = this._internalRoot;
	if (_ !== null) {
		this._internalRoot = null;
		var et = _.containerInfo;
		Sk(function () {
			gl(null, _, null, null);
		}),
			(et[uf] = null);
	}
};
function nl(_) {
	this._internalRoot = _;
}
nl.prototype.unstable_scheduleHydration = function (_) {
	if (_) {
		var et = Hc();
		_ = { blockedOn: null, target: _, priority: et };
		for (var tt = 0; tt < Qc.length && et !== 0 && et < Qc[tt].priority; tt++);
		Qc.splice(tt, 0, _), tt === 0 && Vc(_);
	}
};
function ol(_) {
	return !(!_ || (_.nodeType !== 1 && _.nodeType !== 9 && _.nodeType !== 11));
}
function pl(_) {
	return !(
		!_ ||
		(_.nodeType !== 1 &&
			_.nodeType !== 9 &&
			_.nodeType !== 11 &&
			(_.nodeType !== 8 || _.nodeValue !== " react-mount-point-unstable "))
	);
}
function ql() {}
function rl(_, et, tt, nt, rt) {
	if (rt) {
		if (typeof nt == "function") {
			var it = nt;
			nt = function () {
				var lt = hl(ot);
				it.call(lt);
			};
		}
		var ot = fl(et, nt, _, 0, null, !1, !1, "", ql);
		return (_._reactRootContainer = ot), (_[uf] = ot.current), sf(_.nodeType === 8 ? _.parentNode : _), Sk(), ot;
	}
	for (; (rt = _.lastChild); ) _.removeChild(rt);
	if (typeof nt == "function") {
		var at = nt;
		nt = function () {
			var lt = hl(st);
			at.call(lt);
		};
	}
	var st = cl(_, 0, !1, null, null, !1, !1, "", ql);
	return (
		(_._reactRootContainer = st),
		(_[uf] = st.current),
		sf(_.nodeType === 8 ? _.parentNode : _),
		Sk(function () {
			gl(et, st, tt, nt);
		}),
		st
	);
}
function sl(_, et, tt, nt, rt) {
	var it = tt._reactRootContainer;
	if (it) {
		var ot = it;
		if (typeof rt == "function") {
			var at = rt;
			rt = function () {
				var st = hl(ot);
				at.call(st);
			};
		}
		gl(et, ot, _, rt);
	} else ot = rl(tt, et, _, rt, nt);
	return hl(ot);
}
Ec = function (_) {
	switch (_.tag) {
		case 3:
			var et = _.stateNode;
			if (et.current.memoizedState.isDehydrated) {
				var tt = tc(et.pendingLanes);
				tt !== 0 && (Cc(et, tt | 1), Ek(et, B$1()), (K & 6) === 0 && ((Hj = B$1() + 500), jg()));
			}
			break;
		case 13:
			Sk(function () {
				var nt = Zg(_, 1);
				if (nt !== null) {
					var rt = L();
					mh(nt, _, 1, rt);
				}
			}),
				jl(_, 1);
	}
};
Fc = function (_) {
	if (_.tag === 13) {
		var et = Zg(_, 134217728);
		if (et !== null) {
			var tt = L();
			mh(et, _, 134217728, tt);
		}
		jl(_, 134217728);
	}
};
Gc = function (_) {
	if (_.tag === 13) {
		var et = lh(_),
			tt = Zg(_, et);
		if (tt !== null) {
			var nt = L();
			mh(tt, _, et, nt);
		}
		jl(_, et);
	}
};
Hc = function () {
	return C$2;
};
Ic = function (_, et) {
	var tt = C$2;
	try {
		return (C$2 = _), et();
	} finally {
		C$2 = tt;
	}
};
yb = function (_, et, tt) {
	switch (et) {
		case "input":
			if ((bb(_, tt), (et = tt.name), tt.type === "radio" && et != null)) {
				for (tt = _; tt.parentNode; ) tt = tt.parentNode;
				for (
					tt = tt.querySelectorAll("input[name=" + JSON.stringify("" + et) + '][type="radio"]'), et = 0;
					et < tt.length;
					et++
				) {
					var nt = tt[et];
					if (nt !== _ && nt.form === _.form) {
						var rt = Db(nt);
						if (!rt) throw Error(p$3(90));
						Wa(nt), bb(nt, rt);
					}
				}
			}
			break;
		case "textarea":
			ib(_, tt);
			break;
		case "select":
			(et = tt.value), et != null && fb(_, !!tt.multiple, et, !1);
	}
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: !1, Events: [Cb, ue, Db, Eb, Fb, Rk] },
	ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" },
	vl = {
		bundleType: ul.bundleType,
		version: ul.version,
		rendererPackageName: ul.rendererPackageName,
		rendererConfig: ul.rendererConfig,
		overrideHookState: null,
		overrideHookStateDeletePath: null,
		overrideHookStateRenamePath: null,
		overrideProps: null,
		overridePropsDeletePath: null,
		overridePropsRenamePath: null,
		setErrorHandler: null,
		setSuspenseHandler: null,
		scheduleUpdate: null,
		currentDispatcherRef: ua.ReactCurrentDispatcher,
		findHostInstanceByFiber: function (_) {
			return (_ = Zb(_)), _ === null ? null : _.stateNode;
		},
		findFiberByHostInstance: ul.findFiberByHostInstance || kl,
		findHostInstancesForRefresh: null,
		scheduleRefresh: null,
		scheduleRoot: null,
		setRefreshHandler: null,
		getCurrentFiber: null,
		reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
	};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
	var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
	if (!wl.isDisabled && wl.supportsFiber)
		try {
			(kc = wl.inject(vl)), (lc = wl);
		} catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function (_, et) {
	var tt = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
	if (!ol(et)) throw Error(p$3(200));
	return dl(_, et, null, tt);
};
reactDom_production_min.createRoot = function (_, et) {
	if (!ol(_)) throw Error(p$3(299));
	var tt = !1,
		nt = "",
		rt = ll;
	return (
		et != null &&
			(et.unstable_strictMode === !0 && (tt = !0),
			et.identifierPrefix !== void 0 && (nt = et.identifierPrefix),
			et.onRecoverableError !== void 0 && (rt = et.onRecoverableError)),
		(et = cl(_, 1, !1, null, null, tt, !1, nt, rt)),
		(_[uf] = et.current),
		sf(_.nodeType === 8 ? _.parentNode : _),
		new ml(et)
	);
};
reactDom_production_min.findDOMNode = function (_) {
	if (_ == null) return null;
	if (_.nodeType === 1) return _;
	var et = _._reactInternals;
	if (et === void 0)
		throw typeof _.render == "function" ? Error(p$3(188)) : ((_ = Object.keys(_).join(",")), Error(p$3(268, _)));
	return (_ = Zb(et)), (_ = _ === null ? null : _.stateNode), _;
};
reactDom_production_min.flushSync = function (_) {
	return Sk(_);
};
reactDom_production_min.hydrate = function (_, et, tt) {
	if (!pl(et)) throw Error(p$3(200));
	return sl(null, _, et, !0, tt);
};
reactDom_production_min.hydrateRoot = function (_, et, tt) {
	if (!ol(_)) throw Error(p$3(405));
	var nt = (tt != null && tt.hydratedSources) || null,
		rt = !1,
		it = "",
		ot = ll;
	if (
		(tt != null &&
			(tt.unstable_strictMode === !0 && (rt = !0),
			tt.identifierPrefix !== void 0 && (it = tt.identifierPrefix),
			tt.onRecoverableError !== void 0 && (ot = tt.onRecoverableError)),
		(et = fl(et, null, _, 1, tt != null ? tt : null, rt, !1, it, ot)),
		(_[uf] = et.current),
		sf(_),
		nt)
	)
		for (_ = 0; _ < nt.length; _++)
			(tt = nt[_]),
				(rt = tt._getVersion),
				(rt = rt(tt._source)),
				et.mutableSourceEagerHydrationData == null
					? (et.mutableSourceEagerHydrationData = [tt, rt])
					: et.mutableSourceEagerHydrationData.push(tt, rt);
	return new nl(et);
};
reactDom_production_min.render = function (_, et, tt) {
	if (!pl(et)) throw Error(p$3(200));
	return sl(null, _, et, !1, tt);
};
reactDom_production_min.unmountComponentAtNode = function (_) {
	if (!pl(_)) throw Error(p$3(40));
	return _._reactRootContainer
		? (Sk(function () {
				sl(null, null, _, !1, function () {
					(_._reactRootContainer = null), (_[uf] = null);
				});
		  }),
		  !0)
		: !1;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function (_, et, tt, nt) {
	if (!pl(tt)) throw Error(p$3(200));
	if (_ == null || _._reactInternals === void 0) throw Error(p$3(38));
	return sl(_, et, tt, !1, nt);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
(function (_) {
	function et() {
		if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
			try {
				__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(et);
			} catch (tt) {
				console.error(tt);
			}
	}
	et(), (_.exports = reactDom_production_min);
})(reactDom);
var [PortalManagerContextProvider, usePortalManager] = createContext({ strict: !1, name: "PortalManagerContext" });
function PortalManager(_) {
	const { children: et, zIndex: tt } = _;
	return jsx(PortalManagerContextProvider, { value: { zIndex: tt }, children: et });
}
PortalManager.displayName = "PortalManager";
var [PortalContextProvider, usePortalContext] = createContext({ strict: !1, name: "PortalContext" }),
	PORTAL_CLASSNAME = "chakra-portal",
	PORTAL_SELECTOR = ".chakra-portal",
	Container = (_) =>
		jsx("div", {
			className: "chakra-portal-zIndex",
			style: { position: "absolute", zIndex: _.zIndex, top: 0, left: 0, right: 0 },
			children: _.children,
		}),
	DefaultPortal = (_) => {
		const { appendToParentPortal: et, children: tt } = _,
			[nt, rt] = react.exports.useState(null),
			it = react.exports.useRef(null),
			[, ot] = react.exports.useState({});
		react.exports.useEffect(() => ot({}), []);
		const at = usePortalContext(),
			st = usePortalManager();
		useSafeLayoutEffect$2(() => {
			if (!nt) return;
			const ut = nt.ownerDocument,
				dt = et && at != null ? at : ut.body;
			if (!dt) return;
			(it.current = ut.createElement("div")),
				(it.current.className = PORTAL_CLASSNAME),
				dt.appendChild(it.current),
				ot({});
			const ct = it.current;
			return () => {
				dt.contains(ct) && dt.removeChild(ct);
			};
		}, [nt]);
		const lt = st != null && st.zIndex ? jsx(Container, { zIndex: st == null ? void 0 : st.zIndex, children: tt }) : tt;
		return it.current
			? reactDom.exports.createPortal(jsx(PortalContextProvider, { value: it.current, children: lt }), it.current)
			: jsx("span", {
					ref: (ut) => {
						ut && rt(ut);
					},
			  });
	},
	ContainerPortal = (_) => {
		const { children: et, containerRef: tt, appendToParentPortal: nt } = _,
			rt = tt.current,
			it = rt != null ? rt : typeof window < "u" ? document.body : void 0,
			ot = react.exports.useMemo(() => {
				const st = rt == null ? void 0 : rt.ownerDocument.createElement("div");
				return st && (st.className = PORTAL_CLASSNAME), st;
			}, [rt]),
			[, at] = react.exports.useState({});
		return (
			useSafeLayoutEffect$2(() => at({}), []),
			useSafeLayoutEffect$2(() => {
				if (!(!ot || !it))
					return (
						it.appendChild(ot),
						() => {
							it.removeChild(ot);
						}
					);
			}, [ot, it]),
			it && ot
				? reactDom.exports.createPortal(jsx(PortalContextProvider, { value: nt ? ot : null, children: et }), ot)
				: null
		);
	};
function Portal(_) {
	const { containerRef: et, ...tt } = _;
	return et ? jsx(ContainerPortal, { containerRef: et, ...tt }) : jsx(DefaultPortal, { ...tt });
}
Portal.defaultProps = { appendToParentPortal: !0 };
Portal.className = PORTAL_CLASSNAME;
Portal.selector = PORTAL_SELECTOR;
Portal.displayName = "Portal";
var getDefaultParent = function (_) {
		if (typeof document > "u") return null;
		var et = Array.isArray(_) ? _[0] : _;
		return et.ownerDocument.body;
	},
	counterMap = new WeakMap(),
	uncontrolledNodes = new WeakMap(),
	markerMap = {},
	lockCount = 0,
	applyAttributeToOthers = function (_, et, tt, nt) {
		var rt = Array.isArray(_) ? _ : [_];
		markerMap[tt] || (markerMap[tt] = new WeakMap());
		var it = markerMap[tt],
			ot = [],
			at = new Set(),
			st = new Set(rt),
			lt = function (dt) {
				!dt || at.has(dt) || (at.add(dt), lt(dt.parentNode));
			};
		rt.forEach(lt);
		var ut = function (dt) {
			!dt ||
				st.has(dt) ||
				Array.prototype.forEach.call(dt.children, function (ct) {
					if (at.has(ct)) ut(ct);
					else {
						var ft = ct.getAttribute(nt),
							mt = ft !== null && ft !== "false",
							pt = (counterMap.get(ct) || 0) + 1,
							vt = (it.get(ct) || 0) + 1;
						counterMap.set(ct, pt),
							it.set(ct, vt),
							ot.push(ct),
							pt === 1 && mt && uncontrolledNodes.set(ct, !0),
							vt === 1 && ct.setAttribute(tt, "true"),
							mt || ct.setAttribute(nt, "true");
					}
				});
		};
		return (
			ut(et),
			at.clear(),
			lockCount++,
			function () {
				ot.forEach(function (dt) {
					var ct = counterMap.get(dt) - 1,
						ft = it.get(dt) - 1;
					counterMap.set(dt, ct),
						it.set(dt, ft),
						ct || (uncontrolledNodes.has(dt) || dt.removeAttribute(nt), uncontrolledNodes.delete(dt)),
						ft || dt.removeAttribute(tt);
				}),
					lockCount--,
					lockCount ||
						((counterMap = new WeakMap()),
						(counterMap = new WeakMap()),
						(uncontrolledNodes = new WeakMap()),
						(markerMap = {}));
			}
		);
	},
	hideOthers = function (_, et, tt) {
		tt === void 0 && (tt = "data-aria-hidden");
		var nt = Array.from(Array.isArray(_) ? _ : [_]),
			rt = et || getDefaultParent(_);
		return rt
			? (nt.push.apply(nt, Array.from(rt.querySelectorAll("[aria-live]"))),
			  applyAttributeToOthers(nt, rt, tt, "aria-hidden"))
			: function () {
					return null;
			  };
	};
function _objectWithoutPropertiesLoose(_, et) {
	if (_ == null) return {};
	var tt = {},
		nt = Object.keys(_),
		rt,
		it;
	for (it = 0; it < nt.length; it++) (rt = nt[it]), !(et.indexOf(rt) >= 0) && (tt[rt] = _[rt]);
	return tt;
}
var propTypes = { exports: {} },
	ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
	ReactPropTypesSecret_1 = ReactPropTypesSecret$1,
	ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function () {
	function _(nt, rt, it, ot, at, st) {
		if (st !== ReactPropTypesSecret) {
			var lt = new Error(
				"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
			);
			throw ((lt.name = "Invariant Violation"), lt);
		}
	}
	_.isRequired = _;
	function et() {
		return _;
	}
	var tt = {
		array: _,
		bigint: _,
		bool: _,
		func: _,
		number: _,
		object: _,
		string: _,
		symbol: _,
		any: _,
		arrayOf: et,
		element: _,
		elementType: _,
		instanceOf: et,
		node: _,
		objectOf: et,
		oneOf: et,
		oneOfType: et,
		shape: et,
		exact: et,
		checkPropTypes: emptyFunctionWithReset,
		resetWarningCache: emptyFunction,
	};
	return (tt.PropTypes = tt), tt;
};
propTypes.exports = factoryWithThrowingShims();
var FOCUS_GROUP = "data-focus-lock",
	FOCUS_DISABLED = "data-focus-lock-disabled",
	FOCUS_ALLOW = "data-no-focus-lock",
	FOCUS_AUTO = "data-autofocus-inside",
	FOCUS_NO_AUTOFOCUS = "data-no-autofocus";
function assignRef(_, et) {
	return typeof _ == "function" ? _(et) : _ && (_.current = et), _;
}
function useCallbackRef(_, et) {
	var tt = react.exports.useState(function () {
		return {
			value: _,
			callback: et,
			facade: {
				get current() {
					return tt.value;
				},
				set current(nt) {
					var rt = tt.value;
					rt !== nt && ((tt.value = nt), tt.callback(nt, rt));
				},
			},
		};
	})[0];
	return (tt.callback = et), tt.facade;
}
function useMergeRefs(_, et) {
	return useCallbackRef(et || null, function (tt) {
		return _.forEach(function (nt) {
			return assignRef(nt, tt);
		});
	});
}
var hiddenGuard = {
	width: "1px",
	height: "0px",
	padding: 0,
	overflow: "hidden",
	position: "fixed",
	top: "1px",
	left: "1px",
};
function ItoI(_) {
	return _;
}
function innerCreateMedium(_, et) {
	et === void 0 && (et = ItoI);
	var tt = [],
		nt = !1,
		rt = {
			read: function () {
				if (nt)
					throw new Error(
						"Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
					);
				return tt.length ? tt[tt.length - 1] : _;
			},
			useMedium: function (it) {
				var ot = et(it, nt);
				return (
					tt.push(ot),
					function () {
						tt = tt.filter(function (at) {
							return at !== ot;
						});
					}
				);
			},
			assignSyncMedium: function (it) {
				for (nt = !0; tt.length; ) {
					var ot = tt;
					(tt = []), ot.forEach(it);
				}
				tt = {
					push: function (at) {
						return it(at);
					},
					filter: function () {
						return tt;
					},
				};
			},
			assignMedium: function (it) {
				nt = !0;
				var ot = [];
				if (tt.length) {
					var at = tt;
					(tt = []), at.forEach(it), (ot = tt);
				}
				var st = function () {
						var ut = ot;
						(ot = []), ut.forEach(it);
					},
					lt = function () {
						return Promise.resolve().then(st);
					};
				lt(),
					(tt = {
						push: function (ut) {
							ot.push(ut), lt();
						},
						filter: function (ut) {
							return (ot = ot.filter(ut)), tt;
						},
					});
			},
		};
	return rt;
}
function createMedium(_, et) {
	return et === void 0 && (et = ItoI), innerCreateMedium(_, et);
}
function createSidecarMedium(_) {
	_ === void 0 && (_ = {});
	var et = innerCreateMedium(null);
	return (et.options = __assign$4({ async: !0, ssr: !1 }, _)), et;
}
var SideCar$1 = function (_) {
	var et = _.sideCar,
		tt = __rest$2(_, ["sideCar"]);
	if (!et) throw new Error("Sidecar: please provide `sideCar` property to import the right car");
	var nt = et.read();
	if (!nt) throw new Error("Sidecar medium not found");
	return jsx(nt, { ...__assign$4({}, tt) });
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(_, et) {
	return _.useMedium(et), SideCar$1;
}
var mediumFocus = createMedium({}, function (_) {
		var et = _.target,
			tt = _.currentTarget;
		return { target: et, currentTarget: tt };
	}),
	mediumBlur = createMedium(),
	mediumEffect = createMedium(),
	mediumSidecar = createSidecarMedium({ async: !0 }),
	emptyArray = [],
	FocusLock$2 = react.exports.forwardRef(function (et, tt) {
		var nt,
			rt = react.exports.useState(),
			it = rt[0],
			ot = rt[1],
			at = react.exports.useRef(),
			st = react.exports.useRef(!1),
			lt = react.exports.useRef(null),
			ut = et.children,
			dt = et.disabled,
			ct = et.noFocusGuards,
			ft = et.persistentFocus,
			mt = et.crossFrame,
			pt = et.autoFocus;
		et.allowTextSelection;
		var vt = et.group,
			ht = et.className,
			gt = et.whiteList,
			yt = et.hasPositiveIndices,
			xt = et.shards,
			St = xt === void 0 ? emptyArray : xt,
			wt = et.as,
			Ct = wt === void 0 ? "div" : wt,
			Et = et.lockProps,
			_t = Et === void 0 ? {} : Et,
			$t = et.sideCar,
			At = et.returnFocus,
			Lt = et.focusOptions,
			Nt = et.onActivation,
			Ft = et.onDeactivation,
			Gt = react.exports.useState({}),
			Bt = Gt[0],
			jt = react.exports.useCallback(
				function () {
					(lt.current = lt.current || (document && document.activeElement)),
						at.current && Nt && Nt(at.current),
						(st.current = !0);
				},
				[Nt]
			),
			It = react.exports.useCallback(
				function () {
					(st.current = !1), Ft && Ft(at.current);
				},
				[Ft]
			);
		react.exports.useEffect(function () {
			dt || (lt.current = null);
		}, []);
		var Dt = react.exports.useCallback(
				function (qt) {
					var Wt = lt.current;
					if (Wt && Wt.focus) {
						var Xt = typeof At == "function" ? At(Wt) : At;
						if (Xt) {
							var Zt = typeof Xt == "object" ? Xt : void 0;
							(lt.current = null),
								qt
									? Promise.resolve().then(function () {
											return Wt.focus(Zt);
									  })
									: Wt.focus(Zt);
						}
					}
				},
				[At]
			),
			Rt = react.exports.useCallback(function (qt) {
				st.current && mediumFocus.useMedium(qt);
			}, []),
			bt = mediumBlur.useMedium,
			kt = react.exports.useCallback(function (qt) {
				at.current !== qt && ((at.current = qt), ot(qt));
			}, []),
			zt = _extends$1(((nt = {}), (nt[FOCUS_DISABLED] = dt && "disabled"), (nt[FOCUS_GROUP] = vt), nt), _t),
			Vt = ct !== !0,
			Yt = Vt && ct !== "tail",
			Ut = useMergeRefs([tt, kt]);
		return jsxs(Fragment, {
			children: [
				Vt && [
					jsx("div", { "data-focus-guard": !0, tabIndex: dt ? -1 : 0, style: hiddenGuard }, "guard-first"),
					yt
						? jsx("div", { "data-focus-guard": !0, tabIndex: dt ? -1 : 1, style: hiddenGuard }, "guard-nearest")
						: null,
				],
				!dt &&
					jsx($t, {
						id: Bt,
						sideCar: mediumSidecar,
						observed: it,
						disabled: dt,
						persistentFocus: ft,
						crossFrame: mt,
						autoFocus: pt,
						whiteList: gt,
						shards: St,
						onActivation: jt,
						onDeactivation: It,
						returnFocus: Dt,
						focusOptions: Lt,
					}),
				jsx(Ct, { ref: Ut, ...zt, className: ht, onBlur: bt, onFocus: Rt, children: ut }),
				Yt && jsx("div", { "data-focus-guard": !0, tabIndex: dt ? -1 : 0, style: hiddenGuard }),
			],
		});
	});
FocusLock$2.propTypes = {};
FocusLock$2.defaultProps = {
	children: void 0,
	disabled: !1,
	returnFocus: !1,
	focusOptions: void 0,
	noFocusGuards: !1,
	autoFocus: !0,
	persistentFocus: !1,
	crossFrame: !0,
	hasPositiveIndices: void 0,
	allowTextSelection: void 0,
	group: void 0,
	className: void 0,
	whiteList: void 0,
	shards: void 0,
	as: "div",
	lockProps: {},
	onActivation: void 0,
	onDeactivation: void 0,
};
const FocusLockUI = FocusLock$2;
function _setPrototypeOf(_, et) {
	return (
		(_setPrototypeOf = Object.setPrototypeOf
			? Object.setPrototypeOf.bind()
			: function (nt, rt) {
					return (nt.__proto__ = rt), nt;
			  }),
		_setPrototypeOf(_, et)
	);
}
function _inheritsLoose(_, et) {
	(_.prototype = Object.create(et.prototype)), (_.prototype.constructor = _), _setPrototypeOf(_, et);
}
function _defineProperty$2(_, et, tt) {
	return (
		et in _
			? Object.defineProperty(_, et, { value: tt, enumerable: !0, configurable: !0, writable: !0 })
			: (_[et] = tt),
		_
	);
}
function withSideEffect(_, et) {
	function tt(nt) {
		return nt.displayName || nt.name || "Component";
	}
	return function (rt) {
		var it = [],
			ot;
		function at() {
			(ot = _(
				it.map(function (lt) {
					return lt.props;
				})
			)),
				et(ot);
		}
		var st = (function (lt) {
			_inheritsLoose(ut, lt);
			function ut() {
				return lt.apply(this, arguments) || this;
			}
			ut.peek = function () {
				return ot;
			};
			var dt = ut.prototype;
			return (
				(dt.componentDidMount = function () {
					it.push(this), at();
				}),
				(dt.componentDidUpdate = function () {
					at();
				}),
				(dt.componentWillUnmount = function () {
					var ft = it.indexOf(this);
					it.splice(ft, 1), at();
				}),
				(dt.render = function () {
					return jsx(rt, { ...this.props });
				}),
				ut
			);
		})(react.exports.PureComponent);
		return _defineProperty$2(st, "displayName", "SideEffect(" + tt(rt) + ")"), st;
	};
}
var toArray$1 = function (_) {
		for (var et = Array(_.length), tt = 0; tt < _.length; ++tt) et[tt] = _[tt];
		return et;
	},
	asArray = function (_) {
		return Array.isArray(_) ? _ : [_];
	},
	isElementHidden = function (_) {
		if (_.nodeType !== Node.ELEMENT_NODE) return !1;
		var et = window.getComputedStyle(_, null);
		return !et || !et.getPropertyValue
			? !1
			: et.getPropertyValue("display") === "none" || et.getPropertyValue("visibility") === "hidden";
	},
	getParentNode = function (_) {
		return _.parentNode && _.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? _.parentNode.host : _.parentNode;
	},
	isTopNode = function (_) {
		return _ === document || (_ && _.nodeType === Node.DOCUMENT_NODE);
	},
	isVisibleUncached = function (_, et) {
		return !_ || isTopNode(_) || (!isElementHidden(_) && et(getParentNode(_)));
	},
	isVisibleCached = function (_, et) {
		var tt = _.get(et);
		if (tt !== void 0) return tt;
		var nt = isVisibleUncached(et, isVisibleCached.bind(void 0, _));
		return _.set(et, nt), nt;
	},
	isAutoFocusAllowedUncached = function (_, et) {
		return _ && !isTopNode(_) ? (isAutoFocusAllowed(_) ? et(getParentNode(_)) : !1) : !0;
	},
	isAutoFocusAllowedCached = function (_, et) {
		var tt = _.get(et);
		if (tt !== void 0) return tt;
		var nt = isAutoFocusAllowedUncached(et, isAutoFocusAllowedCached.bind(void 0, _));
		return _.set(et, nt), nt;
	},
	getDataset = function (_) {
		return _.dataset;
	},
	isHTMLButtonElement = function (_) {
		return _.tagName === "BUTTON";
	},
	isHTMLInputElement = function (_) {
		return _.tagName === "INPUT";
	},
	isRadioElement = function (_) {
		return isHTMLInputElement(_) && _.type === "radio";
	},
	notHiddenInput = function (_) {
		return !((isHTMLInputElement(_) || isHTMLButtonElement(_)) && (_.type === "hidden" || _.disabled));
	},
	isAutoFocusAllowed = function (_) {
		var et = _.getAttribute(FOCUS_NO_AUTOFOCUS);
		return ![!0, "true", ""].includes(et);
	},
	isGuard = function (_) {
		var et;
		return Boolean(_ && ((et = getDataset(_)) === null || et === void 0 ? void 0 : et.focusGuard));
	},
	isNotAGuard = function (_) {
		return !isGuard(_);
	},
	isDefined = function (_) {
		return Boolean(_);
	},
	tabSort = function (_, et) {
		var tt = _.tabIndex - et.tabIndex,
			nt = _.index - et.index;
		if (tt) {
			if (!_.tabIndex) return 1;
			if (!et.tabIndex) return -1;
		}
		return tt || nt;
	},
	orderByTabIndex = function (_, et, tt) {
		return toArray$1(_)
			.map(function (nt, rt) {
				return {
					node: nt,
					index: rt,
					tabIndex: tt && nt.tabIndex === -1 ? ((nt.dataset || {}).focusGuard ? 0 : -1) : nt.tabIndex,
				};
			})
			.filter(function (nt) {
				return !et || nt.tabIndex >= 0;
			})
			.sort(tabSort);
	},
	tabbables = [
		"button:enabled",
		"select:enabled",
		"textarea:enabled",
		"input:enabled",
		"a[href]",
		"area[href]",
		"summary",
		"iframe",
		"object",
		"embed",
		"audio[controls]",
		"video[controls]",
		"[tabindex]",
		"[contenteditable]",
		"[autofocus]",
	],
	queryTabbables = tabbables.join(","),
	queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]"),
	getFocusablesWithShadowDom = function (_, et) {
		var tt;
		return toArray$1(((tt = _.shadowRoot) === null || tt === void 0 ? void 0 : tt.children) || _.children).reduce(
			function (nt, rt) {
				return nt.concat(
					rt.matches(et ? queryGuardTabbables : queryTabbables) ? [rt] : [],
					getFocusablesWithShadowDom(rt)
				);
			},
			[]
		);
	},
	getFocusables = function (_, et) {
		return _.reduce(function (tt, nt) {
			return tt.concat(
				getFocusablesWithShadowDom(nt, et),
				nt.parentNode
					? toArray$1(nt.parentNode.querySelectorAll(queryTabbables)).filter(function (rt) {
							return rt === nt;
					  })
					: []
			);
		}, []);
	},
	getParentAutofocusables = function (_) {
		var et = _.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
		return toArray$1(et)
			.map(function (tt) {
				return getFocusables([tt]);
			})
			.reduce(function (tt, nt) {
				return tt.concat(nt);
			}, []);
	},
	filterFocusable = function (_, et) {
		return toArray$1(_)
			.filter(function (tt) {
				return isVisibleCached(et, tt);
			})
			.filter(function (tt) {
				return notHiddenInput(tt);
			});
	},
	filterAutoFocusable = function (_, et) {
		return (
			et === void 0 && (et = new Map()),
			toArray$1(_).filter(function (tt) {
				return isAutoFocusAllowedCached(et, tt);
			})
		);
	},
	getTabbableNodes = function (_, et, tt) {
		return orderByTabIndex(filterFocusable(getFocusables(_, tt), et), !0, tt);
	},
	getAllTabbableNodes = function (_, et) {
		return orderByTabIndex(filterFocusable(getFocusables(_), et), !1);
	},
	parentAutofocusables = function (_, et) {
		return filterFocusable(getParentAutofocusables(_), et);
	},
	contains$1 = function (_, et) {
		return (
			(_.shadowRoot ? contains$1(_.shadowRoot, et) : Object.getPrototypeOf(_).contains.call(_, et)) ||
			toArray$1(_.children).some(function (tt) {
				return contains$1(tt, et);
			})
		);
	},
	filterNested = function (_) {
		for (var et = new Set(), tt = _.length, nt = 0; nt < tt; nt += 1)
			for (var rt = nt + 1; rt < tt; rt += 1) {
				var it = _[nt].compareDocumentPosition(_[rt]);
				(it & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0 && et.add(rt),
					(it & Node.DOCUMENT_POSITION_CONTAINS) > 0 && et.add(nt);
			}
		return _.filter(function (ot, at) {
			return !et.has(at);
		});
	},
	getTopParent = function (_) {
		return _.parentNode ? getTopParent(_.parentNode) : _;
	},
	getAllAffectedNodes = function (_) {
		var et = asArray(_);
		return et.filter(Boolean).reduce(function (tt, nt) {
			var rt = nt.getAttribute(FOCUS_GROUP);
			return (
				tt.push.apply(
					tt,
					rt
						? filterNested(
								toArray$1(
									getTopParent(nt).querySelectorAll(
										"[".concat(FOCUS_GROUP, '="').concat(rt, '"]:not([').concat(FOCUS_DISABLED, '="disabled"])')
									)
								)
						  )
						: [nt]
				),
				tt
			);
		}, []);
	},
	getNestedShadowActiveElement = function (_) {
		return _.activeElement
			? _.activeElement.shadowRoot
				? getNestedShadowActiveElement(_.activeElement.shadowRoot)
				: _.activeElement
			: void 0;
	},
	getActiveElement = function () {
		return document.activeElement
			? document.activeElement.shadowRoot
				? getNestedShadowActiveElement(document.activeElement.shadowRoot)
				: document.activeElement
			: void 0;
	},
	focusInFrame = function (_) {
		return _ === document.activeElement;
	},
	focusInsideIframe = function (_) {
		return Boolean(
			toArray$1(_.querySelectorAll("iframe")).some(function (et) {
				return focusInFrame(et);
			})
		);
	},
	focusInside = function (_) {
		var et = document && getActiveElement();
		return !et || (et.dataset && et.dataset.focusGuard)
			? !1
			: getAllAffectedNodes(_).some(function (tt) {
					return contains$1(tt, et) || focusInsideIframe(tt);
			  });
	},
	focusIsHidden = function () {
		var _ = document && getActiveElement();
		return _
			? toArray$1(document.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function (et) {
					return contains$1(et, _);
			  })
			: !1;
	},
	findSelectedRadio = function (_, et) {
		return (
			et
				.filter(isRadioElement)
				.filter(function (tt) {
					return tt.name === _.name;
				})
				.filter(function (tt) {
					return tt.checked;
				})[0] || _
		);
	},
	correctNode = function (_, et) {
		return isRadioElement(_) && _.name ? findSelectedRadio(_, et) : _;
	},
	correctNodes = function (_) {
		var et = new Set();
		return (
			_.forEach(function (tt) {
				return et.add(correctNode(tt, _));
			}),
			_.filter(function (tt) {
				return et.has(tt);
			})
		);
	},
	pickFirstFocus = function (_) {
		return _[0] && _.length > 1 ? correctNode(_[0], _) : _[0];
	},
	pickFocusable = function (_, et) {
		return _.length > 1 ? _.indexOf(correctNode(_[et], _)) : et;
	},
	NEW_FOCUS = "NEW_FOCUS",
	newFocus = function (_, et, tt, nt) {
		var rt = _.length,
			it = _[0],
			ot = _[rt - 1],
			at = isGuard(tt);
		if (!(tt && _.indexOf(tt) >= 0)) {
			var st = tt !== void 0 ? et.indexOf(tt) : -1,
				lt = nt ? et.indexOf(nt) : st,
				ut = nt ? _.indexOf(nt) : -1,
				dt = st - lt,
				ct = et.indexOf(it),
				ft = et.indexOf(ot),
				mt = correctNodes(et),
				pt = tt !== void 0 ? mt.indexOf(tt) : -1,
				vt = pt - (nt ? mt.indexOf(nt) : st),
				ht = pickFocusable(_, 0),
				gt = pickFocusable(_, rt - 1);
			if (st === -1 || ut === -1) return NEW_FOCUS;
			if (!dt && ut >= 0) return ut;
			if (st <= ct && at && Math.abs(dt) > 1) return gt;
			if (st >= ft && at && Math.abs(dt) > 1) return ht;
			if (dt && Math.abs(vt) > 1) return ut;
			if (st <= ct) return gt;
			if (st > ft) return ht;
			if (dt) return Math.abs(dt) > 1 ? ut : (rt + ut + dt) % rt;
		}
	},
	getParents = function (_, et) {
		return (
			et === void 0 && (et = []), et.push(_), _.parentNode && getParents(_.parentNode.host || _.parentNode, et), et
		);
	},
	getCommonParent = function (_, et) {
		for (var tt = getParents(_), nt = getParents(et), rt = 0; rt < tt.length; rt += 1) {
			var it = tt[rt];
			if (nt.indexOf(it) >= 0) return it;
		}
		return !1;
	},
	getTopCommonParent = function (_, et, tt) {
		var nt = asArray(_),
			rt = asArray(et),
			it = nt[0],
			ot = !1;
		return (
			rt.filter(Boolean).forEach(function (at) {
				(ot = getCommonParent(ot || at, at) || ot),
					tt.filter(Boolean).forEach(function (st) {
						var lt = getCommonParent(it, st);
						lt && (!ot || contains$1(lt, ot) ? (ot = lt) : (ot = getCommonParent(lt, ot)));
					});
			}),
			ot
		);
	},
	allParentAutofocusables = function (_, et) {
		return _.reduce(function (tt, nt) {
			return tt.concat(parentAutofocusables(nt, et));
		}, []);
	},
	findAutoFocused = function (_) {
		return function (et) {
			var tt;
			return (
				et.autofocus || !!(!((tt = getDataset(et)) === null || tt === void 0) && tt.autofocus) || _.indexOf(et) >= 0
			);
		};
	},
	reorderNodes = function (_, et) {
		var tt = new Map();
		return (
			et.forEach(function (nt) {
				return tt.set(nt.node, nt);
			}),
			_.map(function (nt) {
				return tt.get(nt);
			}).filter(isDefined)
		);
	},
	getFocusMerge = function (_, et) {
		var tt = document && getActiveElement(),
			nt = getAllAffectedNodes(_).filter(isNotAGuard),
			rt = getTopCommonParent(tt || _, _, nt),
			it = new Map(),
			ot = getAllTabbableNodes(nt, it),
			at = getTabbableNodes(nt, it).filter(function (ft) {
				var mt = ft.node;
				return isNotAGuard(mt);
			});
		if (!(!at[0] && ((at = ot), !at[0]))) {
			var st = getAllTabbableNodes([rt], it).map(function (ft) {
					var mt = ft.node;
					return mt;
				}),
				lt = reorderNodes(st, at),
				ut = lt.map(function (ft) {
					var mt = ft.node;
					return mt;
				}),
				dt = newFocus(ut, st, tt, et);
			if (dt === NEW_FOCUS) {
				var ct = filterAutoFocusable(
					ot.map(function (ft) {
						var mt = ft.node;
						return mt;
					})
				).filter(findAutoFocused(allParentAutofocusables(nt, it)));
				return { node: ct && ct.length ? pickFirstFocus(ct) : pickFirstFocus(filterAutoFocusable(ut)) };
			}
			return dt === void 0 ? dt : lt[dt];
		}
	},
	getFocusabledIn = function (_) {
		var et = getAllAffectedNodes(_).filter(isNotAGuard),
			tt = getTopCommonParent(_, _, et),
			nt = new Map(),
			rt = getTabbableNodes([tt], nt, !0),
			it = getTabbableNodes(et, nt)
				.filter(function (ot) {
					var at = ot.node;
					return isNotAGuard(at);
				})
				.map(function (ot) {
					var at = ot.node;
					return at;
				});
		return rt.map(function (ot) {
			var at = ot.node,
				st = ot.index;
			return { node: at, index: st, lockItem: it.indexOf(at) >= 0, guard: isGuard(at) };
		});
	},
	focusOn = function (_, et) {
		"focus" in _ && _.focus(et), "contentWindow" in _ && _.contentWindow && _.contentWindow.focus();
	},
	guardCount = 0,
	lockDisabled = !1,
	setFocus$1 = function (_, et, tt) {
		tt === void 0 && (tt = {});
		var nt = getFocusMerge(_, et);
		if (!lockDisabled && nt) {
			if (guardCount > 2) {
				console.error(
					"FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting"
				),
					(lockDisabled = !0),
					setTimeout(function () {
						lockDisabled = !1;
					}, 1);
				return;
			}
			guardCount++, focusOn(nt.node, tt.focusOptions), guardCount--;
		}
	};
const moveFocusInside = setFocus$1;
function deferAction(_) {
	var et = window,
		tt = et.setImmediate;
	typeof tt < "u" ? tt(_) : setTimeout(_, 1);
}
var focusOnBody = function () {
		return document && document.activeElement === document.body;
	},
	isFreeFocus = function () {
		return focusOnBody() || focusIsHidden();
	},
	lastActiveTrap = null,
	lastActiveFocus = null,
	lastPortaledElement = null,
	focusWasOutsideWindow = !1,
	defaultWhitelist = function () {
		return !0;
	},
	focusWhitelisted = function (et) {
		return (lastActiveTrap.whiteList || defaultWhitelist)(et);
	},
	recordPortal = function (et, tt) {
		lastPortaledElement = { observerNode: et, portaledElement: tt };
	},
	focusIsPortaledPair = function (et) {
		return lastPortaledElement && lastPortaledElement.portaledElement === et;
	};
function autoGuard(_, et, tt, nt) {
	var rt = null,
		it = _;
	do {
		var ot = nt[it];
		if (ot.guard) ot.node.dataset.focusAutoGuard && (rt = ot);
		else if (ot.lockItem) {
			if (it !== _) return;
			rt = null;
		} else break;
	} while ((it += tt) !== et);
	rt && (rt.node.tabIndex = 0);
}
var extractRef$1 = function (et) {
		return et && "current" in et ? et.current : et;
	},
	focusWasOutside = function (et) {
		return et ? Boolean(focusWasOutsideWindow) : focusWasOutsideWindow === "meanwhile";
	},
	checkInHost = function _(et, tt, nt) {
		return (
			tt &&
			((tt.host === et && (!tt.activeElement || nt.contains(tt.activeElement))) ||
				(tt.parentNode && _(et, tt.parentNode, nt)))
		);
	},
	withinHost = function (et, tt) {
		return tt.some(function (nt) {
			return checkInHost(et, nt, nt);
		});
	},
	activateTrap = function () {
		var et = !1;
		if (lastActiveTrap) {
			var tt = lastActiveTrap,
				nt = tt.observed,
				rt = tt.persistentFocus,
				it = tt.autoFocus,
				ot = tt.shards,
				at = tt.crossFrame,
				st = tt.focusOptions,
				lt = nt || (lastPortaledElement && lastPortaledElement.portaledElement),
				ut = document && document.activeElement;
			if (lt) {
				var dt = [lt].concat(ot.map(extractRef$1).filter(Boolean));
				if (
					((!ut || focusWhitelisted(ut)) &&
						(rt || focusWasOutside(at) || !isFreeFocus() || (!lastActiveFocus && it)) &&
						(lt &&
							!(focusInside(dt) || (ut && withinHost(ut, dt)) || focusIsPortaledPair(ut)) &&
							(document && !lastActiveFocus && ut && !it
								? (ut.blur && ut.blur(), document.body.focus())
								: ((et = moveFocusInside(dt, lastActiveFocus, { focusOptions: st })), (lastPortaledElement = {}))),
						(focusWasOutsideWindow = !1),
						(lastActiveFocus = document && document.activeElement)),
					document)
				) {
					var ct = document && document.activeElement,
						ft = getFocusabledIn(dt),
						mt = ft
							.map(function (pt) {
								var vt = pt.node;
								return vt;
							})
							.indexOf(ct);
					mt > -1 &&
						(ft
							.filter(function (pt) {
								var vt = pt.guard,
									ht = pt.node;
								return vt && ht.dataset.focusAutoGuard;
							})
							.forEach(function (pt) {
								var vt = pt.node;
								return vt.removeAttribute("tabIndex");
							}),
						autoGuard(mt, ft.length, 1, ft),
						autoGuard(mt, -1, -1, ft));
				}
			}
		}
		return et;
	},
	onTrap = function (et) {
		activateTrap() && et && (et.stopPropagation(), et.preventDefault());
	},
	onBlur = function () {
		return deferAction(activateTrap);
	},
	onFocus = function (et) {
		var tt = et.target,
			nt = et.currentTarget;
		nt.contains(tt) || recordPortal(nt, tt);
	},
	FocusWatcher = function () {
		return null;
	},
	onWindowBlur = function () {
		(focusWasOutsideWindow = "just"),
			setTimeout(function () {
				focusWasOutsideWindow = "meanwhile";
			}, 0);
	},
	attachHandler = function () {
		document.addEventListener("focusin", onTrap),
			document.addEventListener("focusout", onBlur),
			window.addEventListener("blur", onWindowBlur);
	},
	detachHandler = function () {
		document.removeEventListener("focusin", onTrap),
			document.removeEventListener("focusout", onBlur),
			window.removeEventListener("blur", onWindowBlur);
	};
function reducePropsToState(_) {
	return _.filter(function (et) {
		var tt = et.disabled;
		return !tt;
	});
}
function handleStateChangeOnClient(_) {
	var et = _.slice(-1)[0];
	et && !lastActiveTrap && attachHandler();
	var tt = lastActiveTrap,
		nt = tt && et && et.id === tt.id;
	(lastActiveTrap = et),
		tt &&
			!nt &&
			(tt.onDeactivation(),
			_.filter(function (rt) {
				var it = rt.id;
				return it === tt.id;
			}).length || tt.returnFocus(!et)),
		et
			? ((lastActiveFocus = null),
			  (!nt || tt.observed !== et.observed) && et.onActivation(),
			  activateTrap(),
			  deferAction(activateTrap))
			: (detachHandler(), (lastActiveFocus = null));
}
mediumFocus.assignSyncMedium(onFocus);
mediumBlur.assignMedium(onBlur);
mediumEffect.assignMedium(function (_) {
	return _({ moveFocusInside, focusInside });
});
const FocusTrap = withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);
var FocusLockCombination = react.exports.forwardRef(function (et, tt) {
		return jsx(FocusLockUI, { sideCar: FocusTrap, ref: tt, ...et });
	}),
	_ref = FocusLockUI.propTypes || {};
_ref.sideCar;
_objectWithoutPropertiesLoose(_ref, ["sideCar"]);
FocusLockCombination.propTypes = {};
const FocusLock$1 = FocusLockCombination;
var FocusLock = (_) => {
	const {
			initialFocusRef: et,
			finalFocusRef: tt,
			contentRef: nt,
			restoreFocus: rt,
			children: it,
			isDisabled: ot,
			autoFocus: at,
			persistentFocus: st,
			lockFocusAcrossFrames: lt,
		} = _,
		ut = react.exports.useCallback(() => {
			et != null && et.current
				? et.current.focus()
				: nt != null &&
				  nt.current &&
				  getAllFocusable(nt.current).length === 0 &&
				  requestAnimationFrame(() => {
						var mt;
						(mt = nt.current) == null || mt.focus();
				  });
		}, [et, nt]),
		dt = react.exports.useCallback(() => {
			var ft;
			(ft = tt == null ? void 0 : tt.current) == null || ft.focus();
		}, [tt]);
	return jsx(FocusLock$1, {
		crossFrame: lt,
		persistentFocus: st,
		autoFocus: at,
		disabled: ot,
		onActivation: ut,
		onDeactivation: dt,
		returnFocus: rt && !tt,
		children: it,
	});
};
FocusLock.displayName = "FocusLock";
var zeroRightClassName = "right-scroll-bar-position",
	fullWidthClassName = "width-before-scroll-bar",
	noScrollbarsClassName = "with-scroll-bars-hidden",
	removedBarSizeVariable = "--removed-body-scroll-bar-size",
	effectCar = createSidecarMedium(),
	nothing = function () {},
	RemoveScroll$1 = react.exports.forwardRef(function (_, et) {
		var tt = react.exports.useRef(null),
			nt = react.exports.useState({ onScrollCapture: nothing, onWheelCapture: nothing, onTouchMoveCapture: nothing }),
			rt = nt[0],
			it = nt[1],
			ot = _.forwardProps,
			at = _.children,
			st = _.className,
			lt = _.removeScrollBar,
			ut = _.enabled,
			dt = _.shards,
			ct = _.sideCar,
			ft = _.noIsolation,
			mt = _.inert,
			pt = _.allowPinchZoom,
			vt = _.as,
			ht = vt === void 0 ? "div" : vt,
			gt = __rest$2(_, [
				"forwardProps",
				"children",
				"className",
				"removeScrollBar",
				"enabled",
				"shards",
				"sideCar",
				"noIsolation",
				"inert",
				"allowPinchZoom",
				"as",
			]),
			yt = ct,
			xt = useMergeRefs([tt, et]),
			St = __assign$4(__assign$4({}, gt), rt);
		return jsxs(Fragment, {
			children: [
				ut &&
					jsx(yt, {
						sideCar: effectCar,
						removeScrollBar: lt,
						shards: dt,
						noIsolation: ft,
						inert: mt,
						setCallbacks: it,
						allowPinchZoom: !!pt,
						lockRef: tt,
					}),
				ot
					? react.exports.cloneElement(react.exports.Children.only(at), __assign$4(__assign$4({}, St), { ref: xt }))
					: jsx(ht, { ...__assign$4({}, St, { className: st, ref: xt }), children: at }),
			],
		});
	});
RemoveScroll$1.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
RemoveScroll$1.classNames = { fullWidth: fullWidthClassName, zeroRight: zeroRightClassName };
var getNonce = function () {
	if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
};
function makeStyleTag() {
	if (!document) return null;
	var _ = document.createElement("style");
	_.type = "text/css";
	var et = getNonce();
	return et && _.setAttribute("nonce", et), _;
}
function injectStyles(_, et) {
	_.styleSheet ? (_.styleSheet.cssText = et) : _.appendChild(document.createTextNode(et));
}
function insertStyleTag(_) {
	var et = document.head || document.getElementsByTagName("head")[0];
	et.appendChild(_);
}
var stylesheetSingleton = function () {
		var _ = 0,
			et = null;
		return {
			add: function (tt) {
				_ == 0 && (et = makeStyleTag()) && (injectStyles(et, tt), insertStyleTag(et)), _++;
			},
			remove: function () {
				_--, !_ && et && (et.parentNode && et.parentNode.removeChild(et), (et = null));
			},
		};
	},
	styleHookSingleton = function () {
		var _ = stylesheetSingleton();
		return function (et, tt) {
			react.exports.useEffect(
				function () {
					return (
						_.add(et),
						function () {
							_.remove();
						}
					);
				},
				[et && tt]
			);
		};
	},
	styleSingleton = function () {
		var _ = styleHookSingleton(),
			et = function (tt) {
				var nt = tt.styles,
					rt = tt.dynamic;
				return _(nt, rt), null;
			};
		return et;
	},
	zeroGap = { left: 0, top: 0, right: 0, gap: 0 },
	parse$2 = function (_) {
		return parseInt(_ || "", 10) || 0;
	},
	getOffset = function (_) {
		var et = window.getComputedStyle(document.body),
			tt = et[_ === "padding" ? "paddingLeft" : "marginLeft"],
			nt = et[_ === "padding" ? "paddingTop" : "marginTop"],
			rt = et[_ === "padding" ? "paddingRight" : "marginRight"];
		return [parse$2(tt), parse$2(nt), parse$2(rt)];
	},
	getGapWidth = function (_) {
		if ((_ === void 0 && (_ = "margin"), typeof window > "u")) return zeroGap;
		var et = getOffset(_),
			tt = document.documentElement.clientWidth,
			nt = window.innerWidth;
		return { left: et[0], top: et[1], right: et[2], gap: Math.max(0, nt - tt + et[2] - et[0]) };
	},
	Style = styleSingleton(),
	getStyles = function (_, et, tt, nt) {
		var rt = _.left,
			it = _.top,
			ot = _.right,
			at = _.gap;
		return (
			tt === void 0 && (tt = "margin"),
			`
  .`
				.concat(
					noScrollbarsClassName,
					` {
   overflow: hidden `
				)
				.concat(
					nt,
					`;
   padding-right: `
				)
				.concat(at, "px ")
				.concat(
					nt,
					`;
  }
  body {
    overflow: hidden `
				)
				.concat(
					nt,
					`;
    overscroll-behavior: contain;
    `
				)
				.concat(
					[
						et && "position: relative ".concat(nt, ";"),
						tt === "margin" &&
							`
    padding-left: `
								.concat(
									rt,
									`px;
    padding-top: `
								)
								.concat(
									it,
									`px;
    padding-right: `
								)
								.concat(
									ot,
									`px;
    margin-left:0;
    margin-top:0;
    margin-right: `
								)
								.concat(at, "px ")
								.concat(
									nt,
									`;
    `
								),
						tt === "padding" && "padding-right: ".concat(at, "px ").concat(nt, ";"),
					]
						.filter(Boolean)
						.join(""),
					`
  }
  
  .`
				)
				.concat(
					zeroRightClassName,
					` {
    right: `
				)
				.concat(at, "px ")
				.concat(
					nt,
					`;
  }
  
  .`
				)
				.concat(
					fullWidthClassName,
					` {
    margin-right: `
				)
				.concat(at, "px ")
				.concat(
					nt,
					`;
  }
  
  .`
				)
				.concat(zeroRightClassName, " .")
				.concat(
					zeroRightClassName,
					` {
    right: 0 `
				)
				.concat(
					nt,
					`;
  }
  
  .`
				)
				.concat(fullWidthClassName, " .")
				.concat(
					fullWidthClassName,
					` {
    margin-right: 0 `
				)
				.concat(
					nt,
					`;
  }
  
  body {
    `
				)
				.concat(removedBarSizeVariable, ": ")
				.concat(
					at,
					`px;
  }
`
				)
		);
	},
	RemoveScrollBar = function (_) {
		var et = _.noRelative,
			tt = _.noImportant,
			nt = _.gapMode,
			rt = nt === void 0 ? "margin" : nt,
			it = react.exports.useMemo(
				function () {
					return getGapWidth(rt);
				},
				[rt]
			);
		return jsx(Style, { styles: getStyles(it, !et, rt, tt ? "" : "!important") });
	},
	passiveSupported = !1;
if (typeof window < "u")
	try {
		var options = Object.defineProperty({}, "passive", {
			get: function () {
				return (passiveSupported = !0), !0;
			},
		});
		window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
	} catch {
		passiveSupported = !1;
	}
var nonPassive = passiveSupported ? { passive: !1 } : !1,
	alwaysContainsScroll = function (_) {
		return _.tagName === "TEXTAREA";
	},
	elementCanBeScrolled = function (_, et) {
		var tt = window.getComputedStyle(_);
		return tt[et] !== "hidden" && !(tt.overflowY === tt.overflowX && !alwaysContainsScroll(_) && tt[et] === "visible");
	},
	elementCouldBeVScrolled = function (_) {
		return elementCanBeScrolled(_, "overflowY");
	},
	elementCouldBeHScrolled = function (_) {
		return elementCanBeScrolled(_, "overflowX");
	},
	locationCouldBeScrolled = function (_, et) {
		var tt = et;
		do {
			typeof ShadowRoot < "u" && tt instanceof ShadowRoot && (tt = tt.host);
			var nt = elementCouldBeScrolled(_, tt);
			if (nt) {
				var rt = getScrollVariables(_, tt),
					it = rt[1],
					ot = rt[2];
				if (it > ot) return !0;
			}
			tt = tt.parentNode;
		} while (tt && tt !== document.body);
		return !1;
	},
	getVScrollVariables = function (_) {
		var et = _.scrollTop,
			tt = _.scrollHeight,
			nt = _.clientHeight;
		return [et, tt, nt];
	},
	getHScrollVariables = function (_) {
		var et = _.scrollLeft,
			tt = _.scrollWidth,
			nt = _.clientWidth;
		return [et, tt, nt];
	},
	elementCouldBeScrolled = function (_, et) {
		return _ === "v" ? elementCouldBeVScrolled(et) : elementCouldBeHScrolled(et);
	},
	getScrollVariables = function (_, et) {
		return _ === "v" ? getVScrollVariables(et) : getHScrollVariables(et);
	},
	getDirectionFactor = function (_, et) {
		return _ === "h" && et === "rtl" ? -1 : 1;
	},
	handleScroll = function (_, et, tt, nt, rt) {
		var it = getDirectionFactor(_, window.getComputedStyle(et).direction),
			ot = it * nt,
			at = tt.target,
			st = et.contains(at),
			lt = !1,
			ut = ot > 0,
			dt = 0,
			ct = 0;
		do {
			var ft = getScrollVariables(_, at),
				mt = ft[0],
				pt = ft[1],
				vt = ft[2],
				ht = pt - vt - it * mt;
			(mt || ht) && elementCouldBeScrolled(_, at) && ((dt += ht), (ct += mt)), (at = at.parentNode);
		} while ((!st && at !== document.body) || (st && (et.contains(at) || et === at)));
		return (
			((ut && ((rt && dt === 0) || (!rt && ot > dt))) || (!ut && ((rt && ct === 0) || (!rt && -ot > ct)))) && (lt = !0),
			lt
		);
	},
	getTouchXY = function (_) {
		return "changedTouches" in _ ? [_.changedTouches[0].clientX, _.changedTouches[0].clientY] : [0, 0];
	},
	getDeltaXY = function (_) {
		return [_.deltaX, _.deltaY];
	},
	extractRef = function (_) {
		return _ && "current" in _ ? _.current : _;
	},
	deltaCompare = function (_, et) {
		return _[0] === et[0] && _[1] === et[1];
	},
	generateStyle = function (_) {
		return `
  .block-interactivity-`
			.concat(
				_,
				` {pointer-events: none;}
  .allow-interactivity-`
			)
			.concat(
				_,
				` {pointer-events: all;}
`
			);
	},
	idCounter = 0,
	lockStack = [];
function RemoveScrollSideCar(_) {
	var et = react.exports.useRef([]),
		tt = react.exports.useRef([0, 0]),
		nt = react.exports.useRef(),
		rt = react.exports.useState(idCounter++)[0],
		it = react.exports.useState(function () {
			return styleSingleton();
		})[0],
		ot = react.exports.useRef(_);
	react.exports.useEffect(
		function () {
			ot.current = _;
		},
		[_]
	),
		react.exports.useEffect(
			function () {
				if (_.inert) {
					document.body.classList.add("block-interactivity-".concat(rt));
					var pt = __spreadArray([_.lockRef.current], (_.shards || []).map(extractRef), !0).filter(Boolean);
					return (
						pt.forEach(function (vt) {
							return vt.classList.add("allow-interactivity-".concat(rt));
						}),
						function () {
							document.body.classList.remove("block-interactivity-".concat(rt)),
								pt.forEach(function (vt) {
									return vt.classList.remove("allow-interactivity-".concat(rt));
								});
						}
					);
				}
			},
			[_.inert, _.lockRef.current, _.shards]
		);
	var at = react.exports.useCallback(function (pt, vt) {
			if ("touches" in pt && pt.touches.length === 2) return !ot.current.allowPinchZoom;
			var ht = getTouchXY(pt),
				gt = tt.current,
				yt = "deltaX" in pt ? pt.deltaX : gt[0] - ht[0],
				xt = "deltaY" in pt ? pt.deltaY : gt[1] - ht[1],
				St,
				wt = pt.target,
				Ct = Math.abs(yt) > Math.abs(xt) ? "h" : "v";
			if ("touches" in pt && Ct === "h" && wt.type === "range") return !1;
			var Et = locationCouldBeScrolled(Ct, wt);
			if (!Et) return !0;
			if ((Et ? (St = Ct) : ((St = Ct === "v" ? "h" : "v"), (Et = locationCouldBeScrolled(Ct, wt))), !Et)) return !1;
			if ((!nt.current && "changedTouches" in pt && (yt || xt) && (nt.current = St), !St)) return !0;
			var _t = nt.current || St;
			return handleScroll(_t, vt, pt, _t === "h" ? yt : xt, !0);
		}, []),
		st = react.exports.useCallback(function (pt) {
			var vt = pt;
			if (!(!lockStack.length || lockStack[lockStack.length - 1] !== it)) {
				var ht = "deltaY" in vt ? getDeltaXY(vt) : getTouchXY(vt),
					gt = et.current.filter(function (St) {
						return St.name === vt.type && St.target === vt.target && deltaCompare(St.delta, ht);
					})[0];
				if (gt && gt.should) {
					vt.cancelable && vt.preventDefault();
					return;
				}
				if (!gt) {
					var yt = (ot.current.shards || [])
							.map(extractRef)
							.filter(Boolean)
							.filter(function (St) {
								return St.contains(vt.target);
							}),
						xt = yt.length > 0 ? at(vt, yt[0]) : !ot.current.noIsolation;
					xt && vt.cancelable && vt.preventDefault();
				}
			}
		}, []),
		lt = react.exports.useCallback(function (pt, vt, ht, gt) {
			var yt = { name: pt, delta: vt, target: ht, should: gt };
			et.current.push(yt),
				setTimeout(function () {
					et.current = et.current.filter(function (xt) {
						return xt !== yt;
					});
				}, 1);
		}, []),
		ut = react.exports.useCallback(function (pt) {
			(tt.current = getTouchXY(pt)), (nt.current = void 0);
		}, []),
		dt = react.exports.useCallback(function (pt) {
			lt(pt.type, getDeltaXY(pt), pt.target, at(pt, _.lockRef.current));
		}, []),
		ct = react.exports.useCallback(function (pt) {
			lt(pt.type, getTouchXY(pt), pt.target, at(pt, _.lockRef.current));
		}, []);
	react.exports.useEffect(function () {
		return (
			lockStack.push(it),
			_.setCallbacks({ onScrollCapture: dt, onWheelCapture: dt, onTouchMoveCapture: ct }),
			document.addEventListener("wheel", st, nonPassive),
			document.addEventListener("touchmove", st, nonPassive),
			document.addEventListener("touchstart", ut, nonPassive),
			function () {
				(lockStack = lockStack.filter(function (pt) {
					return pt !== it;
				})),
					document.removeEventListener("wheel", st, nonPassive),
					document.removeEventListener("touchmove", st, nonPassive),
					document.removeEventListener("touchstart", ut, nonPassive);
			}
		);
	}, []);
	var ft = _.removeScrollBar,
		mt = _.inert;
	return jsxs(Fragment, {
		children: [
			mt ? jsx(it, { styles: generateStyle(rt) }) : null,
			ft ? jsx(RemoveScrollBar, { gapMode: "margin" }) : null,
		],
	});
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = react.exports.forwardRef(function (_, et) {
	return jsx(RemoveScroll$1, { ...__assign$4({}, _, { ref: et, sideCar: SideCar }) });
});
ReactRemoveScroll.classNames = RemoveScroll$1.classNames;
const RemoveScroll = ReactRemoveScroll;
var cx$2 = (..._) => _.filter(Boolean).join(" ");
function callAllHandlers$1(..._) {
	return function (tt) {
		_.some((nt) => (nt == null || nt(tt), tt == null ? void 0 : tt.defaultPrevented));
	};
}
var ModalManager = class {
		constructor() {
			fn(this, "modals");
			this.modals = [];
		}
		add(_) {
			this.modals.push(_);
		}
		remove(_) {
			this.modals = this.modals.filter((et) => et !== _);
		}
		isTopModal(_) {
			return this.modals[this.modals.length - 1] === _;
		}
	},
	manager = new ModalManager();
function useModalManager(_, et) {
	react.exports.useEffect(
		() => (
			et && manager.add(_),
			() => {
				manager.remove(_);
			}
		),
		[et, _]
	);
}
function useModal(_) {
	const {
			isOpen: et,
			onClose: tt,
			id: nt,
			closeOnOverlayClick: rt = !0,
			closeOnEsc: it = !0,
			useInert: ot = !0,
			onOverlayClick: at,
			onEsc: st,
		} = _,
		lt = react.exports.useRef(null),
		ut = react.exports.useRef(null),
		[dt, ct, ft] = useIds(nt, "chakra-modal", "chakra-modal--header", "chakra-modal--body");
	useAriaHidden(lt, et && ot), useModalManager(lt, et);
	const mt = react.exports.useRef(null),
		pt = react.exports.useCallback((Et) => {
			mt.current = Et.target;
		}, []),
		vt = react.exports.useCallback(
			(Et) => {
				Et.key === "Escape" && (Et.stopPropagation(), it && (tt == null || tt()), st == null || st());
			},
			[it, tt, st]
		),
		[ht, gt] = react.exports.useState(!1),
		[yt, xt] = react.exports.useState(!1),
		St = react.exports.useCallback(
			(Et = {}, _t = null) => ({
				role: "dialog",
				...Et,
				ref: mergeRefs(_t, lt),
				id: dt,
				tabIndex: -1,
				"aria-modal": !0,
				"aria-labelledby": ht ? ct : void 0,
				"aria-describedby": yt ? ft : void 0,
				onClick: callAllHandlers$1(Et.onClick, ($t) => $t.stopPropagation()),
			}),
			[ft, yt, dt, ct, ht]
		),
		wt = react.exports.useCallback(
			(Et) => {
				Et.stopPropagation(),
					mt.current === Et.target && (!manager.isTopModal(lt) || (rt && (tt == null || tt()), at == null || at()));
			},
			[tt, rt, at]
		),
		Ct = react.exports.useCallback(
			(Et = {}, _t = null) => ({
				...Et,
				ref: mergeRefs(_t, ut),
				onClick: callAllHandlers$1(Et.onClick, wt),
				onKeyDown: callAllHandlers$1(Et.onKeyDown, vt),
				onMouseDown: callAllHandlers$1(Et.onMouseDown, pt),
			}),
			[vt, pt, wt]
		);
	return {
		isOpen: et,
		onClose: tt,
		headerId: ct,
		bodyId: ft,
		setBodyMounted: xt,
		setHeaderMounted: gt,
		dialogRef: lt,
		overlayRef: ut,
		getDialogProps: St,
		getDialogContainerProps: Ct,
	};
}
function useAriaHidden(_, et) {
	const tt = _.current;
	react.exports.useEffect(() => {
		if (!(!_.current || !et)) return hideOthers(_.current);
	}, [et, _, tt]);
}
function useIds(_, ...et) {
	const tt = react.exports.useId(),
		nt = _ || tt;
	return react.exports.useMemo(() => et.map((rt) => `${rt}-${nt}`), [nt, et]);
}
var [ModalStylesProvider, useModalStyles] = createContext({
		name: "ModalStylesContext",
		errorMessage: `useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `,
	}),
	[ModalContextProvider, useModalContext] = createContext({
		strict: !0,
		name: "ModalContext",
		errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`",
	}),
	Modal = (_) => {
		const {
				portalProps: et,
				children: tt,
				autoFocus: nt,
				trapFocus: rt,
				initialFocusRef: it,
				finalFocusRef: ot,
				returnFocusOnClose: at,
				blockScrollOnMount: st,
				allowPinchZoom: lt,
				preserveScrollBarGap: ut,
				motionPreset: dt,
				lockFocusAcrossFrames: ct,
				onCloseComplete: ft,
			} = _,
			mt = useMultiStyleConfig("Modal", _),
			vt = {
				...useModal(_),
				autoFocus: nt,
				trapFocus: rt,
				initialFocusRef: it,
				finalFocusRef: ot,
				returnFocusOnClose: at,
				blockScrollOnMount: st,
				allowPinchZoom: lt,
				preserveScrollBarGap: ut,
				motionPreset: dt,
				lockFocusAcrossFrames: ct,
			};
		return jsx(ModalContextProvider, {
			value: vt,
			children: jsx(ModalStylesProvider, {
				value: mt,
				children: jsx(AnimatePresence, {
					onExitComplete: ft,
					children: vt.isOpen && jsx(Portal, { ...et, children: tt }),
				}),
			}),
		});
	};
Modal.defaultProps = {
	lockFocusAcrossFrames: !0,
	returnFocusOnClose: !0,
	scrollBehavior: "outside",
	trapFocus: !0,
	autoFocus: !0,
	blockScrollOnMount: !0,
	allowPinchZoom: !1,
	motionPreset: "scale",
};
Modal.displayName = "Modal";
var ModalBody = forwardRef((_, et) => {
	const { className: tt, ...nt } = _,
		{ bodyId: rt, setBodyMounted: it } = useModalContext();
	react.exports.useEffect(() => (it(!0), () => it(!1)), [it]);
	const ot = cx$2("chakra-modal__body", tt),
		at = useModalStyles();
	return React$1.createElement(chakra.div, { ref: et, className: ot, id: rt, ...nt, __css: at.body });
});
ModalBody.displayName = "ModalBody";
var ModalCloseButton = forwardRef((_, et) => {
	const { onClick: tt, className: nt, ...rt } = _,
		{ onClose: it } = useModalContext(),
		ot = cx$2("chakra-modal__close-btn", nt),
		at = useModalStyles();
	return jsx(CloseButton, {
		ref: et,
		__css: at.closeButton,
		className: ot,
		onClick: callAllHandlers$1(tt, (st) => {
			st.stopPropagation(), it();
		}),
		...rt,
	});
});
ModalCloseButton.displayName = "ModalCloseButton";
function ModalFocusScope(_) {
	const {
			autoFocus: et,
			trapFocus: tt,
			dialogRef: nt,
			initialFocusRef: rt,
			blockScrollOnMount: it,
			allowPinchZoom: ot,
			finalFocusRef: at,
			returnFocusOnClose: st,
			preserveScrollBarGap: lt,
			lockFocusAcrossFrames: ut,
		} = useModalContext(),
		[dt, ct] = usePresence();
	return (
		react.exports.useEffect(() => {
			!dt && ct && setTimeout(ct);
		}, [dt, ct]),
		jsx(FocusLock, {
			autoFocus: et,
			isDisabled: !tt,
			initialFocusRef: rt,
			finalFocusRef: at,
			restoreFocus: st,
			contentRef: nt,
			lockFocusAcrossFrames: ut,
			children: jsx(RemoveScroll, {
				removeScrollBar: !lt,
				allowPinchZoom: ot,
				enabled: it,
				forwardProps: !0,
				children: _.children,
			}),
		})
	);
}
var transitions = {
		slideInBottom: { ...slideFadeConfig, custom: { offsetY: 16, reverse: !0 } },
		slideInRight: { ...slideFadeConfig, custom: { offsetX: 16, reverse: !0 } },
		scale: { ...scaleFadeConfig, custom: { initialScale: 0.95, reverse: !0 } },
		none: {},
	},
	Motion = chakra(motion.section),
	ModalTransition = react.exports.forwardRef((_, et) => {
		const { preset: tt, ...nt } = _,
			rt = transitions[tt];
		return jsx(Motion, { ref: et, ...rt, ...nt });
	});
ModalTransition.displayName = "ModalTransition";
var ModalContent = forwardRef((_, et) => {
	const { className: tt, children: nt, containerProps: rt, ...it } = _,
		{ getDialogProps: ot, getDialogContainerProps: at } = useModalContext(),
		st = ot(it, et),
		lt = at(rt),
		ut = cx$2("chakra-modal__content", tt),
		dt = useModalStyles(),
		ct = { display: "flex", flexDirection: "column", position: "relative", width: "100%", outline: 0, ...dt.dialog },
		ft = {
			display: "flex",
			width: "100vw",
			height: "100vh",
			"@supports(height: -webkit-fill-available)": { height: "-webkit-fill-available" },
			position: "fixed",
			left: 0,
			top: 0,
			...dt.dialogContainer,
		},
		{ motionPreset: mt } = useModalContext();
	return React$1.createElement(
		ModalFocusScope,
		null,
		React$1.createElement(
			chakra.div,
			{ ...lt, className: "chakra-modal__content-container", tabIndex: -1, __css: ft },
			jsx(ModalTransition, { preset: mt, className: ut, ...st, __css: ct, children: nt })
		)
	);
});
ModalContent.displayName = "ModalContent";
var ModalFooter = forwardRef((_, et) => {
	const { className: tt, ...nt } = _,
		rt = cx$2("chakra-modal__footer", tt),
		it = useModalStyles(),
		ot = { display: "flex", alignItems: "center", justifyContent: "flex-end", ...it.footer };
	return React$1.createElement(chakra.footer, { ref: et, ...nt, __css: ot, className: rt });
});
ModalFooter.displayName = "ModalFooter";
var ModalHeader = forwardRef((_, et) => {
	const { className: tt, ...nt } = _,
		{ headerId: rt, setHeaderMounted: it } = useModalContext();
	react.exports.useEffect(() => (it(!0), () => it(!1)), [it]);
	const ot = cx$2("chakra-modal__header", tt),
		at = useModalStyles(),
		st = { flex: 0, ...at.header };
	return React$1.createElement(chakra.header, { ref: et, className: ot, id: rt, ...nt, __css: st });
});
ModalHeader.displayName = "ModalHeader";
var MotionDiv = chakra(motion.div),
	ModalOverlay = forwardRef((_, et) => {
		const { className: tt, transition: nt, ...rt } = _,
			it = cx$2("chakra-modal__overlay", tt),
			ot = useModalStyles(),
			at = { pos: "fixed", left: "0", top: "0", w: "100vw", h: "100vh", ...ot.overlay },
			{ motionPreset: st } = useModalContext();
		return jsx(MotionDiv, { ...(st === "none" ? {} : fadeConfig), __css: at, ref: et, className: it, ...rt });
	});
ModalOverlay.displayName = "ModalOverlay";
forwardRef((_, et) => jsx(ModalContent, { ref: et, role: "alertdialog", ..._ }));
var [DrawerContextProvider, useDrawerContext] = createContext(),
	placementMap = { start: { ltr: "left", rtl: "right" }, end: { ltr: "right", rtl: "left" } };
function getDrawerPlacement(_, et) {
	var nt;
	var tt;
	if (!!_) return (nt = (tt = placementMap[_]) == null ? void 0 : tt[et]) != null ? nt : _;
}
function Drawer(_) {
	var et;
	const { isOpen: tt, onClose: nt, placement: rt = "right", children: it, ...ot } = _,
		at = useTheme(),
		st = (et = at.components) == null ? void 0 : et.Drawer,
		lt = getDrawerPlacement(rt, at.direction);
	return jsx(DrawerContextProvider, {
		value: { placement: lt },
		children: jsx(Modal, { isOpen: tt, onClose: nt, styleConfig: st, ...ot, children: it }),
	});
}
var StyledSlide = chakra(Slide),
	DrawerContent = forwardRef((_, et) => {
		const { className: tt, children: nt, ...rt } = _,
			{ getDialogProps: it, getDialogContainerProps: ot, isOpen: at } = useModalContext(),
			st = it(rt, et),
			lt = ot(),
			ut = cx$2("chakra-modal__content", tt),
			dt = useModalStyles(),
			ct = { display: "flex", flexDirection: "column", position: "relative", width: "100%", outline: 0, ...dt.dialog },
			ft = {
				display: "flex",
				width: "100vw",
				height: "100vh",
				position: "fixed",
				left: 0,
				top: 0,
				...dt.dialogContainer,
			},
			{ placement: mt } = useDrawerContext();
		return React$1.createElement(
			chakra.div,
			{ ...lt, className: "chakra-modal__content-container", __css: ft },
			jsx(ModalFocusScope, {
				children: jsx(StyledSlide, { direction: mt, in: at, className: ut, ...st, __css: ct, children: nt }),
			})
		);
	});
DrawerContent.displayName = "DrawerContent";
var cx$1 = (..._) => _.filter(Boolean).join(" ");
function runIfFn$2(_, ...et) {
	return isFunction$6(_) ? _(...et) : _;
}
var isFunction$6 = (_) => typeof _ == "function";
function callAllHandlers(..._) {
	return function (tt) {
		_.some((nt) => (nt == null || nt(tt), tt == null ? void 0 : tt.defaultPrevented));
	};
}
function callAll(..._) {
	return function (tt) {
		_.forEach((nt) => {
			nt == null || nt(tt);
		});
	};
}
var [PopoverProvider, usePopoverContext] = createContext({
		name: "PopoverContext",
		errorMessage:
			"usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`",
	}),
	[PopoverStylesProvider, usePopoverStyles] = createContext({
		name: "PopoverStylesContext",
		errorMessage: `usePopoverStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Popover />" `,
	}),
	TRIGGER = { click: "click", hover: "hover" };
function usePopover(_ = {}) {
	const {
			closeOnBlur: et = !0,
			closeOnEsc: tt = !0,
			initialFocusRef: nt,
			id: rt,
			returnFocusOnClose: it = !0,
			autoFocus: ot = !0,
			arrowSize: at,
			arrowShadowColor: st,
			trigger: lt = TRIGGER.click,
			openDelay: ut = 200,
			closeDelay: dt = 200,
			isLazy: ct,
			lazyBehavior: ft = "unmount",
			computePositionOnMount: mt,
			...pt
		} = _,
		{ isOpen: vt, onClose: ht, onOpen: gt, onToggle: yt } = useDisclosure(_),
		xt = react.exports.useRef(null),
		St = react.exports.useRef(null),
		wt = react.exports.useRef(null),
		Ct = react.exports.useRef(!1),
		Et = react.exports.useRef(!1);
	vt && (Et.current = !0);
	const [_t, $t] = react.exports.useState(!1),
		[At, Lt] = react.exports.useState(!1),
		Nt = react.exports.useId(),
		Ft = rt != null ? rt : Nt,
		[Gt, Bt, jt, It] = ["popover-trigger", "popover-content", "popover-header", "popover-body"].map(
			(Jt) => `${Jt}-${Ft}`
		),
		{
			referenceRef: Dt,
			getArrowProps: Rt,
			getPopperProps: bt,
			getArrowInnerProps: kt,
			forceUpdate: zt,
		} = usePopper({ ...pt, enabled: vt || !!mt }),
		Vt = useAnimationState$1({ isOpen: vt, ref: wt });
	useFocusOnPointerDown({ enabled: vt, ref: St }),
		useFocusOnHide$1(wt, { focusRef: St, visible: vt, shouldFocus: it && lt === TRIGGER.click }),
		useFocusOnShow(wt, { focusRef: nt, visible: vt, shouldFocus: ot && lt === TRIGGER.click });
	const Yt = lazyDisclosure({ wasSelected: Et.current, enabled: ct, mode: ft, isSelected: Vt.present }),
		Ut = react.exports.useCallback(
			(Jt = {}, tn = null) => {
				const an = {
					...Jt,
					style: {
						...Jt.style,
						transformOrigin: cssVars.transformOrigin.varRef,
						[cssVars.arrowSize.var]: at ? `${at}px` : void 0,
						[cssVars.arrowShadowColor.var]: st,
					},
					ref: mergeRefs(wt, tn),
					children: Yt ? Jt.children : null,
					id: Bt,
					tabIndex: -1,
					role: "dialog",
					onKeyDown: callAllHandlers(Jt.onKeyDown, (mn) => {
						tt && mn.key === "Escape" && ht();
					}),
					onBlur: callAllHandlers(Jt.onBlur, (mn) => {
						const xn = getRelatedTarget(mn),
							gn = contains(wt.current, xn),
							vn = contains(St.current, xn);
						vt && et && !gn && !vn && ht();
					}),
					"aria-labelledby": _t ? jt : void 0,
					"aria-describedby": At ? It : void 0,
				};
				return (
					lt === TRIGGER.hover &&
						((an.role = "tooltip"),
						(an.onMouseEnter = callAllHandlers(Jt.onMouseEnter, () => {
							Ct.current = !0;
						})),
						(an.onMouseLeave = callAllHandlers(Jt.onMouseLeave, (mn) => {
							mn.nativeEvent.relatedTarget !== null && ((Ct.current = !1), setTimeout(ht, dt));
						}))),
					an
				);
			},
			[Yt, Bt, _t, jt, At, It, lt, tt, ht, vt, et, dt, st, at]
		),
		qt = react.exports.useCallback(
			(Jt = {}, tn = null) => bt({ ...Jt, style: { visibility: vt ? "visible" : "hidden", ...Jt.style } }, tn),
			[vt, bt]
		),
		Wt = react.exports.useCallback((Jt, tn = null) => ({ ...Jt, ref: mergeRefs(tn, xt, Dt) }), [xt, Dt]),
		Xt = react.exports.useRef(),
		Zt = react.exports.useRef(),
		pn = react.exports.useCallback(
			(Jt) => {
				xt.current == null && Dt(Jt);
			},
			[Dt]
		),
		Sn = react.exports.useCallback(
			(Jt = {}, tn = null) => {
				const an = {
					...Jt,
					ref: mergeRefs(St, tn, pn),
					id: Gt,
					"aria-haspopup": "dialog",
					"aria-expanded": vt,
					"aria-controls": Bt,
				};
				return (
					lt === TRIGGER.click && (an.onClick = callAllHandlers(Jt.onClick, yt)),
					lt === TRIGGER.hover &&
						((an.onFocus = callAllHandlers(Jt.onFocus, () => {
							Xt.current === void 0 && gt();
						})),
						(an.onBlur = callAllHandlers(Jt.onBlur, (mn) => {
							const xn = getRelatedTarget(mn),
								gn = !contains(wt.current, xn);
							vt && et && gn && ht();
						})),
						(an.onKeyDown = callAllHandlers(Jt.onKeyDown, (mn) => {
							mn.key === "Escape" && ht();
						})),
						(an.onMouseEnter = callAllHandlers(Jt.onMouseEnter, () => {
							(Ct.current = !0), (Xt.current = window.setTimeout(gt, ut));
						})),
						(an.onMouseLeave = callAllHandlers(Jt.onMouseLeave, () => {
							(Ct.current = !1),
								Xt.current && (clearTimeout(Xt.current), (Xt.current = void 0)),
								(Zt.current = window.setTimeout(() => {
									Ct.current === !1 && ht();
								}, dt));
						}))),
					an
				);
			},
			[Gt, vt, Bt, lt, pn, yt, gt, et, ht, ut, dt]
		);
	react.exports.useEffect(
		() => () => {
			Xt.current && clearTimeout(Xt.current), Zt.current && clearTimeout(Zt.current);
		},
		[]
	);
	const yn = react.exports.useCallback(
			(Jt = {}, tn = null) => ({
				...Jt,
				id: jt,
				ref: mergeRefs(tn, (an) => {
					$t(!!an);
				}),
			}),
			[jt]
		),
		Qt = react.exports.useCallback(
			(Jt = {}, tn = null) => ({
				...Jt,
				id: It,
				ref: mergeRefs(tn, (an) => {
					Lt(!!an);
				}),
			}),
			[It]
		);
	return {
		forceUpdate: zt,
		isOpen: vt,
		onAnimationComplete: Vt.onComplete,
		onClose: ht,
		getAnchorProps: Wt,
		getArrowProps: Rt,
		getArrowInnerProps: kt,
		getPopoverPositionerProps: qt,
		getPopoverProps: Ut,
		getTriggerProps: Sn,
		getHeaderProps: yn,
		getBodyProps: Qt,
	};
}
function contains(_, et) {
	return _ === et || (_ == null ? void 0 : _.contains(et));
}
function getRelatedTarget(_) {
	var tt;
	const et = _.currentTarget.ownerDocument.activeElement;
	return (tt = _.relatedTarget) != null ? tt : et;
}
function Popover$1(_) {
	const et = useMultiStyleConfig("Popover", _),
		{ children: tt, ...nt } = omitThemingProps(_),
		rt = useTheme(),
		it = usePopover({ ...nt, direction: rt.direction });
	return jsx(PopoverProvider, {
		value: it,
		children: jsx(PopoverStylesProvider, {
			value: et,
			children: runIfFn$2(tt, { isOpen: it.isOpen, onClose: it.onClose, forceUpdate: it.forceUpdate }),
		}),
	});
}
Popover$1.displayName = "Popover";
var PopoverBody = forwardRef(function (et, tt) {
	const { getBodyProps: nt } = usePopoverContext(),
		rt = usePopoverStyles();
	return React$1.createElement(chakra.div, {
		...nt(et, tt),
		className: cx$1("chakra-popover__body", et.className),
		__css: rt.body,
	});
});
PopoverBody.displayName = "PopoverBody";
var PopoverCloseButton = forwardRef(function (et, tt) {
	const { onClose: nt } = usePopoverContext(),
		rt = usePopoverStyles();
	return jsx(CloseButton, {
		size: "sm",
		onClick: nt,
		className: cx$1("chakra-popover__close-btn", et.className),
		__css: rt.closeButton,
		ref: tt,
		...et,
	});
});
PopoverCloseButton.displayName = "PopoverCloseButton";
function mergeVariants(_) {
	if (!!_)
		return {
			enter: { ..._.enter, visibility: "visible" },
			exit: { ..._.exit, transitionEnd: { visibility: "hidden" } },
		};
}
var scaleFade = {
		exit: { opacity: 0, scale: 0.95, transition: { duration: 0.1, ease: [0.4, 0, 1, 1] } },
		enter: { scale: 1, opacity: 1, transition: { duration: 0.15, ease: [0, 0, 0.2, 1] } },
	},
	Section = motion(chakra.section),
	PopoverTransition = forwardRef(function (et, tt) {
		const { isOpen: nt } = usePopoverContext();
		return React$1.createElement(Section, {
			ref: tt,
			variants: mergeVariants(et.variants),
			...et,
			initial: !1,
			animate: nt ? "enter" : "exit",
		});
	});
PopoverTransition.defaultProps = { variants: scaleFade };
PopoverTransition.displayName = "PopoverTransition";
var PopoverContent$1 = forwardRef(function (et, tt) {
	const { rootProps: nt, ...rt } = et,
		{ getPopoverProps: it, getPopoverPositionerProps: ot, onAnimationComplete: at } = usePopoverContext(),
		st = usePopoverStyles(),
		lt = { position: "relative", display: "flex", flexDirection: "column", ...st.content };
	return React$1.createElement(
		chakra.div,
		{ ...ot(nt), __css: st.popper, className: "chakra-popover__popper" },
		jsx(PopoverTransition, {
			...it(rt, tt),
			onAnimationComplete: callAll(at, rt.onAnimationComplete),
			className: cx$1("chakra-popover__content", et.className),
			__css: lt,
		})
	);
});
PopoverContent$1.displayName = "PopoverContent";
var PopoverHeader = forwardRef(function (et, tt) {
	const { getHeaderProps: nt } = usePopoverContext(),
		rt = usePopoverStyles();
	return React$1.createElement(chakra.header, {
		...nt(et, tt),
		className: cx$1("chakra-popover__header", et.className),
		__css: rt.header,
	});
});
PopoverHeader.displayName = "PopoverHeader";
function PopoverTrigger(_) {
	const et = react.exports.Children.only(_.children),
		{ getTriggerProps: tt } = usePopoverContext();
	return react.exports.cloneElement(et, tt(et.props, et.ref));
}
PopoverTrigger.displayName = "PopoverTrigger";
var cx = (..._) => _.filter(Boolean).join(" "),
	[TableStylesProvider, useTableStyles] = createContext({
		name: "TableStylesContext",
		errorMessage: `useTableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Table />" `,
	}),
	Table = forwardRef((_, et) => {
		const tt = useMultiStyleConfig("Table", _),
			{ className: nt, ...rt } = omitThemingProps(_);
		return React$1.createElement(
			TableStylesProvider,
			{ value: tt },
			React$1.createElement(chakra.table, {
				role: "table",
				ref: et,
				__css: tt.table,
				className: cx("chakra-table", nt),
				...rt,
			})
		);
	});
Table.displayName = "Table";
forwardRef((_, et) => {
	var ot;
	const { overflow: tt, overflowX: nt, className: rt, ...it } = _;
	return React$1.createElement(chakra.div, {
		ref: et,
		className: cx("chakra-table__container", rt),
		...it,
		__css: {
			display: "block",
			whiteSpace: "nowrap",
			WebkitOverflowScrolling: "touch",
			overflowX: (ot = tt != null ? tt : nt) != null ? ot : "auto",
			overflowY: "hidden",
			maxWidth: "100%",
		},
	});
});
var TableCaption = forwardRef((_, et) => {
	const { placement: tt = "bottom", ...nt } = _,
		rt = useTableStyles();
	return React$1.createElement(chakra.caption, { ...nt, ref: et, __css: { ...rt.caption, captionSide: tt } });
});
TableCaption.displayName = "TableCaption";
var Thead = forwardRef((_, et) => {
		const tt = useTableStyles();
		return React$1.createElement(chakra.thead, { ..._, ref: et, __css: tt.thead });
	}),
	Tbody = forwardRef((_, et) => {
		const tt = useTableStyles();
		return React$1.createElement(chakra.tbody, { ..._, ref: et, __css: tt.tbody });
	});
forwardRef((_, et) => {
	const tt = useTableStyles();
	return React$1.createElement(chakra.tfoot, { ..._, ref: et, __css: tt.tfoot });
});
var Th = forwardRef(({ isNumeric: _, ...et }, tt) => {
		const nt = useTableStyles();
		return React$1.createElement(chakra.th, { ...et, ref: tt, __css: nt.th, "data-is-numeric": _ });
	}),
	Tr = forwardRef((_, et) => {
		const tt = useTableStyles();
		return React$1.createElement(chakra.tr, { role: "row", ..._, ref: et, __css: tt.tr });
	}),
	Td = forwardRef(({ isNumeric: _, ...et }, tt) => {
		const nt = useTableStyles();
		return React$1.createElement(chakra.td, { role: "gridcell", ...et, ref: tt, __css: nt.td, "data-is-numeric": _ });
	});
function anatomy(_, et = {}) {
	let tt = !1;
	function nt() {
		if (!tt) {
			tt = !0;
			return;
		}
		throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?");
	}
	function rt(...ut) {
		nt();
		for (const dt of ut) et[dt] = st(dt);
		return anatomy(_, et);
	}
	function it(...ut) {
		for (const dt of ut) dt in et || (et[dt] = st(dt));
		return anatomy(_, et);
	}
	function ot() {
		return Object.fromEntries(Object.entries(et).map(([dt, ct]) => [dt, ct.selector]));
	}
	function at() {
		return Object.fromEntries(Object.entries(et).map(([dt, ct]) => [dt, ct.className]));
	}
	function st(ut) {
		const ft = `chakra-${(["container", "root"].includes(ut != null ? ut : "") ? [_] : [_, ut])
			.filter(Boolean)
			.join("__")}`;
		return { className: ft, selector: `.${ft}`, toString: () => ut };
	}
	return {
		parts: rt,
		toPart: st,
		extend: it,
		selectors: ot,
		classnames: at,
		get keys() {
			return Object.keys(et);
		},
		__type: {},
	};
}
var accordionAnatomy = anatomy("accordion").parts("root", "container", "button", "panel").extend("icon"),
	alertAnatomy = anatomy("alert").parts("title", "description", "container").extend("icon", "spinner"),
	avatarAnatomy = anatomy("avatar").parts("label", "badge", "container").extend("excessLabel", "group"),
	breadcrumbAnatomy = anatomy("breadcrumb").parts("link", "item", "container").extend("separator");
anatomy("button").parts();
var checkboxAnatomy = anatomy("checkbox").parts("control", "icon", "container").extend("label");
anatomy("progress").parts("track", "filledTrack").extend("label");
var drawerAnatomy = anatomy("drawer")
		.parts("overlay", "dialogContainer", "dialog")
		.extend("header", "closeButton", "body", "footer"),
	editableAnatomy = anatomy("editable").parts("preview", "input", "textarea"),
	formAnatomy = anatomy("form").parts("container", "requiredIndicator", "helperText"),
	formErrorAnatomy = anatomy("formError").parts("text", "icon"),
	inputAnatomy = anatomy("input").parts("addon", "field", "element"),
	listAnatomy = anatomy("list").parts("container", "item", "icon"),
	menuAnatomy = anatomy("menu").parts("button", "list", "item").extend("groupTitle", "command", "divider"),
	modalAnatomy = anatomy("modal")
		.parts("overlay", "dialogContainer", "dialog")
		.extend("header", "closeButton", "body", "footer"),
	numberInputAnatomy = anatomy("numberinput").parts("root", "field", "stepperGroup", "stepper");
anatomy("pininput").parts("field");
var popoverAnatomy = anatomy("popover")
		.parts("content", "header", "body", "footer")
		.extend("popper", "arrow", "closeButton"),
	progressAnatomy = anatomy("progress").parts("label", "filledTrack", "track"),
	radioAnatomy = anatomy("radio").parts("container", "control", "label"),
	selectAnatomy = anatomy("select").parts("field", "icon"),
	sliderAnatomy = anatomy("slider").parts("container", "track", "thumb", "filledTrack", "mark"),
	statAnatomy = anatomy("stat").parts("container", "label", "helpText", "number", "icon"),
	switchAnatomy = anatomy("switch").parts("container", "track", "thumb"),
	tableAnatomy = anatomy("table").parts("table", "thead", "tbody", "tr", "th", "td", "tfoot", "caption"),
	tabsAnatomy = anatomy("tabs").parts("root", "tab", "tablist", "tabpanel", "tabpanels", "indicator"),
	tagAnatomy = anatomy("tag").parts("container", "label", "closeButton");
function bound01(_, et) {
	isOnePointZero(_) && (_ = "100%");
	var tt = isPercentage(_);
	return (
		(_ = et === 360 ? _ : Math.min(et, Math.max(0, parseFloat(_)))),
		tt && (_ = parseInt(String(_ * et), 10) / 100),
		Math.abs(_ - et) < 1e-6
			? 1
			: (et === 360
					? (_ = (_ < 0 ? (_ % et) + et : _ % et) / parseFloat(String(et)))
					: (_ = (_ % et) / parseFloat(String(et))),
			  _)
	);
}
function clamp01(_) {
	return Math.min(1, Math.max(0, _));
}
function isOnePointZero(_) {
	return typeof _ == "string" && _.indexOf(".") !== -1 && parseFloat(_) === 1;
}
function isPercentage(_) {
	return typeof _ == "string" && _.indexOf("%") !== -1;
}
function boundAlpha(_) {
	return (_ = parseFloat(_)), (isNaN(_) || _ < 0 || _ > 1) && (_ = 1), _;
}
function convertToPercentage(_) {
	return _ <= 1 ? "".concat(Number(_) * 100, "%") : _;
}
function pad2(_) {
	return _.length === 1 ? "0" + _ : String(_);
}
function rgbToRgb(_, et, tt) {
	return { r: bound01(_, 255) * 255, g: bound01(et, 255) * 255, b: bound01(tt, 255) * 255 };
}
function rgbToHsl(_, et, tt) {
	(_ = bound01(_, 255)), (et = bound01(et, 255)), (tt = bound01(tt, 255));
	var nt = Math.max(_, et, tt),
		rt = Math.min(_, et, tt),
		it = 0,
		ot = 0,
		at = (nt + rt) / 2;
	if (nt === rt) (ot = 0), (it = 0);
	else {
		var st = nt - rt;
		switch (((ot = at > 0.5 ? st / (2 - nt - rt) : st / (nt + rt)), nt)) {
			case _:
				it = (et - tt) / st + (et < tt ? 6 : 0);
				break;
			case et:
				it = (tt - _) / st + 2;
				break;
			case tt:
				it = (_ - et) / st + 4;
				break;
		}
		it /= 6;
	}
	return { h: it, s: ot, l: at };
}
function hue2rgb(_, et, tt) {
	return (
		tt < 0 && (tt += 1),
		tt > 1 && (tt -= 1),
		tt < 1 / 6 ? _ + (et - _) * (6 * tt) : tt < 1 / 2 ? et : tt < 2 / 3 ? _ + (et - _) * (2 / 3 - tt) * 6 : _
	);
}
function hslToRgb(_, et, tt) {
	var nt, rt, it;
	if (((_ = bound01(_, 360)), (et = bound01(et, 100)), (tt = bound01(tt, 100)), et === 0))
		(rt = tt), (it = tt), (nt = tt);
	else {
		var ot = tt < 0.5 ? tt * (1 + et) : tt + et - tt * et,
			at = 2 * tt - ot;
		(nt = hue2rgb(at, ot, _ + 1 / 3)), (rt = hue2rgb(at, ot, _)), (it = hue2rgb(at, ot, _ - 1 / 3));
	}
	return { r: nt * 255, g: rt * 255, b: it * 255 };
}
function rgbToHsv(_, et, tt) {
	(_ = bound01(_, 255)), (et = bound01(et, 255)), (tt = bound01(tt, 255));
	var nt = Math.max(_, et, tt),
		rt = Math.min(_, et, tt),
		it = 0,
		ot = nt,
		at = nt - rt,
		st = nt === 0 ? 0 : at / nt;
	if (nt === rt) it = 0;
	else {
		switch (nt) {
			case _:
				it = (et - tt) / at + (et < tt ? 6 : 0);
				break;
			case et:
				it = (tt - _) / at + 2;
				break;
			case tt:
				it = (_ - et) / at + 4;
				break;
		}
		it /= 6;
	}
	return { h: it, s: st, v: ot };
}
function hsvToRgb(_, et, tt) {
	(_ = bound01(_, 360) * 6), (et = bound01(et, 100)), (tt = bound01(tt, 100));
	var nt = Math.floor(_),
		rt = _ - nt,
		it = tt * (1 - et),
		ot = tt * (1 - rt * et),
		at = tt * (1 - (1 - rt) * et),
		st = nt % 6,
		lt = [tt, ot, it, it, at, tt][st],
		ut = [at, tt, tt, ot, it, it][st],
		dt = [it, it, at, tt, tt, ot][st];
	return { r: lt * 255, g: ut * 255, b: dt * 255 };
}
function rgbToHex(_, et, tt, nt) {
	var rt = [pad2(Math.round(_).toString(16)), pad2(Math.round(et).toString(16)), pad2(Math.round(tt).toString(16))];
	return nt &&
		rt[0].startsWith(rt[0].charAt(1)) &&
		rt[1].startsWith(rt[1].charAt(1)) &&
		rt[2].startsWith(rt[2].charAt(1))
		? rt[0].charAt(0) + rt[1].charAt(0) + rt[2].charAt(0)
		: rt.join("");
}
function rgbaToHex(_, et, tt, nt, rt) {
	var it = [
		pad2(Math.round(_).toString(16)),
		pad2(Math.round(et).toString(16)),
		pad2(Math.round(tt).toString(16)),
		pad2(convertDecimalToHex(nt)),
	];
	return rt &&
		it[0].startsWith(it[0].charAt(1)) &&
		it[1].startsWith(it[1].charAt(1)) &&
		it[2].startsWith(it[2].charAt(1)) &&
		it[3].startsWith(it[3].charAt(1))
		? it[0].charAt(0) + it[1].charAt(0) + it[2].charAt(0) + it[3].charAt(0)
		: it.join("");
}
function convertDecimalToHex(_) {
	return Math.round(parseFloat(_) * 255).toString(16);
}
function convertHexToDecimal(_) {
	return parseIntFromHex(_) / 255;
}
function parseIntFromHex(_) {
	return parseInt(_, 16);
}
function numberInputToObject(_) {
	return { r: _ >> 16, g: (_ & 65280) >> 8, b: _ & 255 };
}
var names = {
	aliceblue: "#f0f8ff",
	antiquewhite: "#faebd7",
	aqua: "#00ffff",
	aquamarine: "#7fffd4",
	azure: "#f0ffff",
	beige: "#f5f5dc",
	bisque: "#ffe4c4",
	black: "#000000",
	blanchedalmond: "#ffebcd",
	blue: "#0000ff",
	blueviolet: "#8a2be2",
	brown: "#a52a2a",
	burlywood: "#deb887",
	cadetblue: "#5f9ea0",
	chartreuse: "#7fff00",
	chocolate: "#d2691e",
	coral: "#ff7f50",
	cornflowerblue: "#6495ed",
	cornsilk: "#fff8dc",
	crimson: "#dc143c",
	cyan: "#00ffff",
	darkblue: "#00008b",
	darkcyan: "#008b8b",
	darkgoldenrod: "#b8860b",
	darkgray: "#a9a9a9",
	darkgreen: "#006400",
	darkgrey: "#a9a9a9",
	darkkhaki: "#bdb76b",
	darkmagenta: "#8b008b",
	darkolivegreen: "#556b2f",
	darkorange: "#ff8c00",
	darkorchid: "#9932cc",
	darkred: "#8b0000",
	darksalmon: "#e9967a",
	darkseagreen: "#8fbc8f",
	darkslateblue: "#483d8b",
	darkslategray: "#2f4f4f",
	darkslategrey: "#2f4f4f",
	darkturquoise: "#00ced1",
	darkviolet: "#9400d3",
	deeppink: "#ff1493",
	deepskyblue: "#00bfff",
	dimgray: "#696969",
	dimgrey: "#696969",
	dodgerblue: "#1e90ff",
	firebrick: "#b22222",
	floralwhite: "#fffaf0",
	forestgreen: "#228b22",
	fuchsia: "#ff00ff",
	gainsboro: "#dcdcdc",
	ghostwhite: "#f8f8ff",
	goldenrod: "#daa520",
	gold: "#ffd700",
	gray: "#808080",
	green: "#008000",
	greenyellow: "#adff2f",
	grey: "#808080",
	honeydew: "#f0fff0",
	hotpink: "#ff69b4",
	indianred: "#cd5c5c",
	indigo: "#4b0082",
	ivory: "#fffff0",
	khaki: "#f0e68c",
	lavenderblush: "#fff0f5",
	lavender: "#e6e6fa",
	lawngreen: "#7cfc00",
	lemonchiffon: "#fffacd",
	lightblue: "#add8e6",
	lightcoral: "#f08080",
	lightcyan: "#e0ffff",
	lightgoldenrodyellow: "#fafad2",
	lightgray: "#d3d3d3",
	lightgreen: "#90ee90",
	lightgrey: "#d3d3d3",
	lightpink: "#ffb6c1",
	lightsalmon: "#ffa07a",
	lightseagreen: "#20b2aa",
	lightskyblue: "#87cefa",
	lightslategray: "#778899",
	lightslategrey: "#778899",
	lightsteelblue: "#b0c4de",
	lightyellow: "#ffffe0",
	lime: "#00ff00",
	limegreen: "#32cd32",
	linen: "#faf0e6",
	magenta: "#ff00ff",
	maroon: "#800000",
	mediumaquamarine: "#66cdaa",
	mediumblue: "#0000cd",
	mediumorchid: "#ba55d3",
	mediumpurple: "#9370db",
	mediumseagreen: "#3cb371",
	mediumslateblue: "#7b68ee",
	mediumspringgreen: "#00fa9a",
	mediumturquoise: "#48d1cc",
	mediumvioletred: "#c71585",
	midnightblue: "#191970",
	mintcream: "#f5fffa",
	mistyrose: "#ffe4e1",
	moccasin: "#ffe4b5",
	navajowhite: "#ffdead",
	navy: "#000080",
	oldlace: "#fdf5e6",
	olive: "#808000",
	olivedrab: "#6b8e23",
	orange: "#ffa500",
	orangered: "#ff4500",
	orchid: "#da70d6",
	palegoldenrod: "#eee8aa",
	palegreen: "#98fb98",
	paleturquoise: "#afeeee",
	palevioletred: "#db7093",
	papayawhip: "#ffefd5",
	peachpuff: "#ffdab9",
	peru: "#cd853f",
	pink: "#ffc0cb",
	plum: "#dda0dd",
	powderblue: "#b0e0e6",
	purple: "#800080",
	rebeccapurple: "#663399",
	red: "#ff0000",
	rosybrown: "#bc8f8f",
	royalblue: "#4169e1",
	saddlebrown: "#8b4513",
	salmon: "#fa8072",
	sandybrown: "#f4a460",
	seagreen: "#2e8b57",
	seashell: "#fff5ee",
	sienna: "#a0522d",
	silver: "#c0c0c0",
	skyblue: "#87ceeb",
	slateblue: "#6a5acd",
	slategray: "#708090",
	slategrey: "#708090",
	snow: "#fffafa",
	springgreen: "#00ff7f",
	steelblue: "#4682b4",
	tan: "#d2b48c",
	teal: "#008080",
	thistle: "#d8bfd8",
	tomato: "#ff6347",
	turquoise: "#40e0d0",
	violet: "#ee82ee",
	wheat: "#f5deb3",
	white: "#ffffff",
	whitesmoke: "#f5f5f5",
	yellow: "#ffff00",
	yellowgreen: "#9acd32",
};
function inputToRGB(_) {
	var et = { r: 0, g: 0, b: 0 },
		tt = 1,
		nt = null,
		rt = null,
		it = null,
		ot = !1,
		at = !1;
	return (
		typeof _ == "string" && (_ = stringInputToObject(_)),
		typeof _ == "object" &&
			(isValidCSSUnit(_.r) && isValidCSSUnit(_.g) && isValidCSSUnit(_.b)
				? ((et = rgbToRgb(_.r, _.g, _.b)), (ot = !0), (at = String(_.r).substr(-1) === "%" ? "prgb" : "rgb"))
				: isValidCSSUnit(_.h) && isValidCSSUnit(_.s) && isValidCSSUnit(_.v)
				? ((nt = convertToPercentage(_.s)),
				  (rt = convertToPercentage(_.v)),
				  (et = hsvToRgb(_.h, nt, rt)),
				  (ot = !0),
				  (at = "hsv"))
				: isValidCSSUnit(_.h) &&
				  isValidCSSUnit(_.s) &&
				  isValidCSSUnit(_.l) &&
				  ((nt = convertToPercentage(_.s)),
				  (it = convertToPercentage(_.l)),
				  (et = hslToRgb(_.h, nt, it)),
				  (ot = !0),
				  (at = "hsl")),
			Object.prototype.hasOwnProperty.call(_, "a") && (tt = _.a)),
		(tt = boundAlpha(tt)),
		{
			ok: ot,
			format: _.format || at,
			r: Math.min(255, Math.max(et.r, 0)),
			g: Math.min(255, Math.max(et.g, 0)),
			b: Math.min(255, Math.max(et.b, 0)),
			a: tt,
		}
	);
}
var CSS_INTEGER = "[-\\+]?\\d+%?",
	CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?",
	CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")"),
	PERMISSIVE_MATCH3 = "[\\s|\\(]+("
		.concat(CSS_UNIT, ")[,|\\s]+(")
		.concat(CSS_UNIT, ")[,|\\s]+(")
		.concat(CSS_UNIT, ")\\s*\\)?"),
	PERMISSIVE_MATCH4 = "[\\s|\\(]+("
		.concat(CSS_UNIT, ")[,|\\s]+(")
		.concat(CSS_UNIT, ")[,|\\s]+(")
		.concat(CSS_UNIT, ")[,|\\s]+(")
		.concat(CSS_UNIT, ")\\s*\\)?"),
	matchers = {
		CSS_UNIT: new RegExp(CSS_UNIT),
		rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
		rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
		hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
		hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
		hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
		hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
		hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
		hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
	};
function stringInputToObject(_) {
	if (((_ = _.trim().toLowerCase()), _.length === 0)) return !1;
	var et = !1;
	if (names[_]) (_ = names[_]), (et = !0);
	else if (_ === "transparent") return { r: 0, g: 0, b: 0, a: 0, format: "name" };
	var tt = matchers.rgb.exec(_);
	return tt
		? { r: tt[1], g: tt[2], b: tt[3] }
		: ((tt = matchers.rgba.exec(_)),
		  tt
				? { r: tt[1], g: tt[2], b: tt[3], a: tt[4] }
				: ((tt = matchers.hsl.exec(_)),
				  tt
						? { h: tt[1], s: tt[2], l: tt[3] }
						: ((tt = matchers.hsla.exec(_)),
						  tt
								? { h: tt[1], s: tt[2], l: tt[3], a: tt[4] }
								: ((tt = matchers.hsv.exec(_)),
								  tt
										? { h: tt[1], s: tt[2], v: tt[3] }
										: ((tt = matchers.hsva.exec(_)),
										  tt
												? { h: tt[1], s: tt[2], v: tt[3], a: tt[4] }
												: ((tt = matchers.hex8.exec(_)),
												  tt
														? {
																r: parseIntFromHex(tt[1]),
																g: parseIntFromHex(tt[2]),
																b: parseIntFromHex(tt[3]),
																a: convertHexToDecimal(tt[4]),
																format: et ? "name" : "hex8",
														  }
														: ((tt = matchers.hex6.exec(_)),
														  tt
																? {
																		r: parseIntFromHex(tt[1]),
																		g: parseIntFromHex(tt[2]),
																		b: parseIntFromHex(tt[3]),
																		format: et ? "name" : "hex",
																  }
																: ((tt = matchers.hex4.exec(_)),
																  tt
																		? {
																				r: parseIntFromHex(tt[1] + tt[1]),
																				g: parseIntFromHex(tt[2] + tt[2]),
																				b: parseIntFromHex(tt[3] + tt[3]),
																				a: convertHexToDecimal(tt[4] + tt[4]),
																				format: et ? "name" : "hex8",
																		  }
																		: ((tt = matchers.hex3.exec(_)),
																		  tt
																				? {
																						r: parseIntFromHex(tt[1] + tt[1]),
																						g: parseIntFromHex(tt[2] + tt[2]),
																						b: parseIntFromHex(tt[3] + tt[3]),
																						format: et ? "name" : "hex",
																				  }
																				: !1)))))))));
}
function isValidCSSUnit(_) {
	return Boolean(matchers.CSS_UNIT.exec(String(_)));
}
var TinyColor = (function () {
	function _(et, tt) {
		et === void 0 && (et = ""), tt === void 0 && (tt = {});
		var nt;
		if (et instanceof _) return et;
		typeof et == "number" && (et = numberInputToObject(et)), (this.originalInput = et);
		var rt = inputToRGB(et);
		(this.originalInput = et),
			(this.r = rt.r),
			(this.g = rt.g),
			(this.b = rt.b),
			(this.a = rt.a),
			(this.roundA = Math.round(100 * this.a) / 100),
			(this.format = (nt = tt.format) !== null && nt !== void 0 ? nt : rt.format),
			(this.gradientType = tt.gradientType),
			this.r < 1 && (this.r = Math.round(this.r)),
			this.g < 1 && (this.g = Math.round(this.g)),
			this.b < 1 && (this.b = Math.round(this.b)),
			(this.isValid = rt.ok);
	}
	return (
		(_.prototype.isDark = function () {
			return this.getBrightness() < 128;
		}),
		(_.prototype.isLight = function () {
			return !this.isDark();
		}),
		(_.prototype.getBrightness = function () {
			var et = this.toRgb();
			return (et.r * 299 + et.g * 587 + et.b * 114) / 1e3;
		}),
		(_.prototype.getLuminance = function () {
			var et = this.toRgb(),
				tt,
				nt,
				rt,
				it = et.r / 255,
				ot = et.g / 255,
				at = et.b / 255;
			return (
				it <= 0.03928 ? (tt = it / 12.92) : (tt = Math.pow((it + 0.055) / 1.055, 2.4)),
				ot <= 0.03928 ? (nt = ot / 12.92) : (nt = Math.pow((ot + 0.055) / 1.055, 2.4)),
				at <= 0.03928 ? (rt = at / 12.92) : (rt = Math.pow((at + 0.055) / 1.055, 2.4)),
				0.2126 * tt + 0.7152 * nt + 0.0722 * rt
			);
		}),
		(_.prototype.getAlpha = function () {
			return this.a;
		}),
		(_.prototype.setAlpha = function (et) {
			return (this.a = boundAlpha(et)), (this.roundA = Math.round(100 * this.a) / 100), this;
		}),
		(_.prototype.toHsv = function () {
			var et = rgbToHsv(this.r, this.g, this.b);
			return { h: et.h * 360, s: et.s, v: et.v, a: this.a };
		}),
		(_.prototype.toHsvString = function () {
			var et = rgbToHsv(this.r, this.g, this.b),
				tt = Math.round(et.h * 360),
				nt = Math.round(et.s * 100),
				rt = Math.round(et.v * 100);
			return this.a === 1
				? "hsv(".concat(tt, ", ").concat(nt, "%, ").concat(rt, "%)")
				: "hsva(".concat(tt, ", ").concat(nt, "%, ").concat(rt, "%, ").concat(this.roundA, ")");
		}),
		(_.prototype.toHsl = function () {
			var et = rgbToHsl(this.r, this.g, this.b);
			return { h: et.h * 360, s: et.s, l: et.l, a: this.a };
		}),
		(_.prototype.toHslString = function () {
			var et = rgbToHsl(this.r, this.g, this.b),
				tt = Math.round(et.h * 360),
				nt = Math.round(et.s * 100),
				rt = Math.round(et.l * 100);
			return this.a === 1
				? "hsl(".concat(tt, ", ").concat(nt, "%, ").concat(rt, "%)")
				: "hsla(".concat(tt, ", ").concat(nt, "%, ").concat(rt, "%, ").concat(this.roundA, ")");
		}),
		(_.prototype.toHex = function (et) {
			return et === void 0 && (et = !1), rgbToHex(this.r, this.g, this.b, et);
		}),
		(_.prototype.toHexString = function (et) {
			return et === void 0 && (et = !1), "#" + this.toHex(et);
		}),
		(_.prototype.toHex8 = function (et) {
			return et === void 0 && (et = !1), rgbaToHex(this.r, this.g, this.b, this.a, et);
		}),
		(_.prototype.toHex8String = function (et) {
			return et === void 0 && (et = !1), "#" + this.toHex8(et);
		}),
		(_.prototype.toRgb = function () {
			return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b), a: this.a };
		}),
		(_.prototype.toRgbString = function () {
			var et = Math.round(this.r),
				tt = Math.round(this.g),
				nt = Math.round(this.b);
			return this.a === 1
				? "rgb(".concat(et, ", ").concat(tt, ", ").concat(nt, ")")
				: "rgba(".concat(et, ", ").concat(tt, ", ").concat(nt, ", ").concat(this.roundA, ")");
		}),
		(_.prototype.toPercentageRgb = function () {
			var et = function (tt) {
				return "".concat(Math.round(bound01(tt, 255) * 100), "%");
			};
			return { r: et(this.r), g: et(this.g), b: et(this.b), a: this.a };
		}),
		(_.prototype.toPercentageRgbString = function () {
			var et = function (tt) {
				return Math.round(bound01(tt, 255) * 100);
			};
			return this.a === 1
				? "rgb(".concat(et(this.r), "%, ").concat(et(this.g), "%, ").concat(et(this.b), "%)")
				: "rgba("
						.concat(et(this.r), "%, ")
						.concat(et(this.g), "%, ")
						.concat(et(this.b), "%, ")
						.concat(this.roundA, ")");
		}),
		(_.prototype.toName = function () {
			if (this.a === 0) return "transparent";
			if (this.a < 1) return !1;
			for (
				var et = "#" + rgbToHex(this.r, this.g, this.b, !1), tt = 0, nt = Object.entries(names);
				tt < nt.length;
				tt++
			) {
				var rt = nt[tt],
					it = rt[0],
					ot = rt[1];
				if (et === ot) return it;
			}
			return !1;
		}),
		(_.prototype.toString = function (et) {
			var tt = Boolean(et);
			et = et != null ? et : this.format;
			var nt = !1,
				rt = this.a < 1 && this.a >= 0,
				it = !tt && rt && (et.startsWith("hex") || et === "name");
			return it
				? et === "name" && this.a === 0
					? this.toName()
					: this.toRgbString()
				: (et === "rgb" && (nt = this.toRgbString()),
				  et === "prgb" && (nt = this.toPercentageRgbString()),
				  (et === "hex" || et === "hex6") && (nt = this.toHexString()),
				  et === "hex3" && (nt = this.toHexString(!0)),
				  et === "hex4" && (nt = this.toHex8String(!0)),
				  et === "hex8" && (nt = this.toHex8String()),
				  et === "name" && (nt = this.toName()),
				  et === "hsl" && (nt = this.toHslString()),
				  et === "hsv" && (nt = this.toHsvString()),
				  nt || this.toHexString());
		}),
		(_.prototype.toNumber = function () {
			return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
		}),
		(_.prototype.clone = function () {
			return new _(this.toString());
		}),
		(_.prototype.lighten = function (et) {
			et === void 0 && (et = 10);
			var tt = this.toHsl();
			return (tt.l += et / 100), (tt.l = clamp01(tt.l)), new _(tt);
		}),
		(_.prototype.brighten = function (et) {
			et === void 0 && (et = 10);
			var tt = this.toRgb();
			return (
				(tt.r = Math.max(0, Math.min(255, tt.r - Math.round(255 * -(et / 100))))),
				(tt.g = Math.max(0, Math.min(255, tt.g - Math.round(255 * -(et / 100))))),
				(tt.b = Math.max(0, Math.min(255, tt.b - Math.round(255 * -(et / 100))))),
				new _(tt)
			);
		}),
		(_.prototype.darken = function (et) {
			et === void 0 && (et = 10);
			var tt = this.toHsl();
			return (tt.l -= et / 100), (tt.l = clamp01(tt.l)), new _(tt);
		}),
		(_.prototype.tint = function (et) {
			return et === void 0 && (et = 10), this.mix("white", et);
		}),
		(_.prototype.shade = function (et) {
			return et === void 0 && (et = 10), this.mix("black", et);
		}),
		(_.prototype.desaturate = function (et) {
			et === void 0 && (et = 10);
			var tt = this.toHsl();
			return (tt.s -= et / 100), (tt.s = clamp01(tt.s)), new _(tt);
		}),
		(_.prototype.saturate = function (et) {
			et === void 0 && (et = 10);
			var tt = this.toHsl();
			return (tt.s += et / 100), (tt.s = clamp01(tt.s)), new _(tt);
		}),
		(_.prototype.greyscale = function () {
			return this.desaturate(100);
		}),
		(_.prototype.spin = function (et) {
			var tt = this.toHsl(),
				nt = (tt.h + et) % 360;
			return (tt.h = nt < 0 ? 360 + nt : nt), new _(tt);
		}),
		(_.prototype.mix = function (et, tt) {
			tt === void 0 && (tt = 50);
			var nt = this.toRgb(),
				rt = new _(et).toRgb(),
				it = tt / 100,
				ot = {
					r: (rt.r - nt.r) * it + nt.r,
					g: (rt.g - nt.g) * it + nt.g,
					b: (rt.b - nt.b) * it + nt.b,
					a: (rt.a - nt.a) * it + nt.a,
				};
			return new _(ot);
		}),
		(_.prototype.analogous = function (et, tt) {
			et === void 0 && (et = 6), tt === void 0 && (tt = 30);
			var nt = this.toHsl(),
				rt = 360 / tt,
				it = [this];
			for (nt.h = (nt.h - ((rt * et) >> 1) + 720) % 360; --et; ) (nt.h = (nt.h + rt) % 360), it.push(new _(nt));
			return it;
		}),
		(_.prototype.complement = function () {
			var et = this.toHsl();
			return (et.h = (et.h + 180) % 360), new _(et);
		}),
		(_.prototype.monochromatic = function (et) {
			et === void 0 && (et = 6);
			for (var tt = this.toHsv(), nt = tt.h, rt = tt.s, it = tt.v, ot = [], at = 1 / et; et--; )
				ot.push(new _({ h: nt, s: rt, v: it })), (it = (it + at) % 1);
			return ot;
		}),
		(_.prototype.splitcomplement = function () {
			var et = this.toHsl(),
				tt = et.h;
			return [this, new _({ h: (tt + 72) % 360, s: et.s, l: et.l }), new _({ h: (tt + 216) % 360, s: et.s, l: et.l })];
		}),
		(_.prototype.onBackground = function (et) {
			var tt = this.toRgb(),
				nt = new _(et).toRgb();
			return new _({ r: nt.r + (tt.r - nt.r) * tt.a, g: nt.g + (tt.g - nt.g) * tt.a, b: nt.b + (tt.b - nt.b) * tt.a });
		}),
		(_.prototype.triad = function () {
			return this.polyad(3);
		}),
		(_.prototype.tetrad = function () {
			return this.polyad(4);
		}),
		(_.prototype.polyad = function (et) {
			for (var tt = this.toHsl(), nt = tt.h, rt = [this], it = 360 / et, ot = 1; ot < et; ot++)
				rt.push(new _({ h: (nt + ot * it) % 360, s: tt.s, l: tt.l }));
			return rt;
		}),
		(_.prototype.equals = function (et) {
			return this.toRgbString() === new _(et).toRgbString();
		}),
		_
	);
})();
function random(_) {
	if ((_ === void 0 && (_ = {}), _.count !== void 0 && _.count !== null)) {
		var et = _.count,
			tt = [];
		for (_.count = void 0; et > tt.length; ) (_.count = null), _.seed && (_.seed += 1), tt.push(random(_));
		return (_.count = et), tt;
	}
	var nt = pickHue(_.hue, _.seed),
		rt = pickSaturation(nt, _),
		it = pickBrightness(nt, rt, _),
		ot = { h: nt, s: rt, v: it };
	return _.alpha !== void 0 && (ot.a = _.alpha), new TinyColor(ot);
}
function pickHue(_, et) {
	var tt = getHueRange(_),
		nt = randomWithin(tt, et);
	return nt < 0 && (nt = 360 + nt), nt;
}
function pickSaturation(_, et) {
	if (et.hue === "monochrome") return 0;
	if (et.luminosity === "random") return randomWithin([0, 100], et.seed);
	var tt = getColorInfo(_).saturationRange,
		nt = tt[0],
		rt = tt[1];
	switch (et.luminosity) {
		case "bright":
			nt = 55;
			break;
		case "dark":
			nt = rt - 10;
			break;
		case "light":
			rt = 55;
			break;
	}
	return randomWithin([nt, rt], et.seed);
}
function pickBrightness(_, et, tt) {
	var nt = getMinimumBrightness(_, et),
		rt = 100;
	switch (tt.luminosity) {
		case "dark":
			rt = nt + 20;
			break;
		case "light":
			nt = (rt + nt) / 2;
			break;
		case "random":
			(nt = 0), (rt = 100);
			break;
	}
	return randomWithin([nt, rt], tt.seed);
}
function getMinimumBrightness(_, et) {
	for (var tt = getColorInfo(_).lowerBounds, nt = 0; nt < tt.length - 1; nt++) {
		var rt = tt[nt][0],
			it = tt[nt][1],
			ot = tt[nt + 1][0],
			at = tt[nt + 1][1];
		if (et >= rt && et <= ot) {
			var st = (at - it) / (ot - rt),
				lt = it - st * rt;
			return st * et + lt;
		}
	}
	return 0;
}
function getHueRange(_) {
	var et = parseInt(_, 10);
	if (!Number.isNaN(et) && et < 360 && et > 0) return [et, et];
	if (typeof _ == "string") {
		var tt = bounds.find(function (ot) {
			return ot.name === _;
		});
		if (tt) {
			var nt = defineColor(tt);
			if (nt.hueRange) return nt.hueRange;
		}
		var rt = new TinyColor(_);
		if (rt.isValid) {
			var it = rt.toHsv().h;
			return [it, it];
		}
	}
	return [0, 360];
}
function getColorInfo(_) {
	_ >= 334 && _ <= 360 && (_ -= 360);
	for (var et = 0, tt = bounds; et < tt.length; et++) {
		var nt = tt[et],
			rt = defineColor(nt);
		if (rt.hueRange && _ >= rt.hueRange[0] && _ <= rt.hueRange[1]) return rt;
	}
	throw Error("Color not found");
}
function randomWithin(_, et) {
	if (et === void 0) return Math.floor(_[0] + Math.random() * (_[1] + 1 - _[0]));
	var tt = _[1] || 1,
		nt = _[0] || 0;
	et = (et * 9301 + 49297) % 233280;
	var rt = et / 233280;
	return Math.floor(nt + rt * (tt - nt));
}
function defineColor(_) {
	var et = _.lowerBounds[0][0],
		tt = _.lowerBounds[_.lowerBounds.length - 1][0],
		nt = _.lowerBounds[_.lowerBounds.length - 1][1],
		rt = _.lowerBounds[0][1];
	return {
		name: _.name,
		hueRange: _.hueRange,
		lowerBounds: _.lowerBounds,
		saturationRange: [et, tt],
		brightnessRange: [nt, rt],
	};
}
var bounds = [
	{
		name: "monochrome",
		hueRange: null,
		lowerBounds: [
			[0, 0],
			[100, 0],
		],
	},
	{
		name: "red",
		hueRange: [-26, 18],
		lowerBounds: [
			[20, 100],
			[30, 92],
			[40, 89],
			[50, 85],
			[60, 78],
			[70, 70],
			[80, 60],
			[90, 55],
			[100, 50],
		],
	},
	{
		name: "orange",
		hueRange: [19, 46],
		lowerBounds: [
			[20, 100],
			[30, 93],
			[40, 88],
			[50, 86],
			[60, 85],
			[70, 70],
			[100, 70],
		],
	},
	{
		name: "yellow",
		hueRange: [47, 62],
		lowerBounds: [
			[25, 100],
			[40, 94],
			[50, 89],
			[60, 86],
			[70, 84],
			[80, 82],
			[90, 80],
			[100, 75],
		],
	},
	{
		name: "green",
		hueRange: [63, 178],
		lowerBounds: [
			[30, 100],
			[40, 90],
			[50, 85],
			[60, 81],
			[70, 74],
			[80, 64],
			[90, 50],
			[100, 40],
		],
	},
	{
		name: "blue",
		hueRange: [179, 257],
		lowerBounds: [
			[20, 100],
			[30, 86],
			[40, 80],
			[50, 74],
			[60, 60],
			[70, 52],
			[80, 44],
			[90, 39],
			[100, 35],
		],
	},
	{
		name: "purple",
		hueRange: [258, 282],
		lowerBounds: [
			[20, 100],
			[30, 87],
			[40, 79],
			[50, 70],
			[60, 65],
			[70, 59],
			[80, 52],
			[90, 45],
			[100, 42],
		],
	},
	{
		name: "pink",
		hueRange: [283, 334],
		lowerBounds: [
			[20, 100],
			[30, 90],
			[40, 86],
			[60, 84],
			[80, 80],
			[90, 75],
			[100, 73],
		],
	},
];
function dlv_es_default(_, et, tt, nt, rt) {
	for (et = et.split ? et.split(".") : et, nt = 0; nt < et.length; nt++) _ = _ ? _[et[nt]] : rt;
	return _ === rt ? tt : _;
}
var isEmptyObject = (_) => Object.keys(_).length === 0,
	getColor = (_, et, tt) => {
		const nt = dlv_es_default(_, `colors.${et}`, et),
			{ isValid: rt } = new TinyColor(nt);
		return rt ? nt : tt;
	},
	tone = (_) => (et) => {
		const tt = getColor(et, _);
		return new TinyColor(tt).isDark() ? "dark" : "light";
	},
	isDark = (_) => (et) => tone(_)(et) === "dark",
	transparentize = (_, et) => (tt) => {
		const nt = getColor(tt, _);
		return new TinyColor(nt).setAlpha(et).toRgbString();
	};
function generateStripe(_ = "1rem", et = "rgba(255, 255, 255, 0.15)") {
	return {
		backgroundImage: `linear-gradient(
    45deg,
    ${et} 25%,
    transparent 25%,
    transparent 50%,
    ${et} 50%,
    ${et} 75%,
    transparent 75%,
    transparent
  )`,
		backgroundSize: `${_} ${_}`,
	};
}
function randomColor(_) {
	const et = random().toHexString();
	return !_ || isEmptyObject(_)
		? et
		: _.string && _.colors
		? randomColorFromList(_.string, _.colors)
		: _.string && !_.colors
		? randomColorFromString(_.string)
		: _.colors && !_.string
		? randomFromList(_.colors)
		: et;
}
function randomColorFromString(_) {
	let et = 0;
	if (_.length === 0) return et.toString();
	for (let nt = 0; nt < _.length; nt += 1) (et = _.charCodeAt(nt) + ((et << 5) - et)), (et = et & et);
	let tt = "#";
	for (let nt = 0; nt < 3; nt += 1) tt += `00${((et >> (nt * 8)) & 255).toString(16)}`.substr(-2);
	return tt;
}
function randomColorFromList(_, et) {
	let tt = 0;
	if (_.length === 0) return et[0];
	for (let nt = 0; nt < _.length; nt += 1) (tt = _.charCodeAt(nt) + ((tt << 5) - tt)), (tt = tt & tt);
	return (tt = ((tt % et.length) + et.length) % et.length), et[tt];
}
function randomFromList(_) {
	return _[Math.floor(Math.random() * _.length)];
}
function mode(_, et) {
	return (tt) => (tt.colorMode === "dark" ? et : _);
}
function orient(_) {
	const { orientation: et, vertical: tt, horizontal: nt } = _;
	return et ? (et === "vertical" ? tt : nt) : {};
}
function isObject$4(_) {
	const et = typeof _;
	return _ != null && (et === "object" || et === "function") && !Array.isArray(_);
}
function toRef(_) {
	return isObject$4(_) && _.reference ? _.reference : String(_);
}
var toExpr = (_, ...et) => et.map(toRef).join(` ${_} `).replace(/calc/g, ""),
	add = (..._) => `calc(${toExpr("+", ..._)})`,
	subtract = (..._) => `calc(${toExpr("-", ..._)})`,
	multiply = (..._) => `calc(${toExpr("*", ..._)})`,
	divide = (..._) => `calc(${toExpr("/", ..._)})`,
	negate = (_) => {
		const et = toRef(_);
		return et != null && !Number.isNaN(parseFloat(et))
			? String(et).startsWith("-")
				? String(et).slice(1)
				: `-${et}`
			: multiply(et, -1);
	},
	calc = Object.assign(
		(_) => ({
			add: (...et) => calc(add(_, ...et)),
			subtract: (...et) => calc(subtract(_, ...et)),
			multiply: (...et) => calc(multiply(_, ...et)),
			divide: (...et) => calc(divide(_, ...et)),
			negate: () => calc(negate(_)),
			toString: () => _.toString(),
		}),
		{ add, subtract, multiply, divide, negate }
	);
function isDecimal(_) {
	return !Number.isInteger(parseFloat(_.toString()));
}
function replaceWhiteSpace(_, et = "-") {
	return _.replace(/\s+/g, et);
}
function escape(_) {
	const et = replaceWhiteSpace(_.toString());
	return et.includes("\\.") ? _ : isDecimal(_) ? et.replace(".", "\\.") : _;
}
function addPrefix(_, et = "") {
	return [et, escape(_)].filter(Boolean).join("-");
}
function toVarRef(_, et) {
	return `var(${escape(_)}${et ? `, ${et}` : ""})`;
}
function toVar(_, et = "") {
	return `--${addPrefix(_, et)}`;
}
function cssVar(_, et) {
	const tt = toVar(_, et == null ? void 0 : et.prefix);
	return { variable: tt, reference: toVarRef(tt, getFallback(et == null ? void 0 : et.fallback)) };
}
function getFallback(_) {
	return typeof _ == "string" ? _ : _ == null ? void 0 : _.reference;
}
var { definePartsStyle, defineMultiStyleConfig } = createMultiStyleConfigHelpers(accordionAnatomy.keys),
	baseStyleContainer = { borderTopWidth: "1px", borderColor: "inherit", _last: { borderBottomWidth: "1px" } },
	baseStyleButton = {
		transitionProperty: "common",
		transitionDuration: "normal",
		fontSize: "md",
		_focusVisible: { boxShadow: "outline" },
		_hover: { bg: "blackAlpha.50" },
		_disabled: { opacity: 0.4, cursor: "not-allowed" },
		px: "4",
		py: "2",
	},
	baseStylePanel = { pt: "2", px: "4", pb: "5" },
	baseStyleIcon = { fontSize: "1.25em" },
	baseStyle = definePartsStyle({
		container: baseStyleContainer,
		button: baseStyleButton,
		panel: baseStylePanel,
		icon: baseStyleIcon,
	}),
	accordionTheme = defineMultiStyleConfig({ baseStyle }),
	{ definePartsStyle: definePartsStyle2, defineMultiStyleConfig: defineMultiStyleConfig2 } =
		createMultiStyleConfigHelpers(alertAnatomy.keys),
	$fg = cssVar$1("alert-fg"),
	$bg = cssVar$1("alert-bg"),
	baseStyle2 = definePartsStyle2({
		container: { bg: $bg.reference, px: "4", py: "3" },
		title: { fontWeight: "bold", lineHeight: "6", marginEnd: "2" },
		description: { lineHeight: "6" },
		icon: { color: $fg.reference, flexShrink: 0, marginEnd: "3", w: "5", h: "6" },
		spinner: { color: $fg.reference, flexShrink: 0, marginEnd: "3", w: "5", h: "5" },
	});
function getBg(_) {
	const { theme: et, colorScheme: tt } = _,
		nt = getColor(et, `${tt}.100`, tt),
		rt = transparentize(`${tt}.200`, 0.16)(et);
	return mode(nt, rt)(_);
}
var variantSubtle = definePartsStyle2((_) => {
		const { colorScheme: et } = _,
			tt = mode(`${et}.500`, `${et}.200`)(_);
		return { container: { [$bg.variable]: getBg(_), [$fg.variable]: `colors.${tt}` } };
	}),
	variantLeftAccent = definePartsStyle2((_) => {
		const { colorScheme: et } = _,
			tt = mode(`${et}.500`, `${et}.200`)(_);
		return {
			container: {
				[$bg.variable]: getBg(_),
				[$fg.variable]: `colors.${tt}`,
				paddingStart: "3",
				borderStartWidth: "4px",
				borderStartColor: $fg.reference,
			},
		};
	}),
	variantTopAccent = definePartsStyle2((_) => {
		const { colorScheme: et } = _,
			tt = mode(`${et}.500`, `${et}.200`)(_);
		return {
			container: {
				[$bg.variable]: getBg(_),
				[$fg.variable]: `colors.${tt}`,
				pt: "2",
				borderTopWidth: "4px",
				borderTopColor: $fg.reference,
			},
		};
	}),
	variantSolid = definePartsStyle2((_) => {
		const { colorScheme: et } = _,
			tt = mode(`${et}.500`, `${et}.200`)(_),
			nt = mode("white", "gray.900")(_);
		return { container: { [$bg.variable]: `colors.${tt}`, [$fg.variable]: `colors.${nt}`, color: $fg.reference } };
	}),
	variants = {
		subtle: variantSubtle,
		"left-accent": variantLeftAccent,
		"top-accent": variantTopAccent,
		solid: variantSolid,
	},
	alertTheme = defineMultiStyleConfig2({
		baseStyle: baseStyle2,
		variants,
		defaultProps: { variant: "subtle", colorScheme: "blue" },
	}),
	spacing = {
		px: "1px",
		0.5: "0.125rem",
		1: "0.25rem",
		1.5: "0.375rem",
		2: "0.5rem",
		2.5: "0.625rem",
		3: "0.75rem",
		3.5: "0.875rem",
		4: "1rem",
		5: "1.25rem",
		6: "1.5rem",
		7: "1.75rem",
		8: "2rem",
		9: "2.25rem",
		10: "2.5rem",
		12: "3rem",
		14: "3.5rem",
		16: "4rem",
		20: "5rem",
		24: "6rem",
		28: "7rem",
		32: "8rem",
		36: "9rem",
		40: "10rem",
		44: "11rem",
		48: "12rem",
		52: "13rem",
		56: "14rem",
		60: "15rem",
		64: "16rem",
		72: "18rem",
		80: "20rem",
		96: "24rem",
	},
	largeSizes = {
		max: "max-content",
		min: "min-content",
		full: "100%",
		"3xs": "14rem",
		"2xs": "16rem",
		xs: "20rem",
		sm: "24rem",
		md: "28rem",
		lg: "32rem",
		xl: "36rem",
		"2xl": "42rem",
		"3xl": "48rem",
		"4xl": "56rem",
		"5xl": "64rem",
		"6xl": "72rem",
		"7xl": "80rem",
		"8xl": "90rem",
		prose: "60ch",
	},
	container = { sm: "640px", md: "768px", lg: "1024px", xl: "1280px" },
	sizes = { ...spacing, ...largeSizes, container },
	sizes_default = sizes,
	isFunction$5 = (_) => typeof _ == "function";
function runIfFn$1(_, ...et) {
	return isFunction$5(_) ? _(...et) : _;
}
var { definePartsStyle: definePartsStyle3, defineMultiStyleConfig: defineMultiStyleConfig3 } =
		createMultiStyleConfigHelpers(avatarAnatomy.keys),
	baseStyleBadge = (_) => ({ borderRadius: "full", border: "0.2em solid", borderColor: mode("white", "gray.800")(_) }),
	baseStyleExcessLabel = (_) => ({ bg: mode("gray.200", "whiteAlpha.400")(_) }),
	baseStyleContainer2 = (_) => {
		const { name: et, theme: tt } = _,
			nt = et ? randomColor({ string: et }) : "gray.400",
			rt = isDark(nt)(tt);
		let it = "white";
		rt || (it = "gray.800");
		const ot = mode("white", "gray.800")(_);
		return { bg: nt, color: it, borderColor: ot, verticalAlign: "top" };
	},
	baseStyle3 = definePartsStyle3((_) => ({
		badge: runIfFn$1(baseStyleBadge, _),
		excessLabel: runIfFn$1(baseStyleExcessLabel, _),
		container: runIfFn$1(baseStyleContainer2, _),
	}));
function getSize(_) {
	const et = _ !== "100%" ? sizes_default[_] : void 0;
	return definePartsStyle3({
		container: { width: _, height: _, fontSize: `calc(${et != null ? et : _} / 2.5)` },
		excessLabel: { width: _, height: _ },
		label: {
			fontSize: `calc(${et != null ? et : _} / 2.5)`,
			lineHeight: _ !== "100%" ? (et != null ? et : _) : void 0,
		},
	});
}
var sizes2 = {
		"2xs": getSize(4),
		xs: getSize(6),
		sm: getSize(8),
		md: getSize(12),
		lg: getSize(16),
		xl: getSize(24),
		"2xl": getSize(32),
		full: getSize("100%"),
	},
	avatarTheme = defineMultiStyleConfig3({ baseStyle: baseStyle3, sizes: sizes2, defaultProps: { size: "md" } }),
	baseStyle4 = { px: 1, textTransform: "uppercase", fontSize: "xs", borderRadius: "sm", fontWeight: "bold" },
	variantSolid2 = (_) => {
		const { colorScheme: et, theme: tt } = _,
			nt = transparentize(`${et}.500`, 0.6)(tt);
		return { bg: mode(`${et}.500`, nt)(_), color: mode("white", "whiteAlpha.800")(_) };
	},
	variantSubtle2 = (_) => {
		const { colorScheme: et, theme: tt } = _,
			nt = transparentize(`${et}.200`, 0.16)(tt);
		return { bg: mode(`${et}.100`, nt)(_), color: mode(`${et}.800`, `${et}.200`)(_) };
	},
	variantOutline = (_) => {
		const { colorScheme: et, theme: tt } = _,
			nt = transparentize(`${et}.200`, 0.8)(tt),
			rt = getColor(tt, `${et}.500`),
			it = mode(rt, nt)(_);
		return { color: it, boxShadow: `inset 0 0 0px 1px ${it}` };
	},
	variants2 = { solid: variantSolid2, subtle: variantSubtle2, outline: variantOutline },
	badgeTheme = { baseStyle: baseStyle4, variants: variants2, defaultProps: { variant: "subtle", colorScheme: "gray" } },
	{ defineMultiStyleConfig: defineMultiStyleConfig4, definePartsStyle: definePartsStyle4 } =
		createMultiStyleConfigHelpers(breadcrumbAnatomy.keys),
	baseStyleLink = {
		transitionProperty: "common",
		transitionDuration: "fast",
		transitionTimingFunction: "ease-out",
		cursor: "pointer",
		textDecoration: "none",
		outline: "none",
		color: "inherit",
		_hover: { textDecoration: "underline" },
		_focusVisible: { boxShadow: "outline" },
	},
	baseStyle5 = definePartsStyle4({ link: baseStyleLink }),
	breadcrumbTheme = defineMultiStyleConfig4({ baseStyle: baseStyle5 }),
	baseStyle6 = {
		lineHeight: "1.2",
		borderRadius: "md",
		fontWeight: "semibold",
		transitionProperty: "common",
		transitionDuration: "normal",
		_focusVisible: { boxShadow: "outline" },
		_disabled: { opacity: 0.4, cursor: "not-allowed", boxShadow: "none" },
		_hover: { _disabled: { bg: "initial" } },
	},
	variantGhost = (_) => {
		const { colorScheme: et, theme: tt } = _;
		if (et === "gray")
			return {
				color: mode("inherit", "whiteAlpha.900")(_),
				_hover: { bg: mode("gray.100", "whiteAlpha.200")(_) },
				_active: { bg: mode("gray.200", "whiteAlpha.300")(_) },
			};
		const nt = transparentize(`${et}.200`, 0.12)(tt),
			rt = transparentize(`${et}.200`, 0.24)(tt);
		return {
			color: mode(`${et}.600`, `${et}.200`)(_),
			bg: "transparent",
			_hover: { bg: mode(`${et}.50`, nt)(_) },
			_active: { bg: mode(`${et}.100`, rt)(_) },
		};
	},
	variantOutline2 = (_) => {
		const { colorScheme: et } = _,
			tt = mode("gray.200", "whiteAlpha.300")(_);
		return {
			border: "1px solid",
			borderColor: et === "gray" ? tt : "currentColor",
			".chakra-button__group[data-attached] > &:not(:last-of-type)": { marginEnd: "-1px" },
			...runIfFn$1(variantGhost, _),
		};
	},
	accessibleColorMap = {
		yellow: { bg: "yellow.400", color: "black", hoverBg: "yellow.500", activeBg: "yellow.600" },
		cyan: { bg: "cyan.400", color: "black", hoverBg: "cyan.500", activeBg: "cyan.600" },
	},
	variantSolid3 = (_) => {
		var at;
		const { colorScheme: et } = _;
		if (et === "gray") {
			const st = mode("gray.100", "whiteAlpha.200")(_);
			return {
				bg: st,
				_hover: { bg: mode("gray.200", "whiteAlpha.300")(_), _disabled: { bg: st } },
				_active: { bg: mode("gray.300", "whiteAlpha.400")(_) },
			};
		}
		const {
				bg: tt = `${et}.500`,
				color: nt = "white",
				hoverBg: rt = `${et}.600`,
				activeBg: it = `${et}.700`,
			} = (at = accessibleColorMap[et]) != null ? at : {},
			ot = mode(tt, `${et}.200`)(_);
		return {
			bg: ot,
			color: mode(nt, "gray.800")(_),
			_hover: { bg: mode(rt, `${et}.300`)(_), _disabled: { bg: ot } },
			_active: { bg: mode(it, `${et}.400`)(_) },
		};
	},
	variantLink = (_) => {
		const { colorScheme: et } = _;
		return {
			padding: 0,
			height: "auto",
			lineHeight: "normal",
			verticalAlign: "baseline",
			color: mode(`${et}.500`, `${et}.200`)(_),
			_hover: { textDecoration: "underline", _disabled: { textDecoration: "none" } },
			_active: { color: mode(`${et}.700`, `${et}.500`)(_) },
		};
	},
	variantUnstyled = { bg: "none", color: "inherit", display: "inline", lineHeight: "inherit", m: "0", p: "0" },
	variants3 = {
		ghost: variantGhost,
		outline: variantOutline2,
		solid: variantSolid3,
		link: variantLink,
		unstyled: variantUnstyled,
	},
	sizes3 = {
		lg: { h: "12", minW: "12", fontSize: "lg", px: "6" },
		md: { h: "10", minW: "10", fontSize: "md", px: "4" },
		sm: { h: "8", minW: "8", fontSize: "sm", px: "3" },
		xs: { h: "6", minW: "6", fontSize: "xs", px: "2" },
	},
	buttonTheme = {
		baseStyle: baseStyle6,
		variants: variants3,
		sizes: sizes3,
		defaultProps: { variant: "solid", size: "md", colorScheme: "gray" },
	},
	{ definePartsStyle: definePartsStyle5, defineMultiStyleConfig: defineMultiStyleConfig5 } =
		createMultiStyleConfigHelpers(checkboxAnatomy.keys),
	$size = cssVar$1("checkbox-size"),
	baseStyleControl = (_) => {
		const { colorScheme: et } = _;
		return {
			w: $size.reference,
			h: $size.reference,
			transitionProperty: "box-shadow",
			transitionDuration: "normal",
			border: "2px solid",
			borderRadius: "sm",
			borderColor: "inherit",
			color: "white",
			_checked: {
				bg: mode(`${et}.500`, `${et}.200`)(_),
				borderColor: mode(`${et}.500`, `${et}.200`)(_),
				color: mode("white", "gray.900")(_),
				_hover: { bg: mode(`${et}.600`, `${et}.300`)(_), borderColor: mode(`${et}.600`, `${et}.300`)(_) },
				_disabled: {
					borderColor: mode("gray.200", "transparent")(_),
					bg: mode("gray.200", "whiteAlpha.300")(_),
					color: mode("gray.500", "whiteAlpha.500")(_),
				},
			},
			_indeterminate: {
				bg: mode(`${et}.500`, `${et}.200`)(_),
				borderColor: mode(`${et}.500`, `${et}.200`)(_),
				color: mode("white", "gray.900")(_),
			},
			_disabled: { bg: mode("gray.100", "whiteAlpha.100")(_), borderColor: mode("gray.100", "transparent")(_) },
			_focusVisible: { boxShadow: "outline" },
			_invalid: { borderColor: mode("red.500", "red.300")(_) },
		};
	},
	baseStyleContainer3 = { _disabled: { cursor: "not-allowed" } },
	baseStyleLabel = { userSelect: "none", _disabled: { opacity: 0.4 } },
	baseStyleIcon2 = { transitionProperty: "transform", transitionDuration: "normal" },
	baseStyle7 = definePartsStyle5((_) => ({
		icon: baseStyleIcon2,
		container: baseStyleContainer3,
		control: runIfFn$1(baseStyleControl, _),
		label: baseStyleLabel,
	})),
	sizes4 = {
		sm: definePartsStyle5({
			control: { [$size.variable]: "sizes.3" },
			label: { fontSize: "sm" },
			icon: { fontSize: "3xs" },
		}),
		md: definePartsStyle5({
			control: { [$size.variable]: "sizes.4" },
			label: { fontSize: "md" },
			icon: { fontSize: "2xs" },
		}),
		lg: definePartsStyle5({
			control: { [$size.variable]: "sizes.5" },
			label: { fontSize: "lg" },
			icon: { fontSize: "2xs" },
		}),
	},
	checkboxTheme = defineMultiStyleConfig5({
		baseStyle: baseStyle7,
		sizes: sizes4,
		defaultProps: { size: "md", colorScheme: "blue" },
	}),
	$size2 = cssVar("close-button-size"),
	baseStyle8 = (_) => {
		const et = mode("blackAlpha.100", "whiteAlpha.100")(_),
			tt = mode("blackAlpha.200", "whiteAlpha.200")(_);
		return {
			w: [$size2.reference],
			h: [$size2.reference],
			borderRadius: "md",
			transitionProperty: "common",
			transitionDuration: "normal",
			_disabled: { opacity: 0.4, cursor: "not-allowed", boxShadow: "none" },
			_hover: { bg: et },
			_active: { bg: tt },
			_focusVisible: { boxShadow: "outline" },
		};
	},
	sizes5 = {
		lg: { [$size2.variable]: "sizes.10", fontSize: "md" },
		md: { [$size2.variable]: "sizes.8", fontSize: "xs" },
		sm: { [$size2.variable]: "sizes.6", fontSize: "2xs" },
	},
	closeButtonTheme = { baseStyle: baseStyle8, sizes: sizes5, defaultProps: { size: "md" } },
	{ variants: variants4, defaultProps } = badgeTheme,
	baseStyle9 = { fontFamily: "mono", fontSize: "sm", px: "0.2em", borderRadius: "sm" },
	codeTheme = { baseStyle: baseStyle9, variants: variants4, defaultProps },
	baseStyle10 = { w: "100%", mx: "auto", maxW: "prose", px: "4" },
	containerTheme = { baseStyle: baseStyle10 },
	baseStyle11 = { opacity: 0.6, borderColor: "inherit" },
	variantSolid4 = { borderStyle: "solid" },
	variantDashed = { borderStyle: "dashed" },
	variants5 = { solid: variantSolid4, dashed: variantDashed },
	dividerTheme = { baseStyle: baseStyle11, variants: variants5, defaultProps: { variant: "solid" } },
	{ definePartsStyle: definePartsStyle6, defineMultiStyleConfig: defineMultiStyleConfig6 } =
		createMultiStyleConfigHelpers(drawerAnatomy.keys);
function getSize2(_) {
	return definePartsStyle6(_ === "full" ? { dialog: { maxW: "100vw", h: "100vh" } } : { dialog: { maxW: _ } });
}
var baseStyleOverlay = { bg: "blackAlpha.600", zIndex: "overlay" },
	baseStyleDialogContainer = { display: "flex", zIndex: "modal", justifyContent: "center" },
	baseStyleDialog = (_) => {
		const { isFullHeight: et } = _;
		return {
			...(et && { height: "100vh" }),
			zIndex: "modal",
			maxH: "100vh",
			bg: mode("white", "gray.700")(_),
			color: "inherit",
			boxShadow: mode("lg", "dark-lg")(_),
		};
	},
	baseStyleHeader = { px: "6", py: "4", fontSize: "xl", fontWeight: "semibold" },
	baseStyleCloseButton = { position: "absolute", top: "2", insetEnd: "3" },
	baseStyleBody = { px: "6", py: "2", flex: "1", overflow: "auto" },
	baseStyleFooter = { px: "6", py: "4" },
	baseStyle12 = definePartsStyle6((_) => ({
		overlay: baseStyleOverlay,
		dialogContainer: baseStyleDialogContainer,
		dialog: runIfFn$1(baseStyleDialog, _),
		header: baseStyleHeader,
		closeButton: baseStyleCloseButton,
		body: baseStyleBody,
		footer: baseStyleFooter,
	})),
	sizes6 = {
		xs: getSize2("xs"),
		sm: getSize2("md"),
		md: getSize2("lg"),
		lg: getSize2("2xl"),
		xl: getSize2("4xl"),
		full: getSize2("full"),
	},
	drawerTheme = defineMultiStyleConfig6({ baseStyle: baseStyle12, sizes: sizes6, defaultProps: { size: "xs" } }),
	{ definePartsStyle: definePartsStyle7, defineMultiStyleConfig: defineMultiStyleConfig7 } =
		createMultiStyleConfigHelpers(editableAnatomy.keys),
	baseStylePreview = { borderRadius: "md", py: "1", transitionProperty: "common", transitionDuration: "normal" },
	baseStyleInput = {
		borderRadius: "md",
		py: "1",
		transitionProperty: "common",
		transitionDuration: "normal",
		width: "full",
		_focusVisible: { boxShadow: "outline" },
		_placeholder: { opacity: 0.6 },
	},
	baseStyleTextarea = {
		borderRadius: "md",
		py: "1",
		transitionProperty: "common",
		transitionDuration: "normal",
		width: "full",
		_focusVisible: { boxShadow: "outline" },
		_placeholder: { opacity: 0.6 },
	},
	baseStyle13 = definePartsStyle7({ preview: baseStylePreview, input: baseStyleInput, textarea: baseStyleTextarea }),
	editableTheme = defineMultiStyleConfig7({ baseStyle: baseStyle13 }),
	{ definePartsStyle: definePartsStyle8, defineMultiStyleConfig: defineMultiStyleConfig8 } =
		createMultiStyleConfigHelpers(formAnatomy.keys),
	baseStyleRequiredIndicator = (_) => ({ marginStart: "1", color: mode("red.500", "red.300")(_) }),
	baseStyleHelperText = (_) => ({
		mt: "2",
		color: mode("gray.600", "whiteAlpha.600")(_),
		lineHeight: "normal",
		fontSize: "sm",
	}),
	baseStyle14 = definePartsStyle8((_) => ({
		container: { width: "100%", position: "relative" },
		requiredIndicator: runIfFn$1(baseStyleRequiredIndicator, _),
		helperText: runIfFn$1(baseStyleHelperText, _),
	})),
	formTheme = defineMultiStyleConfig8({ baseStyle: baseStyle14 }),
	{ definePartsStyle: definePartsStyle9, defineMultiStyleConfig: defineMultiStyleConfig9 } =
		createMultiStyleConfigHelpers(formErrorAnatomy.keys),
	baseStyleText = (_) => ({ color: mode("red.500", "red.300")(_), mt: "2", fontSize: "sm", lineHeight: "normal" }),
	baseStyleIcon3 = (_) => ({ marginEnd: "0.5em", color: mode("red.500", "red.300")(_) }),
	baseStyle15 = definePartsStyle9((_) => ({ text: runIfFn$1(baseStyleText, _), icon: runIfFn$1(baseStyleIcon3, _) })),
	formErrorTheme = defineMultiStyleConfig9({ baseStyle: baseStyle15 }),
	baseStyle16 = {
		fontSize: "md",
		marginEnd: "3",
		mb: "2",
		fontWeight: "medium",
		transitionProperty: "common",
		transitionDuration: "normal",
		opacity: 1,
		_disabled: { opacity: 0.4 },
	},
	formLabelTheme = { baseStyle: baseStyle16 },
	baseStyle17 = { fontFamily: "heading", fontWeight: "bold" },
	sizes7 = {
		"4xl": { fontSize: ["6xl", null, "7xl"], lineHeight: 1 },
		"3xl": { fontSize: ["5xl", null, "6xl"], lineHeight: 1 },
		"2xl": { fontSize: ["4xl", null, "5xl"], lineHeight: [1.2, null, 1] },
		xl: { fontSize: ["3xl", null, "4xl"], lineHeight: [1.33, null, 1.2] },
		lg: { fontSize: ["2xl", null, "3xl"], lineHeight: [1.33, null, 1.2] },
		md: { fontSize: "xl", lineHeight: 1.2 },
		sm: { fontSize: "md", lineHeight: 1.2 },
		xs: { fontSize: "sm", lineHeight: 1.2 },
	},
	headingTheme = { baseStyle: baseStyle17, sizes: sizes7, defaultProps: { size: "xl" } },
	{ definePartsStyle: definePartsStyle10, defineMultiStyleConfig: defineMultiStyleConfig10 } =
		createMultiStyleConfigHelpers(inputAnatomy.keys),
	baseStyle18 = definePartsStyle10({
		field: {
			width: "100%",
			minWidth: 0,
			outline: 0,
			position: "relative",
			appearance: "none",
			transitionProperty: "common",
			transitionDuration: "normal",
			_disabled: { opacity: 0.4, cursor: "not-allowed" },
		},
	}),
	size = {
		lg: { fontSize: "lg", px: "4", h: "12", borderRadius: "md" },
		md: { fontSize: "md", px: "4", h: "10", borderRadius: "md" },
		sm: { fontSize: "sm", px: "3", h: "8", borderRadius: "sm" },
		xs: { fontSize: "xs", px: "2", h: "6", borderRadius: "sm" },
	},
	sizes8 = {
		lg: definePartsStyle10({ field: size.lg, addon: size.lg }),
		md: definePartsStyle10({ field: size.md, addon: size.md }),
		sm: definePartsStyle10({ field: size.sm, addon: size.sm }),
		xs: definePartsStyle10({ field: size.xs, addon: size.xs }),
	};
function getDefaults(_) {
	const { focusBorderColor: et, errorBorderColor: tt } = _;
	return {
		focusBorderColor: et || mode("blue.500", "blue.300")(_),
		errorBorderColor: tt || mode("red.500", "red.300")(_),
	};
}
var variantOutline3 = definePartsStyle10((_) => {
		const { theme: et } = _,
			{ focusBorderColor: tt, errorBorderColor: nt } = getDefaults(_);
		return {
			field: {
				border: "1px solid",
				borderColor: "inherit",
				bg: "inherit",
				_hover: { borderColor: mode("gray.300", "whiteAlpha.400")(_) },
				_readOnly: { boxShadow: "none !important", userSelect: "all" },
				_invalid: { borderColor: getColor(et, nt), boxShadow: `0 0 0 1px ${getColor(et, nt)}` },
				_focusVisible: { zIndex: 1, borderColor: getColor(et, tt), boxShadow: `0 0 0 1px ${getColor(et, tt)}` },
			},
			addon: {
				border: "1px solid",
				borderColor: mode("inherit", "whiteAlpha.50")(_),
				bg: mode("gray.100", "whiteAlpha.300")(_),
			},
		};
	}),
	variantFilled = definePartsStyle10((_) => {
		const { theme: et } = _,
			{ focusBorderColor: tt, errorBorderColor: nt } = getDefaults(_);
		return {
			field: {
				border: "2px solid",
				borderColor: "transparent",
				bg: mode("gray.100", "whiteAlpha.50")(_),
				_hover: { bg: mode("gray.200", "whiteAlpha.100")(_) },
				_readOnly: { boxShadow: "none !important", userSelect: "all" },
				_invalid: { borderColor: getColor(et, nt) },
				_focusVisible: { bg: "transparent", borderColor: getColor(et, tt) },
			},
			addon: { border: "2px solid", borderColor: "transparent", bg: mode("gray.100", "whiteAlpha.50")(_) },
		};
	}),
	variantFlushed = definePartsStyle10((_) => {
		const { theme: et } = _,
			{ focusBorderColor: tt, errorBorderColor: nt } = getDefaults(_);
		return {
			field: {
				borderBottom: "1px solid",
				borderColor: "inherit",
				borderRadius: "0",
				px: "0",
				bg: "transparent",
				_readOnly: { boxShadow: "none !important", userSelect: "all" },
				_invalid: { borderColor: getColor(et, nt), boxShadow: `0px 1px 0px 0px ${getColor(et, nt)}` },
				_focusVisible: { borderColor: getColor(et, tt), boxShadow: `0px 1px 0px 0px ${getColor(et, tt)}` },
			},
			addon: { borderBottom: "2px solid", borderColor: "inherit", borderRadius: "0", px: "0", bg: "transparent" },
		};
	}),
	variantUnstyled2 = definePartsStyle10({
		field: { bg: "transparent", px: "0", height: "auto" },
		addon: { bg: "transparent", px: "0", height: "auto" },
	}),
	variants6 = { outline: variantOutline3, filled: variantFilled, flushed: variantFlushed, unstyled: variantUnstyled2 },
	inputTheme = defineMultiStyleConfig10({
		baseStyle: baseStyle18,
		sizes: sizes8,
		variants: variants6,
		defaultProps: { size: "md", variant: "outline" },
	}),
	baseStyle19 = (_) => ({
		bg: mode("gray.100", "whiteAlpha")(_),
		borderRadius: "md",
		borderWidth: "1px",
		borderBottomWidth: "3px",
		fontSize: "0.8em",
		fontWeight: "bold",
		lineHeight: "normal",
		px: "0.4em",
		whiteSpace: "nowrap",
	}),
	kbdTheme = { baseStyle: baseStyle19 },
	baseStyle20 = {
		transitionProperty: "common",
		transitionDuration: "fast",
		transitionTimingFunction: "ease-out",
		cursor: "pointer",
		textDecoration: "none",
		outline: "none",
		color: "inherit",
		_hover: { textDecoration: "underline" },
		_focusVisible: { boxShadow: "outline" },
	},
	linkTheme = { baseStyle: baseStyle20 },
	{ defineMultiStyleConfig: defineMultiStyleConfig11, definePartsStyle: definePartsStyle11 } =
		createMultiStyleConfigHelpers(listAnatomy.keys),
	baseStyleIcon4 = { marginEnd: "2", display: "inline", verticalAlign: "text-bottom" },
	baseStyle21 = definePartsStyle11({ icon: baseStyleIcon4 }),
	listTheme = defineMultiStyleConfig11({ baseStyle: baseStyle21 }),
	{ defineMultiStyleConfig: defineMultiStyleConfig12, definePartsStyle: definePartsStyle12 } =
		createMultiStyleConfigHelpers(menuAnatomy.keys),
	baseStyleList = (_) => ({
		bg: mode("#fff", "gray.700")(_),
		boxShadow: mode("sm", "dark-lg")(_),
		color: "inherit",
		minW: "3xs",
		py: "2",
		zIndex: 1,
		borderRadius: "md",
		borderWidth: "1px",
	}),
	baseStyleItem = (_) => ({
		py: "1.5",
		px: "3",
		transitionProperty: "background",
		transitionDuration: "ultra-fast",
		transitionTimingFunction: "ease-in",
		_focus: { bg: mode("gray.100", "whiteAlpha.100")(_) },
		_active: { bg: mode("gray.200", "whiteAlpha.200")(_) },
		_expanded: { bg: mode("gray.100", "whiteAlpha.100")(_) },
		_disabled: { opacity: 0.4, cursor: "not-allowed" },
	}),
	baseStyleGroupTitle = { mx: 4, my: 2, fontWeight: "semibold", fontSize: "sm" },
	baseStyleCommand = { opacity: 0.6 },
	baseStyleDivider = { border: 0, borderBottom: "1px solid", borderColor: "inherit", my: "2", opacity: 0.6 },
	baseStyleButton2 = { transitionProperty: "common", transitionDuration: "normal" },
	baseStyle22 = definePartsStyle12((_) => ({
		button: baseStyleButton2,
		list: runIfFn$1(baseStyleList, _),
		item: runIfFn$1(baseStyleItem, _),
		groupTitle: baseStyleGroupTitle,
		command: baseStyleCommand,
		divider: baseStyleDivider,
	})),
	menuTheme = defineMultiStyleConfig12({ baseStyle: baseStyle22 }),
	{ defineMultiStyleConfig: defineMultiStyleConfig13, definePartsStyle: definePartsStyle13 } =
		createMultiStyleConfigHelpers(modalAnatomy.keys),
	baseStyleOverlay2 = { bg: "blackAlpha.600", zIndex: "modal" },
	baseStyleDialogContainer2 = (_) => {
		const { isCentered: et, scrollBehavior: tt } = _;
		return {
			display: "flex",
			zIndex: "modal",
			justifyContent: "center",
			alignItems: et ? "center" : "flex-start",
			overflow: tt === "inside" ? "hidden" : "auto",
		};
	},
	baseStyleDialog2 = (_) => {
		const { scrollBehavior: et } = _;
		return {
			borderRadius: "md",
			bg: mode("white", "gray.700")(_),
			color: "inherit",
			my: "16",
			zIndex: "modal",
			maxH: et === "inside" ? "calc(100% - 7.5rem)" : void 0,
			boxShadow: mode("lg", "dark-lg")(_),
		};
	},
	baseStyleHeader2 = { px: "6", py: "4", fontSize: "xl", fontWeight: "semibold" },
	baseStyleCloseButton2 = { position: "absolute", top: "2", insetEnd: "3" },
	baseStyleBody2 = (_) => {
		const { scrollBehavior: et } = _;
		return { px: "6", py: "2", flex: "1", overflow: et === "inside" ? "auto" : void 0 };
	},
	baseStyleFooter2 = { px: "6", py: "4" },
	baseStyle23 = definePartsStyle13((_) => ({
		overlay: baseStyleOverlay2,
		dialogContainer: runIfFn$1(baseStyleDialogContainer2, _),
		dialog: runIfFn$1(baseStyleDialog2, _),
		header: baseStyleHeader2,
		closeButton: baseStyleCloseButton2,
		body: runIfFn$1(baseStyleBody2, _),
		footer: baseStyleFooter2,
	}));
function getSize3(_) {
	return definePartsStyle13(
		_ === "full" ? { dialog: { maxW: "100vw", minH: "$100vh", my: "0", borderRadius: "0" } } : { dialog: { maxW: _ } }
	);
}
var sizes9 = {
		xs: getSize3("xs"),
		sm: getSize3("sm"),
		md: getSize3("md"),
		lg: getSize3("lg"),
		xl: getSize3("xl"),
		"2xl": getSize3("2xl"),
		"3xl": getSize3("3xl"),
		"4xl": getSize3("4xl"),
		"5xl": getSize3("5xl"),
		"6xl": getSize3("6xl"),
		full: getSize3("full"),
	},
	modalTheme = defineMultiStyleConfig13({ baseStyle: baseStyle23, sizes: sizes9, defaultProps: { size: "md" } }),
	typography = {
		letterSpacings: {
			tighter: "-0.05em",
			tight: "-0.025em",
			normal: "0",
			wide: "0.025em",
			wider: "0.05em",
			widest: "0.1em",
		},
		lineHeights: {
			normal: "normal",
			none: 1,
			shorter: 1.25,
			short: 1.375,
			base: 1.5,
			tall: 1.625,
			taller: "2",
			3: ".75rem",
			4: "1rem",
			5: "1.25rem",
			6: "1.5rem",
			7: "1.75rem",
			8: "2rem",
			9: "2.25rem",
			10: "2.5rem",
		},
		fontWeights: {
			hairline: 100,
			thin: 200,
			light: 300,
			normal: 400,
			medium: 500,
			semibold: 600,
			bold: 700,
			extrabold: 800,
			black: 900,
		},
		fonts: {
			heading:
				'-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
			body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
			mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace',
		},
		fontSizes: {
			"3xs": "0.45rem",
			"2xs": "0.625rem",
			xs: "0.75rem",
			sm: "0.875rem",
			md: "1rem",
			lg: "1.125rem",
			xl: "1.25rem",
			"2xl": "1.5rem",
			"3xl": "1.875rem",
			"4xl": "2.25rem",
			"5xl": "3rem",
			"6xl": "3.75rem",
			"7xl": "4.5rem",
			"8xl": "6rem",
			"9xl": "8rem",
		},
	},
	typography_default = typography,
	{ defineMultiStyleConfig: defineMultiStyleConfig14, definePartsStyle: definePartsStyle14 } =
		createMultiStyleConfigHelpers(numberInputAnatomy.keys),
	$stepperWidth = cssVar("number-input-stepper-width"),
	$inputPadding = cssVar("number-input-input-padding"),
	inputPaddingValue = calc($stepperWidth).add("0.5rem").toString(),
	baseStyleRoot = { [$stepperWidth.variable]: "sizes.6", [$inputPadding.variable]: inputPaddingValue },
	baseStyleField = (_) => {
		var tt;
		var et;
		return (tt = (et = runIfFn$1(inputTheme.baseStyle, _)) == null ? void 0 : et.field) != null ? tt : {};
	},
	baseStyleStepperGroup = { width: [$stepperWidth.reference] },
	baseStyleStepper = (_) => ({
		borderStart: "1px solid",
		borderStartColor: mode("inherit", "whiteAlpha.300")(_),
		color: mode("inherit", "whiteAlpha.800")(_),
		_active: { bg: mode("gray.200", "whiteAlpha.300")(_) },
		_disabled: { opacity: 0.4, cursor: "not-allowed" },
	}),
	baseStyle24 = definePartsStyle14((_) => {
		var et;
		return {
			root: baseStyleRoot,
			field: baseStyleField,
			stepperGroup: baseStyleStepperGroup,
			stepper: (et = runIfFn$1(baseStyleStepper, _)) != null ? et : {},
		};
	});
function getSize4(_) {
	var at;
	var et, tt;
	const nt = (et = inputTheme.sizes) == null ? void 0 : et[_],
		rt = { lg: "md", md: "md", sm: "sm", xs: "sm" },
		it = (at = (tt = nt.field) == null ? void 0 : tt.fontSize) != null ? at : "md",
		ot = typography_default.fontSizes[it];
	return definePartsStyle14({
		field: { ...nt.field, paddingInlineEnd: $inputPadding.reference, verticalAlign: "top" },
		stepper: {
			fontSize: calc(ot).multiply(0.75).toString(),
			_first: { borderTopEndRadius: rt[_] },
			_last: { borderBottomEndRadius: rt[_], mt: "-1px", borderTopWidth: 1 },
		},
	});
}
var sizes10 = { xs: getSize4("xs"), sm: getSize4("sm"), md: getSize4("md"), lg: getSize4("lg") },
	numberInputTheme = defineMultiStyleConfig14({
		baseStyle: baseStyle24,
		sizes: sizes10,
		variants: inputTheme.variants,
		defaultProps: inputTheme.defaultProps,
	}),
	_a$1,
	baseStyle25 = { ...((_a$1 = inputTheme.baseStyle) == null ? void 0 : _a$1.field), textAlign: "center" },
	sizes11 = {
		lg: { fontSize: "lg", w: 12, h: 12, borderRadius: "md" },
		md: { fontSize: "md", w: 10, h: 10, borderRadius: "md" },
		sm: { fontSize: "sm", w: 8, h: 8, borderRadius: "sm" },
		xs: { fontSize: "xs", w: 6, h: 6, borderRadius: "sm" },
	},
	_a2,
	mr,
	variants7 = {
		outline: (_) => {
			var nt;
			var et, tt;
			return (nt =
				(tt = runIfFn$1((et = inputTheme.variants) == null ? void 0 : et.outline, _)) == null ? void 0 : tt.field) !=
				null
				? nt
				: {};
		},
		flushed: (_) => {
			var nt;
			var et, tt;
			return (nt =
				(tt = runIfFn$1((et = inputTheme.variants) == null ? void 0 : et.flushed, _)) == null ? void 0 : tt.field) !=
				null
				? nt
				: {};
		},
		filled: (_) => {
			var nt;
			var et, tt;
			return (nt =
				(tt = runIfFn$1((et = inputTheme.variants) == null ? void 0 : et.filled, _)) == null ? void 0 : tt.field) !=
				null
				? nt
				: {};
		},
		unstyled: (mr = (_a2 = inputTheme.variants) == null ? void 0 : _a2.unstyled.field) != null ? mr : {},
	},
	pinInputTheme = {
		baseStyle: baseStyle25,
		sizes: sizes11,
		variants: variants7,
		defaultProps: inputTheme.defaultProps,
	},
	{ defineMultiStyleConfig: defineMultiStyleConfig15, definePartsStyle: definePartsStyle15 } =
		createMultiStyleConfigHelpers(popoverAnatomy.keys),
	$popperBg = cssVar("popper-bg"),
	$arrowBg = cssVar("popper-arrow-bg"),
	$arrowShadowColor = cssVar("popper-arrow-shadow-color"),
	baseStylePopper = { zIndex: 10 },
	baseStyleContent = (_) => {
		const et = mode("white", "gray.700")(_),
			tt = mode("gray.200", "whiteAlpha.300")(_);
		return {
			[$popperBg.variable]: `colors.${et}`,
			bg: $popperBg.reference,
			[$arrowBg.variable]: $popperBg.reference,
			[$arrowShadowColor.variable]: `colors.${tt}`,
			width: "xs",
			border: "1px solid",
			borderColor: "inherit",
			borderRadius: "md",
			boxShadow: "sm",
			zIndex: "inherit",
			_focusVisible: { outline: 0, boxShadow: "outline" },
		};
	},
	baseStyleHeader3 = { px: 3, py: 2, borderBottomWidth: "1px" },
	baseStyleBody3 = { px: 3, py: 2 },
	baseStyleFooter3 = { px: 3, py: 2, borderTopWidth: "1px" },
	baseStyleCloseButton3 = { position: "absolute", borderRadius: "md", top: 1, insetEnd: 2, padding: 2 },
	baseStyle26 = definePartsStyle15((_) => ({
		popper: baseStylePopper,
		content: baseStyleContent(_),
		header: baseStyleHeader3,
		body: baseStyleBody3,
		footer: baseStyleFooter3,
		closeButton: baseStyleCloseButton3,
	})),
	popoverTheme = defineMultiStyleConfig15({ baseStyle: baseStyle26 }),
	{ defineMultiStyleConfig: defineMultiStyleConfig16, definePartsStyle: definePartsStyle16 } =
		createMultiStyleConfigHelpers(progressAnatomy.keys),
	filledStyle = (_) => {
		const { colorScheme: et, theme: tt, isIndeterminate: nt, hasStripe: rt } = _,
			it = mode(generateStripe(), generateStripe("1rem", "rgba(0,0,0,0.1)"))(_),
			ot = mode(`${et}.500`, `${et}.200`)(_),
			at = `linear-gradient(
    to right,
    transparent 0%,
    ${getColor(tt, ot)} 50%,
    transparent 100%
  )`;
		return { ...(!nt && rt && it), ...(nt ? { bgImage: at } : { bgColor: ot }) };
	},
	baseStyleLabel2 = { lineHeight: "1", fontSize: "0.25em", fontWeight: "bold", color: "white" },
	baseStyleTrack = (_) => ({ bg: mode("gray.100", "whiteAlpha.300")(_) }),
	baseStyleFilledTrack = (_) => ({ transitionProperty: "common", transitionDuration: "slow", ...filledStyle(_) }),
	baseStyle27 = definePartsStyle16((_) => ({
		label: baseStyleLabel2,
		filledTrack: baseStyleFilledTrack(_),
		track: baseStyleTrack(_),
	})),
	sizes12 = {
		xs: definePartsStyle16({ track: { h: "1" } }),
		sm: definePartsStyle16({ track: { h: "2" } }),
		md: definePartsStyle16({ track: { h: "3" } }),
		lg: definePartsStyle16({ track: { h: "4" } }),
	},
	progressTheme = defineMultiStyleConfig16({
		sizes: sizes12,
		baseStyle: baseStyle27,
		defaultProps: { size: "md", colorScheme: "blue" },
	}),
	{ defineMultiStyleConfig: defineMultiStyleConfig17, definePartsStyle: definePartsStyle17 } =
		createMultiStyleConfigHelpers(radioAnatomy.keys),
	baseStyleControl2 = (_) => {
		var et;
		const tt = (et = runIfFn$1(checkboxTheme.baseStyle, _)) == null ? void 0 : et.control;
		return {
			...tt,
			borderRadius: "full",
			_checked: {
				...(tt == null ? void 0 : tt._checked),
				_before: {
					content: '""',
					display: "inline-block",
					pos: "relative",
					w: "50%",
					h: "50%",
					borderRadius: "50%",
					bg: "currentColor",
				},
			},
		};
	},
	baseStyle28 = definePartsStyle17((_) => {
		var et, tt, nt, rt;
		return {
			label: (tt = (et = checkboxTheme).baseStyle) == null ? void 0 : tt.call(et, _).label,
			container: (rt = (nt = checkboxTheme).baseStyle) == null ? void 0 : rt.call(nt, _).container,
			control: baseStyleControl2(_),
		};
	}),
	sizes13 = {
		md: definePartsStyle17({ control: { w: "4", h: "4" }, label: { fontSize: "md" } }),
		lg: definePartsStyle17({ control: { w: "5", h: "5" }, label: { fontSize: "lg" } }),
		sm: definePartsStyle17({ control: { width: "3", height: "3" }, label: { fontSize: "sm" } }),
	},
	radioTheme = defineMultiStyleConfig17({
		baseStyle: baseStyle28,
		sizes: sizes13,
		defaultProps: { size: "md", colorScheme: "blue" },
	}),
	{ defineMultiStyleConfig: defineMultiStyleConfig18, definePartsStyle: definePartsStyle18 } =
		createMultiStyleConfigHelpers(selectAnatomy.keys),
	baseStyleField2 = (_) => {
		var et;
		return {
			...((et = inputTheme.baseStyle) == null ? void 0 : et.field),
			bg: mode("white", "gray.700")(_),
			appearance: "none",
			paddingBottom: "1px",
			lineHeight: "normal",
			"> option, > optgroup": { bg: mode("white", "gray.700")(_) },
		};
	},
	baseStyleIcon5 = {
		width: "6",
		height: "100%",
		insetEnd: "2",
		position: "relative",
		color: "currentColor",
		fontSize: "xl",
		_disabled: { opacity: 0.5 },
	},
	baseStyle29 = definePartsStyle18((_) => ({ field: baseStyleField2(_), icon: baseStyleIcon5 })),
	iconSpacing = { paddingInlineEnd: "8" },
	_a3,
	_b,
	_c,
	_d,
	_e,
	_f,
	_g,
	_h,
	sizes14 = {
		lg: {
			...((_a3 = inputTheme.sizes) == null ? void 0 : _a3.lg),
			field: { ...((_b = inputTheme.sizes) == null ? void 0 : _b.lg.field), ...iconSpacing },
		},
		md: {
			...((_c = inputTheme.sizes) == null ? void 0 : _c.md),
			field: { ...((_d = inputTheme.sizes) == null ? void 0 : _d.md.field), ...iconSpacing },
		},
		sm: {
			...((_e = inputTheme.sizes) == null ? void 0 : _e.sm),
			field: { ...((_f = inputTheme.sizes) == null ? void 0 : _f.sm.field), ...iconSpacing },
		},
		xs: {
			...((_g = inputTheme.sizes) == null ? void 0 : _g.xs),
			field: { ...((_h = inputTheme.sizes) == null ? void 0 : _h.sm.field), ...iconSpacing },
			icon: { insetEnd: "1" },
		},
	},
	selectTheme = defineMultiStyleConfig18({
		baseStyle: baseStyle29,
		sizes: sizes14,
		variants: inputTheme.variants,
		defaultProps: inputTheme.defaultProps,
	}),
	$startColor = cssVar$1("skeleton-start-color"),
	$endColor = cssVar$1("skeleton-end-color"),
	baseStyle30 = (_) => {
		const et = mode("gray.100", "gray.800")(_),
			tt = mode("gray.400", "gray.600")(_),
			{ startColor: nt = et, endColor: rt = tt, theme: it } = _,
			ot = getColor(it, nt),
			at = getColor(it, rt);
		return {
			[$startColor.variable]: ot,
			[$endColor.variable]: at,
			opacity: 0.7,
			borderRadius: "2px",
			borderColor: ot,
			background: at,
		};
	},
	skeletonTheme = { baseStyle: baseStyle30 },
	baseStyle31 = (_) => ({
		borderRadius: "md",
		fontWeight: "semibold",
		_focusVisible: {
			boxShadow: "outline",
			padding: "4",
			position: "fixed",
			top: "6",
			insetStart: "6",
			bg: mode("white", "gray.700")(_),
		},
	}),
	skipLinkTheme = { baseStyle: baseStyle31 },
	{ defineMultiStyleConfig: defineMultiStyleConfig19, definePartsStyle: definePartsStyle19 } =
		createMultiStyleConfigHelpers(sliderAnatomy.keys),
	$thumbSize = cssVar$1("slider-thumb-size"),
	$trackSize = cssVar$1("slider-track-size"),
	baseStyleContainer4 = (_) => {
		const { orientation: et } = _;
		return {
			display: "inline-block",
			position: "relative",
			cursor: "pointer",
			_disabled: { opacity: 0.6, cursor: "default", pointerEvents: "none" },
			...orient({ orientation: et, vertical: { h: "100%" }, horizontal: { w: "100%" } }),
		};
	},
	baseStyleTrack2 = (_) => ({
		...orient({
			orientation: _.orientation,
			horizontal: { h: $trackSize.reference },
			vertical: { w: $trackSize.reference },
		}),
		overflow: "hidden",
		borderRadius: "sm",
		bg: mode("gray.200", "whiteAlpha.200")(_),
		_disabled: { bg: mode("gray.300", "whiteAlpha.300")(_) },
	}),
	baseStyleThumb = (_) => {
		const { orientation: et } = _;
		return {
			...orient({
				orientation: et,
				vertical: {
					left: "50%",
					transform: "translateX(-50%)",
					_active: { transform: "translateX(-50%) scale(1.15)" },
				},
				horizontal: {
					top: "50%",
					transform: "translateY(-50%)",
					_active: { transform: "translateY(-50%) scale(1.15)" },
				},
			}),
			w: $thumbSize.reference,
			h: $thumbSize.reference,
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			position: "absolute",
			outline: 0,
			zIndex: 1,
			borderRadius: "full",
			bg: "white",
			boxShadow: "base",
			border: "1px solid",
			borderColor: "transparent",
			transitionProperty: "transform",
			transitionDuration: "normal",
			_focusVisible: { boxShadow: "outline" },
			_disabled: { bg: "gray.300" },
		};
	},
	baseStyleFilledTrack2 = (_) => {
		const { colorScheme: et } = _;
		return { width: "inherit", height: "inherit", bg: mode(`${et}.500`, `${et}.200`)(_) };
	},
	baseStyle32 = definePartsStyle19((_) => ({
		container: baseStyleContainer4(_),
		track: baseStyleTrack2(_),
		thumb: baseStyleThumb(_),
		filledTrack: baseStyleFilledTrack2(_),
	})),
	sizeLg = definePartsStyle19({ container: { [$thumbSize.variable]: "sizes.4", [$trackSize.variable]: "sizes.1" } }),
	sizeMd = definePartsStyle19({ container: { [$thumbSize.variable]: "sizes.3.5", [$trackSize.variable]: "sizes.1" } }),
	sizeSm = definePartsStyle19({
		container: { [$thumbSize.variable]: "sizes.2.5", [$trackSize.variable]: "sizes.0.5" },
	}),
	sizes15 = { lg: sizeLg, md: sizeMd, sm: sizeSm },
	sliderTheme = defineMultiStyleConfig19({
		baseStyle: baseStyle32,
		sizes: sizes15,
		defaultProps: { size: "md", colorScheme: "blue" },
	}),
	$size3 = cssVar("spinner-size"),
	baseStyle33 = { width: [$size3.reference], height: [$size3.reference] },
	sizes16 = {
		xs: { [$size3.variable]: "sizes.3" },
		sm: { [$size3.variable]: "sizes.4" },
		md: { [$size3.variable]: "sizes.6" },
		lg: { [$size3.variable]: "sizes.8" },
		xl: { [$size3.variable]: "sizes.12" },
	},
	spinnerTheme = { baseStyle: baseStyle33, sizes: sizes16, defaultProps: { size: "md" } },
	{ defineMultiStyleConfig: defineMultiStyleConfig20, definePartsStyle: definePartsStyle20 } =
		createMultiStyleConfigHelpers(statAnatomy.keys),
	baseStyleLabel3 = { fontWeight: "medium" },
	baseStyleHelpText = { opacity: 0.8, marginBottom: "2" },
	baseStyleNumber = { verticalAlign: "baseline", fontWeight: "semibold" },
	baseStyleIcon6 = { marginEnd: 1, w: "3.5", h: "3.5", verticalAlign: "middle" },
	baseStyle34 = definePartsStyle20({
		container: {},
		label: baseStyleLabel3,
		helpText: baseStyleHelpText,
		number: baseStyleNumber,
		icon: baseStyleIcon6,
	}),
	sizes17 = {
		md: definePartsStyle20({ label: { fontSize: "sm" }, helpText: { fontSize: "sm" }, number: { fontSize: "2xl" } }),
	},
	statTheme = defineMultiStyleConfig20({ baseStyle: baseStyle34, sizes: sizes17, defaultProps: { size: "md" } }),
	{ defineMultiStyleConfig: defineMultiStyleConfig21, definePartsStyle: definePartsStyle21 } =
		createMultiStyleConfigHelpers(switchAnatomy.keys),
	$width = cssVar("switch-track-width"),
	$height = cssVar("switch-track-height"),
	$diff = cssVar("switch-track-diff"),
	diffValue = calc.subtract($width, $height),
	$translateX = cssVar("switch-thumb-x"),
	baseStyleTrack3 = (_) => {
		const { colorScheme: et } = _;
		return {
			borderRadius: "full",
			p: "0.5",
			width: [$width.reference],
			height: [$height.reference],
			transitionProperty: "common",
			transitionDuration: "fast",
			bg: mode("gray.300", "whiteAlpha.400")(_),
			_focusVisible: { boxShadow: "outline" },
			_disabled: { opacity: 0.4, cursor: "not-allowed" },
			_checked: { bg: mode(`${et}.500`, `${et}.200`)(_) },
		};
	},
	baseStyleThumb2 = {
		bg: "white",
		transitionProperty: "transform",
		transitionDuration: "normal",
		borderRadius: "inherit",
		width: [$height.reference],
		height: [$height.reference],
		_checked: { transform: `translateX(${$translateX.reference})` },
	},
	baseStyle35 = definePartsStyle21((_) => ({
		container: {
			[$diff.variable]: diffValue,
			[$translateX.variable]: $diff.reference,
			_rtl: { [$translateX.variable]: calc($diff).negate().toString() },
		},
		track: baseStyleTrack3(_),
		thumb: baseStyleThumb2,
	})),
	sizes18 = {
		sm: definePartsStyle21({ container: { [$width.variable]: "1.375rem", [$height.variable]: "sizes.3" } }),
		md: definePartsStyle21({ container: { [$width.variable]: "1.875rem", [$height.variable]: "sizes.4" } }),
		lg: definePartsStyle21({ container: { [$width.variable]: "2.875rem", [$height.variable]: "sizes.6" } }),
	},
	switchTheme = defineMultiStyleConfig21({
		baseStyle: baseStyle35,
		sizes: sizes18,
		defaultProps: { size: "md", colorScheme: "blue" },
	}),
	{ defineMultiStyleConfig: defineMultiStyleConfig22, definePartsStyle: definePartsStyle22 } =
		createMultiStyleConfigHelpers(tableAnatomy.keys),
	baseStyle36 = definePartsStyle22({
		table: { fontVariantNumeric: "lining-nums tabular-nums", borderCollapse: "collapse", width: "full" },
		th: {
			fontFamily: "heading",
			fontWeight: "bold",
			textTransform: "uppercase",
			letterSpacing: "wider",
			textAlign: "start",
		},
		td: { textAlign: "start" },
		caption: { mt: 4, fontFamily: "heading", textAlign: "center", fontWeight: "medium" },
	}),
	numericStyles = { "&[data-is-numeric=true]": { textAlign: "end" } },
	variantSimple = definePartsStyle22((_) => {
		const { colorScheme: et } = _;
		return {
			th: {
				color: mode("gray.600", "gray.400")(_),
				borderBottom: "1px",
				borderColor: mode(`${et}.100`, `${et}.700`)(_),
				...numericStyles,
			},
			td: { borderBottom: "1px", borderColor: mode(`${et}.100`, `${et}.700`)(_), ...numericStyles },
			caption: { color: mode("gray.600", "gray.100")(_) },
			tfoot: { tr: { "&:last-of-type": { th: { borderBottomWidth: 0 } } } },
		};
	}),
	variantStripe = definePartsStyle22((_) => {
		const { colorScheme: et } = _;
		return {
			th: {
				color: mode("gray.600", "gray.400")(_),
				borderBottom: "1px",
				borderColor: mode(`${et}.100`, `${et}.700`)(_),
				...numericStyles,
			},
			td: { borderBottom: "1px", borderColor: mode(`${et}.100`, `${et}.700`)(_), ...numericStyles },
			caption: { color: mode("gray.600", "gray.100")(_) },
			tbody: {
				tr: {
					"&:nth-of-type(odd)": {
						"th, td": { borderBottomWidth: "1px", borderColor: mode(`${et}.100`, `${et}.700`)(_) },
						td: { background: mode(`${et}.100`, `${et}.700`)(_) },
					},
				},
			},
			tfoot: { tr: { "&:last-of-type": { th: { borderBottomWidth: 0 } } } },
		};
	}),
	variants8 = { simple: variantSimple, striped: variantStripe, unstyled: {} },
	sizes19 = {
		sm: definePartsStyle22({
			th: { px: "4", py: "1", lineHeight: "4", fontSize: "xs" },
			td: { px: "4", py: "2", fontSize: "sm", lineHeight: "4" },
			caption: { px: "4", py: "2", fontSize: "xs" },
		}),
		md: definePartsStyle22({
			th: { px: "6", py: "3", lineHeight: "4", fontSize: "xs" },
			td: { px: "6", py: "4", lineHeight: "5" },
			caption: { px: "6", py: "2", fontSize: "sm" },
		}),
		lg: definePartsStyle22({
			th: { px: "8", py: "4", lineHeight: "5", fontSize: "sm" },
			td: { px: "8", py: "5", lineHeight: "6" },
			caption: { px: "6", py: "2", fontSize: "md" },
		}),
	},
	tableTheme = defineMultiStyleConfig22({
		baseStyle: baseStyle36,
		variants: variants8,
		sizes: sizes19,
		defaultProps: { variant: "simple", size: "md", colorScheme: "gray" },
	}),
	{ defineMultiStyleConfig: defineMultiStyleConfig23, definePartsStyle: definePartsStyle23 } =
		createMultiStyleConfigHelpers(tabsAnatomy.keys),
	baseStyleRoot2 = (_) => {
		const { orientation: et } = _;
		return { display: et === "vertical" ? "flex" : "block" };
	},
	baseStyleTab = (_) => {
		const { isFitted: et } = _;
		return {
			flex: et ? 1 : void 0,
			transitionProperty: "common",
			transitionDuration: "normal",
			_focusVisible: { zIndex: 1, boxShadow: "outline" },
			_disabled: { cursor: "not-allowed", opacity: 0.4 },
		};
	},
	baseStyleTablist = (_) => {
		const { align: et = "start", orientation: tt } = _;
		return {
			justifyContent: { end: "flex-end", center: "center", start: "flex-start" }[et],
			flexDirection: tt === "vertical" ? "column" : "row",
		};
	},
	baseStyleTabpanel = { p: 4 },
	baseStyle37 = definePartsStyle23((_) => ({
		root: baseStyleRoot2(_),
		tab: baseStyleTab(_),
		tablist: baseStyleTablist(_),
		tabpanel: baseStyleTabpanel,
	})),
	sizes20 = {
		sm: definePartsStyle23({ tab: { py: 1, px: 4, fontSize: "sm" } }),
		md: definePartsStyle23({ tab: { fontSize: "md", py: 2, px: 4 } }),
		lg: definePartsStyle23({ tab: { fontSize: "lg", py: 3, px: 4 } }),
	},
	variantLine = definePartsStyle23((_) => {
		const { colorScheme: et, orientation: tt } = _,
			nt = tt === "vertical",
			rt = tt === "vertical" ? "borderStart" : "borderBottom",
			it = nt ? "marginStart" : "marginBottom";
		return {
			tablist: { [rt]: "2px solid", borderColor: "inherit" },
			tab: {
				[rt]: "2px solid",
				borderColor: "transparent",
				[it]: "-2px",
				_selected: { color: mode(`${et}.600`, `${et}.300`)(_), borderColor: "currentColor" },
				_active: { bg: mode("gray.200", "whiteAlpha.300")(_) },
				_disabled: { _active: { bg: "none" } },
			},
		};
	}),
	variantEnclosed = definePartsStyle23((_) => {
		const { colorScheme: et } = _;
		return {
			tab: {
				borderTopRadius: "md",
				border: "1px solid",
				borderColor: "transparent",
				mb: "-1px",
				_selected: {
					color: mode(`${et}.600`, `${et}.300`)(_),
					borderColor: "inherit",
					borderBottomColor: mode("white", "gray.800")(_),
				},
			},
			tablist: { mb: "-1px", borderBottom: "1px solid", borderColor: "inherit" },
		};
	}),
	variantEnclosedColored = definePartsStyle23((_) => {
		const { colorScheme: et } = _;
		return {
			tab: {
				border: "1px solid",
				borderColor: "inherit",
				bg: mode("gray.50", "whiteAlpha.50")(_),
				mb: "-1px",
				_notLast: { marginEnd: "-1px" },
				_selected: {
					bg: mode("#fff", "gray.800")(_),
					color: mode(`${et}.600`, `${et}.300`)(_),
					borderColor: "inherit",
					borderTopColor: "currentColor",
					borderBottomColor: "transparent",
				},
			},
			tablist: { mb: "-1px", borderBottom: "1px solid", borderColor: "inherit" },
		};
	}),
	variantSoftRounded = definePartsStyle23((_) => {
		const { colorScheme: et, theme: tt } = _;
		return {
			tab: {
				borderRadius: "full",
				fontWeight: "semibold",
				color: "gray.600",
				_selected: { color: getColor(tt, `${et}.700`), bg: getColor(tt, `${et}.100`) },
			},
		};
	}),
	variantSolidRounded = definePartsStyle23((_) => {
		const { colorScheme: et } = _;
		return {
			tab: {
				borderRadius: "full",
				fontWeight: "semibold",
				color: mode("gray.600", "inherit")(_),
				_selected: { color: mode("#fff", "gray.800")(_), bg: mode(`${et}.600`, `${et}.300`)(_) },
			},
		};
	}),
	variantUnstyled3 = definePartsStyle23({}),
	variants9 = {
		line: variantLine,
		enclosed: variantEnclosed,
		"enclosed-colored": variantEnclosedColored,
		"soft-rounded": variantSoftRounded,
		"solid-rounded": variantSolidRounded,
		unstyled: variantUnstyled3,
	},
	tabsTheme = defineMultiStyleConfig23({
		baseStyle: baseStyle37,
		sizes: sizes20,
		variants: variants9,
		defaultProps: { size: "md", variant: "line", colorScheme: "blue" },
	}),
	{ defineMultiStyleConfig: defineMultiStyleConfig24, definePartsStyle: definePartsStyle24 } =
		createMultiStyleConfigHelpers(tagAnatomy.keys),
	baseStyleContainer5 = {
		fontWeight: "medium",
		lineHeight: 1.2,
		outline: 0,
		borderRadius: "md",
		_focusVisible: { boxShadow: "outline" },
	},
	baseStyleLabel4 = { lineHeight: 1.2, overflow: "visible" },
	baseStyleCloseButton4 = {
		fontSize: "lg",
		w: "5",
		h: "5",
		transitionProperty: "common",
		transitionDuration: "normal",
		borderRadius: "full",
		marginStart: "1.5",
		marginEnd: "-1",
		opacity: 0.5,
		_disabled: { opacity: 0.4 },
		_focusVisible: { boxShadow: "outline", bg: "rgba(0, 0, 0, 0.14)" },
		_hover: { opacity: 0.8 },
		_active: { opacity: 1 },
	},
	baseStyle38 = definePartsStyle24({
		container: baseStyleContainer5,
		label: baseStyleLabel4,
		closeButton: baseStyleCloseButton4,
	}),
	sizes21 = {
		sm: definePartsStyle24({
			container: { minH: "5", minW: "5", fontSize: "xs", px: "2" },
			closeButton: { marginEnd: "-2px", marginStart: "0.35rem" },
		}),
		md: definePartsStyle24({ container: { minH: "6", minW: "6", fontSize: "sm", px: "2" } }),
		lg: definePartsStyle24({ container: { minH: "8", minW: "8", fontSize: "md", px: "3" } }),
	},
	variants10 = {
		subtle: definePartsStyle24((_) => {
			var et;
			return { container: (et = badgeTheme.variants) == null ? void 0 : et.subtle(_) };
		}),
		solid: definePartsStyle24((_) => {
			var et;
			return { container: (et = badgeTheme.variants) == null ? void 0 : et.solid(_) };
		}),
		outline: definePartsStyle24((_) => {
			var et;
			return { container: (et = badgeTheme.variants) == null ? void 0 : et.outline(_) };
		}),
	},
	tagTheme = defineMultiStyleConfig24({
		variants: variants10,
		baseStyle: baseStyle38,
		sizes: sizes21,
		defaultProps: { size: "md", variant: "subtle", colorScheme: "gray" },
	}),
	_a4,
	baseStyle39 = {
		...((_a4 = inputTheme.baseStyle) == null ? void 0 : _a4.field),
		paddingY: "2",
		minHeight: "20",
		lineHeight: "short",
		verticalAlign: "top",
	},
	_a5,
	gr,
	variants11 = {
		outline: (_) => {
			var tt;
			var et;
			return (tt = (et = inputTheme.variants) == null ? void 0 : et.outline(_).field) != null ? tt : {};
		},
		flushed: (_) => {
			var tt;
			var et;
			return (tt = (et = inputTheme.variants) == null ? void 0 : et.flushed(_).field) != null ? tt : {};
		},
		filled: (_) => {
			var tt;
			var et;
			return (tt = (et = inputTheme.variants) == null ? void 0 : et.filled(_).field) != null ? tt : {};
		},
		unstyled: (gr = (_a5 = inputTheme.variants) == null ? void 0 : _a5.unstyled.field) != null ? gr : {},
	},
	_a6,
	_b2,
	_c2,
	_d2,
	yr,
	vr,
	br,
	xr,
	sizes22 = {
		xs: (yr = (_a6 = inputTheme.sizes) == null ? void 0 : _a6.xs.field) != null ? yr : {},
		sm: (vr = (_b2 = inputTheme.sizes) == null ? void 0 : _b2.sm.field) != null ? vr : {},
		md: (br = (_c2 = inputTheme.sizes) == null ? void 0 : _c2.md.field) != null ? br : {},
		lg: (xr = (_d2 = inputTheme.sizes) == null ? void 0 : _d2.lg.field) != null ? xr : {},
	},
	textareaTheme = {
		baseStyle: baseStyle39,
		sizes: sizes22,
		variants: variants11,
		defaultProps: { size: "md", variant: "outline" },
	},
	$bg2 = cssVar("tooltip-bg"),
	$fg2 = cssVar("tooltip-fg"),
	$arrowBg2 = cssVar("popper-arrow-bg"),
	baseStyle40 = (_) => {
		const et = mode("gray.700", "gray.300")(_),
			tt = mode("whiteAlpha.900", "gray.900")(_);
		return {
			bg: $bg2.reference,
			color: $fg2.reference,
			[$bg2.variable]: `colors.${et}`,
			[$fg2.variable]: `colors.${tt}`,
			[$arrowBg2.variable]: $bg2.reference,
			px: "2",
			py: "0.5",
			borderRadius: "sm",
			fontWeight: "medium",
			fontSize: "sm",
			boxShadow: "md",
			maxW: "xs",
			zIndex: "tooltip",
		};
	},
	tooltipTheme = { baseStyle: baseStyle40 },
	components$1 = {
		Accordion: accordionTheme,
		Alert: alertTheme,
		Avatar: avatarTheme,
		Badge: badgeTheme,
		Breadcrumb: breadcrumbTheme,
		Button: buttonTheme,
		Checkbox: checkboxTheme,
		CloseButton: closeButtonTheme,
		Code: codeTheme,
		Container: containerTheme,
		Divider: dividerTheme,
		Drawer: drawerTheme,
		Editable: editableTheme,
		Form: formTheme,
		FormError: formErrorTheme,
		FormLabel: formLabelTheme,
		Heading: headingTheme,
		Input: inputTheme,
		Kbd: kbdTheme,
		Link: linkTheme,
		List: listTheme,
		Menu: menuTheme,
		Modal: modalTheme,
		NumberInput: numberInputTheme,
		PinInput: pinInputTheme,
		Popover: popoverTheme,
		Progress: progressTheme,
		Radio: radioTheme,
		Select: selectTheme,
		Skeleton: skeletonTheme,
		SkipLink: skipLinkTheme,
		Slider: sliderTheme,
		Spinner: spinnerTheme,
		Stat: statTheme,
		Switch: switchTheme,
		Table: tableTheme,
		Tabs: tabsTheme,
		Tag: tagTheme,
		Textarea: textareaTheme,
		Tooltip: tooltipTheme,
	},
	borders = { none: 0, "1px": "1px solid", "2px": "2px solid", "4px": "4px solid", "8px": "8px solid" },
	borders_default = borders,
	breakpoints = { base: "0em", sm: "30em", md: "48em", lg: "62em", xl: "80em", "2xl": "96em" },
	breakpoints_default = breakpoints,
	colors = {
		transparent: "transparent",
		current: "currentColor",
		black: "#000000",
		white: "#FFFFFF",
		whiteAlpha: {
			50: "rgba(255, 255, 255, 0.04)",
			100: "rgba(255, 255, 255, 0.06)",
			200: "rgba(255, 255, 255, 0.08)",
			300: "rgba(255, 255, 255, 0.16)",
			400: "rgba(255, 255, 255, 0.24)",
			500: "rgba(255, 255, 255, 0.36)",
			600: "rgba(255, 255, 255, 0.48)",
			700: "rgba(255, 255, 255, 0.64)",
			800: "rgba(255, 255, 255, 0.80)",
			900: "rgba(255, 255, 255, 0.92)",
		},
		blackAlpha: {
			50: "rgba(0, 0, 0, 0.04)",
			100: "rgba(0, 0, 0, 0.06)",
			200: "rgba(0, 0, 0, 0.08)",
			300: "rgba(0, 0, 0, 0.16)",
			400: "rgba(0, 0, 0, 0.24)",
			500: "rgba(0, 0, 0, 0.36)",
			600: "rgba(0, 0, 0, 0.48)",
			700: "rgba(0, 0, 0, 0.64)",
			800: "rgba(0, 0, 0, 0.80)",
			900: "rgba(0, 0, 0, 0.92)",
		},
		gray: {
			50: "#F7FAFC",
			100: "#EDF2F7",
			200: "#E2E8F0",
			300: "#CBD5E0",
			400: "#A0AEC0",
			500: "#718096",
			600: "#4A5568",
			700: "#2D3748",
			800: "#1A202C",
			900: "#171923",
		},
		red: {
			50: "#FFF5F5",
			100: "#FED7D7",
			200: "#FEB2B2",
			300: "#FC8181",
			400: "#F56565",
			500: "#E53E3E",
			600: "#C53030",
			700: "#9B2C2C",
			800: "#822727",
			900: "#63171B",
		},
		orange: {
			50: "#FFFAF0",
			100: "#FEEBC8",
			200: "#FBD38D",
			300: "#F6AD55",
			400: "#ED8936",
			500: "#DD6B20",
			600: "#C05621",
			700: "#9C4221",
			800: "#7B341E",
			900: "#652B19",
		},
		yellow: {
			50: "#FFFFF0",
			100: "#FEFCBF",
			200: "#FAF089",
			300: "#F6E05E",
			400: "#ECC94B",
			500: "#D69E2E",
			600: "#B7791F",
			700: "#975A16",
			800: "#744210",
			900: "#5F370E",
		},
		green: {
			50: "#F0FFF4",
			100: "#C6F6D5",
			200: "#9AE6B4",
			300: "#68D391",
			400: "#48BB78",
			500: "#38A169",
			600: "#2F855A",
			700: "#276749",
			800: "#22543D",
			900: "#1C4532",
		},
		teal: {
			50: "#E6FFFA",
			100: "#B2F5EA",
			200: "#81E6D9",
			300: "#4FD1C5",
			400: "#38B2AC",
			500: "#319795",
			600: "#2C7A7B",
			700: "#285E61",
			800: "#234E52",
			900: "#1D4044",
		},
		blue: {
			50: "#ebf8ff",
			100: "#bee3f8",
			200: "#90cdf4",
			300: "#63b3ed",
			400: "#4299e1",
			500: "#3182ce",
			600: "#2b6cb0",
			700: "#2c5282",
			800: "#2a4365",
			900: "#1A365D",
		},
		cyan: {
			50: "#EDFDFD",
			100: "#C4F1F9",
			200: "#9DECF9",
			300: "#76E4F7",
			400: "#0BC5EA",
			500: "#00B5D8",
			600: "#00A3C4",
			700: "#0987A0",
			800: "#086F83",
			900: "#065666",
		},
		purple: {
			50: "#FAF5FF",
			100: "#E9D8FD",
			200: "#D6BCFA",
			300: "#B794F4",
			400: "#9F7AEA",
			500: "#805AD5",
			600: "#6B46C1",
			700: "#553C9A",
			800: "#44337A",
			900: "#322659",
		},
		pink: {
			50: "#FFF5F7",
			100: "#FED7E2",
			200: "#FBB6CE",
			300: "#F687B3",
			400: "#ED64A6",
			500: "#D53F8C",
			600: "#B83280",
			700: "#97266D",
			800: "#702459",
			900: "#521B41",
		},
		linkedin: {
			50: "#E8F4F9",
			100: "#CFEDFB",
			200: "#9BDAF3",
			300: "#68C7EC",
			400: "#34B3E4",
			500: "#00A0DC",
			600: "#008CC9",
			700: "#0077B5",
			800: "#005E93",
			900: "#004471",
		},
		facebook: {
			50: "#E8F4F9",
			100: "#D9DEE9",
			200: "#B7C2DA",
			300: "#6482C0",
			400: "#4267B2",
			500: "#385898",
			600: "#314E89",
			700: "#29487D",
			800: "#223B67",
			900: "#1E355B",
		},
		messenger: {
			50: "#D0E6FF",
			100: "#B9DAFF",
			200: "#A2CDFF",
			300: "#7AB8FF",
			400: "#2E90FF",
			500: "#0078FF",
			600: "#0063D1",
			700: "#0052AC",
			800: "#003C7E",
			900: "#002C5C",
		},
		whatsapp: {
			50: "#dffeec",
			100: "#b9f5d0",
			200: "#90edb3",
			300: "#65e495",
			400: "#3cdd78",
			500: "#22c35e",
			600: "#179848",
			700: "#0c6c33",
			800: "#01421c",
			900: "#001803",
		},
		twitter: {
			50: "#E5F4FD",
			100: "#C8E9FB",
			200: "#A8DCFA",
			300: "#83CDF7",
			400: "#57BBF5",
			500: "#1DA1F2",
			600: "#1A94DA",
			700: "#1681BF",
			800: "#136B9E",
			900: "#0D4D71",
		},
		telegram: {
			50: "#E3F2F9",
			100: "#C5E4F3",
			200: "#A2D4EC",
			300: "#7AC1E4",
			400: "#47A9DA",
			500: "#0088CC",
			600: "#007AB8",
			700: "#006BA1",
			800: "#005885",
			900: "#003F5E",
		},
	},
	colors_default = colors,
	radii = {
		none: "0",
		sm: "0.125rem",
		base: "0.25rem",
		md: "0.375rem",
		lg: "0.5rem",
		xl: "0.75rem",
		"2xl": "1rem",
		"3xl": "1.5rem",
		full: "9999px",
	},
	radius_default = radii,
	shadows = {
		xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
		sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
		base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
		md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
		lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
		xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
		"2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
		outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
		inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
		none: "none",
		"dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px",
	},
	shadows_default = shadows,
	transitionProperty = {
		common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
		colors: "background-color, border-color, color, fill, stroke",
		dimensions: "width, height",
		position: "left, right, top, bottom",
		background: "background-color, background-image, background-position",
	},
	transitionTimingFunction = {
		"ease-in": "cubic-bezier(0.4, 0, 1, 1)",
		"ease-out": "cubic-bezier(0, 0, 0.2, 1)",
		"ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)",
	},
	transitionDuration = {
		"ultra-fast": "50ms",
		faster: "100ms",
		fast: "150ms",
		normal: "200ms",
		slow: "300ms",
		slower: "400ms",
		"ultra-slow": "500ms",
	},
	transition = { property: transitionProperty, easing: transitionTimingFunction, duration: transitionDuration },
	transition_default = transition,
	zIndices = {
		hide: -1,
		auto: "auto",
		base: 0,
		docked: 10,
		dropdown: 1e3,
		sticky: 1100,
		banner: 1200,
		overlay: 1300,
		modal: 1400,
		popover: 1500,
		skipLink: 1600,
		toast: 1700,
		tooltip: 1800,
	},
	z_index_default = zIndices,
	blur = { none: 0, sm: "4px", base: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" },
	blur_default = blur,
	foundations = {
		breakpoints: breakpoints_default,
		zIndices: z_index_default,
		radii: radius_default,
		blur: blur_default,
		colors: colors_default,
		...typography_default,
		sizes: sizes_default,
		shadows: shadows_default,
		space: spacing,
		borders: borders_default,
		transition: transition_default,
	},
	semanticTokens = {
		colors: {
			"chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
			"chakra-body-bg": { _light: "white", _dark: "gray.800" },
			"chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
			"chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" },
		},
	},
	styles = {
		global: {
			body: {
				fontFamily: "body",
				color: "chakra-body-text",
				bg: "chakra-body-bg",
				transitionProperty: "background-color",
				transitionDuration: "normal",
				lineHeight: "base",
			},
			"*::placeholder": { color: "chakra-placeholder-color" },
			"*, *::before, &::after": { borderColor: "chakra-border-color", wordWrap: "break-word" },
		},
	};
function isObject$3(_) {
	const et = typeof _;
	return _ != null && (et === "object" || et === "function") && !Array.isArray(_);
}
var requiredChakraThemeKeys = [
	"borders",
	"breakpoints",
	"colors",
	"components",
	"config",
	"direction",
	"fonts",
	"fontSizes",
	"fontWeights",
	"letterSpacings",
	"lineHeights",
	"radii",
	"shadows",
	"sizes",
	"space",
	"styles",
	"transition",
	"zIndices",
];
function isChakraTheme(_) {
	return isObject$3(_) ? requiredChakraThemeKeys.every((et) => Object.prototype.hasOwnProperty.call(_, et)) : !1;
}
var direction = "ltr",
	config$2 = { useSystemColorMode: !1, initialColorMode: "light", cssVarPrefix: "chakra" },
	theme = { semanticTokens, direction, ...foundations, components: components$1, styles, config: config$2 };
function useTimeout(_, et) {
	const tt = useCallbackRef$2(_);
	react.exports.useEffect(() => {
		if (et == null) return;
		let nt = null;
		return (
			(nt = window.setTimeout(() => {
				tt();
			}, et)),
			() => {
				nt && window.clearTimeout(nt);
			}
		);
	}, [et, tt]);
}
function runIfFn(_, ...et) {
	return isFunction$4(_) ? _(...et) : _;
}
var isFunction$4 = (_) => typeof _ == "function",
	findById = (_, et) => _.find((tt) => tt.id === et);
function findToast(_, et) {
	const tt = getToastPosition(_, et),
		nt = tt ? _[tt].findIndex((rt) => rt.id === et) : -1;
	return { position: tt, index: nt };
}
function getToastPosition(_, et) {
	for (const [tt, nt] of Object.entries(_)) if (findById(nt, et)) return tt;
}
function getToastStyle(_) {
	const et = _.includes("right"),
		tt = _.includes("left");
	let nt = "center";
	return (
		et && (nt = "flex-end"), tt && (nt = "flex-start"), { display: "flex", flexDirection: "column", alignItems: nt }
	);
}
function getToastListStyle(_) {
	const tt = _ === "top" || _ === "bottom" ? "0 auto" : void 0,
		nt = _.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0,
		rt = _.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0,
		it = _.includes("left") ? void 0 : "env(safe-area-inset-right, 0px)",
		ot = _.includes("right") ? void 0 : "env(safe-area-inset-left, 0px)";
	return {
		position: "fixed",
		zIndex: 5500,
		pointerEvents: "none",
		display: "flex",
		flexDirection: "column",
		margin: tt,
		top: nt,
		bottom: rt,
		right: it,
		left: ot,
	};
}
var initialState$2 = { top: [], "top-left": [], "top-right": [], "bottom-left": [], bottom: [], "bottom-right": [] },
	toastStore = createStore(initialState$2);
function createStore(_) {
	let et = _;
	const tt = new Set(),
		nt = (rt) => {
			(et = rt(et)), tt.forEach((it) => it());
		};
	return {
		getState: () => et,
		subscribe: (rt) => (
			tt.add(rt),
			() => {
				nt(() => _), tt.delete(rt);
			}
		),
		removeToast: (rt, it) => {
			nt((ot) => ({ ...ot, [it]: ot[it].filter((at) => at.id != rt) }));
		},
		notify: (rt, it) => {
			const ot = createToast(rt, it),
				{ position: at, id: st } = ot;
			return (
				nt((lt) => {
					var ct, ft;
					const dt = at.includes("top")
						? [ot, ...((ct = lt[at]) != null ? ct : [])]
						: [...((ft = lt[at]) != null ? ft : []), ot];
					return { ...lt, [at]: dt };
				}),
				st
			);
		},
		update: (rt, it) => {
			!rt ||
				nt((ot) => {
					const at = { ...ot },
						{ position: st, index: lt } = findToast(at, rt);
					return st && lt !== -1 && (at[st][lt] = { ...at[st][lt], ...it, message: createRenderToast(it) }), at;
				});
		},
		closeAll: ({ positions: rt } = {}) => {
			nt((it) => {
				const ot = ["bottom", "bottom-right", "bottom-left", "top", "top-left", "top-right"];
				return (rt != null ? rt : ot).reduce(
					(st, lt) => ((st[lt] = it[lt].map((ut) => ({ ...ut, requestClose: !0 }))), st),
					{ ...it }
				);
			});
		},
		close: (rt) => {
			nt((it) => {
				const ot = getToastPosition(it, rt);
				return ot ? { ...it, [ot]: it[ot].map((at) => (at.id == rt ? { ...at, requestClose: !0 } : at)) } : it;
			});
		},
		isActive: (rt) => Boolean(findToast(toastStore.getState(), rt).position),
	};
}
var counter$1 = 0;
function createToast(_, et = {}) {
	var rt, it;
	counter$1 += 1;
	const tt = (rt = et.id) != null ? rt : counter$1,
		nt = (it = et.position) != null ? it : "bottom";
	return {
		id: tt,
		message: _,
		position: nt,
		duration: et.duration,
		onCloseComplete: et.onCloseComplete,
		onRequestRemove: () => toastStore.removeToast(String(tt), nt),
		status: et.status,
		requestClose: !1,
		containerStyle: et.containerStyle,
	};
}
var Toast = (_) => {
	const {
			status: et,
			variant: tt = "solid",
			id: nt,
			title: rt,
			isClosable: it,
			onClose: ot,
			description: at,
			icon: st,
		} = _,
		lt = nt ? { root: `toast-${nt}`, title: `toast-${nt}-title`, description: `toast-${nt}-description` } : void 0;
	return React$1.createElement(
		Alert,
		{
			addRole: !1,
			status: et,
			variant: tt,
			id: lt == null ? void 0 : lt.root,
			alignItems: "start",
			borderRadius: "md",
			boxShadow: "lg",
			paddingEnd: 8,
			textAlign: "start",
			width: "auto",
		},
		jsx(AlertIcon, { children: st }),
		React$1.createElement(
			chakra.div,
			{ flex: "1", maxWidth: "100%" },
			rt && jsx(AlertTitle, { id: lt == null ? void 0 : lt.title, children: rt }),
			at && jsx(AlertDescription, { id: lt == null ? void 0 : lt.description, display: "block", children: at })
		),
		it && jsx(CloseButton, { size: "sm", onClick: ot, position: "absolute", insetEnd: 1, top: 1 })
	);
};
function createRenderToast(_ = {}) {
	const { render: et, toastComponent: tt = Toast } = _;
	return (rt) => (typeof et == "function" ? et(rt) : jsx(tt, { ...rt, ..._ }));
}
var toastMotionVariants = {
		initial: (_) => {
			const { position: et } = _,
				tt = ["top", "bottom"].includes(et) ? "y" : "x";
			let nt = ["top-right", "bottom-right"].includes(et) ? 1 : -1;
			return et === "bottom" && (nt = 1), { opacity: 0, [tt]: nt * 24 };
		},
		animate: { opacity: 1, y: 0, x: 0, scale: 1, transition: { duration: 0.4, ease: [0.4, 0, 0.2, 1] } },
		exit: { opacity: 0, scale: 0.85, transition: { duration: 0.2, ease: [0.4, 0, 1, 1] } },
	},
	ToastComponent = react.exports.memo((_) => {
		const {
				id: et,
				message: tt,
				onCloseComplete: nt,
				onRequestRemove: rt,
				requestClose: it = !1,
				position: ot = "bottom",
				duration: at = 5e3,
				containerStyle: st,
				motionVariants: lt = toastMotionVariants,
				toastSpacing: ut = "0.5rem",
			} = _,
			[dt, ct] = react.exports.useState(at),
			ft = useIsPresent();
		useUpdateEffect$1(() => {
			ft || nt == null || nt();
		}, [ft]),
			useUpdateEffect$1(() => {
				ct(at);
			}, [at]);
		const mt = () => ct(null),
			pt = () => ct(at),
			vt = () => {
				ft && rt();
			};
		react.exports.useEffect(() => {
			ft && it && rt();
		}, [ft, it, rt]),
			useTimeout(vt, dt);
		const ht = react.exports.useMemo(
				() => ({ pointerEvents: "auto", maxWidth: 560, minWidth: 300, margin: ut, ...st }),
				[st, ut]
			),
			gt = react.exports.useMemo(() => getToastStyle(ot), [ot]);
		return React$1.createElement(
			motion.li,
			{
				layout: !0,
				className: "chakra-toast",
				variants: lt,
				initial: "initial",
				animate: "animate",
				exit: "exit",
				onHoverStart: mt,
				onHoverEnd: pt,
				custom: { position: ot },
				style: gt,
			},
			React$1.createElement(
				chakra.div,
				{ role: "status", "aria-atomic": "true", className: "chakra-toast__inner", __css: ht },
				runIfFn(tt, { id: et, onClose: vt })
			)
		);
	});
ToastComponent.displayName = "ToastComponent";
var ToastProvider = (_) => {
		const et = react.exports.useSyncExternalStore(toastStore.subscribe, toastStore.getState, toastStore.getState),
			{ children: tt, motionVariants: nt, component: rt = ToastComponent, portalProps: it } = _,
			at = Object.keys(et).map((st) => {
				const lt = et[st];
				return jsx(
					"ul",
					{
						role: "region",
						"aria-live": "polite",
						id: `chakra-toast-manager-${st}`,
						style: getToastListStyle(st),
						children: jsx(AnimatePresence, {
							initial: !1,
							children: lt.map((ut) => jsx(rt, { motionVariants: nt, ...ut }, ut.id)),
						}),
					},
					st
				);
			});
		return jsxs(Fragment, { children: [tt, jsx(Portal, { ...it, children: at })] });
	},
	ChakraProvider$1 = (_) => {
		const {
				children: et,
				colorModeManager: tt,
				portalZIndex: nt,
				resetCSS: rt = !0,
				theme: it = {},
				environment: ot,
				cssVarsRoot: at,
			} = _,
			st = jsx(EnvironmentProvider, { environment: ot, children: et });
		return jsx(ThemeProvider, {
			theme: it,
			cssVarsRoot: at,
			children: jsxs(ColorModeProvider, {
				colorModeManager: tt,
				options: it.config,
				children: [
					rt ? jsx(CSSReset, {}) : jsx(CSSPolyfill, {}),
					jsx(GlobalStyle, {}),
					nt ? jsx(PortalManager, { zIndex: nt, children: st }) : st,
				],
			}),
		});
	};
function ChakraProvider({ children: _, theme: et = theme, toastOptions: tt, ...nt }) {
	return jsxs(ChakraProvider$1, { theme: et, ...nt, children: [_, jsx(ToastProvider, { ...tt })] });
}
function extendTheme(..._) {
	let et = [..._],
		tt = _[_.length - 1];
	return (
		isChakraTheme(tt) && et.length > 1 ? (et = et.slice(0, et.length - 1)) : (tt = theme),
		pipe$1(...et.map((nt) => (rt) => isFunction$8(nt) ? nt(rt) : mergeThemeOverride(rt, nt)))(tt)
	);
}
function mergeThemeOverride(..._) {
	return mergeWith({}, ..._, mergeThemeCustomizer);
}
function mergeThemeCustomizer(_, et, tt, nt) {
	if ((isFunction$8(_) || isFunction$8(et)) && Object.prototype.hasOwnProperty.call(nt, tt))
		return (...rt) => {
			const it = isFunction$8(_) ? _(...rt) : _,
				ot = isFunction$8(et) ? et(...rt) : et;
			return mergeWith({}, it, ot, mergeThemeCustomizer);
		};
}
var config$1 = { attributes: !0, characterData: !0, subtree: !0, childList: !0 };
function useMutationObserver(_, et, tt = config$1) {
	react.exports.useEffect(() => {
		if (_.current) {
			const nt = new MutationObserver(et);
			return (
				nt.observe(_.current, tt),
				() => {
					nt.disconnect();
				}
			);
		}
	}, [et, tt]);
}
var MapShim = (function () {
		if (typeof Map < "u") return Map;
		function _(et, tt) {
			var nt = -1;
			return (
				et.some(function (rt, it) {
					return rt[0] === tt ? ((nt = it), !0) : !1;
				}),
				nt
			);
		}
		return (function () {
			function et() {
				this.__entries__ = [];
			}
			return (
				Object.defineProperty(et.prototype, "size", {
					get: function () {
						return this.__entries__.length;
					},
					enumerable: !0,
					configurable: !0,
				}),
				(et.prototype.get = function (tt) {
					var nt = _(this.__entries__, tt),
						rt = this.__entries__[nt];
					return rt && rt[1];
				}),
				(et.prototype.set = function (tt, nt) {
					var rt = _(this.__entries__, tt);
					~rt ? (this.__entries__[rt][1] = nt) : this.__entries__.push([tt, nt]);
				}),
				(et.prototype.delete = function (tt) {
					var nt = this.__entries__,
						rt = _(nt, tt);
					~rt && nt.splice(rt, 1);
				}),
				(et.prototype.has = function (tt) {
					return !!~_(this.__entries__, tt);
				}),
				(et.prototype.clear = function () {
					this.__entries__.splice(0);
				}),
				(et.prototype.forEach = function (tt, nt) {
					nt === void 0 && (nt = null);
					for (var rt = 0, it = this.__entries__; rt < it.length; rt++) {
						var ot = it[rt];
						tt.call(nt, ot[1], ot[0]);
					}
				}),
				et
			);
		})();
	})(),
	isBrowser = typeof window < "u" && typeof document < "u" && window.document === document,
	global$1 = (function () {
		return typeof global < "u" && global.Math === Math
			? global
			: typeof self < "u" && self.Math === Math
			? self
			: typeof window < "u" && window.Math === Math
			? window
			: Function("return this")();
	})(),
	requestAnimationFrame$1 = (function () {
		return typeof requestAnimationFrame == "function"
			? requestAnimationFrame.bind(global$1)
			: function (_) {
					return setTimeout(function () {
						return _(Date.now());
					}, 1e3 / 60);
			  };
	})(),
	trailingTimeout = 2;
function throttle(_, et) {
	var tt = !1,
		nt = !1,
		rt = 0;
	function it() {
		tt && ((tt = !1), _()), nt && at();
	}
	function ot() {
		requestAnimationFrame$1(it);
	}
	function at() {
		var st = Date.now();
		if (tt) {
			if (st - rt < trailingTimeout) return;
			nt = !0;
		} else (tt = !0), (nt = !1), setTimeout(ot, et);
		rt = st;
	}
	return at;
}
var REFRESH_DELAY = 20,
	transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
	mutationObserverSupported = typeof MutationObserver < "u",
	ResizeObserverController = (function () {
		function _() {
			(this.connected_ = !1),
				(this.mutationEventsAdded_ = !1),
				(this.mutationsObserver_ = null),
				(this.observers_ = []),
				(this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
				(this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY));
		}
		return (
			(_.prototype.addObserver = function (et) {
				~this.observers_.indexOf(et) || this.observers_.push(et), this.connected_ || this.connect_();
			}),
			(_.prototype.removeObserver = function (et) {
				var tt = this.observers_,
					nt = tt.indexOf(et);
				~nt && tt.splice(nt, 1), !tt.length && this.connected_ && this.disconnect_();
			}),
			(_.prototype.refresh = function () {
				var et = this.updateObservers_();
				et && this.refresh();
			}),
			(_.prototype.updateObservers_ = function () {
				var et = this.observers_.filter(function (tt) {
					return tt.gatherActive(), tt.hasActive();
				});
				return (
					et.forEach(function (tt) {
						return tt.broadcastActive();
					}),
					et.length > 0
				);
			}),
			(_.prototype.connect_ = function () {
				!isBrowser ||
					this.connected_ ||
					(document.addEventListener("transitionend", this.onTransitionEnd_),
					window.addEventListener("resize", this.refresh),
					mutationObserverSupported
						? ((this.mutationsObserver_ = new MutationObserver(this.refresh)),
						  this.mutationsObserver_.observe(document, {
								attributes: !0,
								childList: !0,
								characterData: !0,
								subtree: !0,
						  }))
						: (document.addEventListener("DOMSubtreeModified", this.refresh), (this.mutationEventsAdded_ = !0)),
					(this.connected_ = !0));
			}),
			(_.prototype.disconnect_ = function () {
				!isBrowser ||
					!this.connected_ ||
					(document.removeEventListener("transitionend", this.onTransitionEnd_),
					window.removeEventListener("resize", this.refresh),
					this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
					this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh),
					(this.mutationsObserver_ = null),
					(this.mutationEventsAdded_ = !1),
					(this.connected_ = !1));
			}),
			(_.prototype.onTransitionEnd_ = function (et) {
				var tt = et.propertyName,
					nt = tt === void 0 ? "" : tt,
					rt = transitionKeys.some(function (it) {
						return !!~nt.indexOf(it);
					});
				rt && this.refresh();
			}),
			(_.getInstance = function () {
				return this.instance_ || (this.instance_ = new _()), this.instance_;
			}),
			(_.instance_ = null),
			_
		);
	})(),
	defineConfigurable = function (_, et) {
		for (var tt = 0, nt = Object.keys(et); tt < nt.length; tt++) {
			var rt = nt[tt];
			Object.defineProperty(_, rt, { value: et[rt], enumerable: !1, writable: !1, configurable: !0 });
		}
		return _;
	},
	getWindowOf = function (_) {
		var et = _ && _.ownerDocument && _.ownerDocument.defaultView;
		return et || global$1;
	},
	emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(_) {
	return parseFloat(_) || 0;
}
function getBordersSize(_) {
	for (var et = [], tt = 1; tt < arguments.length; tt++) et[tt - 1] = arguments[tt];
	return et.reduce(function (nt, rt) {
		var it = _["border-" + rt + "-width"];
		return nt + toFloat(it);
	}, 0);
}
function getPaddings(_) {
	for (var et = ["top", "right", "bottom", "left"], tt = {}, nt = 0, rt = et; nt < rt.length; nt++) {
		var it = rt[nt],
			ot = _["padding-" + it];
		tt[it] = toFloat(ot);
	}
	return tt;
}
function getSVGContentRect(_) {
	var et = _.getBBox();
	return createRectInit(0, 0, et.width, et.height);
}
function getHTMLElementContentRect(_) {
	var et = _.clientWidth,
		tt = _.clientHeight;
	if (!et && !tt) return emptyRect;
	var nt = getWindowOf(_).getComputedStyle(_),
		rt = getPaddings(nt),
		it = rt.left + rt.right,
		ot = rt.top + rt.bottom,
		at = toFloat(nt.width),
		st = toFloat(nt.height);
	if (
		(nt.boxSizing === "border-box" &&
			(Math.round(at + it) !== et && (at -= getBordersSize(nt, "left", "right") + it),
			Math.round(st + ot) !== tt && (st -= getBordersSize(nt, "top", "bottom") + ot)),
		!isDocumentElement(_))
	) {
		var lt = Math.round(at + it) - et,
			ut = Math.round(st + ot) - tt;
		Math.abs(lt) !== 1 && (at -= lt), Math.abs(ut) !== 1 && (st -= ut);
	}
	return createRectInit(rt.left, rt.top, at, st);
}
var isSVGGraphicsElement = (function () {
	return typeof SVGGraphicsElement < "u"
		? function (_) {
				return _ instanceof getWindowOf(_).SVGGraphicsElement;
		  }
		: function (_) {
				return _ instanceof getWindowOf(_).SVGElement && typeof _.getBBox == "function";
		  };
})();
function isDocumentElement(_) {
	return _ === getWindowOf(_).document.documentElement;
}
function getContentRect(_) {
	return isBrowser ? (isSVGGraphicsElement(_) ? getSVGContentRect(_) : getHTMLElementContentRect(_)) : emptyRect;
}
function createReadOnlyRect(_) {
	var et = _.x,
		tt = _.y,
		nt = _.width,
		rt = _.height,
		it = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object,
		ot = Object.create(it.prototype);
	return (
		defineConfigurable(ot, { x: et, y: tt, width: nt, height: rt, top: tt, right: et + nt, bottom: rt + tt, left: et }),
		ot
	);
}
function createRectInit(_, et, tt, nt) {
	return { x: _, y: et, width: tt, height: nt };
}
var ResizeObservation = (function () {
		function _(et) {
			(this.broadcastWidth = 0),
				(this.broadcastHeight = 0),
				(this.contentRect_ = createRectInit(0, 0, 0, 0)),
				(this.target = et);
		}
		return (
			(_.prototype.isActive = function () {
				var et = getContentRect(this.target);
				return (this.contentRect_ = et), et.width !== this.broadcastWidth || et.height !== this.broadcastHeight;
			}),
			(_.prototype.broadcastRect = function () {
				var et = this.contentRect_;
				return (this.broadcastWidth = et.width), (this.broadcastHeight = et.height), et;
			}),
			_
		);
	})(),
	ResizeObserverEntry = (function () {
		function _(et, tt) {
			var nt = createReadOnlyRect(tt);
			defineConfigurable(this, { target: et, contentRect: nt });
		}
		return _;
	})(),
	ResizeObserverSPI = (function () {
		function _(et, tt, nt) {
			if (((this.activeObservations_ = []), (this.observations_ = new MapShim()), typeof et != "function"))
				throw new TypeError("The callback provided as parameter 1 is not a function.");
			(this.callback_ = et), (this.controller_ = tt), (this.callbackCtx_ = nt);
		}
		return (
			(_.prototype.observe = function (et) {
				if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
				if (!(typeof Element > "u" || !(Element instanceof Object))) {
					if (!(et instanceof getWindowOf(et).Element)) throw new TypeError('parameter 1 is not of type "Element".');
					var tt = this.observations_;
					tt.has(et) ||
						(tt.set(et, new ResizeObservation(et)), this.controller_.addObserver(this), this.controller_.refresh());
				}
			}),
			(_.prototype.unobserve = function (et) {
				if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
				if (!(typeof Element > "u" || !(Element instanceof Object))) {
					if (!(et instanceof getWindowOf(et).Element)) throw new TypeError('parameter 1 is not of type "Element".');
					var tt = this.observations_;
					!tt.has(et) || (tt.delete(et), tt.size || this.controller_.removeObserver(this));
				}
			}),
			(_.prototype.disconnect = function () {
				this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
			}),
			(_.prototype.gatherActive = function () {
				var et = this;
				this.clearActive(),
					this.observations_.forEach(function (tt) {
						tt.isActive() && et.activeObservations_.push(tt);
					});
			}),
			(_.prototype.broadcastActive = function () {
				if (!!this.hasActive()) {
					var et = this.callbackCtx_,
						tt = this.activeObservations_.map(function (nt) {
							return new ResizeObserverEntry(nt.target, nt.broadcastRect());
						});
					this.callback_.call(et, tt, et), this.clearActive();
				}
			}),
			(_.prototype.clearActive = function () {
				this.activeObservations_.splice(0);
			}),
			(_.prototype.hasActive = function () {
				return this.activeObservations_.length > 0;
			}),
			_
		);
	})(),
	observers = typeof WeakMap < "u" ? new WeakMap() : new MapShim(),
	ResizeObserver = (function () {
		function _(et) {
			if (!(this instanceof _)) throw new TypeError("Cannot call a class as a function.");
			if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
			var tt = ResizeObserverController.getInstance(),
				nt = new ResizeObserverSPI(et, tt, this);
			observers.set(this, nt);
		}
		return _;
	})();
["observe", "unobserve", "disconnect"].forEach(function (_) {
	ResizeObserver.prototype[_] = function () {
		var et;
		return (et = observers.get(this))[_].apply(et, arguments);
	};
});
var index$2 = (function () {
		return typeof global$1.ResizeObserver < "u" ? global$1.ResizeObserver : ResizeObserver;
	})(),
	Observables = ({ mutationObservables: _, resizeObservables: et, refresh: tt }) => {
		const [nt, rt] = react.exports.useState(0),
			it = react.exports.useRef(document.documentElement || document.body);
		function ot(st) {
			const lt = Array.from(st);
			for (const ut of lt)
				if (_) {
					if (!ut.attributes) continue;
					_.find((ct) => ut.matches(ct)) && tt(!0);
				}
		}
		function at(st) {
			const lt = Array.from(st);
			for (const ut of lt)
				if (et) {
					if (!ut.attributes) continue;
					et.find((ct) => ut.matches(ct)) && rt(nt + 1);
				}
		}
		return (
			useMutationObserver(
				it,
				(st) => {
					for (const lt of st)
						lt.addedNodes.length !== 0 && (ot(lt.addedNodes), at(lt.addedNodes)),
							lt.removedNodes.length !== 0 && (ot(lt.removedNodes), at(lt.removedNodes));
				},
				{ childList: !0, subtree: !0 }
			),
			react.exports.useEffect(() => {
				if (!et) return;
				const st = new index$2(() => {
					tt();
				});
				for (const lt of et) {
					const ut = document.querySelector(lt);
					ut && st.observe(ut);
				}
				return () => {
					st.disconnect();
				};
			}, [et, nt]),
			null
		);
	},
	Observables_default = Observables;
function getRect(_) {
	let et = initialState$1;
	return _ && (et = _.getBoundingClientRect()), et;
}
function useRect(_, et) {
	const [tt, nt] = react.exports.useState(initialState$1),
		rt = react.exports.useCallback(() => {
			!(_ != null && _.current) || nt(getRect(_ == null ? void 0 : _.current));
		}, [_ == null ? void 0 : _.current]);
	return (
		react.exports.useEffect(
			() => (rt(), window.addEventListener("resize", rt), () => window.removeEventListener("resize", rt)),
			[_ == null ? void 0 : _.current, et]
		),
		tt
	);
}
var initialState$1 = { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 };
function smoothScroll(_, et) {
	return new Promise((tt) => {
		if (!(_ instanceof Element)) throw new TypeError("Argument 1 must be an Element");
		let nt = 0,
			rt = null;
		const it = Object.assign({ behavior: "smooth" }, et);
		_.scrollIntoView(it), requestAnimationFrame(ot);
		function ot() {
			const at = _ == null ? void 0 : _.getBoundingClientRect().top;
			if (at === rt) {
				if (nt++ > 2) return tt(null);
			} else (nt = 0), (rt = at);
			requestAnimationFrame(ot);
		}
	});
}
function safe(_) {
	return _ < 0 ? 0 : _;
}
function getInViewThreshold(_) {
	return typeof _ == "object" && _ !== null
		? { thresholdX: _.x || 0, thresholdY: _.y || 0 }
		: { thresholdX: _ || 0, thresholdY: _ || 0 };
}
function getWindow() {
	const _ = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
		et = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	return { w: _, h: et };
}
function inView({ top: _, right: et, bottom: tt, left: nt, threshold: rt }) {
	const { w: it, h: ot } = getWindow(),
		{ thresholdX: at, thresholdY: st } = getInViewThreshold(rt);
	return _ < 0 && tt - _ > ot ? !0 : _ >= 0 + st && nt >= 0 + at && tt <= ot - st && et <= it - at;
}
var isHoriz = (_) => /(left|right)/.test(_),
	isOutsideX = (_, et) => _ > et,
	isOutsideY = (_, et) => _ > et;
function bestPositionOf(_) {
	return Object.keys(_)
		.map((et) => ({ position: et, value: _[et] }))
		.sort((et, tt) => tt.value - et.value)
		.map((et) => et.position);
}
var defaultPadding = 10;
function getPadding$1(_ = defaultPadding) {
	return Array.isArray(_) ? (_[0] ? [_[0], _[1] ? _[1] : _[0]] : [defaultPadding, defaultPadding]) : [_, _];
}
var defaultStyles$2 = {
	maskWrapper: () => ({
		opacity: 0.7,
		left: 0,
		top: 0,
		position: "fixed",
		zIndex: 99999,
		pointerEvents: "none",
		color: "#000",
	}),
	svgWrapper: ({ windowWidth: _, windowHeight: et, wpx: tt, wpy: nt }) => ({
		width: _,
		height: et,
		left: Number(tt) / 2,
		top: Number(nt) / 2,
		position: "fixed",
	}),
	maskArea: ({ x: _, y: et, width: tt, height: nt }) => ({ x: _, y: et, width: tt, height: nt, fill: "black", rx: 0 }),
	maskRect: ({ windowWidth: _, windowHeight: et, maskID: tt }) => ({
		x: 0,
		y: 0,
		width: _,
		height: et,
		fill: "currentColor",
		mask: `url(#${tt})`,
	}),
	clickArea: ({ windowWidth: _, windowHeight: et, clipID: tt }) => ({
		x: 0,
		y: 0,
		width: _,
		height: et,
		fill: "currentcolor",
		pointerEvents: "auto",
		clipPath: `url(#${tt})`,
	}),
	highlightedArea: ({ x: _, y: et, width: tt, height: nt }) => ({
		x: _,
		y: et,
		width: tt,
		height: nt,
		pointerEvents: "auto",
		fill: "transparent",
		display: "none",
	}),
};
function stylesMatcher$2(_) {
	return (et, tt) => {
		const nt = defaultStyles$2[et](tt),
			rt = _[et];
		return rt ? rt(nt, tt) : nt;
	};
}
var Mask = ({
		padding: _ = 10,
		wrapperPadding: et = 0,
		onClick: tt,
		onClickHighlighted: nt,
		styles: rt = {},
		sizes: it,
		className: ot,
		highlightedAreaClassName: at,
		maskId: st,
		clipId: lt,
	}) => {
		const ut = st || uniqueId("mask__"),
			dt = lt || uniqueId("clip__"),
			ct = stylesMatcher$2(rt),
			[ft, mt] = getPadding$1(_),
			[pt, vt] = getPadding$1(et),
			{ w: ht, h: gt } = getWindow(),
			yt = safe((it == null ? void 0 : it.width) + ft * 2),
			xt = safe((it == null ? void 0 : it.height) + mt * 2),
			St = safe((it == null ? void 0 : it.top) - mt - vt / 2),
			wt = safe((it == null ? void 0 : it.left) - ft - pt / 2),
			Ct = ht - pt,
			Et = gt - vt,
			_t = ct("maskArea", { x: wt, y: St, width: yt, height: xt });
		return jsx("div", {
			style: ct("maskWrapper", {}),
			onClick: tt,
			className: ot,
			children: jsxs("svg", {
				width: Ct,
				height: Et,
				xmlns: "http://www.w3.org/2000/svg",
				style: ct("svgWrapper", { windowWidth: Ct, windowHeight: Et, wpx: pt, wpy: vt }),
				children: [
					jsxs("defs", {
						children: [
							jsxs("mask", {
								id: ut,
								children: [
									jsx("rect", { x: 0, y: 0, width: Ct, height: Et, fill: "white" }),
									jsx("rect", { style: _t, rx: _t.rx ? 1 : void 0 }),
								],
							}),
							jsx("clipPath", {
								id: dt,
								children: jsx("polygon", {
									points: `0 0, 0 ${Et}, ${wt} ${Et}, ${wt} ${St}, ${wt + yt} ${St}, ${wt + yt} ${St + xt}, ${wt} ${
										St + xt
									}, ${wt} ${Et}, ${Ct} ${Et}, ${Ct} 0`,
								}),
							}),
						],
					}),
					jsx("rect", { style: ct("maskRect", { windowWidth: Ct, windowHeight: Et, maskID: ut }) }),
					jsx("rect", {
						style: ct("clickArea", {
							windowWidth: Ct,
							windowHeight: Et,
							top: St,
							left: wt,
							width: yt,
							height: xt,
							clipID: dt,
						}),
					}),
					jsx("rect", {
						style: ct("highlightedArea", { x: wt, y: St, width: yt, height: xt }),
						className: at,
						onClick: nt,
					}),
				],
			}),
		});
	},
	Mask_default = Mask;
function uniqueId(_) {
	return _ + Math.random().toString(36).substring(2, 16);
}
var defaultStyles$1 = {
	popover: () => ({
		position: "fixed",
		maxWidth: 353,
		backgroundColor: "#fff",
		padding: "24px 30px",
		boxShadow: "0 0.5em 3em rgba(0, 0, 0, 0.3)",
		color: "inherit",
		zIndex: 1e5,
		transition: "transform 0.3s",
		top: 0,
		left: 0,
	}),
};
function stylesMatcher$1(_) {
	return (et, tt) => {
		const nt = defaultStyles$1[et](tt),
			rt = _[et];
		return rt ? rt(nt, tt) : nt;
	};
}
var Popover = ({
		children: _,
		position: et = "bottom",
		padding: tt = 10,
		styles: nt = {},
		sizes: rt,
		refresher: it,
		...ot
	}) => {
		const at = react.exports.useRef(null),
			st = react.exports.useRef(""),
			lt = react.exports.useRef(""),
			ut = react.exports.useRef(""),
			{ w: dt, h: ct } = getWindow(),
			ft = stylesMatcher$1(nt),
			mt = useRect(at, it),
			{ width: pt, height: vt } = mt,
			ht = rt == null ? void 0 : rt.left,
			gt = rt == null ? void 0 : rt.top,
			yt = rt == null ? void 0 : rt.right,
			xt = rt == null ? void 0 : rt.bottom,
			St =
				et && typeof et == "function"
					? et(
							{
								width: pt,
								height: vt,
								windowWidth: dt,
								windowHeight: ct,
								top: gt,
								left: ht,
								right: yt,
								bottom: xt,
								x: rt.x,
								y: rt.y,
							},
							mt
					  )
					: et,
			wt = { left: ht, right: dt - yt, top: gt, bottom: ct - xt },
			[Ct, Et] = getPadding$1(tt),
			_t = (Nt) => wt[Nt] > (isHoriz(Nt) ? pt + Ct * 2 : vt + Et * 2),
			$t = (Nt) => {
				const Ft = bestPositionOf(wt);
				for (let Gt = 0; Gt < Ft.length; Gt++) if (_t(Ft[Gt])) return (st.current = Ft[Gt]), Nt[Ft[Gt]];
				return (st.current = "center"), Nt.center;
			},
			Lt = ((Nt) => {
				if (Array.isArray(Nt)) {
					const Dt = isOutsideX(Nt[0], dt),
						Rt = isOutsideY(Nt[1], ct);
					return (st.current = "custom"), [Dt ? dt / 2 - pt / 2 : Nt[0], Rt ? ct / 2 - vt / 2 : Nt[1]];
				}
				const Ft = isOutsideX(ht + pt, dt) ? yt - pt + Ct : ht - Ct,
					Gt = Ft > Ct ? Ft : Ct,
					Bt = isOutsideY(gt + vt, ct) ? xt - vt + Et : gt - Et,
					jt = Bt > Et ? Bt : Et;
				isOutsideY(gt + vt, ct) ? (lt.current = "bottom") : (lt.current = "top"),
					isOutsideX(ht + pt, dt) ? (ut.current = "left") : (ut.current = "right");
				const It = {
					top: [Gt, gt - vt - Et * 2],
					right: [yt + Ct * 2, jt],
					bottom: [Gt, xt + Et * 2],
					left: [ht - pt - Ct * 2, jt],
					center: [dt / 2 - pt / 2, ct / 2 - vt / 2],
				};
				return Nt === "center" || _t(Nt) ? ((st.current = Nt), It[Nt]) : $t(It);
			})(St);
		return jsx("div", {
			className: "reactour__popover",
			style: {
				...ft("popover", { position: st.current, verticalAlign: lt.current, horizontalAlign: ut.current }),
				transform: `translate(${Math.round(Lt[0])}px, ${Math.round(Lt[1])}px)`,
			},
			ref: at,
			...ot,
			children: _,
		});
	},
	Popover_default = Popover,
	initialState = {
		bottom: 0,
		height: 0,
		left: 0,
		right: 0,
		top: 0,
		width: 0,
		windowWidth: 0,
		windowHeight: 0,
		x: 0,
		y: 0,
	};
function useSizes(_, et = { block: "center", behavior: "smooth", inViewThreshold: 0 }) {
	const [tt, nt] = react.exports.useState(!1),
		[rt, it] = react.exports.useState(!1),
		[ot, at] = react.exports.useState(!1),
		[st, lt] = react.exports.useState(null),
		[ut, dt] = react.exports.useState(initialState),
		ct =
			(_ == null ? void 0 : _.selector) instanceof Element
				? _ == null
					? void 0
					: _.selector
				: document.querySelector(_ == null ? void 0 : _.selector),
		ft = react.exports.useCallback(() => {
			const { hasHighligtedElems: pt, ...vt } = getHighlightedRect(
				ct,
				_ == null ? void 0 : _.highlightedSelectors,
				_ == null ? void 0 : _.bypassElem
			);
			Object.entries(ut).some(([ht, gt]) => vt[ht] !== gt) && dt(vt);
		}, [ct, _ == null ? void 0 : _.highlightedSelectors, ut]);
	react.exports.useEffect(
		() => (ft(), window.addEventListener("resize", ft), () => window.removeEventListener("resize", ft)),
		[ct, _ == null ? void 0 : _.highlightedSelectors, st]
	),
		react.exports.useEffect(() => {
			!inView({ ...ut, threshold: et.inViewThreshold }) &&
				ct &&
				(nt(!0),
				smoothScroll(ct, et)
					.then(() => {
						rt || lt(Date.now());
					})
					.finally(() => {
						nt(!1);
					}));
		}, [ut]);
	const mt = react.exports.useCallback(() => {
		it(!0);
		const { hasHighligtedElems: pt, ...vt } = getHighlightedRect(
			ct,
			_ == null ? void 0 : _.highlightedSelectors,
			_ == null ? void 0 : _.bypassElem
		);
		at(pt), dt(vt), it(!1);
	}, [ct, _ == null ? void 0 : _.highlightedSelectors, ut]);
	return { sizes: ut, transition: tt, target: ct, observableRefresher: mt, isHighlightingObserved: ot };
}
function getHighlightedRect(_, et = [], tt = !0) {
	let nt = !1;
	const { w: rt, h: it } = getWindow();
	if (!et) return { ...getRect(_), windowWidth: rt, windowHeight: it, hasHighligtedElems: !1 };
	let ot = getRect(_),
		at = { bottom: 0, height: 0, left: rt, right: 0, top: it, width: 0 };
	for (const lt of et) {
		const ut = document.querySelector(lt);
		if (!ut || ut.style.display === "none" || ut.style.visibility === "hidden") continue;
		const dt = getRect(ut);
		(nt = !0),
			tt || !_
				? (dt.top < at.top && (at.top = dt.top),
				  dt.right > at.right && (at.right = dt.right),
				  dt.bottom > at.bottom && (at.bottom = dt.bottom),
				  dt.left < at.left && (at.left = dt.left),
				  (at.width = at.right - at.left),
				  (at.height = at.bottom - at.top))
				: (dt.top < ot.top && (ot.top = dt.top),
				  dt.right > ot.right && (ot.right = dt.right),
				  dt.bottom > ot.bottom && (ot.bottom = dt.bottom),
				  dt.left < ot.left && (ot.left = dt.left),
				  (ot.width = ot.right - ot.left),
				  (ot.height = ot.bottom - ot.top));
	}
	const st = tt || !_ ? at.width > 0 && at.height > 0 : !1;
	return {
		left: (st ? at : ot).left,
		top: (st ? at : ot).top,
		right: (st ? at : ot).right,
		bottom: (st ? at : ot).bottom,
		width: (st ? at : ot).width,
		height: (st ? at : ot).height,
		windowWidth: rt,
		windowHeight: it,
		hasHighligtedElems: nt,
		x: ot.x,
		y: ot.y,
	};
}
var Keyboard = ({
		disableKeyboardNavigation: _,
		setCurrentStep: et,
		currentStep: tt,
		setIsOpen: nt,
		stepsLength: rt,
		disable: it,
		rtl: ot,
	}) => {
		function at(st) {
			if ((st.stopPropagation(), _ === !0 || it)) return;
			let lt, ut, dt;
			_ && ((lt = _.includes("esc")), (ut = _.includes("right")), (dt = _.includes("left")));
			function ct() {
				et(Math.min(tt + 1, rt - 1));
			}
			function ft() {
				et(Math.max(tt - 1, 0));
			}
			st.keyCode === 27 && !lt && (st.preventDefault(), nt(!1)),
				st.keyCode === 39 && !ut && (st.preventDefault(), ot ? ft() : ct()),
				st.keyCode === 37 && !dt && (st.preventDefault(), ot ? ct() : ft());
		}
		return (
			react.exports.useEffect(
				() => (
					window.addEventListener("keydown", at, !1),
					() => {
						window.removeEventListener("keydown", at);
					}
				),
				[it, et, tt]
			),
			null
		);
	},
	Keyboard_default = Keyboard,
	defaultStyles = {
		badge: () => ({
			position: "absolute",
			fontFamily: "monospace",
			background: "var(--reactour-accent,#007aff)",
			height: "1.875em",
			lineHeight: 2,
			paddingLeft: "0.8125em",
			paddingRight: "0.8125em",
			fontSize: "1em",
			borderRadius: "1.625em",
			color: "white",
			textAlign: "center",
			boxShadow: "0 0.25em 0.5em rgba(0, 0, 0, 0.3)",
			top: "-0.8125em",
			left: "-0.8125em",
		}),
		controls: () => ({ display: "flex", marginTop: 24, alignItems: "center", justifyContent: "space-between" }),
		navigation: () => ({
			counterReset: "dot",
			display: "flex",
			justifyContent: "space-between",
			alignItems: "center",
			flexWrap: "wrap",
		}),
		button: ({ disabled: _ }) => ({
			display: "block",
			padding: 0,
			border: 0,
			background: "none",
			cursor: _ ? "not-allowed" : "pointer",
		}),
		arrow: ({ disabled: _ }) => ({ color: _ ? "#caccce" : "#646464", width: 16, height: 12, flex: "0 0 16px" }),
		dot: ({ current: _, disabled: et, showNumber: tt }) => ({
			counterIncrement: "dot",
			width: 8,
			height: 8,
			border: _ ? "0" : "1px solid #caccce",
			borderRadius: "100%",
			padding: 0,
			display: "block",
			margin: 4,
			transition: "opacity 0.3s, transform 0.3s",
			cursor: et ? "not-allowed" : "pointer",
			transform: `scale(${_ ? 1.25 : 1})`,
			color: _ ? "var(--reactour-accent, #007aff)" : "#caccce",
			background: _ ? "var(--reactour-accent, #007aff)" : "none",
		}),
		close: ({ disabled: _ }) => ({
			position: "absolute",
			top: 22,
			right: 22,
			width: 9,
			height: 9,
			"--rt-close-btn": _ ? "#caccce" : "#5e5e5e",
			"--rt-close-btn-disabled": _ ? "#caccce" : "#000",
		}),
		svg: () => ({ display: "block" }),
	};
function stylesMatcher(_) {
	return (et, tt) => {
		const nt = defaultStyles[et](tt),
			rt = _[et];
		return rt ? rt(nt, tt) : nt;
	};
}
var Badge = ({ styles: _ = {}, children: et }) => {
		const tt = stylesMatcher(_);
		return React$1.createElement("span", { style: tt("badge", {}) }, et);
	},
	Badge_default = Badge,
	Close = ({ styles: _ = {}, onClick: et, disabled: tt, ...nt }) => {
		const rt = stylesMatcher(_);
		return React$1.createElement(
			"button",
			{
				className: "reactour__close-button",
				style: { ...rt("button", {}), ...rt("close", { disabled: tt }) },
				onClick: et,
				...nt,
			},
			React$1.createElement(
				"svg",
				{ viewBox: "0 0 9.1 9.1", "aria-hidden": !0, role: "presentation", style: { ...rt("svg", {}) } },
				React$1.createElement("path", {
					fill: "currentColor",
					d: "M5.9 4.5l2.8-2.8c.4-.4.4-1 0-1.4-.4-.4-1-.4-1.4 0L4.5 3.1 1.7.3C1.3-.1.7-.1.3.3c-.4.4-.4 1 0 1.4l2.8 2.8L.3 7.4c-.4.4-.4 1 0 1.4.2.2.4.3.7.3s.5-.1.7-.3L4.5 6l2.8 2.8c.3.2.5.3.8.3s.5-.1.7-.3c.4-.4.4-1 0-1.4L5.9 4.5z",
				})
			)
		);
	},
	Close_default = Close,
	Content = ({
		content: _,
		setCurrentStep: et,
		transition: tt,
		isHighlightingObserved: nt,
		currentStep: rt,
		setIsOpen: it,
	}) =>
		typeof _ == "function"
			? _({ setCurrentStep: et, transition: tt, isHighlightingObserved: nt, currentStep: rt, setIsOpen: it })
			: _,
	Content_default = Content,
	Navigation$1 = ({
		styles: _ = {},
		steps: et,
		setCurrentStep: tt,
		currentStep: nt,
		setIsOpen: rt,
		nextButton: it,
		prevButton: ot,
		disableDots: at,
		hideDots: st,
		hideButtons: lt,
		disableAll: ut,
		rtl: dt,
		Arrow: ct = DefaultArrow,
	}) => {
		const ft = et.length,
			mt = stylesMatcher(_),
			pt = ({ onClick: vt, kind: ht = "next", children: gt, hideArrow: yt }) => {
				function xt() {
					ut ||
						(vt && typeof vt == "function" ? vt() : tt(ht === "next" ? Math.min(nt + 1, ft - 1) : Math.max(nt - 1, 0)));
				}
				return React$1.createElement(
					"button",
					{
						style: mt("button", { kind: ht, disabled: ut || (ht === "next" ? ft - 1 === nt : nt === 0) }),
						onClick: xt,
						"aria-label": `Go to ${ht} step`,
					},
					yt
						? null
						: React$1.createElement(ct, {
								styles: _,
								inverted: dt ? ht === "prev" : ht === "next",
								disabled: ut || (ht === "next" ? ft - 1 === nt : nt === 0),
						  }),
					gt
				);
			};
		return React$1.createElement(
			"div",
			{ style: mt("controls", {}), dir: dt ? "rtl" : "ltr" },
			lt
				? null
				: ot && typeof ot == "function"
				? ot({ Button: pt, setCurrentStep: tt, currentStep: nt, stepsLength: ft, setIsOpen: rt, steps: et })
				: React$1.createElement(pt, { kind: "prev" }),
			st
				? null
				: React$1.createElement(
						"div",
						{ style: mt("navigation", {}) },
						Array.from({ length: ft }, (vt, ht) => ht).map((vt) => {
							var ht;
							return React$1.createElement("button", {
								style: mt("dot", { current: vt === nt, disabled: at || ut }),
								onClick: () => {
									!at && !ut && tt(vt);
								},
								key: `navigation_dot_${vt}`,
								"aria-label": ((ht = et[vt]) == null ? void 0 : ht.navDotAriaLabel) || `Go to step ${vt + 1}`,
							});
						})
				  ),
			lt
				? null
				: it && typeof it == "function"
				? it({ Button: pt, setCurrentStep: tt, currentStep: nt, stepsLength: ft, setIsOpen: rt, steps: et })
				: React$1.createElement(pt, null)
		);
	},
	Navigation_default = Navigation$1,
	DefaultArrow = ({ styles: _ = {}, inverted: et = !1, disabled: tt }) => {
		const nt = stylesMatcher(_);
		return React$1.createElement(
			"svg",
			{ viewBox: "0 0 18.4 14.4", style: nt("arrow", { inverted: et, disabled: tt }) },
			React$1.createElement("path", {
				d: et ? "M17 7.2H1M10.8 1L17 7.2l-6.2 6.2" : "M1.4 7.2h16M7.6 1L1.4 7.2l6.2 6.2",
				fill: "none",
				stroke: "currentColor",
				strokeWidth: "2",
				strokeLinecap: "round",
				strokeMiterlimit: "10",
			})
		);
	},
	components = {
		Badge: Badge_default,
		Close: Close_default,
		Content: Content_default,
		Navigation: Navigation_default,
		Arrow: DefaultArrow,
	},
	defaultComponents = (_) => ({ ...components, ..._ }),
	PopoverContent = ({
		styles: _,
		components: et = {},
		badgeContent: tt,
		accessibilityOptions: nt,
		disabledActions: rt,
		onClickClose: it,
		steps: ot,
		setCurrentStep: at,
		currentStep: st,
		transition: lt,
		isHighlightingObserved: ut,
		setIsOpen: dt,
		nextButton: ct,
		prevButton: ft,
		disableDotsNavigation: mt,
		rtl: pt,
		showPrevNextButtons: vt = !0,
		showCloseButton: ht = !0,
		showNavigation: gt = !0,
		showBadge: yt = !0,
		showDots: xt = !0,
	}) => {
		const St = ot[st],
			{ Badge: wt, Close: Ct, Content: Et, Navigation: _t, Arrow: $t } = defaultComponents(et),
			At = tt && typeof tt == "function" ? tt({ currentStep: st, totalSteps: ot.length, transition: lt }) : st + 1;
		function Lt() {
			rt ||
				(it && typeof it == "function"
					? it({ setCurrentStep: at, setIsOpen: dt, currentStep: st, steps: ot })
					: dt(!1));
		}
		return React$1.createElement(
			React$1.Fragment,
			null,
			yt ? React$1.createElement(wt, { styles: _ }, At) : null,
			ht
				? React$1.createElement(Ct, {
						styles: _,
						"aria-label": nt == null ? void 0 : nt.closeButtonAriaLabel,
						disabled: rt,
						onClick: Lt,
				  })
				: null,
			React$1.createElement(Et, {
				content: St == null ? void 0 : St.content,
				setCurrentStep: at,
				currentStep: st,
				transition: lt,
				isHighlightingObserved: ut,
				setIsOpen: dt,
			}),
			gt
				? React$1.createElement(_t, {
						setCurrentStep: at,
						currentStep: st,
						setIsOpen: dt,
						steps: ot,
						styles: _,
						"aria-hidden": !(nt != null && nt.showNavigationScreenReaders),
						nextButton: ct,
						prevButton: ft,
						disableDots: mt,
						hideButtons: !vt,
						hideDots: !xt,
						disableAll: rt,
						rtl: pt,
						Arrow: $t,
				  })
				: null
		);
	},
	PopoverContent_default = PopoverContent,
	Tour = ({
		currentStep: _,
		setCurrentStep: et,
		setIsOpen: tt,
		steps: nt = [],
		styles: rt = {},
		scrollSmooth: it,
		afterOpen: ot,
		beforeClose: at,
		padding: st = 10,
		position: lt,
		onClickMask: ut,
		onClickHighlighted: dt,
		className: ct = "reactour__popover",
		maskClassName: ft = "reactour__mask",
		highlightedMaskClassName: mt,
		disableInteraction: pt,
		disableKeyboardNavigation: vt,
		inViewThreshold: ht,
		disabledActions: gt,
		setDisabledActions: yt,
		rtl: xt,
		accessibilityOptions: St = { closeButtonAriaLabel: "Close Tour", showNavigationScreenReaders: !0 },
		ContentComponent: wt,
		Wrapper: Ct,
		onTransition: Et = () => "center",
		..._t
	}) => {
		const $t = nt[_],
			At = ($t == null ? void 0 : $t.styles) || rt,
			{
				sizes: Lt,
				transition: Nt,
				observableRefresher: Ft,
				isHighlightingObserved: Gt,
				target: Bt,
			} = useSizes($t, { block: "center", behavior: it ? "smooth" : "auto", inViewThreshold: ht });
		react.exports.useEffect(
			() => (
				ot && typeof ot == "function" && ot(Bt),
				() => {
					at && typeof at == "function" && at(Bt);
				}
			),
			[]
		);
		const {
			maskPadding: jt,
			popoverPadding: It,
			wrapperPadding: Dt,
		} = getPadding(($t == null ? void 0 : $t.padding) || st);
		function Rt() {
			gt ||
				(ut && typeof ut == "function" ? ut({ setCurrentStep: et, setIsOpen: tt, currentStep: _, steps: nt }) : tt(!1));
		}
		const bt = $t != null && $t.stepInteraction ? !($t != null && $t.stepInteraction) : pt;
		react.exports.useEffect(
			() => (
				($t == null ? void 0 : $t.action) &&
					typeof ($t == null ? void 0 : $t.action) == "function" &&
					($t == null || $t.action(Bt)),
				($t == null ? void 0 : $t.disableActions) !== void 0 && yt($t == null ? void 0 : $t.disableActions),
				() => {
					($t == null ? void 0 : $t.actionAfter) &&
						typeof ($t == null ? void 0 : $t.actionAfter) == "function" &&
						($t == null || $t.actionAfter(Bt));
				}
			),
			[$t]
		);
		const kt = Nt ? Et : $t != null && $t.position ? ($t == null ? void 0 : $t.position) : lt,
			zt = Ct || React$1.Fragment;
		return $t
			? jsxs(zt, {
					children: [
						jsx(Observables_default, {
							mutationObservables: $t == null ? void 0 : $t.mutationObservables,
							resizeObservables: $t == null ? void 0 : $t.resizeObservables,
							refresh: Ft,
						}),
						jsx(Keyboard_default, {
							setCurrentStep: et,
							currentStep: _,
							setIsOpen: tt,
							stepsLength: nt.length,
							disableKeyboardNavigation: vt,
							disable: gt,
							rtl: xt,
						}),
						jsx(Mask_default, {
							sizes: Nt ? initialState2 : Lt,
							onClick: Rt,
							styles: { highlightedArea: (Vt) => ({ ...Vt, display: bt ? "block" : "none" }), ...At },
							padding: Nt ? 0 : jt,
							highlightedAreaClassName: mt,
							className: ft,
							onClickHighlighted: dt,
							wrapperPadding: Dt,
						}),
						jsx(Popover_default, {
							sizes: Lt,
							styles: At,
							position: kt,
							padding: It,
							"aria-labelledby": St == null ? void 0 : St.ariaLabelledBy,
							className: ct,
							refresher: _,
							children: wt
								? jsx(wt, {
										styles: At,
										setCurrentStep: et,
										currentStep: _,
										setIsOpen: tt,
										steps: nt,
										accessibilityOptions: St,
										disabledActions: gt,
										transition: Nt,
										isHighlightingObserved: Gt,
										rtl: xt,
										..._t,
								  })
								: jsx(PopoverContent_default, {
										styles: At,
										setCurrentStep: et,
										currentStep: _,
										setIsOpen: tt,
										steps: nt,
										accessibilityOptions: St,
										disabledActions: gt,
										transition: Nt,
										isHighlightingObserved: Gt,
										rtl: xt,
										..._t,
								  }),
						}),
					],
			  })
			: null;
	},
	Tour_default = Tour;
function getPadding(_) {
	return typeof _ == "object" && _ !== null
		? { maskPadding: _.mask, popoverPadding: _.popover, wrapperPadding: _.wrapper }
		: { maskPadding: _, popoverPadding: _, wrapperPadding: 0 };
}
var initialState2 = { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 },
	defaultState = {
		isOpen: !1,
		setIsOpen: () => !1,
		currentStep: 0,
		setCurrentStep: () => 0,
		steps: [],
		setSteps: () => [],
		disabledActions: !1,
		setDisabledActions: () => !1,
		components: {},
	},
	TourContext = React$1.createContext(defaultState),
	TourProvider = ({
		children: _,
		defaultOpen: et = !1,
		startAt: tt = 0,
		steps: nt,
		setCurrentStep: rt,
		currentStep: it,
		...ot
	}) => {
		const [at, st] = react.exports.useState(et),
			[lt, ut] = react.exports.useState(tt),
			[dt, ct] = react.exports.useState(nt),
			[ft, mt] = react.exports.useState(!1),
			pt = {
				isOpen: at,
				setIsOpen: st,
				currentStep: it || lt,
				setCurrentStep: rt && typeof rt == "function" ? rt : ut,
				steps: dt,
				setSteps: ct,
				disabledActions: ft,
				setDisabledActions: mt,
				...ot,
			};
		return React$1.createElement(
			TourContext.Provider,
			{ value: pt },
			_,
			at ? React$1.createElement(Tour_default, { ...pt }) : null
		);
	};
function useTour() {
	return react.exports.useContext(TourContext);
}
var client = {},
	m$2 = reactDom.exports;
(client.createRoot = m$2.createRoot), (client.hydrateRoot = m$2.hydrateRoot);
/**
 * @remix-run/router 1.0.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function _extends() {
	return (
		(_extends = Object.assign
			? Object.assign.bind()
			: function (_) {
					for (var et = 1; et < arguments.length; et++) {
						var tt = arguments[et];
						for (var nt in tt) Object.prototype.hasOwnProperty.call(tt, nt) && (_[nt] = tt[nt]);
					}
					return _;
			  }),
		_extends.apply(this, arguments)
	);
}
var Action;
(function (_) {
	(_.Pop = "POP"), (_.Push = "PUSH"), (_.Replace = "REPLACE");
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(_) {
	_ === void 0 && (_ = {});
	function et(nt, rt) {
		var it, ot;
		let { pathname: at, search: st, hash: lt } = nt.location;
		return createLocation(
			"",
			{ pathname: at, search: st, hash: lt },
			((it = rt.state) == null ? void 0 : it.usr) || null,
			((ot = rt.state) == null ? void 0 : ot.key) || "default"
		);
	}
	function tt(nt, rt) {
		return typeof rt == "string" ? rt : createPath(rt);
	}
	return getUrlBasedHistory(et, tt, null, _);
}
function createKey() {
	return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(_) {
	return { usr: _.state, key: _.key };
}
function createLocation(_, et, tt, nt) {
	return (
		tt === void 0 && (tt = null),
		_extends(
			{ pathname: typeof _ == "string" ? _ : _.pathname, search: "", hash: "" },
			typeof et == "string" ? parsePath(et) : et,
			{ state: tt, key: (et == null ? void 0 : et.key) || nt || createKey() }
		)
	);
}
function createPath(_) {
	let { pathname: et = "/", search: tt = "", hash: nt = "" } = _;
	return (
		tt && tt !== "?" && (et += tt.charAt(0) === "?" ? tt : "?" + tt),
		nt && nt !== "#" && (et += nt.charAt(0) === "#" ? nt : "#" + nt),
		et
	);
}
function parsePath(_) {
	let et = {};
	if (_) {
		let tt = _.indexOf("#");
		tt >= 0 && ((et.hash = _.substr(tt)), (_ = _.substr(0, tt)));
		let nt = _.indexOf("?");
		nt >= 0 && ((et.search = _.substr(nt)), (_ = _.substr(0, nt))), _ && (et.pathname = _);
	}
	return et;
}
function getUrlBasedHistory(_, et, tt, nt) {
	nt === void 0 && (nt = {});
	let { window: rt = document.defaultView, v5Compat: it = !1 } = nt,
		ot = rt.history,
		at = Action.Pop,
		st = null;
	function lt() {
		(at = Action.Pop), st && st({ action: at, location: ct.location });
	}
	function ut(ft, mt) {
		at = Action.Push;
		let pt = createLocation(ct.location, ft, mt);
		tt == null || tt(pt, ft);
		let vt = getHistoryState(pt),
			ht = ct.createHref(pt);
		try {
			ot.pushState(vt, "", ht);
		} catch {
			rt.location.assign(ht);
		}
		it && st && st({ action: at, location: pt });
	}
	function dt(ft, mt) {
		at = Action.Replace;
		let pt = createLocation(ct.location, ft, mt);
		tt == null || tt(pt, ft);
		let vt = getHistoryState(pt),
			ht = ct.createHref(pt);
		ot.replaceState(vt, "", ht), it && st && st({ action: at, location: pt });
	}
	let ct = {
		get action() {
			return at;
		},
		get location() {
			return _(rt, ot);
		},
		listen(ft) {
			if (st) throw new Error("A history only accepts one active listener");
			return (
				rt.addEventListener(PopStateEventType, lt),
				(st = ft),
				() => {
					rt.removeEventListener(PopStateEventType, lt), (st = null);
				}
			);
		},
		createHref(ft) {
			return et(rt, ft);
		},
		push: ut,
		replace: dt,
		go(ft) {
			return ot.go(ft);
		},
	};
	return ct;
}
var ResultType;
(function (_) {
	(_.data = "data"), (_.deferred = "deferred"), (_.redirect = "redirect"), (_.error = "error");
})(ResultType || (ResultType = {}));
function stripBasename(_, et) {
	if (et === "/") return _;
	if (!_.toLowerCase().startsWith(et.toLowerCase())) return null;
	let tt = et.endsWith("/") ? et.length - 1 : et.length,
		nt = _.charAt(tt);
	return nt && nt !== "/" ? null : _.slice(tt) || "/";
}
function invariant(_, et) {
	if (_ === !1 || _ === null || typeof _ > "u") throw new Error(et);
}
function resolvePath(_, et) {
	et === void 0 && (et = "/");
	let { pathname: tt, search: nt = "", hash: rt = "" } = typeof _ == "string" ? parsePath(_) : _;
	return {
		pathname: tt ? (tt.startsWith("/") ? tt : resolvePathname(tt, et)) : et,
		search: normalizeSearch(nt),
		hash: normalizeHash(rt),
	};
}
function resolvePathname(_, et) {
	let tt = et.replace(/\/+$/, "").split("/");
	return (
		_.split("/").forEach((rt) => {
			rt === ".." ? tt.length > 1 && tt.pop() : rt !== "." && tt.push(rt);
		}),
		tt.length > 1 ? tt.join("/") : "/"
	);
}
function resolveTo(_, et, tt, nt) {
	nt === void 0 && (nt = !1);
	let rt = typeof _ == "string" ? parsePath(_) : _extends({}, _),
		it = _ === "" || rt.pathname === "",
		ot = it ? "/" : rt.pathname,
		at;
	if (nt || ot == null) at = tt;
	else {
		let dt = et.length - 1;
		if (ot.startsWith("..")) {
			let ct = ot.split("/");
			for (; ct[0] === ".."; ) ct.shift(), (dt -= 1);
			rt.pathname = ct.join("/");
		}
		at = dt >= 0 ? et[dt] : "/";
	}
	let st = resolvePath(rt, at),
		lt = ot && ot !== "/" && ot.endsWith("/"),
		ut = (it || ot === ".") && tt.endsWith("/");
	return !st.pathname.endsWith("/") && (lt || ut) && (st.pathname += "/"), st;
}
const joinPaths = (_) => _.join("/").replace(/\/\/+/g, "/"),
	normalizeSearch = (_) => (!_ || _ === "?" ? "" : _.startsWith("?") ? _ : "?" + _),
	normalizeHash = (_) => (!_ || _ === "#" ? "" : _.startsWith("#") ? _ : "#" + _);
/**
 * React Router v6.4.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function isPolyfill(_, et) {
	return (_ === et && (_ !== 0 || 1 / _ === 1 / et)) || (_ !== _ && et !== et);
}
const is$2 = typeof Object.is == "function" ? Object.is : isPolyfill,
	{ useState, useEffect, useLayoutEffect, useDebugValue } = React$2;
function useSyncExternalStore$2(_, et, tt) {
	const nt = et(),
		[{ inst: rt }, it] = useState({ inst: { value: nt, getSnapshot: et } });
	return (
		useLayoutEffect(() => {
			(rt.value = nt), (rt.getSnapshot = et), checkIfSnapshotChanged(rt) && it({ inst: rt });
		}, [_, nt, et]),
		useEffect(
			() => (
				checkIfSnapshotChanged(rt) && it({ inst: rt }),
				_(() => {
					checkIfSnapshotChanged(rt) && it({ inst: rt });
				})
			),
			[_]
		),
		useDebugValue(nt),
		nt
	);
}
function checkIfSnapshotChanged(_) {
	const et = _.getSnapshot,
		tt = _.value;
	try {
		const nt = et();
		return !is$2(tt, nt);
	} catch {
		return !0;
	}
}
function useSyncExternalStore$1(_, et, tt) {
	return et();
}
const canUseDOM = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
	isServerEnvironment = !canUseDOM,
	shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$2 && ((_) => _.useSyncExternalStore)(React$2);
const NavigationContext = react.exports.createContext(null),
	LocationContext = react.exports.createContext(null),
	RouteContext = react.exports.createContext({ outlet: null, matches: [] });
function useInRouterContext() {
	return react.exports.useContext(LocationContext) != null;
}
function useLocation() {
	return useInRouterContext() || invariant(!1), react.exports.useContext(LocationContext).location;
}
function getPathContributingMatches(_) {
	return _.filter((et, tt) => tt === 0 || (!et.route.index && et.pathnameBase !== _[tt - 1].pathnameBase));
}
function useNavigate() {
	useInRouterContext() || invariant(!1);
	let { basename: _, navigator: et } = react.exports.useContext(NavigationContext),
		{ matches: tt } = react.exports.useContext(RouteContext),
		{ pathname: nt } = useLocation(),
		rt = JSON.stringify(getPathContributingMatches(tt).map((at) => at.pathnameBase)),
		it = react.exports.useRef(!1);
	return (
		react.exports.useEffect(() => {
			it.current = !0;
		}),
		react.exports.useCallback(
			function (at, st) {
				if ((st === void 0 && (st = {}), !it.current)) return;
				if (typeof at == "number") {
					et.go(at);
					return;
				}
				let lt = resolveTo(at, JSON.parse(rt), nt, st.relative === "path");
				_ !== "/" && (lt.pathname = lt.pathname === "/" ? _ : joinPaths([_, lt.pathname])),
					(st.replace ? et.replace : et.push)(lt, st.state, st);
			},
			[_, et, rt, nt]
		)
	);
}
var DataRouterHook;
(function (_) {
	(_.UseLoaderData = "useLoaderData"),
		(_.UseActionData = "useActionData"),
		(_.UseRouteError = "useRouteError"),
		(_.UseNavigation = "useNavigation"),
		(_.UseRouteLoaderData = "useRouteLoaderData"),
		(_.UseMatches = "useMatches"),
		(_.UseRevalidator = "useRevalidator");
})(DataRouterHook || (DataRouterHook = {}));
function Router(_) {
	let {
		basename: et = "/",
		children: tt = null,
		location: nt,
		navigationType: rt = Action.Pop,
		navigator: it,
		static: ot = !1,
	} = _;
	useInRouterContext() && invariant(!1);
	let at = et.replace(/^\/*/, "/"),
		st = react.exports.useMemo(() => ({ basename: at, navigator: it, static: ot }), [at, it, ot]);
	typeof nt == "string" && (nt = parsePath(nt));
	let { pathname: lt = "/", search: ut = "", hash: dt = "", state: ct = null, key: ft = "default" } = nt,
		mt = react.exports.useMemo(() => {
			let pt = stripBasename(lt, at);
			return pt == null ? null : { pathname: pt, search: ut, hash: dt, state: ct, key: ft };
		}, [at, lt, ut, dt, ct, ft]);
	return mt == null
		? null
		: jsx(NavigationContext.Provider, {
				value: st,
				children: jsx(LocationContext.Provider, { children: tt, value: { location: mt, navigationType: rt } }),
		  });
}
var AwaitRenderStatus;
(function (_) {
	(_[(_.pending = 0)] = "pending"), (_[(_.success = 1)] = "success"), (_[(_.error = 2)] = "error");
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {});
/**
 * React Router DOM v6.4.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function createSearchParams(_) {
	return (
		_ === void 0 && (_ = ""),
		new URLSearchParams(
			typeof _ == "string" || Array.isArray(_) || _ instanceof URLSearchParams
				? _
				: Object.keys(_).reduce((et, tt) => {
						let nt = _[tt];
						return et.concat(Array.isArray(nt) ? nt.map((rt) => [tt, rt]) : [[tt, nt]]);
				  }, [])
		)
	);
}
function getSearchParamsForLocation(_, et) {
	let tt = createSearchParams(_);
	for (let nt of et.keys())
		tt.has(nt) ||
			et.getAll(nt).forEach((rt) => {
				tt.append(nt, rt);
			});
	return tt;
}
function BrowserRouter(_) {
	let { basename: et, children: tt, window: nt } = _,
		rt = react.exports.useRef();
	rt.current == null && (rt.current = createBrowserHistory({ window: nt, v5Compat: !0 }));
	let it = rt.current,
		[ot, at] = react.exports.useState({ action: it.action, location: it.location });
	return (
		react.exports.useLayoutEffect(() => it.listen(at), [it]),
		jsx(Router, { basename: et, children: tt, location: ot.location, navigationType: ot.action, navigator: it })
	);
}
function useSearchParams(_) {
	let et = react.exports.useRef(createSearchParams(_)),
		tt = useLocation(),
		nt = react.exports.useMemo(() => getSearchParamsForLocation(tt.search, et.current), [tt.search]),
		rt = useNavigate(),
		it = react.exports.useCallback(
			(ot, at) => {
				const st = createSearchParams(typeof ot == "function" ? ot(nt) : ot);
				rt("?" + st, at);
			},
			[rt, nt]
		);
	return [nt, it];
}
const App$1 = "",
	data$1 = [
		{
			title: "Tooled Leather",
			thumbnail: "",
			names: [
				{ name: "Parameters", slug: "tooled-leather-params" },
				{ name: "Loops", slug: "tooled-leather-loops" },
				{ name: "Functions", slug: "tooled-leather-functions" },
				{ name: "Variables", slug: "tooled-leather-vars" },
				{ name: "Conditionals", slug: "tooled-leather-conditionals" },
			],
		},
		{
			title: "Quilting",
			thumbnail: "",
			names: [
				{ name: "Gee's Bend", slug: "quilting-gees" },
				{ name: "Anishinaabe", slug: "quilting-anishinaabe" },
				{ name: "Lakota", slug: "quilting-lakota" },
				{ name: "Parameters", slug: "quilting-params" },
				{ name: "Loops", slug: "quilting-loops" },
				{ name: "Functions", slug: "quilting-functions" },
				{ name: "Variables", slug: "quilting-vars" },
				{ name: "Conditionals", slug: "quilting-conditionals" },
			],
		},
		{
			title: "Cornrow Curves",
			thumbnail: "",
			names: [
				{ name: "Main", slug: "cornrows-main" },
				{ name: "Parameters", slug: "cornrows-params" },
				{ name: "Loops", slug: "cornrows-loops" },
				{ name: "Functions", slug: "cornrows-functions" },
				{ name: "Variables", slug: "cornrows-vars" },
				{ name: "Conditionals", slug: "cornrows-conditionals" },
			],
		},
		{ title: "Bead Loom", thumbnail: "", names: [{ name: "Programming", slug: "beadloom-programming" }] },
		{
			title: "Yarn Arts",
			thumbnail: "",
			names: [
				{ name: "Rectangular", slug: "yarnarts-rectangular" },
				{ name: "Circular", slug: "yarnarts-circular" },
			],
		},
		{
			title: "Adinkra",
			thumbnail: "",
			names: [
				{ name: "Akoma", slug: "adinkra-akoma" },
				{ name: "Mpuannum", slug: "adinkra-mpuannum" },
				{ name: "Sepow", slug: "adinkra-sepow" },
				{ name: "Ananse", slug: "adinkra-ananse" },
			],
		},
		{
			title: "Misc",
			thumbnail: "",
			names: [
				{ name: "PreColumbian Pyramids", slug: "precolumbian-pyramids" },
				{ name: "Woven Heaven, Tangled Earth", slug: "whte-en" },
				{ name: "Woven Heaven, Tangled Earth (Spanish)", slug: "whte-es" },
				{ name: "Woven Heaven, Tangled Earth (Portuguese)", slug: "whte-bp" },
				{ name: "Anishinaabe Arcs", slug: "anishinaabe-arcs" },
			],
		},
	];
createIcon({
	d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z",
	displayName: "CopyIcon",
});
createIcon({
	d: "M23.384,21.619,16.855,15.09a9.284,9.284,0,1,0-1.768,1.768l6.529,6.529a1.266,1.266,0,0,0,1.768,0A1.251,1.251,0,0,0,23.384,21.619ZM2.75,9.5a6.75,6.75,0,1,1,6.75,6.75A6.758,6.758,0,0,1,2.75,9.5Z",
	displayName: "SearchIcon",
});
createIcon({
	d: "M23.414,20.591l-4.645-4.645a10.256,10.256,0,1,0-2.828,2.829l4.645,4.644a2.025,2.025,0,0,0,2.828,0A2,2,0,0,0,23.414,20.591ZM10.25,3.005A7.25,7.25,0,1,1,3,10.255,7.258,7.258,0,0,1,10.25,3.005Z",
	displayName: "Search2Icon",
});
createIcon({
	d: "M21.4,13.7C20.6,13.9,19.8,14,19,14c-5,0-9-4-9-9c0-0.8,0.1-1.6,0.3-2.4c0.1-0.3,0-0.7-0.3-1 c-0.3-0.3-0.6-0.4-1-0.3C4.3,2.7,1,7.1,1,12c0,6.1,4.9,11,11,11c4.9,0,9.3-3.3,10.6-8.1c0.1-0.3,0-0.7-0.3-1 C22.1,13.7,21.7,13.6,21.4,13.7z",
	displayName: "MoonIcon",
});
createIcon({
	displayName: "SunIcon",
	path: jsxs("g", {
		strokeLinejoin: "round",
		strokeLinecap: "round",
		strokeWidth: "2",
		fill: "none",
		stroke: "currentColor",
		children: [
			jsx("circle", { cx: "12", cy: "12", r: "5" }),
			jsx("path", { d: "M12 1v2" }),
			jsx("path", { d: "M12 21v2" }),
			jsx("path", { d: "M4.22 4.22l1.42 1.42" }),
			jsx("path", { d: "M18.36 18.36l1.42 1.42" }),
			jsx("path", { d: "M1 12h2" }),
			jsx("path", { d: "M21 12h2" }),
			jsx("path", { d: "M4.22 19.78l1.42-1.42" }),
			jsx("path", { d: "M18.36 5.64l1.42-1.42" }),
		],
	}),
});
createIcon({
	d: "M0,12a1.5,1.5,0,0,0,1.5,1.5h8.75a.25.25,0,0,1,.25.25V22.5a1.5,1.5,0,0,0,3,0V13.75a.25.25,0,0,1,.25-.25H22.5a1.5,1.5,0,0,0,0-3H13.75a.25.25,0,0,1-.25-.25V1.5a1.5,1.5,0,0,0-3,0v8.75a.25.25,0,0,1-.25.25H1.5A1.5,1.5,0,0,0,0,12Z",
	displayName: "AddIcon",
});
createIcon({
	displayName: "SmallAddIcon",
	viewBox: "0 0 20 20",
	path: jsx("path", {
		fill: "currentColor",
		d: "M14 9h-3V6c0-.55-.45-1-1-1s-1 .45-1 1v3H6c-.55 0-1 .45-1 1s.45 1 1 1h3v3c0 .55.45 1 1 1s1-.45 1-1v-3h3c.55 0 1-.45 1-1s-.45-1-1-1z",
		fillRule: "evenodd",
	}),
});
createIcon({
	viewBox: "0 0 14 14",
	d: "M14,7.77 L14,6.17 L12.06,5.53 L11.61,4.44 L12.49,2.6 L11.36,1.47 L9.55,2.38 L8.46,1.93 L7.77,0.01 L6.17,0.01 L5.54,1.95 L4.43,2.4 L2.59,1.52 L1.46,2.65 L2.37,4.46 L1.92,5.55 L0,6.23 L0,7.82 L1.94,8.46 L2.39,9.55 L1.51,11.39 L2.64,12.52 L4.45,11.61 L5.54,12.06 L6.23,13.98 L7.82,13.98 L8.45,12.04 L9.56,11.59 L11.4,12.47 L12.53,11.34 L11.61,9.53 L12.08,8.44 L14,7.75 L14,7.77 Z M7,10 C5.34,10 4,8.66 4,7 C4,5.34 5.34,4 7,4 C8.66,4 10,5.34 10,7 C10,8.66 8.66,10 7,10 Z",
	displayName: "SettingsIcon",
});
createIcon({
	displayName: "CheckCircleIcon",
	d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z",
});
createIcon({
	d: "M19.5,9.5h-.75V6.75a6.75,6.75,0,0,0-13.5,0V9.5H4.5a2,2,0,0,0-2,2V22a2,2,0,0,0,2,2h15a2,2,0,0,0,2-2V11.5A2,2,0,0,0,19.5,9.5Zm-9.5,6a2,2,0,1,1,3,1.723V19.5a1,1,0,0,1-2,0V17.223A1.994,1.994,0,0,1,10,15.5ZM7.75,6.75a4.25,4.25,0,0,1,8.5,0V9a.5.5,0,0,1-.5.5H8.25a.5.5,0,0,1-.5-.5Z",
	displayName: "LockIcon",
});
createIcon({
	d: "M19.5,9.5h-.75V6.75A6.751,6.751,0,0,0,5.533,4.811a1.25,1.25,0,1,0,2.395.717A4.251,4.251,0,0,1,16.25,6.75V9a.5.5,0,0,1-.5.5H4.5a2,2,0,0,0-2,2V22a2,2,0,0,0,2,2h15a2,2,0,0,0,2-2V11.5A2,2,0,0,0,19.5,9.5Zm-9.5,6a2,2,0,1,1,3,1.723V19.5a1,1,0,0,1-2,0V17.223A1.994,1.994,0,0,1,10,15.5Z",
	displayName: "UnlockIcon",
});
createIcon({
	displayName: "ViewIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M23.432,10.524C20.787,7.614,16.4,4.538,12,4.6,7.6,4.537,3.213,7.615.568,10.524a2.211,2.211,0,0,0,0,2.948C3.182,16.351,7.507,19.4,11.839,19.4h.308c4.347,0,8.671-3.049,11.288-5.929A2.21,2.21,0,0,0,23.432,10.524ZM7.4,12A4.6,4.6,0,1,1,12,16.6,4.6,4.6,0,0,1,7.4,12Z",
			}),
			jsx("circle", { cx: "12", cy: "12", r: "2" }),
		],
	}),
});
createIcon({
	displayName: "ViewOffIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M23.2,10.549a20.954,20.954,0,0,0-4.3-3.6l4-3.995a1,1,0,1,0-1.414-1.414l-.018.018a.737.737,0,0,1-.173.291l-19.5,19.5c-.008.007-.018.009-.026.017a1,1,0,0,0,1.631,1.088l4.146-4.146a11.26,11.26,0,0,0,4.31.939h.3c4.256,0,8.489-2.984,11.051-5.8A2.171,2.171,0,0,0,23.2,10.549ZM16.313,13.27a4.581,4.581,0,0,1-3,3.028,4.3,4.3,0,0,1-3.1-.19.253.253,0,0,1-.068-.407l5.56-5.559a.252.252,0,0,1,.407.067A4.3,4.3,0,0,1,16.313,13.27Z",
			}),
			jsx("path", {
				d: "M7.615,13.4a.244.244,0,0,0,.061-.24A4.315,4.315,0,0,1,7.5,12,4.5,4.5,0,0,1,12,7.5a4.276,4.276,0,0,1,1.16.173.244.244,0,0,0,.24-.062l1.941-1.942a.254.254,0,0,0-.1-.421A10.413,10.413,0,0,0,12,4.75C7.7,4.692,3.4,7.7.813,10.549a2.15,2.15,0,0,0-.007,2.9,21.209,21.209,0,0,0,3.438,3.03.256.256,0,0,0,.326-.029Z",
			}),
		],
	}),
});
createIcon({
	d: "M11.2857,6.05714 L10.08571,4.85714 L7.85714,7.14786 L7.85714,1 L6.14286,1 L6.14286,7.14786 L3.91429,4.85714 L2.71429,6.05714 L7,10.42857 L11.2857,6.05714 Z M1,11.2857 L1,13 L13,13 L13,11.2857 L1,11.2857 Z",
	displayName: "DownloadIcon",
	viewBox: "0 0 14 14",
});
createIcon({
	displayName: "DeleteIcon",
	path: jsx("g", {
		fill: "currentColor",
		children: jsx("path", {
			d: "M19.452 7.5H4.547a.5.5 0 00-.5.545l1.287 14.136A2 2 0 007.326 24h9.347a2 2 0 001.992-1.819L19.95 8.045a.5.5 0 00-.129-.382.5.5 0 00-.369-.163zm-9.2 13a.75.75 0 01-1.5 0v-9a.75.75 0 011.5 0zm5 0a.75.75 0 01-1.5 0v-9a.75.75 0 011.5 0zM22 4h-4.75a.25.25 0 01-.25-.25V2.5A2.5 2.5 0 0014.5 0h-5A2.5 2.5 0 007 2.5v1.25a.25.25 0 01-.25.25H2a1 1 0 000 2h20a1 1 0 000-2zM9 3.75V2.5a.5.5 0 01.5-.5h5a.5.5 0 01.5.5v1.25a.25.25 0 01-.25.25h-5.5A.25.25 0 019 3.75z",
		}),
	}),
});
createIcon({
	displayName: "RepeatIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M10.319,4.936a7.239,7.239,0,0,1,7.1,2.252,1.25,1.25,0,1,0,1.872-1.657A9.737,9.737,0,0,0,9.743,2.5,10.269,10.269,0,0,0,2.378,9.61a.249.249,0,0,1-.271.178l-1.033-.13A.491.491,0,0,0,.6,9.877a.5.5,0,0,0-.019.526l2.476,4.342a.5.5,0,0,0,.373.248.43.43,0,0,0,.062,0,.5.5,0,0,0,.359-.152l3.477-3.593a.5.5,0,0,0-.3-.844L5.15,10.172a.25.25,0,0,1-.2-.333A7.7,7.7,0,0,1,10.319,4.936Z",
			}),
			jsx("path", {
				d: "M23.406,14.1a.5.5,0,0,0,.015-.526l-2.5-4.329A.5.5,0,0,0,20.546,9a.489.489,0,0,0-.421.151l-3.456,3.614a.5.5,0,0,0,.3.842l1.848.221a.249.249,0,0,1,.183.117.253.253,0,0,1,.023.216,7.688,7.688,0,0,1-5.369,4.9,7.243,7.243,0,0,1-7.1-2.253,1.25,1.25,0,1,0-1.872,1.656,9.74,9.74,0,0,0,9.549,3.03,10.261,10.261,0,0,0,7.369-7.12.251.251,0,0,1,.27-.179l1.058.127a.422.422,0,0,0,.06,0A.5.5,0,0,0,23.406,14.1Z",
			}),
		],
	}),
});
createIcon({
	displayName: "RepeatClockIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M12.965,6a1,1,0,0,0-1,1v5.5a1,1,0,0,0,1,1h5a1,1,0,0,0,0-2h-3.75a.25.25,0,0,1-.25-.25V7A1,1,0,0,0,12.965,6Z",
			}),
			jsx("path", {
				d: "M12.567,1.258A10.822,10.822,0,0,0,2.818,8.4a.25.25,0,0,1-.271.163L.858,8.309a.514.514,0,0,0-.485.213.5.5,0,0,0-.021.53l2.679,4.7a.5.5,0,0,0,.786.107l3.77-3.746a.5.5,0,0,0-.279-.85L5.593,9.007a.25.25,0,0,1-.192-.35,8.259,8.259,0,1,1,7.866,11.59,1.25,1.25,0,0,0,.045,2.5h.047a10.751,10.751,0,1,0-.792-21.487Z",
			}),
		],
	}),
});
createIcon({
	displayName: "EditIcon",
	path: jsxs("g", {
		fill: "none",
		stroke: "currentColor",
		strokeLinecap: "round",
		strokeWidth: "2",
		children: [
			jsx("path", { d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }),
			jsx("path", { d: "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" }),
		],
	}),
});
createIcon({ d: "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z", displayName: "ChevronLeftIcon" });
var ChevronRightIcon = createIcon({
		d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z",
		displayName: "ChevronRightIcon",
	}),
	ChevronDownIcon = createIcon({ displayName: "ChevronDownIcon", d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z" });
createIcon({ d: "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z", displayName: "ChevronUpIcon" });
createIcon({ d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z", displayName: "ArrowBackIcon" });
var ArrowForwardIcon = createIcon({
	d: "M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z",
	displayName: "ArrowForwardIcon",
});
createIcon({ d: "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z", displayName: "ArrowUpIcon" });
createIcon({
	viewBox: "0 0 16 16",
	d: "M11.891 9.992a1 1 0 1 1 1.416 1.415l-4.3 4.3a1 1 0 0 1-1.414 0l-4.3-4.3A1 1 0 0 1 4.71 9.992l3.59 3.591 3.591-3.591zm0-3.984L8.3 2.417 4.709 6.008a1 1 0 0 1-1.416-1.415l4.3-4.3a1 1 0 0 1 1.414 0l4.3 4.3a1 1 0 1 1-1.416 1.415z",
	displayName: "ArrowUpDownIcon",
});
createIcon({ d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z", displayName: "ArrowDownIcon" });
createIcon({
	displayName: "ExternalLinkIcon",
	path: jsxs("g", {
		fill: "none",
		stroke: "currentColor",
		strokeLinecap: "round",
		strokeWidth: "2",
		children: [
			jsx("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
			jsx("path", { d: "M15 3h6v6" }),
			jsx("path", { d: "M10 14L21 3" }),
		],
	}),
});
createIcon({
	displayName: "LinkIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M10.458,18.374,7.721,21.11a2.853,2.853,0,0,1-3.942,0l-.892-.891a2.787,2.787,0,0,1,0-3.941l5.8-5.8a2.789,2.789,0,0,1,3.942,0l.893.892A1,1,0,0,0,14.94,9.952l-.893-.892a4.791,4.791,0,0,0-6.771,0l-5.8,5.8a4.787,4.787,0,0,0,0,6.77l.892.891a4.785,4.785,0,0,0,6.771,0l2.736-2.735a1,1,0,1,0-1.414-1.415Z",
			}),
			jsx("path", {
				d: "M22.526,2.363l-.892-.892a4.8,4.8,0,0,0-6.77,0l-2.905,2.9a1,1,0,0,0,1.414,1.414l2.9-2.9a2.79,2.79,0,0,1,3.941,0l.893.893a2.786,2.786,0,0,1,0,3.942l-5.8,5.8a2.769,2.769,0,0,1-1.971.817h0a2.766,2.766,0,0,1-1.969-.816,1,1,0,1,0-1.415,1.412,4.751,4.751,0,0,0,3.384,1.4h0a4.752,4.752,0,0,0,3.385-1.4l5.8-5.8a4.786,4.786,0,0,0,0-6.771Z",
			}),
		],
	}),
});
createIcon({
	displayName: "PlusSquareIcon",
	path: jsxs("g", {
		fill: "none",
		stroke: "currentColor",
		strokeLinecap: "round",
		strokeWidth: "2",
		children: [
			jsx("rect", { height: "18", width: "18", rx: "2", ry: "2", x: "3", y: "3" }),
			jsx("path", { d: "M12 8v8" }),
			jsx("path", { d: "M8 12h8" }),
		],
	}),
});
createIcon({
	displayName: "CalendarIcon",
	viewBox: "0 0 14 14",
	d: "M10.8889,5.5 L3.11111,5.5 L3.11111,7.05556 L10.8889,7.05556 L10.8889,5.5 Z M12.4444,1.05556 L11.6667,1.05556 L11.6667,0 L10.1111,0 L10.1111,1.05556 L3.88889,1.05556 L3.88889,0 L2.33333,0 L2.33333,1.05556 L1.55556,1.05556 C0.692222,1.05556 0.00777777,1.75556 0.00777777,2.61111 L0,12.5 C0,13.3556 0.692222,14 1.55556,14 L12.4444,14 C13.3,14 14,13.3556 14,12.5 L14,2.61111 C14,1.75556 13.3,1.05556 12.4444,1.05556 Z M12.4444,12.5 L1.55556,12.5 L1.55556,3.94444 L12.4444,3.94444 L12.4444,12.5 Z M8.55556,8.61111 L3.11111,8.61111 L3.11111,10.1667 L8.55556,10.1667 L8.55556,8.61111 Z",
});
createIcon({
	d: "M0.913134,0.920639 C1.49851,0.331726 2.29348,0 3.12342,0 L10.8766,0 C11.7065,0 12.5015,0.331725 13.0869,0.920639 C13.6721,1.50939 14,2.30689 14,3.13746 L14,8.12943 C13.9962,8.51443 13.9059,8.97125 13.7629,9.32852 C13.6128,9.683 13.3552,10.0709 13.0869,10.3462 C12.813,10.6163 12.4265,10.8761 12.0734,11.0274 C11.7172,11.1716 11.2607,11.263 10.8766,11.2669 L10.1234,11.2669 L10.1234,12.5676 L10.1209,12.5676 C10.1204,12.793 10.0633,13.0791 9.97807,13.262 C9.8627,13.466 9.61158,13.7198 9.40818,13.8382 L9.40824,13.8383 C9.4077,13.8386 9.40716,13.8388 9.40661,13.8391 C9.40621,13.8393 9.4058,13.8396 9.40539,13.8398 L9.40535,13.8397 C9.22958,13.9254 8.94505,13.9951 8.75059,14 L8.74789,14 C8.35724,13.9963 7.98473,13.8383 7.71035,13.5617 L5.39553,11.2669 L3.12342,11.2669 C2.29348,11.2669 1.49851,10.9352 0.913134,10.3462 C0.644826,10.0709 0.387187,9.683 0.23711,9.32852 C0.0941235,8.97125 0.00379528,8.51443 0,8.12943 L0,3.13746 C0,2.30689 0.327915,1.50939 0.913134,0.920639 Z M3.12342,1.59494 C2.71959,1.59494 2.33133,1.75628 2.04431,2.04503 C1.75713,2.33395 1.59494,2.72681 1.59494,3.13746 L1.59494,8.12943 C1.59114,8.35901 1.62114,8.51076 1.71193,8.72129 C1.79563,8.9346 1.88065,9.06264 2.04431,9.22185 C2.33133,9.5106 2.71959,9.67195 3.12342,9.67195 L5.72383,9.67195 C5.93413,9.67195 6.13592,9.75502 6.28527,9.90308 L8.52848,12.1269 L8.52848,10.4694 C8.52848,10.029 8.88552,9.67195 9.32595,9.67195 L10.8766,9.67195 C11.1034,9.67583 11.2517,9.64614 11.4599,9.55518 C11.6712,9.47132 11.7976,9.38635 11.9557,9.22185 C12.1193,9.06264 12.2044,8.9346 12.2881,8.72129 C12.3789,8.51076 12.4089,8.35901 12.4051,8.12943 L12.4051,3.13746 C12.4051,2.72681 12.2429,2.33394 11.9557,2.04503 C11.6687,1.75628 11.2804,1.59494 10.8766,1.59494 L3.12342,1.59494 Z",
	displayName: "ChatIcon",
	viewBox: "0 0 14 14",
});
createIcon({
	displayName: "TimeIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm0,22A10,10,0,1,1,22,12,10.011,10.011,0,0,1,12,22Z",
			}),
			jsx("path", {
				d: "M17.134,15.81,12.5,11.561V6.5a1,1,0,0,0-2,0V12a1,1,0,0,0,.324.738l4.959,4.545a1.01,1.01,0,0,0,1.413-.061A1,1,0,0,0,17.134,15.81Z",
			}),
		],
	}),
});
createIcon({
	displayName: "ArrowRightIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M13.584,12a2.643,2.643,0,0,1-.775,1.875L3.268,23.416a1.768,1.768,0,0,1-2.5-2.5l8.739-8.739a.25.25,0,0,0,0-.354L.768,3.084a1.768,1.768,0,0,1,2.5-2.5l9.541,9.541A2.643,2.643,0,0,1,13.584,12Z",
			}),
			jsx("path", {
				d: "M23.75,12a2.643,2.643,0,0,1-.775,1.875l-9.541,9.541a1.768,1.768,0,0,1-2.5-2.5l8.739-8.739a.25.25,0,0,0,0-.354L10.934,3.084a1.768,1.768,0,0,1,2.5-2.5l9.541,9.541A2.643,2.643,0,0,1,23.75,12Z",
			}),
		],
	}),
});
createIcon({
	displayName: "ArrowLeftIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M10.416,12a2.643,2.643,0,0,1,.775-1.875L20.732.584a1.768,1.768,0,0,1,2.5,2.5l-8.739,8.739a.25.25,0,0,0,0,.354l8.739,8.739a1.768,1.768,0,0,1-2.5,2.5l-9.541-9.541A2.643,2.643,0,0,1,10.416,12Z",
			}),
			jsx("path", {
				d: "M.25,12a2.643,2.643,0,0,1,.775-1.875L10.566.584a1.768,1.768,0,0,1,2.5,2.5L4.327,11.823a.25.25,0,0,0,0,.354l8.739,8.739a1.768,1.768,0,0,1-2.5,2.5L1.025,13.875A2.643,2.643,0,0,1,.25,12Z",
			}),
		],
	}),
});
createIcon({
	displayName: "AtSignIcon",
	d: "M12,.5A11.634,11.634,0,0,0,.262,12,11.634,11.634,0,0,0,12,23.5a11.836,11.836,0,0,0,6.624-2,1.25,1.25,0,1,0-1.393-2.076A9.34,9.34,0,0,1,12,21a9.132,9.132,0,0,1-9.238-9A9.132,9.132,0,0,1,12,3a9.132,9.132,0,0,1,9.238,9v.891a1.943,1.943,0,0,1-3.884,0V12A5.355,5.355,0,1,0,12,17.261a5.376,5.376,0,0,0,3.861-1.634,4.438,4.438,0,0,0,7.877-2.736V12A11.634,11.634,0,0,0,12,.5Zm0,14.261A2.763,2.763,0,1,1,14.854,12,2.812,2.812,0,0,1,12,14.761Z",
});
createIcon({
	displayName: "AttachmentIcon",
	d: "M21.843,3.455a6.961,6.961,0,0,0-9.846,0L1.619,13.832a5.128,5.128,0,0,0,7.252,7.252L17.3,12.653A3.293,3.293,0,1,0,12.646,8L7.457,13.184A1,1,0,1,0,8.871,14.6L14.06,9.409a1.294,1.294,0,0,1,1.829,1.83L7.457,19.67a3.128,3.128,0,0,1-4.424-4.424L13.411,4.869a4.962,4.962,0,1,1,7.018,7.018L12.646,19.67a1,1,0,1,0,1.414,1.414L21.843,13.3a6.96,6.96,0,0,0,0-9.846Z",
});
createIcon({
	displayName: "UpDownIcon",
	viewBox: "-1 -1 9 11",
	d: "M 3.5 0L 3.98809 -0.569442L 3.5 -0.987808L 3.01191 -0.569442L 3.5 0ZM 3.5 9L 3.01191 9.56944L 3.5 9.98781L 3.98809 9.56944L 3.5 9ZM 0.488094 3.56944L 3.98809 0.569442L 3.01191 -0.569442L -0.488094 2.43056L 0.488094 3.56944ZM 3.01191 0.569442L 6.51191 3.56944L 7.48809 2.43056L 3.98809 -0.569442L 3.01191 0.569442ZM -0.488094 6.56944L 3.01191 9.56944L 3.98809 8.43056L 0.488094 5.43056L -0.488094 6.56944ZM 3.98809 9.56944L 7.48809 6.56944L 6.51191 5.43056L 3.01191 8.43056L 3.98809 9.56944Z",
});
createIcon({
	d: "M23.555,8.729a1.505,1.505,0,0,0-1.406-.98H16.062a.5.5,0,0,1-.472-.334L13.405,1.222a1.5,1.5,0,0,0-2.81,0l-.005.016L8.41,7.415a.5.5,0,0,1-.471.334H1.85A1.5,1.5,0,0,0,.887,10.4l5.184,4.3a.5.5,0,0,1,.155.543L4.048,21.774a1.5,1.5,0,0,0,2.31,1.684l5.346-3.92a.5.5,0,0,1,.591,0l5.344,3.919a1.5,1.5,0,0,0,2.312-1.683l-2.178-6.535a.5.5,0,0,1,.155-.543l5.194-4.306A1.5,1.5,0,0,0,23.555,8.729Z",
	displayName: "StarIcon",
});
createIcon({
	displayName: "EmailIcon",
	path: jsxs("g", {
		fill: "currentColor",
		children: [
			jsx("path", {
				d: "M11.114,14.556a1.252,1.252,0,0,0,1.768,0L22.568,4.87a.5.5,0,0,0-.281-.849A1.966,1.966,0,0,0,22,4H2a1.966,1.966,0,0,0-.289.021.5.5,0,0,0-.281.849Z",
			}),
			jsx("path", {
				d: "M23.888,5.832a.182.182,0,0,0-.2.039l-6.2,6.2a.251.251,0,0,0,0,.354l5.043,5.043a.75.75,0,1,1-1.06,1.061l-5.043-5.043a.25.25,0,0,0-.354,0l-2.129,2.129a2.75,2.75,0,0,1-3.888,0L7.926,13.488a.251.251,0,0,0-.354,0L2.529,18.531a.75.75,0,0,1-1.06-1.061l5.043-5.043a.251.251,0,0,0,0-.354l-6.2-6.2a.18.18,0,0,0-.2-.039A.182.182,0,0,0,0,6V18a2,2,0,0,0,2,2H22a2,2,0,0,0,2-2V6A.181.181,0,0,0,23.888,5.832Z",
			}),
		],
	}),
});
createIcon({
	d: "M2.20731,0.0127209 C2.1105,-0.0066419 1.99432,-0.00664663 1.91687,0.032079 C0.871279,0.438698 0.212942,1.92964 0.0580392,2.95587 C-0.426031,6.28627 2.20731,9.17133 4.62766,11.0689 C6.77694,12.7534 10.9012,15.5223 13.3409,12.8503 C13.6507,12.5211 14.0186,12.037 13.9993,11.553 C13.9412,10.7397 13.186,10.1588 12.6051,9.71349 C12.1598,9.38432 11.2304,8.47427 10.6495,8.49363 C10.1267,8.51299 9.79754,9.05515 9.46837,9.38432 L8.88748,9.96521 C8.79067,10.062 7.55145,9.24878 7.41591,9.15197 C6.91248,8.8228 6.4284,8.45491 6.00242,8.04829 C5.57644,7.64167 5.18919,7.19632 4.86002,6.73161 C4.7632,6.59607 3.96933,5.41495 4.04678,5.31813 C4.04678,5.31813 4.72448,4.58234 4.91811,4.2919 C5.32473,3.67229 5.63453,3.18822 5.16982,2.45243 C4.99556,2.18135 4.78257,1.96836 4.55021,1.73601 C4.14359,1.34875 3.73698,0.942131 3.27227,0.612963 C3.02055,0.419335 2.59457,0.0708094 2.20731,0.0127209 Z",
	displayName: "PhoneIcon",
	viewBox: "0 0 14 14",
});
createIcon({
	viewBox: "0 0 10 10",
	d: "M3,2 C2.44771525,2 2,1.55228475 2,1 C2,0.44771525 2.44771525,0 3,0 C3.55228475,0 4,0.44771525 4,1 C4,1.55228475 3.55228475,2 3,2 Z M3,6 C2.44771525,6 2,5.55228475 2,5 C2,4.44771525 2.44771525,4 3,4 C3.55228475,4 4,4.44771525 4,5 C4,5.55228475 3.55228475,6 3,6 Z M3,10 C2.44771525,10 2,9.55228475 2,9 C2,8.44771525 2.44771525,8 3,8 C3.55228475,8 4,8.44771525 4,9 C4,9.55228475 3.55228475,10 3,10 Z M7,2 C6.44771525,2 6,1.55228475 6,1 C6,0.44771525 6.44771525,0 7,0 C7.55228475,0 8,0.44771525 8,1 C8,1.55228475 7.55228475,2 7,2 Z M7,6 C6.44771525,6 6,5.55228475 6,5 C6,4.44771525 6.44771525,4 7,4 C7.55228475,4 8,4.44771525 8,5 C8,5.55228475 7.55228475,6 7,6 Z M7,10 C6.44771525,10 6,9.55228475 6,9 C6,8.44771525 6.44771525,8 7,8 C7.55228475,8 8,8.44771525 8,9 C8,9.55228475 7.55228475,10 7,10 Z",
	displayName: "DragHandleIcon",
});
createIcon({
	displayName: "SpinnerIcon",
	path: jsxs(Fragment, {
		children: [
			jsx("defs", {
				children: jsxs("linearGradient", {
					x1: "28.154%",
					y1: "63.74%",
					x2: "74.629%",
					y2: "17.783%",
					id: "a",
					children: [
						jsx("stop", { stopColor: "currentColor", offset: "0%" }),
						jsx("stop", { stopColor: "#fff", stopOpacity: "0", offset: "100%" }),
					],
				}),
			}),
			jsxs("g", {
				transform: "translate(2)",
				fill: "none",
				children: [
					jsx("circle", { stroke: "url(#a)", strokeWidth: "4", cx: "10", cy: "12", r: "10" }),
					jsx("path", { d: "M10 2C4.477 2 0 6.477 0 12", stroke: "currentColor", strokeWidth: "4" }),
					jsx("rect", { fill: "currentColor", x: "8", width: "4", height: "4", rx: "8" }),
				],
			}),
		],
	}),
});
var CloseIcon = createIcon({
	displayName: "CloseIcon",
	d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z",
});
createIcon({
	displayName: "SmallCloseIcon",
	viewBox: "0 0 16 16",
	path: jsx("path", {
		d: "M9.41 8l2.29-2.29c.19-.18.3-.43.3-.71a1.003 1.003 0 0 0-1.71-.71L8 6.59l-2.29-2.3a1.003 1.003 0 0 0-1.42 1.42L6.59 8 4.3 10.29c-.19.18-.3.43-.3.71a1.003 1.003 0 0 0 1.71.71L8 9.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 0 0 .71-1.71L9.41 8z",
		fillRule: "evenodd",
		fill: "currentColor",
	}),
});
createIcon({
	d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z",
	displayName: "NotAllowedIcon",
});
createIcon({
	d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z",
	displayName: "TriangleDownIcon",
});
createIcon({
	d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z",
	displayName: "TriangleUpIcon",
});
createIcon({
	displayName: "InfoOutlineIcon",
	path: jsxs("g", {
		fill: "currentColor",
		stroke: "currentColor",
		strokeLinecap: "square",
		strokeWidth: "2",
		children: [
			jsx("circle", { cx: "12", cy: "12", fill: "none", r: "11", stroke: "currentColor" }),
			jsx("line", { fill: "none", x1: "11.959", x2: "11.959", y1: "11", y2: "17" }),
			jsx("circle", { cx: "11.959", cy: "7", r: "1", stroke: "none" }),
		],
	}),
});
createIcon({
	displayName: "BellIcon",
	d: "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z",
});
createIcon({
	d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z",
});
createIcon({
	d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm0,19a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,12,19Zm1.6-6.08a1,1,0,0,0-.6.917,1,1,0,1,1-2,0,3,3,0,0,1,1.8-2.75A2,2,0,1,0,10,9.255a1,1,0,1,1-2,0,4,4,0,1,1,5.6,3.666Z",
	displayName: "QuestionIcon",
});
createIcon({
	displayName: "QuestionOutlineIcon",
	path: jsxs("g", {
		stroke: "currentColor",
		strokeWidth: "1.5",
		children: [
			jsx("path", { strokeLinecap: "round", fill: "none", d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25" }),
			jsx("path", {
				fill: "none",
				strokeLinecap: "round",
				d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0",
			}),
			jsx("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" }),
		],
	}),
});
createIcon({
	d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z",
	displayName: "WarningIcon",
});
createIcon({
	displayName: "WarningTwoIcon",
	d: "M23.119,20,13.772,2.15h0a2,2,0,0,0-3.543,0L.881,20a2,2,0,0,0,1.772,2.928H21.347A2,2,0,0,0,23.119,20ZM11,8.423a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Zm1.05,11.51h-.028a1.528,1.528,0,0,1-1.522-1.47,1.476,1.476,0,0,1,1.448-1.53h.028A1.527,1.527,0,0,1,13.5,18.4,1.475,1.475,0,0,1,12.05,19.933Z",
});
createIcon({
	viewBox: "0 0 14 14",
	path: jsx("g", {
		fill: "currentColor",
		children: jsx("polygon", {
			points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039",
		}),
	}),
});
createIcon({
	displayName: "MinusIcon",
	path: jsx("g", { fill: "currentColor", children: jsx("rect", { height: "4", width: "20", x: "2", y: "10" }) }),
});
var HamburgerIcon = createIcon({
	displayName: "HamburgerIcon",
	viewBox: "0 0 24 24",
	d: "M 3 5 A 1.0001 1.0001 0 1 0 3 7 L 21 7 A 1.0001 1.0001 0 1 0 21 5 L 3 5 z M 3 11 A 1.0001 1.0001 0 1 0 3 13 L 21 13 A 1.0001 1.0001 0 1 0 21 11 L 3 11 z M 3 17 A 1.0001 1.0001 0 1 0 3 19 L 21 19 A 1.0001 1.0001 0 1 0 21 17 L 3 17 z",
});
function HomepageCard({ title: _, names: et }) {
	useNavigate();
	const [tt, nt] = useSearchParams();
	return jsx(Center, {
		py: 6,
		children: jsxs(Box, {
			maxW: "330px",
			w: "full",
			bg: useColorModeValue("white", "gray.800"),
			boxShadow: "2xl",
			rounded: "md",
			overflow: "hidden",
			children: [
				jsx(Stack, {
					textAlign: "center",
					p: 6,
					color: useColorModeValue("gray.800", "white"),
					align: "center",
					children: jsx(Stack, {
						direction: "row",
						align: "center",
						justify: "center",
						children: jsx(Text$2, { fontSize: "2xl", fontWeight: 800, children: _ || "CSDT" }),
					}),
				}),
				jsx(Box, {
					bg: useColorModeValue("gray.50", "gray.900"),
					px: 6,
					py: 10,
					children: jsx(List, {
						spacing: 3,
						children:
							et &&
							et.map((rt) =>
								jsx(ListItem, {
									children: jsx(Button, {
										rightIcon: jsx(ArrowForwardIcon, {}),
										colorScheme: "teal",
										variant: "link",
										w: "100%",
										onClick: () => nt("name=" + rt.slug),
										children: rt.name,
									}),
								})
							),
					}),
				}),
			],
		}),
	});
}
function Footer({ tool: _ }) {
	return jsx("footer", {
		className:
			"transition-all duration-300 ease-in-out bg-gray-800 text-white mt-auto border-t bottom-0 sticky border-gray-800 w-full",
		children: jsx("div", { className: "flex flex-row py-4 justify-center ", children: jsx("p", { children: _ }) }),
	});
}
var DefaultContext = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 },
	IconContext = React$1.createContext && React$1.createContext(DefaultContext),
	__assign$3 =
		(globalThis && globalThis.__assign) ||
		function () {
			return (
				(__assign$3 =
					Object.assign ||
					function (_) {
						for (var et, tt = 1, nt = arguments.length; tt < nt; tt++) {
							et = arguments[tt];
							for (var rt in et) Object.prototype.hasOwnProperty.call(et, rt) && (_[rt] = et[rt]);
						}
						return _;
					}),
				__assign$3.apply(this, arguments)
			);
		},
	__rest$1 =
		(globalThis && globalThis.__rest) ||
		function (_, et) {
			var tt = {};
			for (var nt in _) Object.prototype.hasOwnProperty.call(_, nt) && et.indexOf(nt) < 0 && (tt[nt] = _[nt]);
			if (_ != null && typeof Object.getOwnPropertySymbols == "function")
				for (var rt = 0, nt = Object.getOwnPropertySymbols(_); rt < nt.length; rt++)
					et.indexOf(nt[rt]) < 0 && Object.prototype.propertyIsEnumerable.call(_, nt[rt]) && (tt[nt[rt]] = _[nt[rt]]);
			return tt;
		};
function Tree2Element(_) {
	return (
		_ &&
		_.map(function (et, tt) {
			return React$1.createElement(et.tag, __assign$3({ key: tt }, et.attr), Tree2Element(et.child));
		})
	);
}
function GenIcon(_) {
	return function (et) {
		return jsx(IconBase, { ...__assign$3({ attr: __assign$3({}, _.attr) }, et), children: Tree2Element(_.child) });
	};
}
function IconBase(_) {
	var et = function (tt) {
		var nt = _.attr,
			rt = _.size,
			it = _.title,
			ot = __rest$1(_, ["attr", "size", "title"]),
			at = rt || tt.size || "1em",
			st;
		return (
			tt.className && (st = tt.className),
			_.className && (st = (st ? st + " " : "") + _.className),
			jsxs("svg", {
				...__assign$3({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, tt.attr, nt, ot, {
					className: st,
					style: __assign$3(__assign$3({ color: _.color || tt.color }, tt.style), _.style),
					height: at,
					width: at,
					xmlns: "http://www.w3.org/2000/svg",
				}),
				children: [it && jsx("title", { children: it }), _.children],
			})
		);
	};
	return IconContext !== void 0
		? jsx(IconContext.Consumer, {
				children: function (tt) {
					return et(tt);
				},
		  })
		: et(DefaultContext);
}
function FaBars(_) {
	return GenIcon({
		tag: "svg",
		attr: { viewBox: "0 0 448 512" },
		child: [
			{
				tag: "path",
				attr: {
					d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z",
				},
			},
		],
	})(_);
}
function FaCog(_) {
	return GenIcon({
		tag: "svg",
		attr: { viewBox: "0 0 512 512" },
		child: [
			{
				tag: "path",
				attr: {
					d: "M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z",
				},
			},
		],
	})(_);
}
function FaUserAlt(_) {
	return GenIcon({
		tag: "svg",
		attr: { viewBox: "0 0 512 512" },
		child: [
			{
				tag: "path",
				attr: {
					d: "M256 288c79.5 0 144-64.5 144-144S335.5 0 256 0 112 64.5 112 144s64.5 144 144 144zm128 32h-55.1c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16H128C57.3 320 0 377.3 0 448v16c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48v-16c0-70.7-57.3-128-128-128z",
				},
			},
		],
	})(_);
}
function FaRegQuestionCircle(_) {
	return GenIcon({
		tag: "svg",
		attr: { viewBox: "0 0 512 512" },
		child: [
			{
				tag: "path",
				attr: {
					d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 448c-110.532 0-200-89.431-200-200 0-110.495 89.472-200 200-200 110.491 0 200 89.471 200 200 0 110.53-89.431 200-200 200zm107.244-255.2c0 67.052-72.421 68.084-72.421 92.863V300c0 6.627-5.373 12-12 12h-45.647c-6.627 0-12-5.373-12-12v-8.659c0-35.745 27.1-50.034 47.579-61.516 17.561-9.845 28.324-16.541 28.324-29.579 0-17.246-21.999-28.693-39.784-28.693-23.189 0-33.894 10.977-48.942 29.969-4.057 5.12-11.46 6.071-16.666 2.124l-27.824-21.098c-5.107-3.872-6.251-11.066-2.644-16.363C184.846 131.491 214.94 112 261.794 112c49.071 0 101.45 38.304 101.45 88.8zM298 368c0 23.159-18.841 42-42 42s-42-18.841-42-42 18.841-42 42-42 42 18.841 42 42z",
				},
			},
		],
	})(_);
}
function FaRegUser(_) {
	return GenIcon({
		tag: "svg",
		attr: { viewBox: "0 0 448 512" },
		child: [
			{
				tag: "path",
				attr: {
					d: "M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z",
				},
			},
		],
	})(_);
}
function Navigation() {
	const { isOpen: _, onToggle: et } = useDisclosure$1(),
		tt = "./img/misc",
		nt = JSON.parse(localStorage.getItem("currentUser")) || "";
	return jsxs(DarkMode, {
		children: [
			jsxs(Flex, {
				position: "sticky",
				top: 0,
				className: "bg-gray-800",
				color: "white",
				minH: "60px",
				width: "100%",
				py: { base: 2 },
				px: { base: 4 },
				zIndex: 5,
				borderBottom: 1,
				borderStyle: "solid",
				borderColor: "gray.900",
				align: "center",
				children: [
					jsx(Flex, {
						flex: { base: 1, md: "auto" },
						ml: { base: -2 },
						display: { base: "flex", md: "none" },
						children: jsx(IconButton, {
							onClick: et,
							icon: _ ? jsx(CloseIcon, { w: 3, h: 3 }) : jsx(HamburgerIcon, { w: 5, h: 5 }),
							variant: "ghost",
							"aria-label": "Toggle Navigation",
						}),
					}),
					jsxs(Flex, {
						flex: { base: 1 },
						justify: { base: "center", md: "start" },
						verticalAlign: "middle",
						children: [
							jsx("a", {
								href: "https://www.nsf.gov/",
								children: jsx(Image2, { src: tt + "/nsf.gif", boxSize: "40px" }),
							}),
							jsx("a", { href: "../../index.html", children: jsx(Image2, { src: tt + "/logo.svg" }) }),
							jsx(Flex, { display: { base: "none", md: "flex" }, ml: 10, children: jsx(DesktopNav, {}) }),
						],
					}),
					jsxs(Stack, {
						flex: { base: 1, md: 0 },
						justify: "flex-end",
						direction: "row",
						spacing: 6,
						verticalAlign: "middle",
						zIndex: 10,
						children: [
							(nt == null ? void 0 : nt.username) &&
								jsxs(Menu, {
									children: [
										jsx(MenuButton, {
											as: Button,
											rightIcon: jsx(ChevronDownIcon, {}),
											leftIcon: jsx(FaUserAlt, {}),
											variant: "ghost",
											children: jsx(chakra.span, { px: 1, children: nt == null ? void 0 : nt.username }),
										}),
										jsxs(MenuList, {
											children: [
												jsx(MenuItem, {
													onClick: () => {
														window.location.href = "/users/" + (nt == null ? void 0 : nt.id);
													},
													children: "My Projects",
												}),
												jsx(MenuItem, {
													onClick: () => {
														window.location.href = "/users/" + (nt == null ? void 0 : nt.id) + "/classes";
													},
													children: "My Classrooms",
												}),
												jsx(MenuItem, {
													onClick: () => {
														window.location.href = "/users/" + (nt == null ? void 0 : nt.id) + "/workbooks";
													},
													children: "My Workbooks",
												}),
												jsx(MenuDivider, {}),
												jsx(MenuItem, {
													onClick: () => {
														window.location.href = "/accounts/logout/";
													},
													children: "Not you? (LOGOUT)",
												}),
											],
										}),
									],
								}),
							!(nt != null && nt.username) &&
								jsxs(Fragment, {
									children: [
										jsx(Button, {
											as: "a",
											fontSize: "sm",
											fontWeight: 400,
											variant: "link",
											href: "#!",
											children: "Offline Version 1.0.0",
										}),
									],
								}),
							jsx(Center, {
								height: "auto",
								py: "10px",
								color: "teal",
								display: { base: "none", md: "inline-flex" },
								children: jsx(Divider, { orientation: "vertical", borderColor: "white" }),
							}),
							jsx("a", {
								href: "../../help/index.html",
								className: "font-lg text-bold my-auto h-full inline-flex justify-center",
								children: jsx(FaRegQuestionCircle, {}),
							}),
						],
					}),
				],
			}),
			jsx(Collapse, { in: _, animateOpacity: !0, children: jsx(MobileNav, {}) }),
		],
	});
}
const DesktopNav = () => {
		const _ = "gray.200",
			et = "white",
			tt = "gray.800";
		return jsx(Stack, {
			direction: "row",
			spacing: 4,
			alignItems: "center",
			children: NAV_ITEMS.map((nt) => {
				var rt;
				return jsx(
					Box,
					{
						children: jsxs(Popover$1, {
							trigger: "hover",
							placement: "bottom-start",
							children: [
								jsx(PopoverTrigger, {
									children: jsx(Link, {
										p: 2,
										href: (rt = nt.href) != null ? rt : "#",
										fontSize: "sm",
										fontWeight: 500,
										color: _,
										_hover: { textDecoration: "none", color: et },
										children: nt.label,
									}),
								}),
								nt.children &&
									jsx(PopoverContent$1, {
										border: 0,
										boxShadow: "xl",
										bg: tt,
										p: 4,
										rounded: "xl",
										minW: "sm",
										children: jsx(Stack, {
											children: nt.children.map((it) => jsx(DesktopSubNav, { ...it }, it.label)),
										}),
									}),
							],
						}),
					},
					nt.label
				);
			}),
		});
	},
	DesktopSubNav = ({ label: _, href: et, subLabel: tt }) =>
		jsx(Link, {
			href: et,
			role: "group",
			display: "block",
			p: 2,
			rounded: "md",
			_hover: { bg: "gray.900" },
			children: jsxs(Stack, {
				direction: "row",
				align: "center",
				children: [
					jsxs(Box, {
						children: [
							jsx(Text$2, {
								transition: "all .3s ease",
								_groupHover: { color: "pink.400" },
								fontWeight: 500,
								children: _,
							}),
							jsx(Text$2, { fontSize: "sm", children: tt }),
						],
					}),
					jsx(Flex, {
						transition: "all .3s ease",
						transform: "translateX(-10px)",
						opacity: 0,
						_groupHover: { opacity: "100%", transform: "translateX(0)" },
						justify: "flex-end",
						align: "center",
						flex: 1,
						children: jsx(Icon, { color: "pink.400", w: 5, h: 5, as: ChevronRightIcon }),
					}),
				],
			}),
		}),
	MobileNav = () =>
		jsx(Stack, {
			bg: "gray.800",
			p: 4,
			display: { md: "none" },
			children: NAV_ITEMS.map((_) => jsx(MobileNavItem, { ..._ }, _.label)),
		}),
	MobileNavItem = ({ label: _, children: et, href: tt }) => {
		const { isOpen: nt, onToggle: rt } = useDisclosure$1();
		return jsxs(Stack, {
			spacing: 4,
			onClick: et && rt,
			children: [
				jsxs(Flex, {
					py: 2,
					as: Link,
					href: tt != null ? tt : "#",
					justify: "space-between",
					align: "center",
					_hover: { textDecoration: "none" },
					children: [
						jsx(Text$2, { fontWeight: 600, color: "gray.200", children: _ }),
						et &&
							jsx(Icon, {
								as: ChevronDownIcon,
								transition: "all .25s ease-in-out",
								transform: nt ? "rotate(180deg)" : "",
								w: 6,
								h: 6,
							}),
					],
				}),
				jsx(Collapse, {
					in: nt,
					animateOpacity: !0,
					style: { marginTop: "0!important" },
					children: jsx(Stack, {
						mt: 2,
						pl: 4,
						borderLeft: 1,
						borderStyle: "solid",
						borderColor: "gray.700",
						align: "start",
						children: et && et.map((it) => jsx(Link, { py: 2, href: it.href, children: it.label }, it.label)),
					}),
				}),
			],
		});
	},
	NAV_ITEMS = [];
var axios$3 = { exports: {} },
	axios$2 = { exports: {} },
	bind$2 = function (et, tt) {
		return function () {
			for (var rt = new Array(arguments.length), it = 0; it < rt.length; it++) rt[it] = arguments[it];
			return et.apply(tt, rt);
		};
	},
	bind$1 = bind$2,
	toString$2 = Object.prototype.toString,
	kindOf = (function (_) {
		return function (et) {
			var tt = toString$2.call(et);
			return _[tt] || (_[tt] = tt.slice(8, -1).toLowerCase());
		};
	})(Object.create(null));
function kindOfTest(_) {
	return (
		(_ = _.toLowerCase()),
		function (tt) {
			return kindOf(tt) === _;
		}
	);
}
function isArray$3(_) {
	return Array.isArray(_);
}
function isUndefined$1(_) {
	return typeof _ > "u";
}
function isBuffer$1(_) {
	return (
		_ !== null &&
		!isUndefined$1(_) &&
		_.constructor !== null &&
		!isUndefined$1(_.constructor) &&
		typeof _.constructor.isBuffer == "function" &&
		_.constructor.isBuffer(_)
	);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(_) {
	var et;
	return (
		typeof ArrayBuffer < "u" && ArrayBuffer.isView
			? (et = ArrayBuffer.isView(_))
			: (et = _ && _.buffer && isArrayBuffer(_.buffer)),
		et
	);
}
function isString$2(_) {
	return typeof _ == "string";
}
function isNumber$2(_) {
	return typeof _ == "number";
}
function isObject$2(_) {
	return _ !== null && typeof _ == "object";
}
function isPlainObject$2(_) {
	if (kindOf(_) !== "object") return !1;
	var et = Object.getPrototypeOf(_);
	return et === null || et === Object.prototype;
}
var isDate = kindOfTest("Date"),
	isFile = kindOfTest("File"),
	isBlob = kindOfTest("Blob"),
	isFileList = kindOfTest("FileList");
function isFunction$3(_) {
	return toString$2.call(_) === "[object Function]";
}
function isStream(_) {
	return isObject$2(_) && isFunction$3(_.pipe);
}
function isFormData(_) {
	var et = "[object FormData]";
	return (
		_ &&
		((typeof FormData == "function" && _ instanceof FormData) ||
			toString$2.call(_) === et ||
			(isFunction$3(_.toString) && _.toString() === et))
	);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim$1(_) {
	return _.trim ? _.trim() : _.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
	return typeof navigator < "u" &&
		(navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")
		? !1
		: typeof window < "u" && typeof document < "u";
}
function forEach(_, et) {
	if (!(_ === null || typeof _ > "u"))
		if ((typeof _ != "object" && (_ = [_]), isArray$3(_)))
			for (var tt = 0, nt = _.length; tt < nt; tt++) et.call(null, _[tt], tt, _);
		else for (var rt in _) Object.prototype.hasOwnProperty.call(_, rt) && et.call(null, _[rt], rt, _);
}
function merge$1() {
	var _ = {};
	function et(rt, it) {
		isPlainObject$2(_[it]) && isPlainObject$2(rt)
			? (_[it] = merge$1(_[it], rt))
			: isPlainObject$2(rt)
			? (_[it] = merge$1({}, rt))
			: isArray$3(rt)
			? (_[it] = rt.slice())
			: (_[it] = rt);
	}
	for (var tt = 0, nt = arguments.length; tt < nt; tt++) forEach(arguments[tt], et);
	return _;
}
function extend$2(_, et, tt) {
	return (
		forEach(et, function (rt, it) {
			tt && typeof rt == "function" ? (_[it] = bind$1(rt, tt)) : (_[it] = rt);
		}),
		_
	);
}
function stripBOM(_) {
	return _.charCodeAt(0) === 65279 && (_ = _.slice(1)), _;
}
function inherits(_, et, tt, nt) {
	(_.prototype = Object.create(et.prototype, nt)), (_.prototype.constructor = _), tt && Object.assign(_.prototype, tt);
}
function toFlatObject(_, et, tt) {
	var nt,
		rt,
		it,
		ot = {};
	et = et || {};
	do {
		for (nt = Object.getOwnPropertyNames(_), rt = nt.length; rt-- > 0; )
			(it = nt[rt]), ot[it] || ((et[it] = _[it]), (ot[it] = !0));
		_ = Object.getPrototypeOf(_);
	} while (_ && (!tt || tt(_, et)) && _ !== Object.prototype);
	return et;
}
function endsWith(_, et, tt) {
	(_ = String(_)), (tt === void 0 || tt > _.length) && (tt = _.length), (tt -= et.length);
	var nt = _.indexOf(et, tt);
	return nt !== -1 && nt === tt;
}
function toArray(_) {
	if (!_) return null;
	var et = _.length;
	if (isUndefined$1(et)) return null;
	for (var tt = new Array(et); et-- > 0; ) tt[et] = _[et];
	return tt;
}
var isTypedArray = (function (_) {
		return function (et) {
			return _ && et instanceof _;
		};
	})(typeof Uint8Array < "u" && Object.getPrototypeOf(Uint8Array)),
	utils$e = {
		isArray: isArray$3,
		isArrayBuffer,
		isBuffer: isBuffer$1,
		isFormData,
		isArrayBufferView,
		isString: isString$2,
		isNumber: isNumber$2,
		isObject: isObject$2,
		isPlainObject: isPlainObject$2,
		isUndefined: isUndefined$1,
		isDate,
		isFile,
		isBlob,
		isFunction: isFunction$3,
		isStream,
		isURLSearchParams,
		isStandardBrowserEnv,
		forEach,
		merge: merge$1,
		extend: extend$2,
		trim: trim$1,
		stripBOM,
		inherits,
		toFlatObject,
		kindOf,
		kindOfTest,
		endsWith,
		toArray,
		isTypedArray,
		isFileList,
	},
	utils$d = utils$e;
function encode$1(_) {
	return encodeURIComponent(_)
		.replace(/%3A/gi, ":")
		.replace(/%24/g, "$")
		.replace(/%2C/gi, ",")
		.replace(/%20/g, "+")
		.replace(/%5B/gi, "[")
		.replace(/%5D/gi, "]");
}
var buildURL$1 = function (et, tt, nt) {
		if (!tt) return et;
		var rt;
		if (nt) rt = nt(tt);
		else if (utils$d.isURLSearchParams(tt)) rt = tt.toString();
		else {
			var it = [];
			utils$d.forEach(tt, function (st, lt) {
				st === null ||
					typeof st > "u" ||
					(utils$d.isArray(st) ? (lt = lt + "[]") : (st = [st]),
					utils$d.forEach(st, function (dt) {
						utils$d.isDate(dt) ? (dt = dt.toISOString()) : utils$d.isObject(dt) && (dt = JSON.stringify(dt)),
							it.push(encode$1(lt) + "=" + encode$1(dt));
					}));
			}),
				(rt = it.join("&"));
		}
		if (rt) {
			var ot = et.indexOf("#");
			ot !== -1 && (et = et.slice(0, ot)), (et += (et.indexOf("?") === -1 ? "?" : "&") + rt);
		}
		return et;
	},
	utils$c = utils$e;
function InterceptorManager$1() {
	this.handlers = [];
}
InterceptorManager$1.prototype.use = function (et, tt, nt) {
	return (
		this.handlers.push({
			fulfilled: et,
			rejected: tt,
			synchronous: nt ? nt.synchronous : !1,
			runWhen: nt ? nt.runWhen : null,
		}),
		this.handlers.length - 1
	);
};
InterceptorManager$1.prototype.eject = function (et) {
	this.handlers[et] && (this.handlers[et] = null);
};
InterceptorManager$1.prototype.forEach = function (et) {
	utils$c.forEach(this.handlers, function (nt) {
		nt !== null && et(nt);
	});
};
var InterceptorManager_1 = InterceptorManager$1,
	utils$b = utils$e,
	normalizeHeaderName$1 = function (et, tt) {
		utils$b.forEach(et, function (rt, it) {
			it !== tt && it.toUpperCase() === tt.toUpperCase() && ((et[tt] = rt), delete et[it]);
		});
	},
	utils$a = utils$e;
function AxiosError$2(_, et, tt, nt, rt) {
	Error.call(this),
		(this.message = _),
		(this.name = "AxiosError"),
		et && (this.code = et),
		tt && (this.config = tt),
		nt && (this.request = nt),
		rt && (this.response = rt);
}
utils$a.inherits(AxiosError$2, Error, {
	toJSON: function () {
		return {
			message: this.message,
			name: this.name,
			description: this.description,
			number: this.number,
			fileName: this.fileName,
			lineNumber: this.lineNumber,
			columnNumber: this.columnNumber,
			stack: this.stack,
			config: this.config,
			code: this.code,
			status: this.response && this.response.status ? this.response.status : null,
		};
	},
});
var prototype = AxiosError$2.prototype,
	descriptors = {};
[
	"ERR_BAD_OPTION_VALUE",
	"ERR_BAD_OPTION",
	"ECONNABORTED",
	"ETIMEDOUT",
	"ERR_NETWORK",
	"ERR_FR_TOO_MANY_REDIRECTS",
	"ERR_DEPRECATED",
	"ERR_BAD_RESPONSE",
	"ERR_BAD_REQUEST",
	"ERR_CANCELED",
].forEach(function (_) {
	descriptors[_] = { value: _ };
});
Object.defineProperties(AxiosError$2, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: !0 });
AxiosError$2.from = function (_, et, tt, nt, rt, it) {
	var ot = Object.create(prototype);
	return (
		utils$a.toFlatObject(_, ot, function (st) {
			return st !== Error.prototype;
		}),
		AxiosError$2.call(ot, _.message, et, tt, nt, rt),
		(ot.name = _.name),
		it && Object.assign(ot, it),
		ot
	);
};
var AxiosError_1 = AxiosError$2,
	transitional = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
	utils$9 = utils$e;
function toFormData$1(_, et) {
	et = et || new FormData();
	var tt = [];
	function nt(it) {
		return it === null
			? ""
			: utils$9.isDate(it)
			? it.toISOString()
			: utils$9.isArrayBuffer(it) || utils$9.isTypedArray(it)
			? typeof Blob == "function"
				? new Blob([it])
				: Buffer.from(it)
			: it;
	}
	function rt(it, ot) {
		if (utils$9.isPlainObject(it) || utils$9.isArray(it)) {
			if (tt.indexOf(it) !== -1) throw Error("Circular reference detected in " + ot);
			tt.push(it),
				utils$9.forEach(it, function (st, lt) {
					if (!utils$9.isUndefined(st)) {
						var ut = ot ? ot + "." + lt : lt,
							dt;
						if (st && !ot && typeof st == "object") {
							if (utils$9.endsWith(lt, "{}")) st = JSON.stringify(st);
							else if (utils$9.endsWith(lt, "[]") && (dt = utils$9.toArray(st))) {
								dt.forEach(function (ct) {
									!utils$9.isUndefined(ct) && et.append(ut, nt(ct));
								});
								return;
							}
						}
						rt(st, ut);
					}
				}),
				tt.pop();
		} else et.append(ot, nt(it));
	}
	return rt(_), et;
}
var toFormData_1 = toFormData$1,
	settle,
	hasRequiredSettle;
function requireSettle() {
	if (hasRequiredSettle) return settle;
	hasRequiredSettle = 1;
	var _ = AxiosError_1;
	return (
		(settle = function (tt, nt, rt) {
			var it = rt.config.validateStatus;
			!rt.status || !it || it(rt.status)
				? tt(rt)
				: nt(
						new _(
							"Request failed with status code " + rt.status,
							[_.ERR_BAD_REQUEST, _.ERR_BAD_RESPONSE][Math.floor(rt.status / 100) - 4],
							rt.config,
							rt.request,
							rt
						)
				  );
		}),
		settle
	);
}
var cookies, hasRequiredCookies;
function requireCookies() {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;
	var _ = utils$e;
	return (
		(cookies = _.isStandardBrowserEnv()
			? (function () {
					return {
						write: function (nt, rt, it, ot, at, st) {
							var lt = [];
							lt.push(nt + "=" + encodeURIComponent(rt)),
								_.isNumber(it) && lt.push("expires=" + new Date(it).toGMTString()),
								_.isString(ot) && lt.push("path=" + ot),
								_.isString(at) && lt.push("domain=" + at),
								st === !0 && lt.push("secure"),
								(document.cookie = lt.join("; "));
						},
						read: function (nt) {
							var rt = document.cookie.match(new RegExp("(^|;\\s*)(" + nt + ")=([^;]*)"));
							return rt ? decodeURIComponent(rt[3]) : null;
						},
						remove: function (nt) {
							this.write(nt, "", Date.now() - 864e5);
						},
					};
			  })()
			: (function () {
					return {
						write: function () {},
						read: function () {
							return null;
						},
						remove: function () {},
					};
			  })()),
		cookies
	);
}
var isAbsoluteURL$1 = function (et) {
		return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(et);
	},
	combineURLs$1 = function (et, tt) {
		return tt ? et.replace(/\/+$/, "") + "/" + tt.replace(/^\/+/, "") : et;
	},
	isAbsoluteURL = isAbsoluteURL$1,
	combineURLs = combineURLs$1,
	buildFullPath$1 = function (et, tt) {
		return et && !isAbsoluteURL(tt) ? combineURLs(et, tt) : tt;
	},
	parseHeaders,
	hasRequiredParseHeaders;
function requireParseHeaders() {
	if (hasRequiredParseHeaders) return parseHeaders;
	hasRequiredParseHeaders = 1;
	var _ = utils$e,
		et = [
			"age",
			"authorization",
			"content-length",
			"content-type",
			"etag",
			"expires",
			"from",
			"host",
			"if-modified-since",
			"if-unmodified-since",
			"last-modified",
			"location",
			"max-forwards",
			"proxy-authorization",
			"referer",
			"retry-after",
			"user-agent",
		];
	return (
		(parseHeaders = function (nt) {
			var rt = {},
				it,
				ot,
				at;
			return (
				nt &&
					_.forEach(
						nt.split(`
`),
						function (lt) {
							if (
								((at = lt.indexOf(":")),
								(it = _.trim(lt.substr(0, at)).toLowerCase()),
								(ot = _.trim(lt.substr(at + 1))),
								it)
							) {
								if (rt[it] && et.indexOf(it) >= 0) return;
								it === "set-cookie"
									? (rt[it] = (rt[it] ? rt[it] : []).concat([ot]))
									: (rt[it] = rt[it] ? rt[it] + ", " + ot : ot);
							}
						}
					),
				rt
			);
		}),
		parseHeaders
	);
}
var isURLSameOrigin, hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
	if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
	hasRequiredIsURLSameOrigin = 1;
	var _ = utils$e;
	return (
		(isURLSameOrigin = _.isStandardBrowserEnv()
			? (function () {
					var tt = /(msie|trident)/i.test(navigator.userAgent),
						nt = document.createElement("a"),
						rt;
					function it(ot) {
						var at = ot;
						return (
							tt && (nt.setAttribute("href", at), (at = nt.href)),
							nt.setAttribute("href", at),
							{
								href: nt.href,
								protocol: nt.protocol ? nt.protocol.replace(/:$/, "") : "",
								host: nt.host,
								search: nt.search ? nt.search.replace(/^\?/, "") : "",
								hash: nt.hash ? nt.hash.replace(/^#/, "") : "",
								hostname: nt.hostname,
								port: nt.port,
								pathname: nt.pathname.charAt(0) === "/" ? nt.pathname : "/" + nt.pathname,
							}
						);
					}
					return (
						(rt = it(window.location.href)),
						function (at) {
							var st = _.isString(at) ? it(at) : at;
							return st.protocol === rt.protocol && st.host === rt.host;
						}
					);
			  })()
			: (function () {
					return function () {
						return !0;
					};
			  })()),
		isURLSameOrigin
	);
}
var CanceledError_1, hasRequiredCanceledError;
function requireCanceledError() {
	if (hasRequiredCanceledError) return CanceledError_1;
	hasRequiredCanceledError = 1;
	var _ = AxiosError_1,
		et = utils$e;
	function tt(nt) {
		_.call(this, nt == null ? "canceled" : nt, _.ERR_CANCELED), (this.name = "CanceledError");
	}
	return et.inherits(tt, _, { __CANCEL__: !0 }), (CanceledError_1 = tt), CanceledError_1;
}
var parseProtocol, hasRequiredParseProtocol;
function requireParseProtocol() {
	return (
		hasRequiredParseProtocol ||
			((hasRequiredParseProtocol = 1),
			(parseProtocol = function (et) {
				var tt = /^([-+\w]{1,25})(:?\/\/|:)/.exec(et);
				return (tt && tt[1]) || "";
			})),
		parseProtocol
	);
}
var xhr, hasRequiredXhr;
function requireXhr() {
	if (hasRequiredXhr) return xhr;
	hasRequiredXhr = 1;
	var _ = utils$e,
		et = requireSettle(),
		tt = requireCookies(),
		nt = buildURL$1,
		rt = buildFullPath$1,
		it = requireParseHeaders(),
		ot = requireIsURLSameOrigin(),
		at = transitional,
		st = AxiosError_1,
		lt = requireCanceledError(),
		ut = requireParseProtocol();
	return (
		(xhr = function (ct) {
			return new Promise(function (mt, pt) {
				var vt = ct.data,
					ht = ct.headers,
					gt = ct.responseType,
					yt;
				function xt() {
					ct.cancelToken && ct.cancelToken.unsubscribe(yt), ct.signal && ct.signal.removeEventListener("abort", yt);
				}
				_.isFormData(vt) && _.isStandardBrowserEnv() && delete ht["Content-Type"];
				var St = new XMLHttpRequest();
				if (ct.auth) {
					var wt = ct.auth.username || "",
						Ct = ct.auth.password ? unescape(encodeURIComponent(ct.auth.password)) : "";
					ht.Authorization = "Basic " + btoa(wt + ":" + Ct);
				}
				var Et = rt(ct.baseURL, ct.url);
				St.open(ct.method.toUpperCase(), nt(Et, ct.params, ct.paramsSerializer), !0), (St.timeout = ct.timeout);
				function _t() {
					if (!!St) {
						var Lt = "getAllResponseHeaders" in St ? it(St.getAllResponseHeaders()) : null,
							Nt = !gt || gt === "text" || gt === "json" ? St.responseText : St.response,
							Ft = { data: Nt, status: St.status, statusText: St.statusText, headers: Lt, config: ct, request: St };
						et(
							function (Bt) {
								mt(Bt), xt();
							},
							function (Bt) {
								pt(Bt), xt();
							},
							Ft
						),
							(St = null);
					}
				}
				if (
					("onloadend" in St
						? (St.onloadend = _t)
						: (St.onreadystatechange = function () {
								!St ||
									St.readyState !== 4 ||
									(St.status === 0 && !(St.responseURL && St.responseURL.indexOf("file:") === 0)) ||
									setTimeout(_t);
						  }),
					(St.onabort = function () {
						!St || (pt(new st("Request aborted", st.ECONNABORTED, ct, St)), (St = null));
					}),
					(St.onerror = function () {
						pt(new st("Network Error", st.ERR_NETWORK, ct, St, St)), (St = null);
					}),
					(St.ontimeout = function () {
						var Nt = ct.timeout ? "timeout of " + ct.timeout + "ms exceeded" : "timeout exceeded",
							Ft = ct.transitional || at;
						ct.timeoutErrorMessage && (Nt = ct.timeoutErrorMessage),
							pt(new st(Nt, Ft.clarifyTimeoutError ? st.ETIMEDOUT : st.ECONNABORTED, ct, St)),
							(St = null);
					}),
					_.isStandardBrowserEnv())
				) {
					var $t = (ct.withCredentials || ot(Et)) && ct.xsrfCookieName ? tt.read(ct.xsrfCookieName) : void 0;
					$t && (ht[ct.xsrfHeaderName] = $t);
				}
				"setRequestHeader" in St &&
					_.forEach(ht, function (Nt, Ft) {
						typeof vt > "u" && Ft.toLowerCase() === "content-type" ? delete ht[Ft] : St.setRequestHeader(Ft, Nt);
					}),
					_.isUndefined(ct.withCredentials) || (St.withCredentials = !!ct.withCredentials),
					gt && gt !== "json" && (St.responseType = ct.responseType),
					typeof ct.onDownloadProgress == "function" && St.addEventListener("progress", ct.onDownloadProgress),
					typeof ct.onUploadProgress == "function" &&
						St.upload &&
						St.upload.addEventListener("progress", ct.onUploadProgress),
					(ct.cancelToken || ct.signal) &&
						((yt = function (Lt) {
							!St || (pt(!Lt || (Lt && Lt.type) ? new lt() : Lt), St.abort(), (St = null));
						}),
						ct.cancelToken && ct.cancelToken.subscribe(yt),
						ct.signal && (ct.signal.aborted ? yt() : ct.signal.addEventListener("abort", yt))),
					vt || (vt = null);
				var At = ut(Et);
				if (At && ["http", "https", "file"].indexOf(At) === -1) {
					pt(new st("Unsupported protocol " + At + ":", st.ERR_BAD_REQUEST, ct));
					return;
				}
				St.send(vt);
			});
		}),
		xhr
	);
}
var _null, hasRequired_null;
function require_null() {
	return hasRequired_null || ((hasRequired_null = 1), (_null = null)), _null;
}
var utils$8 = utils$e,
	normalizeHeaderName = normalizeHeaderName$1,
	AxiosError$1 = AxiosError_1,
	transitionalDefaults = transitional,
	toFormData = toFormData_1,
	DEFAULT_CONTENT_TYPE = { "Content-Type": "application/x-www-form-urlencoded" };
function setContentTypeIfUnset(_, et) {
	!utils$8.isUndefined(_) && utils$8.isUndefined(_["Content-Type"]) && (_["Content-Type"] = et);
}
function getDefaultAdapter() {
	var _;
	return (
		(typeof XMLHttpRequest < "u" ||
			(typeof process < "u" && Object.prototype.toString.call(process) === "[object process]")) &&
			(_ = requireXhr()),
		_
	);
}
function stringifySafely(_, et, tt) {
	if (utils$8.isString(_))
		try {
			return (et || JSON.parse)(_), utils$8.trim(_);
		} catch (nt) {
			if (nt.name !== "SyntaxError") throw nt;
		}
	return (tt || JSON.stringify)(_);
}
var defaults$5 = {
	transitional: transitionalDefaults,
	adapter: getDefaultAdapter(),
	transformRequest: [
		function (et, tt) {
			if (
				(normalizeHeaderName(tt, "Accept"),
				normalizeHeaderName(tt, "Content-Type"),
				utils$8.isFormData(et) ||
					utils$8.isArrayBuffer(et) ||
					utils$8.isBuffer(et) ||
					utils$8.isStream(et) ||
					utils$8.isFile(et) ||
					utils$8.isBlob(et))
			)
				return et;
			if (utils$8.isArrayBufferView(et)) return et.buffer;
			if (utils$8.isURLSearchParams(et))
				return setContentTypeIfUnset(tt, "application/x-www-form-urlencoded;charset=utf-8"), et.toString();
			var nt = utils$8.isObject(et),
				rt = tt && tt["Content-Type"],
				it;
			if ((it = utils$8.isFileList(et)) || (nt && rt === "multipart/form-data")) {
				var ot = this.env && this.env.FormData;
				return toFormData(it ? { "files[]": et } : et, ot && new ot());
			} else if (nt || rt === "application/json")
				return setContentTypeIfUnset(tt, "application/json"), stringifySafely(et);
			return et;
		},
	],
	transformResponse: [
		function (et) {
			var tt = this.transitional || defaults$5.transitional,
				nt = tt && tt.silentJSONParsing,
				rt = tt && tt.forcedJSONParsing,
				it = !nt && this.responseType === "json";
			if (it || (rt && utils$8.isString(et) && et.length))
				try {
					return JSON.parse(et);
				} catch (ot) {
					if (it)
						throw ot.name === "SyntaxError"
							? AxiosError$1.from(ot, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response)
							: ot;
				}
			return et;
		},
	],
	timeout: 0,
	xsrfCookieName: "XSRF-TOKEN",
	xsrfHeaderName: "X-XSRF-TOKEN",
	maxContentLength: -1,
	maxBodyLength: -1,
	env: { FormData: require_null() },
	validateStatus: function (et) {
		return et >= 200 && et < 300;
	},
	headers: { common: { Accept: "application/json, text/plain, */*" } },
};
utils$8.forEach(["delete", "get", "head"], function (et) {
	defaults$5.headers[et] = {};
});
utils$8.forEach(["post", "put", "patch"], function (et) {
	defaults$5.headers[et] = utils$8.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$5,
	utils$7 = utils$e,
	defaults$4 = defaults_1,
	transformData$1 = function (et, tt, nt) {
		var rt = this || defaults$4;
		return (
			utils$7.forEach(nt, function (ot) {
				et = ot.call(rt, et, tt);
			}),
			et
		);
	},
	isCancel$1,
	hasRequiredIsCancel;
function requireIsCancel() {
	return (
		hasRequiredIsCancel ||
			((hasRequiredIsCancel = 1),
			(isCancel$1 = function (et) {
				return !!(et && et.__CANCEL__);
			})),
		isCancel$1
	);
}
var utils$6 = utils$e,
	transformData = transformData$1,
	isCancel = requireIsCancel(),
	defaults$3 = defaults_1,
	CanceledError = requireCanceledError();
function throwIfCancellationRequested(_) {
	if ((_.cancelToken && _.cancelToken.throwIfRequested(), _.signal && _.signal.aborted)) throw new CanceledError();
}
var dispatchRequest$1 = function (et) {
		throwIfCancellationRequested(et),
			(et.headers = et.headers || {}),
			(et.data = transformData.call(et, et.data, et.headers, et.transformRequest)),
			(et.headers = utils$6.merge(et.headers.common || {}, et.headers[et.method] || {}, et.headers)),
			utils$6.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function (rt) {
				delete et.headers[rt];
			});
		var tt = et.adapter || defaults$3.adapter;
		return tt(et).then(
			function (rt) {
				return (
					throwIfCancellationRequested(et),
					(rt.data = transformData.call(et, rt.data, rt.headers, et.transformResponse)),
					rt
				);
			},
			function (rt) {
				return (
					isCancel(rt) ||
						(throwIfCancellationRequested(et),
						rt &&
							rt.response &&
							(rt.response.data = transformData.call(et, rt.response.data, rt.response.headers, et.transformResponse))),
					Promise.reject(rt)
				);
			}
		);
	},
	utils$5 = utils$e,
	mergeConfig$2 = function (et, tt) {
		tt = tt || {};
		var nt = {};
		function rt(ut, dt) {
			return utils$5.isPlainObject(ut) && utils$5.isPlainObject(dt)
				? utils$5.merge(ut, dt)
				: utils$5.isPlainObject(dt)
				? utils$5.merge({}, dt)
				: utils$5.isArray(dt)
				? dt.slice()
				: dt;
		}
		function it(ut) {
			if (utils$5.isUndefined(tt[ut])) {
				if (!utils$5.isUndefined(et[ut])) return rt(void 0, et[ut]);
			} else return rt(et[ut], tt[ut]);
		}
		function ot(ut) {
			if (!utils$5.isUndefined(tt[ut])) return rt(void 0, tt[ut]);
		}
		function at(ut) {
			if (utils$5.isUndefined(tt[ut])) {
				if (!utils$5.isUndefined(et[ut])) return rt(void 0, et[ut]);
			} else return rt(void 0, tt[ut]);
		}
		function st(ut) {
			if (ut in tt) return rt(et[ut], tt[ut]);
			if (ut in et) return rt(void 0, et[ut]);
		}
		var lt = {
			url: ot,
			method: ot,
			data: ot,
			baseURL: at,
			transformRequest: at,
			transformResponse: at,
			paramsSerializer: at,
			timeout: at,
			timeoutMessage: at,
			withCredentials: at,
			adapter: at,
			responseType: at,
			xsrfCookieName: at,
			xsrfHeaderName: at,
			onUploadProgress: at,
			onDownloadProgress: at,
			decompress: at,
			maxContentLength: at,
			maxBodyLength: at,
			beforeRedirect: at,
			transport: at,
			httpAgent: at,
			httpsAgent: at,
			cancelToken: at,
			socketPath: at,
			responseEncoding: at,
			validateStatus: st,
		};
		return (
			utils$5.forEach(Object.keys(et).concat(Object.keys(tt)), function (dt) {
				var ct = lt[dt] || it,
					ft = ct(dt);
				(utils$5.isUndefined(ft) && ct !== st) || (nt[dt] = ft);
			}),
			nt
		);
	},
	data,
	hasRequiredData;
function requireData() {
	return hasRequiredData || ((hasRequiredData = 1), (data = { version: "0.27.2" })), data;
}
var VERSION = requireData().version,
	AxiosError = AxiosError_1,
	validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function (_, et) {
	validators$1[_] = function (nt) {
		return typeof nt === _ || "a" + (et < 1 ? "n " : " ") + _;
	};
});
var deprecatedWarnings = {};
validators$1.transitional = function (et, tt, nt) {
	function rt(it, ot) {
		return "[Axios v" + VERSION + "] Transitional option '" + it + "'" + ot + (nt ? ". " + nt : "");
	}
	return function (it, ot, at) {
		if (et === !1)
			throw new AxiosError(rt(ot, " has been removed" + (tt ? " in " + tt : "")), AxiosError.ERR_DEPRECATED);
		return (
			tt &&
				!deprecatedWarnings[ot] &&
				((deprecatedWarnings[ot] = !0),
				console.warn(rt(ot, " has been deprecated since v" + tt + " and will be removed in the near future"))),
			et ? et(it, ot, at) : !0
		);
	};
};
function assertOptions(_, et, tt) {
	if (typeof _ != "object") throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
	for (var nt = Object.keys(_), rt = nt.length; rt-- > 0; ) {
		var it = nt[rt],
			ot = et[it];
		if (ot) {
			var at = _[it],
				st = at === void 0 || ot(at, it, _);
			if (st !== !0) throw new AxiosError("option " + it + " must be " + st, AxiosError.ERR_BAD_OPTION_VALUE);
			continue;
		}
		if (tt !== !0) throw new AxiosError("Unknown option " + it, AxiosError.ERR_BAD_OPTION);
	}
}
var validator$1 = { assertOptions, validators: validators$1 },
	utils$4 = utils$e,
	buildURL = buildURL$1,
	InterceptorManager = InterceptorManager_1,
	dispatchRequest = dispatchRequest$1,
	mergeConfig$1 = mergeConfig$2,
	buildFullPath = buildFullPath$1,
	validator = validator$1,
	validators = validator.validators;
function Axios$1(_) {
	(this.defaults = _), (this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() });
}
Axios$1.prototype.request = function (et, tt) {
	typeof et == "string" ? ((tt = tt || {}), (tt.url = et)) : (tt = et || {}),
		(tt = mergeConfig$1(this.defaults, tt)),
		tt.method
			? (tt.method = tt.method.toLowerCase())
			: this.defaults.method
			? (tt.method = this.defaults.method.toLowerCase())
			: (tt.method = "get");
	var nt = tt.transitional;
	nt !== void 0 &&
		validator.assertOptions(
			nt,
			{
				silentJSONParsing: validators.transitional(validators.boolean),
				forcedJSONParsing: validators.transitional(validators.boolean),
				clarifyTimeoutError: validators.transitional(validators.boolean),
			},
			!1
		);
	var rt = [],
		it = !0;
	this.interceptors.request.forEach(function (ft) {
		(typeof ft.runWhen == "function" && ft.runWhen(tt) === !1) ||
			((it = it && ft.synchronous), rt.unshift(ft.fulfilled, ft.rejected));
	});
	var ot = [];
	this.interceptors.response.forEach(function (ft) {
		ot.push(ft.fulfilled, ft.rejected);
	});
	var at;
	if (!it) {
		var st = [dispatchRequest, void 0];
		for (Array.prototype.unshift.apply(st, rt), st = st.concat(ot), at = Promise.resolve(tt); st.length; )
			at = at.then(st.shift(), st.shift());
		return at;
	}
	for (var lt = tt; rt.length; ) {
		var ut = rt.shift(),
			dt = rt.shift();
		try {
			lt = ut(lt);
		} catch (ct) {
			dt(ct);
			break;
		}
	}
	try {
		at = dispatchRequest(lt);
	} catch (ct) {
		return Promise.reject(ct);
	}
	for (; ot.length; ) at = at.then(ot.shift(), ot.shift());
	return at;
};
Axios$1.prototype.getUri = function (et) {
	et = mergeConfig$1(this.defaults, et);
	var tt = buildFullPath(et.baseURL, et.url);
	return buildURL(tt, et.params, et.paramsSerializer);
};
utils$4.forEach(["delete", "get", "head", "options"], function (et) {
	Axios$1.prototype[et] = function (tt, nt) {
		return this.request(mergeConfig$1(nt || {}, { method: et, url: tt, data: (nt || {}).data }));
	};
});
utils$4.forEach(["post", "put", "patch"], function (et) {
	function tt(nt) {
		return function (it, ot, at) {
			return this.request(
				mergeConfig$1(at || {}, {
					method: et,
					headers: nt ? { "Content-Type": "multipart/form-data" } : {},
					url: it,
					data: ot,
				})
			);
		};
	}
	(Axios$1.prototype[et] = tt()), (Axios$1.prototype[et + "Form"] = tt(!0));
});
var Axios_1 = Axios$1,
	CancelToken_1,
	hasRequiredCancelToken;
function requireCancelToken() {
	if (hasRequiredCancelToken) return CancelToken_1;
	hasRequiredCancelToken = 1;
	var _ = requireCanceledError();
	function et(tt) {
		if (typeof tt != "function") throw new TypeError("executor must be a function.");
		var nt;
		this.promise = new Promise(function (ot) {
			nt = ot;
		});
		var rt = this;
		this.promise.then(function (it) {
			if (!!rt._listeners) {
				var ot,
					at = rt._listeners.length;
				for (ot = 0; ot < at; ot++) rt._listeners[ot](it);
				rt._listeners = null;
			}
		}),
			(this.promise.then = function (it) {
				var ot,
					at = new Promise(function (st) {
						rt.subscribe(st), (ot = st);
					}).then(it);
				return (
					(at.cancel = function () {
						rt.unsubscribe(ot);
					}),
					at
				);
			}),
			tt(function (ot) {
				rt.reason || ((rt.reason = new _(ot)), nt(rt.reason));
			});
	}
	return (
		(et.prototype.throwIfRequested = function () {
			if (this.reason) throw this.reason;
		}),
		(et.prototype.subscribe = function (nt) {
			if (this.reason) {
				nt(this.reason);
				return;
			}
			this._listeners ? this._listeners.push(nt) : (this._listeners = [nt]);
		}),
		(et.prototype.unsubscribe = function (nt) {
			if (!!this._listeners) {
				var rt = this._listeners.indexOf(nt);
				rt !== -1 && this._listeners.splice(rt, 1);
			}
		}),
		(et.source = function () {
			var nt,
				rt = new et(function (ot) {
					nt = ot;
				});
			return { token: rt, cancel: nt };
		}),
		(CancelToken_1 = et),
		CancelToken_1
	);
}
var spread, hasRequiredSpread;
function requireSpread() {
	return (
		hasRequiredSpread ||
			((hasRequiredSpread = 1),
			(spread = function (et) {
				return function (nt) {
					return et.apply(null, nt);
				};
			})),
		spread
	);
}
var isAxiosError, hasRequiredIsAxiosError;
function requireIsAxiosError() {
	if (hasRequiredIsAxiosError) return isAxiosError;
	hasRequiredIsAxiosError = 1;
	var _ = utils$e;
	return (
		(isAxiosError = function (tt) {
			return _.isObject(tt) && tt.isAxiosError === !0;
		}),
		isAxiosError
	);
}
var utils$3 = utils$e,
	bind = bind$2,
	Axios = Axios_1,
	mergeConfig = mergeConfig$2,
	defaults$2 = defaults_1;
function createInstance(_) {
	var et = new Axios(_),
		tt = bind(Axios.prototype.request, et);
	return (
		utils$3.extend(tt, Axios.prototype, et),
		utils$3.extend(tt, et),
		(tt.create = function (rt) {
			return createInstance(mergeConfig(_, rt));
		}),
		tt
	);
}
var axios$1 = createInstance(defaults$2);
axios$1.Axios = Axios;
axios$1.CanceledError = requireCanceledError();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.VERSION = requireData().version;
axios$1.toFormData = toFormData_1;
axios$1.AxiosError = AxiosError_1;
axios$1.Cancel = axios$1.CanceledError;
axios$1.all = function (et) {
	return Promise.all(et);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
(function (_) {
	_.exports = axios$2.exports;
})(axios$3);
const axios = getDefaultExportFromCjs(axios$3.exports);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ function __awaiter(_, et, tt, nt) {
	function rt(it) {
		return it instanceof tt
			? it
			: new tt(function (ot) {
					ot(it);
			  });
	}
	return new (tt || (tt = Promise))(function (it, ot) {
		function at(ut) {
			try {
				lt(nt.next(ut));
			} catch (dt) {
				ot(dt);
			}
		}
		function st(ut) {
			try {
				lt(nt.throw(ut));
			} catch (dt) {
				ot(dt);
			}
		}
		function lt(ut) {
			ut.done ? it(ut.value) : rt(ut.value).then(at, st);
		}
		lt((nt = nt.apply(_, et || [])).next());
	});
}
function __generator(_, et) {
	var tt = {
			label: 0,
			sent: function () {
				if (it[0] & 1) throw it[1];
				return it[1];
			},
			trys: [],
			ops: [],
		},
		nt,
		rt,
		it,
		ot;
	return (
		(ot = { next: at(0), throw: at(1), return: at(2) }),
		typeof Symbol == "function" &&
			(ot[Symbol.iterator] = function () {
				return this;
			}),
		ot
	);
	function at(lt) {
		return function (ut) {
			return st([lt, ut]);
		};
	}
	function st(lt) {
		if (nt) throw new TypeError("Generator is already executing.");
		for (; tt; )
			try {
				if (
					((nt = 1),
					rt &&
						(it = lt[0] & 2 ? rt.return : lt[0] ? rt.throw || ((it = rt.return) && it.call(rt), 0) : rt.next) &&
						!(it = it.call(rt, lt[1])).done)
				)
					return it;
				switch (((rt = 0), it && (lt = [lt[0] & 2, it.value]), lt[0])) {
					case 0:
					case 1:
						it = lt;
						break;
					case 4:
						return tt.label++, { value: lt[1], done: !1 };
					case 5:
						tt.label++, (rt = lt[1]), (lt = [0]);
						continue;
					case 7:
						(lt = tt.ops.pop()), tt.trys.pop();
						continue;
					default:
						if (((it = tt.trys), !(it = it.length > 0 && it[it.length - 1]) && (lt[0] === 6 || lt[0] === 2))) {
							tt = 0;
							continue;
						}
						if (lt[0] === 3 && (!it || (lt[1] > it[0] && lt[1] < it[3]))) {
							tt.label = lt[1];
							break;
						}
						if (lt[0] === 6 && tt.label < it[1]) {
							(tt.label = it[1]), (it = lt);
							break;
						}
						if (it && tt.label < it[2]) {
							(tt.label = it[2]), tt.ops.push(lt);
							break;
						}
						it[2] && tt.ops.pop(), tt.trys.pop();
						continue;
				}
				lt = et.call(_, tt);
			} catch (ut) {
				(lt = [6, ut]), (rt = 0);
			} finally {
				nt = it = 0;
			}
		if (lt[0] & 5) throw lt[1];
		return { value: lt[0] ? lt[1] : void 0, done: !0 };
	}
}
var noop$2 = function () {},
	UNDEFINED = noop$2(),
	OBJECT = Object,
	isUndefined = function (_) {
		return _ === UNDEFINED;
	},
	isFunction$2 = function (_) {
		return typeof _ == "function";
	},
	mergeObjects = function (_, et) {
		return OBJECT.assign({}, _, et);
	},
	STR_UNDEFINED = "undefined",
	hasWindow = function () {
		return typeof window != STR_UNDEFINED;
	},
	hasDocument = function () {
		return typeof document != STR_UNDEFINED;
	},
	hasRequestAnimationFrame = function () {
		return hasWindow() && typeof window.requestAnimationFrame != STR_UNDEFINED;
	},
	table$1 = new WeakMap(),
	counter = 0,
	stableHash = function (_) {
		var et = typeof _,
			tt = _ && _.constructor,
			nt = tt == Date,
			rt,
			it;
		if (OBJECT(_) === _ && !nt && tt != RegExp) {
			if (((rt = table$1.get(_)), rt)) return rt;
			if (((rt = ++counter + "~"), table$1.set(_, rt), tt == Array)) {
				for (rt = "@", it = 0; it < _.length; it++) rt += stableHash(_[it]) + ",";
				table$1.set(_, rt);
			}
			if (tt == OBJECT) {
				rt = "#";
				for (var ot = OBJECT.keys(_).sort(); !isUndefined((it = ot.pop())); )
					isUndefined(_[it]) || (rt += it + ":" + stableHash(_[it]) + ",");
				table$1.set(_, rt);
			}
		} else rt = nt ? _.toJSON() : et == "symbol" ? _.toString() : et == "string" ? JSON.stringify(_) : "" + _;
		return rt;
	},
	online = !0,
	isOnline = function () {
		return online;
	},
	hasWin = hasWindow(),
	hasDoc = hasDocument(),
	onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop$2,
	onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop$2,
	offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop$2,
	offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop$2,
	isVisible = function () {
		var _ = hasDoc && document.visibilityState;
		return isUndefined(_) || _ !== "hidden";
	},
	initFocus = function (_) {
		return (
			onDocumentEvent("visibilitychange", _),
			onWindowEvent("focus", _),
			function () {
				offDocumentEvent("visibilitychange", _), offWindowEvent("focus", _);
			}
		);
	},
	initReconnect = function (_) {
		var et = function () {
				(online = !0), _();
			},
			tt = function () {
				online = !1;
			};
		return (
			onWindowEvent("online", et),
			onWindowEvent("offline", tt),
			function () {
				offWindowEvent("online", et), offWindowEvent("offline", tt);
			}
		);
	},
	preset = { isOnline, isVisible },
	defaultConfigOptions = { initFocus, initReconnect },
	IS_SERVER = !hasWindow() || "Deno" in window,
	rAF = function (_) {
		return hasRequestAnimationFrame() ? window.requestAnimationFrame(_) : setTimeout(_, 1);
	},
	useIsomorphicLayoutEffect = IS_SERVER ? react.exports.useEffect : react.exports.useLayoutEffect,
	navigatorConnection = typeof navigator < "u" && navigator.connection,
	slowConnection =
		!IS_SERVER &&
		navigatorConnection &&
		(["slow-2g", "2g"].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData),
	serialize = function (_) {
		if (isFunction$2(_))
			try {
				_ = _();
			} catch {
				_ = "";
			}
		var et = [].concat(_);
		_ = typeof _ == "string" ? _ : (Array.isArray(_) ? _.length : _) ? stableHash(_) : "";
		var tt = _ ? "$swr$" + _ : "";
		return [_, et, tt];
	},
	SWRGlobalState = new WeakMap(),
	FOCUS_EVENT = 0,
	RECONNECT_EVENT = 1,
	MUTATE_EVENT = 2,
	broadcastState = function (_, et, tt, nt, rt, it, ot) {
		ot === void 0 && (ot = !0);
		var at = SWRGlobalState.get(_),
			st = at[0],
			lt = at[1],
			ut = at[3],
			dt = st[et],
			ct = lt[et];
		if (ot && ct) for (var ft = 0; ft < ct.length; ++ft) ct[ft](tt, nt, rt);
		return it && (delete ut[et], dt && dt[0])
			? dt[0](MUTATE_EVENT).then(function () {
					return _.get(et);
			  })
			: _.get(et);
	},
	__timestamp = 0,
	getTimestamp = function () {
		return ++__timestamp;
	},
	internalMutate = function () {
		for (var _ = [], et = 0; et < arguments.length; et++) _[et] = arguments[et];
		return __awaiter(void 0, void 0, void 0, function () {
			var tt, nt, rt, it, ot, at, st, lt, ut, dt, ct, ft, mt, pt, vt, ht, gt, yt, xt, St, wt;
			return __generator(this, function (Ct) {
				switch (Ct.label) {
					case 0:
						if (
							((tt = _[0]),
							(nt = _[1]),
							(rt = _[2]),
							(it = _[3]),
							(ot = typeof it == "boolean" ? { revalidate: it } : it || {}),
							(at = isUndefined(ot.populateCache) ? !0 : ot.populateCache),
							(st = ot.revalidate !== !1),
							(lt = ot.rollbackOnError !== !1),
							(ut = ot.optimisticData),
							(dt = serialize(nt)),
							(ct = dt[0]),
							(ft = dt[2]),
							!ct)
						)
							return [2];
						if (((mt = SWRGlobalState.get(tt)), (pt = mt[2]), _.length < 3))
							return [2, broadcastState(tt, ct, tt.get(ct), UNDEFINED, UNDEFINED, st, !0)];
						if (
							((vt = rt),
							(gt = getTimestamp()),
							(pt[ct] = [gt, 0]),
							(yt = !isUndefined(ut)),
							(xt = tt.get(ct)),
							yt && ((St = isFunction$2(ut) ? ut(xt) : ut), tt.set(ct, St), broadcastState(tt, ct, St)),
							isFunction$2(vt))
						)
							try {
								vt = vt(tt.get(ct));
							} catch (Et) {
								ht = Et;
							}
						return vt && isFunction$2(vt.then)
							? [
									4,
									vt.catch(function (Et) {
										ht = Et;
									}),
							  ]
							: [3, 2];
					case 1:
						if (((vt = Ct.sent()), gt !== pt[ct][0])) {
							if (ht) throw ht;
							return [2, vt];
						} else ht && yt && lt && ((at = !0), (vt = xt), tt.set(ct, xt));
						Ct.label = 2;
					case 2:
						return (
							at &&
								(ht || (isFunction$2(at) && (vt = at(vt, xt)), tt.set(ct, vt)),
								tt.set(ft, mergeObjects(tt.get(ft), { error: ht }))),
							(pt[ct][1] = getTimestamp()),
							[4, broadcastState(tt, ct, vt, ht, UNDEFINED, st, !!at)]
						);
					case 3:
						if (((wt = Ct.sent()), ht)) throw ht;
						return [2, at ? wt : vt];
				}
			});
		});
	},
	revalidateAllKeys = function (_, et) {
		for (var tt in _) _[tt][0] && _[tt][0](et);
	},
	initCache = function (_, et) {
		if (!SWRGlobalState.has(_)) {
			var tt = mergeObjects(defaultConfigOptions, et),
				nt = {},
				rt = internalMutate.bind(UNDEFINED, _),
				it = noop$2;
			if ((SWRGlobalState.set(_, [nt, {}, {}, {}, rt]), !IS_SERVER)) {
				var ot = tt.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, nt, FOCUS_EVENT))),
					at = tt.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, nt, RECONNECT_EVENT)));
				it = function () {
					ot && ot(), at && at(), SWRGlobalState.delete(_);
				};
			}
			return [_, rt, it];
		}
		return [_, SWRGlobalState.get(_)[4]];
	},
	onErrorRetry = function (_, et, tt, nt, rt) {
		var it = tt.errorRetryCount,
			ot = rt.retryCount,
			at = ~~((Math.random() + 0.5) * (1 << (ot < 8 ? ot : 8))) * tt.errorRetryInterval;
		(!isUndefined(it) && ot > it) || setTimeout(nt, at, rt);
	},
	_a = initCache(new Map()),
	cache = _a[0],
	mutate$1 = _a[1],
	defaultConfig = mergeObjects(
		{
			onLoadingSlow: noop$2,
			onSuccess: noop$2,
			onError: noop$2,
			onErrorRetry,
			onDiscarded: noop$2,
			revalidateOnFocus: !0,
			revalidateOnReconnect: !0,
			revalidateIfStale: !0,
			shouldRetryOnError: !0,
			errorRetryInterval: slowConnection ? 1e4 : 5e3,
			focusThrottleInterval: 5 * 1e3,
			dedupingInterval: 2 * 1e3,
			loadingTimeout: slowConnection ? 5e3 : 3e3,
			compare: function (_, et) {
				return stableHash(_) == stableHash(et);
			},
			isPaused: function () {
				return !1;
			},
			cache,
			mutate: mutate$1,
			fallback: {},
		},
		preset
	),
	mergeConfigs = function (_, et) {
		var tt = mergeObjects(_, et);
		if (et) {
			var nt = _.use,
				rt = _.fallback,
				it = et.use,
				ot = et.fallback;
			nt && it && (tt.use = nt.concat(it)), rt && ot && (tt.fallback = mergeObjects(rt, ot));
		}
		return tt;
	},
	SWRConfigContext = react.exports.createContext({}),
	useStateWithDeps = function (_, et) {
		var tt = react.exports.useState({})[1],
			nt = react.exports.useRef(_),
			rt = react.exports.useRef({ data: !1, error: !1, isValidating: !1 }),
			it = react.exports.useCallback(function (ot) {
				var at = !1,
					st = nt.current;
				for (var lt in ot) {
					var ut = lt;
					st[ut] !== ot[ut] && ((st[ut] = ot[ut]), rt.current[ut] && (at = !0));
				}
				at && !et.current && tt({});
			}, []);
		return (
			useIsomorphicLayoutEffect(function () {
				nt.current = _;
			}),
			[nt, rt.current, it]
		);
	},
	normalize$2 = function (_) {
		return isFunction$2(_[1]) ? [_[0], _[1], _[2] || {}] : [_[0], null, (_[1] === null ? _[2] : _[1]) || {}];
	},
	useSWRConfig = function () {
		return mergeObjects(defaultConfig, react.exports.useContext(SWRConfigContext));
	},
	withArgs = function (_) {
		return function () {
			for (var tt = [], nt = 0; nt < arguments.length; nt++) tt[nt] = arguments[nt];
			var rt = useSWRConfig(),
				it = normalize$2(tt),
				ot = it[0],
				at = it[1],
				st = it[2],
				lt = mergeConfigs(rt, st),
				ut = _,
				dt = lt.use;
			if (dt) for (var ct = dt.length; ct-- > 0; ) ut = dt[ct](ut);
			return ut(ot, at || lt.fetcher, lt);
		};
	},
	subscribeCallback = function (_, et, tt) {
		var nt = et[_] || (et[_] = []);
		return (
			nt.push(tt),
			function () {
				var rt = nt.indexOf(tt);
				rt >= 0 && ((nt[rt] = nt[nt.length - 1]), nt.pop());
			}
		);
	},
	WITH_DEDUPE = { dedupe: !0 },
	useSWRHandler = function (_, et, tt) {
		var nt = tt.cache,
			rt = tt.compare,
			it = tt.fallbackData,
			ot = tt.suspense,
			at = tt.revalidateOnMount,
			st = tt.refreshInterval,
			lt = tt.refreshWhenHidden,
			ut = tt.refreshWhenOffline,
			dt = SWRGlobalState.get(nt),
			ct = dt[0],
			ft = dt[1],
			mt = dt[2],
			pt = dt[3],
			vt = serialize(_),
			ht = vt[0],
			gt = vt[1],
			yt = vt[2],
			xt = react.exports.useRef(!1),
			St = react.exports.useRef(!1),
			wt = react.exports.useRef(ht),
			Ct = react.exports.useRef(et),
			Et = react.exports.useRef(tt),
			_t = function () {
				return Et.current;
			},
			$t = function () {
				return _t().isVisible() && _t().isOnline();
			},
			At = function (qt) {
				return nt.set(yt, mergeObjects(nt.get(yt), qt));
			},
			Lt = nt.get(ht),
			Nt = isUndefined(it) ? tt.fallback[ht] : it,
			Ft = isUndefined(Lt) ? Nt : Lt,
			Gt = nt.get(yt) || {},
			Bt = Gt.error,
			jt = !xt.current,
			It = function () {
				return jt && !isUndefined(at)
					? at
					: _t().isPaused()
					? !1
					: ot
					? isUndefined(Ft)
						? !1
						: tt.revalidateIfStale
					: isUndefined(Ft) || tt.revalidateIfStale;
			},
			Dt = function () {
				return !ht || !et ? !1 : Gt.isValidating ? !0 : jt && It();
			},
			Rt = Dt(),
			bt = useStateWithDeps({ data: Ft, error: Bt, isValidating: Rt }, St),
			kt = bt[0],
			zt = bt[1],
			Vt = bt[2],
			Yt = react.exports.useCallback(
				function (qt) {
					return __awaiter(void 0, void 0, void 0, function () {
						var Wt, Xt, Zt, pn, Sn, yn, Qt, Jt, tn, an, mn, xn, gn;
						return __generator(this, function (vn) {
							switch (vn.label) {
								case 0:
									if (((Wt = Ct.current), !ht || !Wt || St.current || _t().isPaused())) return [2, !1];
									(pn = !0),
										(Sn = qt || {}),
										(yn = !pt[ht] || !Sn.dedupe),
										(Qt = function () {
											return !St.current && ht === wt.current && xt.current;
										}),
										(Jt = function () {
											var kn = pt[ht];
											kn && kn[1] === Zt && delete pt[ht];
										}),
										(tn = { isValidating: !1 }),
										(an = function () {
											At({ isValidating: !1 }), Qt() && Vt(tn);
										}),
										At({ isValidating: !0 }),
										Vt({ isValidating: !0 }),
										(vn.label = 1);
								case 1:
									return (
										vn.trys.push([1, 3, , 4]),
										yn &&
											(broadcastState(nt, ht, kt.current.data, kt.current.error, !0),
											tt.loadingTimeout &&
												!nt.get(ht) &&
												setTimeout(function () {
													pn && Qt() && _t().onLoadingSlow(ht, tt);
												}, tt.loadingTimeout),
											(pt[ht] = [Wt.apply(void 0, gt), getTimestamp()])),
										(gn = pt[ht]),
										(Xt = gn[0]),
										(Zt = gn[1]),
										[4, Xt]
									);
								case 2:
									return (
										(Xt = vn.sent()),
										yn && setTimeout(Jt, tt.dedupingInterval),
										!pt[ht] || pt[ht][1] !== Zt
											? (yn && Qt() && _t().onDiscarded(ht), [2, !1])
											: (At({ error: UNDEFINED }),
											  (tn.error = UNDEFINED),
											  (mn = mt[ht]),
											  !isUndefined(mn) && (Zt <= mn[0] || Zt <= mn[1] || mn[1] === 0)
													? (an(), yn && Qt() && _t().onDiscarded(ht), [2, !1])
													: (rt(kt.current.data, Xt) ? (tn.data = kt.current.data) : (tn.data = Xt),
													  rt(nt.get(ht), Xt) || nt.set(ht, Xt),
													  yn && Qt() && _t().onSuccess(Xt, ht, tt),
													  [3, 4]))
									);
								case 3:
									return (
										(xn = vn.sent()),
										Jt(),
										_t().isPaused() ||
											(At({ error: xn }),
											(tn.error = xn),
											yn &&
												Qt() &&
												(_t().onError(xn, ht, tt),
												((typeof tt.shouldRetryOnError == "boolean" && tt.shouldRetryOnError) ||
													(isFunction$2(tt.shouldRetryOnError) && tt.shouldRetryOnError(xn))) &&
													$t() &&
													_t().onErrorRetry(xn, ht, tt, Yt, { retryCount: (Sn.retryCount || 0) + 1, dedupe: !0 }))),
										[3, 4]
									);
								case 4:
									return (pn = !1), an(), Qt() && yn && broadcastState(nt, ht, tn.data, tn.error, !1), [2, !0];
							}
						});
					});
				},
				[ht]
			),
			Ut = react.exports.useCallback(
				internalMutate.bind(UNDEFINED, nt, function () {
					return wt.current;
				}),
				[]
			);
		if (
			(useIsomorphicLayoutEffect(function () {
				(Ct.current = et), (Et.current = tt);
			}),
			useIsomorphicLayoutEffect(
				function () {
					if (!!ht) {
						var qt = ht !== wt.current,
							Wt = Yt.bind(UNDEFINED, WITH_DEDUPE),
							Xt = function (Qt, Jt, tn) {
								Vt(mergeObjects({ error: Jt, isValidating: tn }, rt(kt.current.data, Qt) ? UNDEFINED : { data: Qt }));
							},
							Zt = 0,
							pn = function (Qt) {
								if (Qt == FOCUS_EVENT) {
									var Jt = Date.now();
									_t().revalidateOnFocus && Jt > Zt && $t() && ((Zt = Jt + _t().focusThrottleInterval), Wt());
								} else if (Qt == RECONNECT_EVENT) _t().revalidateOnReconnect && $t() && Wt();
								else if (Qt == MUTATE_EVENT) return Yt();
							},
							Sn = subscribeCallback(ht, ft, Xt),
							yn = subscribeCallback(ht, ct, pn);
						return (
							(St.current = !1),
							(wt.current = ht),
							(xt.current = !0),
							qt && Vt({ data: Ft, error: Bt, isValidating: Rt }),
							It() && (isUndefined(Ft) || IS_SERVER ? Wt() : rAF(Wt)),
							function () {
								(St.current = !0), Sn(), yn();
							}
						);
					}
				},
				[ht, Yt]
			),
			useIsomorphicLayoutEffect(
				function () {
					var qt;
					function Wt() {
						var Zt = isFunction$2(st) ? st(Ft) : st;
						Zt && qt !== -1 && (qt = setTimeout(Xt, Zt));
					}
					function Xt() {
						!kt.current.error && (lt || _t().isVisible()) && (ut || _t().isOnline()) ? Yt(WITH_DEDUPE).then(Wt) : Wt();
					}
					return (
						Wt(),
						function () {
							qt && (clearTimeout(qt), (qt = -1));
						}
					);
				},
				[st, lt, ut, Yt]
			),
			react.exports.useDebugValue(Ft),
			ot && isUndefined(Ft) && ht)
		)
			throw ((Ct.current = et), (Et.current = tt), (St.current = !1), isUndefined(Bt) ? Yt(WITH_DEDUPE) : Bt);
		return {
			mutate: Ut,
			get data() {
				return (zt.data = !0), Ft;
			},
			get error() {
				return (zt.error = !0), Bt;
			},
			get isValidating() {
				return (zt.isValidating = !0), Rt;
			},
		};
	},
	useSWR = withArgs(useSWRHandler);
const BeadLoomProgramming = [
		{ tutorial_title: "Programming Bead Loom", tool: "Bead Loom", prefix: "beadloom/main/", base: "base.xml" },
		{ title: "Setting Up a Variable", video: "beadloom-1.mp4" },
		{ title: "Set Up our Starting Points: (x, y)", video: "beadloom-2.mp4" },
		{ title: "Loops and Loops Within Loops", video: "beadloom-3.mp4" },
		{ title: "Making a Row of Beads", video: "beadloom-4.mp4" },
		{ title: "Carriage Return our Beads", video: "beadloom-5.mp4" },
		{ title: "Increment Var and Set to Costume Color", video: "beadloom-6.mp4" },
		{ title: "Update the Loop", video: "beadloom-7.mp4" },
		{ title: "Look at What we Made!", video: "beadloom-8.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "main-tut.png",
			background: "beadloom/index.html",
			software: "beadloom/software.html",
		},
	],
	AdinkraAkoma = [
		{
			tutorial_title: "Creating Akoma",
			tool: "Adinkra",
			prefix: "adinkra/akoma/",
			base: "base.xml",
			globalModifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Set Up Akoma",
			video: "akoma-1.mp4",
			description:
				"To start your project, you need to use <strong>When Clicked</strong>, found in the Control category. Anything attached to the block will run when the green flag is clicked. The green flag can be found above the stage, or in the block itself. <br><br> To clear your stage of all stamps and pen trails, use <strong>Clear</strong>, located in the Pen category. <br><br> To move your sprite, use <strong>Go to</strong>, located in the Motion category. To move up, use a positive y value. To move down, use a negative value. To move left, use a negative x value. To move right, use a positive value.<br><br>To rotate your sprite, use <strong>Point at Angle</strong>, located in the Motion category. It rotates to the angle that you give it. <br><br>These five blocks set up the Akoma symbol with a starting location and rotation.",
			short: "Set up your script. ",
			hint: "akoma_solution_1.mp4",
		},
		{
			title: "Draw a Log Spiral",
			video: "akoma-2.mp4",
			description:
				"To create a spiral on the stage, use <strong>log spiral</strong>, located in the Pen category. It takes five values: <br><br><ul><li class='mb-2'><strong>C(the coil value)</strong>: Determines how tightly coiled your spiral is. Larger the number, tighter the coil. <em>Note: try to use values between 0.1 and 1</em></li><li class='mb-2'><strong>Sweep</strong>: The angle in which the log spiral stops at.</li> <li class='mb-2'><strong>Size</strong>: The size of the spiral.</li><li class='mb-2'><strong>Pen Growth</strong>: The rate at which the pen size grows at. Keeping it at 0 gives it a consistent size throughout. A positive number grows the pen size as it draws. A negative number shrinks the size.</li><li class='mb-2'><strong>Clockwise?</strong>: Asking you if you want your spiral to draw clockwise or counterclockwise.</li></ul>",
			short: "Draw the first log spiral.",
			hint: "akoma_solution_2.mp4",
		},
		{
			title: "Draw a Line",
			video: "akoma-3.mp4",
			description:
				"The <strong>line</strong> block, located in the Pen category, allows you to draw a line at your current location. It takes in three values: <br><br><ul><li><strong>Length</strong>: The length of the line. To draw your line forward, use a positive number. To draw your line backwards, use a negative number.</li><li><strong>Pen Growth</strong>: The rate at which the pen size grows as it is being drawn. Negative number means it shrinks. Positive number meanss it grows. Keeping it at zero keeps the size consistent.</li><li><strong>Round end?</strong>: Asking you if you want to have a rounded end for your line or not.</li></ul>",
			short: "Draw the first line.",
			hint: "akoma_solution_3.mp4",
		},
		{
			title: "Finish the Akoma Symbol",
			video: "akoma-4.mp4",
			description:
				"The last thing to do is to finish the second half of the Akoma Adinkra symbol. An easy way of doing this is to <strong>right click on the go to</strong> block, select <strong>Duplicate</strong>. <br><br>This copies everything from that block, downwards. <br><br>Reflecting the second half involves: <br><br><ul><li>Switching the copied go to x location from positive to negative.</li> <li>Switching the copied boolean(True/False) block in the copied log spiral block from positive to negative.</li></ul>",
			short: "Duplicate your code, and reverse it to create the second half.",
			hint: "akoma_solution_4.mp4",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to recreate Akoma in the software by yourself! You may even be able to attempt other symbols as well.",
			outcome: "akoma-tut.png",
			background: "adinkra/index.html",
			software: "adinkra/software.html",
		},
	],
	AdinkraAnanse = [
		{
			tutorial_title: "Creating Ananse",
			tool: "Adinkra",
			prefix: "adinkra/ananse/",
			base: "base.xml",
			globalModifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{ title: "Setting Up Ananse", video: "ananse-1.mp4" },
		{ title: "Drawing a Line", video: "ananse-2.mp4" },
		{ title: "Finishing Up Through Iteration", video: "ananse-3.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to recreate ananse in the software by yourself! You may even be able to attempt other symbols as well.",
			outcome: "ananse-tut.png",
			background: "adinkra/index.html",
			software: "adinkra/software.html",
		},
	],
	AdinkraMpuannum = [
		{
			tutorial_title: "Creating Mpuannum",
			tool: "Adinkra",
			prefix: "adinkra/mpuannum/",
			base: "base.xml",
			globalModifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{ title: "Setting Up Mpuannum", video: "mpuannum-1.mp4" },
		{ title: "Drawing the Remaining Circles", video: "mpuannum-2.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to recreate mpuannum in the software by yourself! You may even be able to attempt other symbols as well.",
			outcome: "mpuannum-goal-2.png",
			background: "adinkra/index.html",
			software: "adinkra/software.html",
		},
	],
	AdinkraSepow = [
		{
			tutorial_title: "Creating Sepow",
			tool: "Adinkra",
			prefix: "adinkra/sepow/",
			base: "base.xml",
			globalModifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{ title: "Setting Up Sepow", video: "sepow-1.mp4" },
		{ title: "Drawing a Line", video: "sepow-2.mp4" },
		{ title: "Finishing Up the Triangle", video: "sepow-3.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to recreate sepow in the software by yourself! You may even be able to attempt other symbols as well.",
			outcome: "sepow-tut.png",
			background: "adinkra/index.html",
			software: "adinkra/software.html",
		},
	],
	Adinkra = {
		"adinkra-akoma": AdinkraAkoma,
		"adinkra-ananse": AdinkraAnanse,
		"adinkra-mpuannum": AdinkraMpuannum,
		"adinkra-sepow": AdinkraSepow,
	},
	Arcs = [
		{
			tutorial_title: "Anishinaabe Arcs",
			tool: "Anishinaabe Arcs",
			module: "Anishinaabe Arcs",
			prefix: "anishinaabearcs/main/",
			legacy: !0,
			base: "arcs-base.xml",
		},
		{
			title: "A Single Arc",
			video: "step0.mp4",
			description:
				"Drag the \u201Cwhen clicked\u201D Control block to the right (click and hold while moving the mouse).. The \u201Cwhen clicked\u201D block starts the program.. Now you can create a script to create an arc.. The \u201Cangle\u201D Motion block will tell the middle of the arc which directions to point.. The \u201Cgo to\u201D Motion block will tell the arc where to move along the x, y, and z axes.. The \u201Cclear\u201D Pen block will erase all prior drawing on the stage.. The \u201Cpen size\u201D Pen block will allow you to set the diameter of the arc's cross section. The \u201Carc\u201D Pen block will allow you to draw an arc by specifying the width and height.. ",
			short: "Create your first arc by dragging in blocks into the scripting panel.",
		},
		{
			title: "Running the Program",
			video: "flag.mp4",
			description:
				"The green flag button is in the upper right corner, just above the stage.. When you click the green flag button it tells the \u201Cwhen clicked\u201D block to run the program, stepping through each block in the script to create a arc.. ",
			short: "Click the green flag to run.",
		},
		{
			title: "Positioning",
			video: "positioning.mp4",
			description:
				"The \u201Cangle\u201D block controls where the middle of the arc is pointing.. The \u201Cgo to\u201D block controls where the arc will be positioned on the coordinate grid.. Update angle to 90 degree angle along the Z axis and position it to x: 0, y: -80, z: 0.",
			short: "Reorientate your arc.",
		},
		{
			title: "Making a Structure",
			video: "step1.mp4",
			description:
				"Drag the \u201Crepeat\u201D Control block into the script panel.. Place the \u201Carc\u201D block into the \u201Crepeat\u201D block.. Drag the \u201Ctranslate\u201D block into the scripting panel and place it inside of the \u201Crepeat\u201D block.. The width, height, and depth of the translation by clicking on the drop down menu within the \u201Ctranslate\u201D block itself.",
			short: "Iterate and translate your arc using the \u201Crepeat\u201D and \u201Ctranslate\u201D blocks.",
		},
		{
			title: "Making Beautiful Structures",
			description: "The translate block controls the spacing.. The repeat block controls the number of iterations.",
			short: "Create 8 arcs with each translating by 20.",
		},
		{
			title: "Make Two Variables",
			video: "step2.mp4",
			description:
				"In the block library you will find a \u201Cmake a variable\u201D button. Click on it to make your first variable.. When the \u201CVariable name\u201D window pops up type in width.. Click \u201COK\u201D and a width variable will appear.. Do the same thing but for creating a height variable.",
			short: "Make variables for width & height.",
		},
		{
			title: "Setting Variables",
			video: "step3.mp4",
			description:
				"Drag in two \u201Cset to\u201D Variable blocks, place them at the beginning of your script, and set them to 100 each.. In the \u201Cset to\u201D blocks use the drop down menu to select the variables you just created: width and height.. Find the \u201Cwidth\u201D and \u201Cheight\u201D Variable blocks that you just create and drag them into the aligning width and height values in the \u201Carc\u201D block.",
			short: "Set your width and height variables by dragging in two \u201Cset to\u201D Variable block.",
		},
		{
			title: "Change Blocks",
			video: "step4.mp4",
			description:
				"Drag in two \u201Cchange by\u201D Variable blocks and place them below the \u201Ctranslate\u201D block in your \u201Crepeat\u201D block.. In each \u201Cchange by\u201D block use the drop down menu to select the variables you just created: width and height.. Change the values in each \u201Cchange by\u201D block to 10.",
			short: "Change the your variables every iteration using the \u201Cchange by\u201D Variable blocks.",
		},
		{
			title: "A New Variable",
			description:
				"In the block library you will find a \u201Cmake a variable\u201D button. Click on it to make your first variable.. When the \u201CVariable name\u201D window pops up type in increment.. Click \u201COK\u201D and a increment variable will appear.",
			short: "Make a variable for increment.",
		},
		{
			title: "Setting Increment",
			video: "setincrement.mp4",
			description:
				"Drag in two \u201Cchange by\u201D Variable blocks and place them below the \u201Ctranslate\u201D block in your \u201Crepeat\u201D block.. In each \u201Cchange by\u201D block use the drop down menu to select the variables you just created: width and height.. Change the values in each \u201Cchange by\u201D block to 10.",
			short: "Set Increment to 10 at the beginning of the script.",
		},
		{
			title: "Changing Variables with Variables",
			video: "step5.mp4",
			description:
				"Find the \u201Cincrement\u201D Variable blocks that you just create and drag it into the \u201Cchange by\u201D height and width blocks.",
			short:
				"Use the \u201Cincrement\u201D variable you created in each of the width and height \u201Cchange by\u201D blocks to control the rate of change.",
		},
		{
			title: "Making Smooth Arcs",
			video: "step6.mp4",
			description:
				"Drag in one \u201Cchange by\u201D blocks and place them below the other \u201Cchange by\u201D blocks in your \u201Crepeat\u201D block.. In the \u201Cchange by\u201D block use the drop down menu to select the variables you just created: increment.. Change the values in each \u201Cchange by\u201D block to -3.5.",
			short: "Change increment every iteration by adding a \u201Cchange by\u201D increment block to your loop.",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "arcs-outcome.png",
			background: "anishinaabearcs/index.html",
			software: "/applications/38/run",
		},
	],
	AnishinaabeArcs = { "anishinaabe-arcs": Arcs },
	CornrowConditionals = [
		{
			tutorial_title: "Conditionals in Cornrow Curves",
			tool: "Cornrow Curves",
			prefix: "cornrows/conditionals/",
			base: "base.xml",
		},
		{ title: "Setting up Your Script", video: "conditionals-1.mp4" },
		{ title: "Creating a Second Braid", video: "conditionals-2.mp4" },
		{ title: "Variables and Position", video: "conditionals-3.mp4" },
		{ title: "Adding Conditionals to Loops", video: "conditionals-4.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "conditionals-tut.png",
			background: "cornrowcurves/index.html",
			software: "cornrowcurves/software.html",
		},
	],
	CornrowFunctions = [
		{
			tutorial_title: "Functions in Cornrow Curves",
			tool: "Cornrow Curves",
			prefix: "cornrows/functions/",
			base: "base.xml",
		},
		{ title: "Setting up Your Script", video: "functions-1.mp4" },
		{ title: "Creating a Square Wave", video: "functions-2.mp4" },
		{ title: "Creating a Custom Block", video: "functions-3.mp4" },
		{ title: "Adding Parameters to Blocks", video: "functions-4.mp4" },
		{ title: "Creating Multiple Braids Using Loops", video: "functions-5.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "functions-tut.png",
			background: "cornrowcurves/index.html",
			software: "cornrowcurves/software.html",
		},
	],
	CornrowLoops = [
		{
			tutorial_title: "Loops in Cornrow Curves",
			tool: "Cornrow Curves",
			prefix: "cornrows/loops/",
			base: "base.xml",
			core: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"doStamp",
				"doSwitchToCostume",
				"translatePercent",
				"doRepeat",
				"rotateByDegrees",
				"newSizeOfCurrent",
				"setEffect",
			],
		},
		{
			title: "Setting up Your Script",
			video: "loops-1.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
		},
		{
			title: "Offsetting the Braid",
			video: "loops-2.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "translatePercent"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
		},
		{
			title: "Create a Second Braid",
			video: "loops-3.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "translatePercent", "rotateByDegrees"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
		},
		{
			title: "Creating Multiple Braids",
			video: "loops-4.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "translatePercent", "rotateByDegrees"],
			modifiers: ["disableSinglePalette"],
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			poster: "loops-tut.png",
			background: "cornrowcurves/index.html",
			software: "cornrowcurves/software.html",
		},
	],
	CornrowMain = [
		{
			tutorial_title: "Cornrow Curves Main",
			tool: "Cornrow Curves",
			prefix: "cornrows/main/",
			base: "base.xml",
			core: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"doStamp",
				"doSwitchToCostume",
				"translatePercent",
				"doRepeat",
				"rotateByDegrees",
				"newSizeOfCurrent",
				"setEffect",
			],
		},
		{
			title: "Setting up Your Script",
			video: "main-1.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
			explanation: "cornrows-1.md",
			tagline: "Initialize your script.",
		},
		{
			title: "Creating Another Plait",
			video: "main-2.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "translatePercent", "doStamp"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
			explanation: "cornrows-2.md",
			tagline: "Create a second plait.",
		},
		{
			title: "Creating Multiple Plaits",
			video: "main-3.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
			],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
			explanation: "cornrows-3.md",
			tagline: "Create a braid using multiple plaits.",
		},
		{
			title: "Curling the Braid",
			video: "main-4.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
				"rotateByDegrees",
			],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
			explanation: "cornrows-4.md",
			tagline: "Add a curve to your braid.",
		},
		{
			title: "Scaling the Braid Size",
			video: "main-5.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
				"rotateByDegrees",
				"newSizeOfCurrent",
			],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
			explanation: "cornrows-5.md",
			tagline: "Scale the size of your braid.",
		},
		{
			title: "Creating Multiple Braids Using Loops",
			video: "main-6.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
				"rotateByDegrees",
				"newSizeOfCurrent",
			],
			modifiers: ["disableSinglePalette"],
			explanation: "cornrows-6.md",
			tagline: "Create multiple braids.",
		},
		{
			title: "Resetting the Braid's Position",
			video: "main-7.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
				"rotateByDegrees",
				"newSizeOfCurrent",
				"setEffect",
			],
			modifiers: ["disableSinglePalette"],
			explanation: "cornrows-7.md",
			tagline: "Update the position of your braids.",
		},
		{
			title: "Adding Some Color",
			video: "main-8.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
				"rotateByDegrees",
				"newSizeOfCurrent",
				"setEffect",
			],
			modifiers: ["disableSinglePalette"],
			explanation: "cornrows-8.md",
			tagline: "Add color to your braids.",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "main-tut.png",
			background: "cornrowcurves/index.html",
			software: "cornrowcurves/software.html",
		},
	],
	CornrowParams = [
		{
			tutorial_title: "Parameters in Cornrow Curves",
			tool: "Cornrow Curves",
			prefix: "cornrows/parameters/",
			base: "base.xml",
			core: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear"],
		},
		{
			title: "Setting up Your Script",
			video: "parameters-1.mp4",
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Creating a Braid",
			video: "parameters-2.mp4",
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Bending Braid Curve",
			video: "parameters-3.mp4",
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Adding More Braids",
			video: "parameters-4.mp4",
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Creating Custom Costumes",
			video: "parameters-5.mp4",
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "enableTutorialTabs"],
		},
		{
			title: "Adding Braids and Saving Project",
			video: "parameters-6.mp4",
			modifiers: ["disableSinglePalette", "enableTutorialTabs"],
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "parameters-tut.png",
			background: "cornrowcurves/index.html",
			software: "cornrowcurves/software.html",
		},
	],
	CornrowVars = [
		{
			tutorial_title: "Variables in Cornrow Curves",
			tool: "Cornrow Curves",
			prefix: "cornrows/variables/",
			base: "base.xml",
		},
		{ title: "Setting up Your Script", video: "variables-1.mp4" },
		{ title: "Adding 'Rainbow' Effect to Custom Blocks", video: "variables-2.mp4" },
		{ title: "Adding Parameters", video: "variables-3.mp4" },
		{ title: "Adding Script Variables", video: "variables-4.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "variables-tut.png",
			background: "cornrowcurves/index.html",
			software: "cornrowcurves/software.html",
		},
	],
	Cornrows = {
		"cornrows-main": CornrowMain,
		"cornrows-params": CornrowParams,
		"cornrows-loops": CornrowLoops,
		"cornrows-functions": CornrowFunctions,
		"cornrows-vars": CornrowVars,
		"cornrows-conditionals": CornrowConditionals,
	},
	PreColumbianPyramids = [
		{
			tutorial_title: "PreColumbian Pyramids",
			tool: "PreColumbian Pyramids",
			module: "Pre-Columbian Pyramids",
			prefix: "precolumbian/main/",
			legacy: !0,
			base: "pyramid-base.xml",
		},
		{
			title: "Set up our program",
			video: "step0.mp4",
			explanation: "pyramid-1.md",
			tagline: "Set the starting location via variables.",
			code: "0001.png",
		},
		{
			title: "Further set up our program",
			video: "step1.mp4",
			explanation: "pyramid-2.md",
			tagline: "Set up the sprite's costume. position, and starting angle.",
			code: "0002.png",
		},
		{
			title: "3-Dimensional Array",
			video: "step2.mp4",
			explanation: "pyramid-3.md",
			tagline: "Create a 3D iterative loop with nested loops. ",
			code: "0003.png",
		},
		{
			title: "Variables",
			video: "step3.mp4",
			explanation: "pyramid-4.md",
			tagline: "Create a 9x9 grid.",
			code: "0004.png",
		},
		{
			title: "Building the Outer Loop",
			video: "step4.mp4",
			explanation: "pyramid-5.md",
			tagline: "Define the outer loop.",
			code: "0005.png",
		},
		{
			title: "A 'Crowning' Achievement",
			video: "step5.mp4",
			explanation: "pyramid-6.md",
			tagline: "Crown the pyramid with a circling stork.",
			code: "0006.png",
		},
		{
			title: "Put our bird into flight",
			video: "step6.mp4",
			explanation: "pyramid-7.md",
			tagline: "Animate the bird using the Rotate block.",
			code: "0007.png",
		},
		{
			title: "Run your program",
			video: "step7.mp4",
			explanation: "pyramid-8.md",
			tagline: "Run your program to create your pyramid!",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "pyramid-outcome.png",
			background: "precolumbianpyramid/index.html",
			software: "/applications/49/run",
		},
	],
	PreColumbian = { "precolumbian-pyramids": PreColumbianPyramids },
	QuiltingAnishinaabe = [
		{
			tutorial_title: "Anishinaabe Quilting",
			tool: "Quilting",
			prefix: "quilting/anishinaabe/",
			base: "base.xml",
			globalModifiers: ["enableSinglePalette", "disableSinglePaletteButtons"],
		},
		{
			title: "Setting up Your Script",
			video: "anishinaabe-1.mp4",
			explanation: "ani-1.md",
			tagline: "Create the first part of your Anishinaabe quilt script.",
		},
		{
			title: "Modifying Your Sprite",
			video: "anishinaabe-2.mp4",
			explanation: "ani-2.md",
			tagline: "Change your sprite to a red 'bigpetal'. ",
		},
		{
			title: "Creating a Ring of Petals",
			video: "anishinaabe-3.mp4",
			explanation: "ani-3.md",
			tagline: "Stamp and repeat your costume to make a ring of petals.",
		},
		{
			title: "Creating a Ring of Flowers",
			video: "anishinaabe-4.mp4",
			explanation: "ani-4.md",
			tagline: "Duplicate your radial design, and create a ring of yellow flowers.",
		},
		{
			title: "Reflecting Your Design",
			video: "anishinaabe-5.mp4",
			explanation: "ani-5.md",
			tagline: "Create another ring of flowers, but reflected.",
		},
		{
			title: "Adding the Medicine Wheel",
			video: "anishinaabe-6.mp4",
			explanation: "ani-6.md",
			tagline: "Add the medicine wheel to the quilt.",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "anishinaabe.png",
			background: "quilting/index.html",
			software: "quilting/software.html",
		},
	],
	QuiltingConditionals = [
		{
			tutorial_title: "Conditionals in Quilting",
			tool: "Quilting",
			prefix: "quilting/conditionals/",
			base: "base.xml",
		},
		{ title: "Setting up Your Script", video: "conditionals-1.mp4" },
		{ title: "Creating a Row", video: "conditionals-2.mp4" },
		{ title: "Variables and Colors", video: "conditionals-3.mp4" },
		{ title: "Adding Conditionals to Loops", video: "conditionals-4.mp4" },
		{ title: "Creating Multiple Conditional Checks", video: "conditionals-5.mp4" },
		{ title: "Creating a Color Picker Block", video: "conditionals-6.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "conditionals-tut.png",
			background: "quilting/index.html",
			software: "quilting/software.html",
		},
	],
	QuiltingFunctions = [
		{ tutorial_title: "Functions in Quilting", tool: "Quilting", prefix: "quilting/functions/", base: "base.xml" },
		{ title: "Setting up Your Script", video: "functions-1.mp4" },
		{ title: "Filling Out the Pattern", video: "functions-2.mp4" },
		{ title: "Creating a New Block", video: "functions-3.mp4" },
		{ title: "Adding Parameters to Custom Blocks", video: "functions-4.mp4" },
		{ title: "Creating a Row of Diamonds", video: "functions-5.mp4" },
		{ title: "Creating Another Custom Block", video: "functions-6.mp4" },
		{ title: "Completing the Quilt", video: "functions-7.mp4" },
		{
			title: "Next Steps",
			category: "Functions",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "functions-tut.png",
			background: "quilting/index.html",
			software: "quilting/software.html",
		},
	],
	QuiltingGees = [
		{
			tutorial_title: "Gee's Bend Quilting",
			tool: "Quilting",
			prefix: "quilting/gees/",
			base: "base.xml",
			globalModifiers: ["enableSinglePalette", "disableTutorialTabs", "disableSinglePaletteButtons"],
		},
		{
			title: "Setting up Your Script",
			video: "gees-1.mp4",
			explanation: "gees-1.md",
			tagline: "Center your sprite on the stage.",
		},
		{
			title: "Modifying Your Sprite",
			video: "gees-2.mp4",
			explanation: "gees-2.md",
			tagline: "Make your sprite bigger.",
		},
		{
			title: "Creating Multiple Stamps",
			video: "gees-3.mp4",
			explanation: "gees-3.md",
			tagline: "Make multiple stamps that decreases in size every time.",
		},
		{
			title: "Changing Colors Every Iteration",
			video: "gees-4.mp4",
			explanation: "gees-4.md",
			tagline: "Give each stamp a unique color.",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "gees.png",
			background: "quilting/index.html",
			software: "quilting/software.html",
		},
	],
	QuiltingLakota = [
		{ tutorial_title: "Lakota Quilting", tool: "Quilting", prefix: "quilting/lakota/", base: "base.xml" },
		{
			title: "Setting up Your Script",
			video: "lakota-1.mp4",
			explanation: "lakota-1.md",
			tagline: "Position your sprite on the stage.",
		},
		{
			title: "Changing Sprite Color and Transparency",
			video: "lakota-2.mp4",
			explanation: "lakota-2.md",
			tagline: "Change the color and transparency of your sprite.",
		},
		{
			title: "Creating a Ring of Diamonds",
			video: "lakota-3.mp4",
			explanation: "lakota-3.md",
			tagline: "Create a ring of diamonds.",
		},
		{
			title: "Creating a Function",
			video: "lakota-4.mp4",
			explanation: "lakota-4.md",
			tagline: "Create a function called 'circle2'.",
		},
		{
			title: "Creating a Second Ring",
			video: "lakota-5.mp4",
			explanation: "lakota-5.md",
			tagline: "Create the second ring of diamonds.",
		},
		{
			title: "Creating a Third Ring",
			video: "lakota-6.mp4",
			explanation: "lakota-6.md",
			tagline: "Create the final ring using a new function, 'circle3'. ",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "lakota.png",
			background: "quilting/index.html",
			software: "quilting/software.html",
		},
	],
	QuiltingLoops = [
		{ tutorial_title: "Loops in Quilting", tool: "Quilting", prefix: "quilting/loops/", base: "base.xml" },
		{ title: "Creating a Single Flower", video: "loops-1.mp4" },
		{ title: "Creating a Row of Flowers", video: "loops-2.mp4" },
		{ title: "Creating Multiple Rows", video: "loops-3.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "loops-tut.png",
			background: "quilting/index.html",
			software: "quilting/software.html",
		},
	],
	QuiltingParams = [
		{
			tutorial_title: "Parameters in Quilting",
			tool: "Quilting",
			core: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doStamp", "doSwitchToCostume"],
			prefix: "quilting/parameters/",
			base: "base.xml",
		},
		{
			title: "Initializing Your Script",
			video: "parameters-1.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Adding Another Costume",
			video: "parameters-2.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doSwitchToCostume", "doStamp"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Adding More Costumes",
			video: "parameters-3.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doSwitchToCostume", "doStamp"],
			modifiers: ["disableSinglePalette", "enableTutorialTabs"],
		},
		{
			title: "Creating the 'Sun' Costume",
			video: "parameters-4.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doSwitchToCostume", "doStamp"],
			modifiers: ["disableSinglePalette", "enableTutorialTabs"],
		},
		{
			title: "Saving Your Progress",
			video: "parameters-5.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doSwitchToCostume", "doStamp"],
			modifiers: ["disableSinglePalette", "enableTutorialTabs"],
		},
		{
			title: "Next Steps",
			category: "Parameters",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "parameters-tut.png",
			background: "quilting/index.html",
			software: "quilting/software.html",
		},
	],
	QuiltingVariables = [
		{ tutorial_title: "Variables in Quilting", tool: "Quilting", prefix: "quilting/variables/", base: "base.xml" },
		{ title: "Setting up Your Script With User Input", video: "variables-1.mp4" },
		{ title: "Creating a Spiral", video: "variables-2.mp4" },
		{ title: "Variables and Colors", video: "variables-3.mp4" },
		{ title: "Creating a Custom Block", video: "variables-4.mp4" },
		{ title: "Adding a New Costume", video: "variables-5.mp4" },
		{ title: "Ask for the Square's Color", video: "variables-6.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "variables-tut.png",
			background: "quilting/index.html",
			software: "quilting/software.html",
		},
	],
	Quilting = {
		"quilting-params": QuiltingParams,
		"quilting-loops": QuiltingLoops,
		"quilting-functions": QuiltingFunctions,
		"quilting-vars": QuiltingVariables,
		"quilting-conditionals": QuiltingConditionals,
		"quilting-anishinaabe": QuiltingAnishinaabe,
		"quilting-gees": QuiltingGees,
		"quilting-lakota": QuiltingLakota,
	},
	TooledLeatherConditionals = [
		{
			tutorial_title: "Conditionals in Tooled Leather",
			tool: "Tooled Leather",
			prefix: "tooledleather/conditionals/",
			base: "tool-conditionals-base.xml",
		},
		{ title: "Getting Started", video: "conditionals-1.mp4" },
		{ title: "Creating a Column", video: "conditionals-2.mp4" },
		{ title: "Setting and Changing Variables", video: "conditionals-3.mp4" },
		{ title: "The If Else Statement", video: "conditionals-4.mp4" },
		{ title: "Creating Multiple Columns", video: "conditionals-5.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "tool-conditionals-outcome.png",
			background: "tooledleather/index.html",
			software: "tooledleather/software.html",
		},
	],
	TooledLeatherFunctions = [
		{
			tutorial_title: "Functions in Tooled Leather",
			tool: "Tooled Leather",
			prefix: "tooledleather/functions/",
			base: "tool-functions-base.xml",
		},
		{ title: "Getting Started", video: "functions-1.mp4" },
		{ title: "Creating a Knot", video: "functions-2.mp4" },
		{ title: "Creating New Blocks", video: "functions-3.mp4" },
		{ title: "Adding Values to New Blocks", video: "functions-4.mp4" },
		{ title: "Creating a Circle of Knots", video: "functions-5.mp4" },
		{ title: "Creating Another Block", video: "functions-6.mp4" },
		{ title: "Creating a Row", video: "functions-7.mp4" },
		{ title: "Creating an Array", video: "functions-8.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "tool-functions-outcome.png",
			background: "tooledleather/index.html",
			software: "tooledleather/software.html",
		},
	],
	TooledLeatherLoops = [
		{
			tutorial_title: "Loops in Tooled Leather",
			tool: "Tooled Leather",
			core: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doStamp", "doRepeat", "translatePercent"],
			prefix: "tooledleather/loops/",
			base: "tool-loops-base.xml",
			globalModifiers: ["enableSinglePalette", "disableTutorialTabs", "disableSinglePaletteButtons"],
		},
		{
			title: "Getting Started",
			video: "tool-loops-1.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear"],
		},
		{
			title: "Stamping and Translating",
			video: "tool-loops-2.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "translatePercent", "doStamp"],
		},
		{
			title: "The Repeat Block",
			video: "tool-loops-3.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
			],
		},
		{
			title: "Creating a Row",
			video: "tool-loops-4.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
			],
		},
		{
			title: "Creating Multiple Rows",
			video: "tool-loops-5.mp4",
			whitelist: [
				"receiveGo",
				"gotoXY",
				"pointAtAngle",
				"setScale",
				"clear",
				"translatePercent",
				"doStamp",
				"doRepeat",
			],
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "tool-loops-outcome.png",
			background: "tooledleather/index.html",
			software: "tooledleather/software.html",
		},
	],
	TooledLeatherParams = [
		{
			tutorial_title: "Parameters in Tooled Leather",
			tool: "Tooled Leather",
			core: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doSwitchToCostume", "doStamp"],
			prefix: "tooledleather/parameters/",
			base: "tool-params-base_v2.xml",
		},
		{
			title: "Getting Started",
			video: "tool-params-1.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Switching Costumes",
			video: "tool-params-2.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doSwitchToCostume", "doStamp"],
			modifiers: ["enableSinglePalette", "disableSinglePaletteButtons", "disableTutorialTabs"],
		},
		{
			title: "Adding More Costumes",
			video: "tool-params-3.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doSwitchToCostume", "doStamp"],
			modifiers: ["disableSinglePalette", "disableTutorialTabs"],
		},
		{
			title: "Drawing Your Own Costumes",
			video: "tool-params-4.mp4",
			whitelist: ["receiveGo", "gotoXY", "pointAtAngle", "setScale", "clear", "doSwitchToCostume", "doStamp"],
			modifiers: ["disableSinglePalette", "enableTutorialTabs"],
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "tool-params-outcome.png",
			background: "tooledleather/index.html",
			software: "tooledleather/software.html",
		},
	],
	TooledLeatherVars = [
		{
			tutorial_title: "Variables in Tooled Leather",
			tool: "Tooled Leather",
			prefix: "tooledleather/variables/",
			base: "tool-vars-base.xml",
		},
		{ title: "Getting Started", video: "variables-1.mp4" },
		{ title: "Script Variables", video: "variables-2.mp4" },
		{ title: "Creating a First Row", video: "variables-3.mp4" },
		{ title: "Creating a Rainbow Effect", video: "variables-4.mp4" },
		{ title: "Simplify With Functions", video: "variables-5.mp4" },
		{ title: "Creating a Second Row", video: "variables-6.mp4" },
		{ title: "Creating a Third Row", video: "variables-7.mp4" },
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "tool-vars-outcome.png",
			background: "tooledleather/index.html",
			software: "tooledleather/software.html",
		},
	],
	TooledLeather = {
		"tooled-leather-params": TooledLeatherParams,
		"tooled-leather-loops": TooledLeatherLoops,
		"tooled-leather-functions": TooledLeatherFunctions,
		"tooled-leather-vars": TooledLeatherVars,
		"tooled-leather-conditionals": TooledLeatherConditionals,
	},
	WovenHeavenEs = [
		{
			tutorial_title: "Cielo Tejido, Tierra Enredada",
			tool: "Cielo Tejido, Tierra Enredada",
			prefix: "whte/es/",
			base: "whte_main_base_es.xml",
		},
		{
			title: "Mi primer programa",
			video: "whte_es_1.mp4",
			tagline: "Configure el inicio del programa.",
			explanation: "whte_es_1.md",
			code: "test.png",
		},
		{
			title: "Haciendo tri\xE1ngulos",
			video: "whte_es_2.mp4",
			tagline: "\xA1Crea tu primer tri\xE1ngulo is\xF3sceles! ",
			explanation: "whte_es_2.md",
		},
		{ title: "Haciendo diamantess", video: "whte_es_3.mp4", explanation: "whte_es_3.md" },
		{ title: "Controlando el Brillo", video: "whte_es_4.mp4", explanation: "whte_es_4.md" },
		{ title: "Dise\xF1ando figuras compuestas", video: "whte_es_5.mp4", explanation: "whte_es_5.md" },
		{ title: "Haciendo l\xEDneas", video: "whte_es_6.mp4", explanation: "whte_es_6.md" },
		{ title: "Entendiendo los ciclos", video: "whte_es_7.mp4", explanation: "whte_es_7.md" },
		{ title: "Creando Variables", video: "whte_es_8.mp4", explanation: "whte_es_8.md" },
		{ title: "Ciclos de ciclos", video: "whte_es_9.mp4", explanation: "whte_es_9.md" },
		{ title: "Organizando bloques", video: "whte_es_10.mp4", explanation: "whte_es_10.md" },
		{ title: "Perfeccionando el dise\xF1o", video: "whte_es_11.mp4", explanation: "whte_es_11.md" },
		{
			title: "Pr\xF3ximos pasos",
			nextSteps:
				"Has completado el tutorial. \xA1Ahora deber\xEDa poder crear sus propios patrones en el software usted mismo!",
			outcome: "whte-main-tut.png",
			background: "whte/index.html",
			software: "whte/software.html",
		},
	],
	WovenHeavenBp = [
		{
			tutorial_title: "C\xE9u Tecido, Terra Emaranhada",
			tool: "C\xE9u Tecido, Terra Emaranhada",
			prefix: "whte/bp/",
			base: "whte_main_base_en.xml",
		},
		{
			title: "Mu Primeiro Programa",
			video: "whte_bp_1.mp4",
			explanation: "whte-bp-1.md",
			tagline: "Inicialize seu programa.",
		},
		{
			title: "Fazendo Tri\xE2ngulos",
			video: "whte_bp_2.mp4",
			explanation: "whte-bp-2.md",
			tagline: "Crie um \xFAnico tri\xE2ngulo.",
		},
		{
			title: "Fazendo Diamantes",
			video: "whte_bp_3.mp4",
			explanation: "whte-bp-3.md",
			tagline: "Crie um segundo tri\xE2ngulo para formar um diamante.",
		},
		{
			title: "Controlando o Brilho",
			video: "whte_bp_4.mp4",
			explanation: "whte-bp-4.md",
			tagline: "Altere o brilho das contas para um tom mais escuro.",
		},
		{
			title: "Projetando Figuras Compostas",
			video: "whte_bp_5.mp4",
			explanation: "whte-bp-5.md",
			tagline: "Crie um segundo diamante dentro do primeiro.",
		},
		{
			title: "Fazendo Linhas",
			video: "whte_bp_6.mp4",
			explanation: "whte-bp-6.md",
			tagline: "Crie uma \xFAnica linha.",
		},
		{
			title: "Entendendo os Ciclos",
			video: "whte_bp_7.mp4",
			explanation: "whte-bp-7.md",
			tagline: "Repita seu c\xF3digo de linha para criar um design.",
		},
		{
			title: "Criando Vari\xE1veis",
			video: "whte_bp_8.mp4",
			explanation: "whte-bp-8.md",
			tagline: "Use uma vari\xE1vel para controlar o comprimento de cada linha.",
		},
		{
			title: "Ciclos de Ciclos",
			video: "whte_bp_9.mp4",
			explanation: "whte-bp-9.md",
			tagline: "Repita o c\xF3digo anterior para criar um novo design.",
		},
		{
			title: "Organizando Blocos",
			video: "whte_bp_10.mp4",
			explanation: "whte-bp-10.md",
			tagline: "Use uma vari\xE1vel para controlar o \xE2ngulo de cada desenho de linha.",
		},
		{
			title: "Aperfei\xE7oando o Design",
			video: "whte_bp_11.mp4",
			explanation: "whte-bp-11.md",
			tagline: "Finalize o design repetindo o c\xF3digo anterior.",
		},
		{
			title: "Pr\xF3ximos Passos",
			nextSteps:
				"Voc\xEA concluiu o tutorial. Agora voc\xEA deve ser capaz de criar seus pr\xF3prios padr\xF5es no software sozinho!",
			outcome: "whte-bp-main-tut.png",
			background: "whte/index.html",
			software: "whte/software.html",
		},
	],
	WovenHeaven = [
		{
			tutorial_title: "Woven Heaven, Tangled Earth",
			tool: "Woven Heaven, Tangled Earth",
			prefix: "whte/main/",
			base: "whte_main_base_en.xml",
		},
		{
			title: "My First Program",
			video: "whte_en_1.mp4",
			explanation: "whte-1.md",
			tagline: "Initialize your program.",
		},
		{
			title: "Making Triangles",
			video: "whte_en_2.mp4",
			explanation: "whte-2.md",
			tagline: "Create a single triangle.",
		},
		{
			title: "Making Diamonds",
			video: "whte_en_3.mp4",
			explanation: "whte-3.md",
			tagline: "Create a second triangle to form a diamond.",
		},
		{
			title: "Controlling the Brightness",
			video: "whte_en_4.mp4",
			explanation: "whte-4.md",
			tagline: "Change the brightness of the beads to a darker shade.",
		},
		{
			title: "Designing Composite Figures",
			video: "whte_en_5.mp4",
			explanation: "whte-5.md",
			tagline: "Create a second diamond within the first.",
		},
		{ title: "Making Lines", video: "whte_en_6.mp4", explanation: "whte-6.md", tagline: "Create a single line." },
		{
			title: "Understanding the Cycles",
			video: "whte_en_7.mp4",
			explanation: "whte-7.md",
			tagline: "Repeat your line code to create a design.",
		},
		{
			title: "Creating Variables",
			video: "whte_en_8.mp4",
			explanation: "whte-8.md",
			tagline: "Use a variable to control the length of each line.",
		},
		{
			title: "Cycles of Cycles",
			video: "whte_en_9.mp4",
			explanation: "whte-9.md",
			tagline: "Repeat your previous code to create a new design.",
		},
		{
			title: "Arranging Blocks",
			video: "whte_en_10.mp4",
			explanation: "whte-10.md",
			tagline: "Use a variable to control the angle of each line design.",
		},
		{
			title: "Perfecting the Design",
			video: "whte_en_11.mp4",
			explanation: "whte-11.md",
			tagline: "Finalize the design by repeating the previous code.",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "whte-main-tut.png",
			background: "whte/index.html",
			software: "whte/software.html",
		},
	],
	WovenHeavenTangledEarth = { "whte-en": WovenHeaven, "whte-es": WovenHeavenEs, "whte-bp": WovenHeavenBp },
	YarnArtsCircular = [
		{ tutorial_title: "Circular Yarn Arts", tool: "Yarn Arts", prefix: "yarnarts/circle/", base: "base.xml" },
		{
			title: "Getting Familiar With Your Script",
			video: "circle-1.mp4",
			explanation: "circle-1.md",
			tagline: "Click the green flag to run the script.",
		},
		{
			title: "Experimenting With Parameter Changes",
			video: "circle-2.mp4",
			explanation: "circle-2.md",
			tagline: "Experiment with the parameters (the values in the blocks). ",
		},
		{
			title: "Creating Two Circles",
			video: "circle-3.mp4",
			explanation: "circle-3.md",
			tagline: "Create two additional circles.",
		},
		{
			title: "Creating Variables",
			video: "circle-4.mp4",
			explanation: "circle-4.md",
			tagline: "Create 'radius' and 'circ' variables for the script.",
		},
		{
			title: "Adding Repeats",
			video: "circle-5.mp4",
			explanation: "circle-5.md",
			tagline: "Fill out your loop by using your variables.",
		},
		{
			title: "Finishing the Nested Loop",
			video: "circle-6.mp4",
			explanation: "circle-6.md",
			tagline: "Finish off the nested loop.",
		},
		{
			title: "Final Touches",
			video: "circle-7.mp4",
			explanation: "circle-7.md",
			tagline: "Change the variable values at the end of the control loop.",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "circle-tut.png",
			background: "yarnarts/index.html",
			software: "yarnarts/software.html",
		},
	],
	YarnArtsRectangular = [
		{ tutorial_title: "Rectangular Yarn Arts", tool: "Yarn Arts", prefix: "yarnarts/rect/", base: "base.xml" },
		{
			title: "Setting up Your Script",
			video: "rect-1.mp4",
			explanation: "rect-1.md",
			tagline: "Initialize your script.",
		},
		{ title: "Nested Iteration", video: "rect-2.mp4", explanation: "rect-2.md", tagline: "Create a nested loop. " },
		{
			title: "Y Axis Movement",
			video: "rect-3.mp4",
			explanation: "rect-3.md",
			tagline: "Add to your script to progress the stitching along the y axis.",
		},
		{
			title: "Adding Color to Your Stitches",
			video: "rect-4.mp4",
			explanation: "rect-4.md",
			tagline: "Add color to your stitches.",
		},
		{
			title: "Adding Triangles",
			video: "rect-5.mp4",
			explanation: "rect-5.md",
			tagline: "Add a triangle to your design.",
		},
		{
			title: "Next Steps",
			nextSteps:
				"You completed the tutorial. You should now be able to create your own patterns in the software by yourself!",
			outcome: "rect-tut.png",
			background: "yarnarts/index.html",
			software: "yarnarts/software.html",
		},
	],
	YarnArts = { "yarnarts-circular": YarnArtsCircular, "yarnarts-rectangular": YarnArtsRectangular },
	AvailableSets = {
		...TooledLeather,
		...Quilting,
		...Cornrows,
		...YarnArts,
		...Adinkra,
		...WovenHeavenTangledEarth,
		...PreColumbian,
		...AnishinaabeArcs,
		"beadloom-programming": BeadLoomProgramming,
	},
	fetchLocalData = (_) => {
		var rt;
		const et = async (it) => await axios.get(it).then((ot) => ot.data),
			{ data: tt, error: nt } = useSWR(_, et, { revalidateOnFocus: !0 });
		return {
			info: tt && tt.length > 0 && ((rt = tt[0]) == null ? void 0 : rt.tutorial_title) ? tt[0] : "",
			data: tt,
			isLoading: !nt && !tt,
			isError: nt,
		};
	},
	selectSet = (_) => {
		var nt;
		const et = _ in AvailableSets ? _ : "tooled-leather-params",
			tt = AvailableSets[et];
		return { info: (nt = tt[0]) != null && nt.tutorial_title ? tt[0] : "", data: tt, isLoading: !tt };
	},
	fetchXML = (_) => axios.get(_, { headers: { "Content-Type": "application/json" } }).then((et) => et.data),
	FetchService = { fetchLocalData, fetchXML, selectSet },
	loadBaseProject = (_) => {
		const et = async (rt) => await axios.get(rt).then((it) => it.data),
			{ data: tt, error: nt } = useSWR(_, et, { revalidateOnFocus: !0 });
		return { data: tt, isLoading: !nt && !tt, isError: nt };
	},
	CSnapService = { loadBaseProject };
var cssUnit = {
	cm: !0,
	mm: !0,
	in: !0,
	px: !0,
	pt: !0,
	pc: !0,
	em: !0,
	ex: !0,
	ch: !0,
	rem: !0,
	vw: !0,
	vh: !0,
	vmin: !0,
	vmax: !0,
	"%": !0,
};
function parseLengthAndUnit(_) {
	if (typeof _ == "number") return { value: _, unit: "px" };
	var et,
		tt = (_.match(/^[0-9.]*/) || "").toString();
	tt.includes(".") ? (et = parseFloat(tt)) : (et = parseInt(tt, 10));
	var nt = (_.match(/[^0-9]*$/) || "").toString();
	return cssUnit[nt]
		? { value: et, unit: nt }
		: (console.warn("React Spinners: ".concat(_, " is not a valid css value. Defaulting to ").concat(et, "px.")),
		  { value: et, unit: "px" });
}
function cssValue(_) {
	var et = parseLengthAndUnit(_);
	return "".concat(et.value).concat(et.unit);
}
var createAnimation = function (_, et, tt) {
		var nt = "react-spinners-".concat(_, "-").concat(tt);
		if (typeof window > "u" || !window.document) return nt;
		var rt = document.createElement("style");
		document.head.appendChild(rt);
		var it = rt.sheet,
			ot = `
    @keyframes `
				.concat(
					nt,
					` {
      `
				)
				.concat(
					et,
					`
    }
  `
				);
		return it && it.insertRule(ot, 0), nt;
	},
	__assign$2 =
		(globalThis && globalThis.__assign) ||
		function () {
			return (
				(__assign$2 =
					Object.assign ||
					function (_) {
						for (var et, tt = 1, nt = arguments.length; tt < nt; tt++) {
							et = arguments[tt];
							for (var rt in et) Object.prototype.hasOwnProperty.call(et, rt) && (_[rt] = et[rt]);
						}
						return _;
					}),
				__assign$2.apply(this, arguments)
			);
		},
	__rest =
		(globalThis && globalThis.__rest) ||
		function (_, et) {
			var tt = {};
			for (var nt in _) Object.prototype.hasOwnProperty.call(_, nt) && et.indexOf(nt) < 0 && (tt[nt] = _[nt]);
			if (_ != null && typeof Object.getOwnPropertySymbols == "function")
				for (var rt = 0, nt = Object.getOwnPropertySymbols(_); rt < nt.length; rt++)
					et.indexOf(nt[rt]) < 0 && Object.prototype.propertyIsEnumerable.call(_, nt[rt]) && (tt[nt[rt]] = _[nt[rt]]);
			return tt;
		},
	puff = [
		createAnimation("PuffLoader", "0% {transform: scale(0)} 100% {transform: scale(1.0)}", "puff-1"),
		createAnimation("PuffLoader", "0% {opacity: 1} 100% {opacity: 0}", "puff-2"),
	];
function PuffLoader(_) {
	var et = _.loading,
		tt = et === void 0 ? !0 : et,
		nt = _.color,
		rt = nt === void 0 ? "#000000" : nt,
		it = _.speedMultiplier,
		ot = it === void 0 ? 1 : it,
		at = _.cssOverride,
		st = at === void 0 ? {} : at,
		lt = _.size,
		ut = lt === void 0 ? 60 : lt,
		dt = __rest(_, ["loading", "color", "speedMultiplier", "cssOverride", "size"]),
		ct = __assign$2({ display: "inherit", position: "relative", width: cssValue(ut), height: cssValue(ut) }, st),
		ft = function (mt) {
			return {
				position: "absolute",
				height: cssValue(ut),
				width: cssValue(ut),
				border: "thick solid ".concat(rt),
				borderRadius: "50%",
				opacity: "1",
				top: "0",
				left: "0",
				animationFillMode: "both",
				animation: "".concat(puff[0], ", ").concat(puff[1]),
				animationDuration: "".concat(2 / ot, "s"),
				animationIterationCount: "infinite",
				animationTimingFunction: "cubic-bezier(0.165, 0.84, 0.44, 1), cubic-bezier(0.3, 0.61, 0.355, 1)",
				animationDelay: mt === 1 ? "-1s" : "0s",
			};
		};
	return tt
		? jsxs("span", {
				...__assign$2({ style: ct }, dt),
				children: [jsx("span", { style: ft(1) }), jsx("span", { style: ft(2) })],
		  })
		: null;
}
const override = { display: "block", margin: "0 auto" };
function LoadIndicator({ isLoading: _ }) {
	return jsx(Fragment, {
		children:
			_ &&
			jsx(Flex, {
				minH: "100vh",
				align: "center",
				justify: "center",
				children: jsx(PuffLoader, { color: "#000000", loading: _, cssOverride: override, size: 150 }),
			}),
	});
}
function LoadContainer({
	isLoading: _,
	children: et,
	isError: tt,
	errorMsg: nt = "There seems to be an issue connecting to the server. Please try again later.",
}) {
	return jsxs(Fragment, {
		children: [
			jsx(LoadIndicator, { isLoading: _ }),
			!_ && jsx(Fragment, { children: et }),
			tt && jsx(Text$2, { children: nt }),
		],
	});
}
function CSnap({ base, coreList, whitelist, modifiers, globalModifiers, ide, setIde, legacy }) {
	const csnap = react.exports.useRef(null),
		prefix = "../",
		{ data, isLoading, isError } = CSnapService.loadBaseProject(`assets/${base}`),
		[blocks, setBlocks] = react.exports.useState(null),
		[ready, setReady] = react.exports.useState(!1),
		source = legacy ? `${prefix}csnap/tutorial.html` : `${prefix}csnap_pro/csdt/snap.html`;
	react.exports.useEffect(() => {
		ide && setBlocks(ide.fetchBlockList()),
			data &&
				ide &&
				ide.loadTutorial(data, !1, coreList, whitelist, () => {
					setReady(!0);
				});
	}, [data, ide]),
		react.exports.useEffect(() => {
			ide && whitelist && ide.displayTutorialBlocks(coreList, whitelist);
		}, [whitelist]),
		react.exports.useEffect(() => {
			ide &&
				modifiers &&
				modifiers.forEach((mod) => {
					eval(`ide.${mod}()`);
				});
		}, [modifiers]),
		react.exports.useEffect(() => {
			ide &&
				modifiers &&
				modifiers.forEach((mod) => {
					eval(`ide.${mod}()`);
				}),
				ide &&
					globalModifiers &&
					globalModifiers.forEach((mod) => {
						eval(`ide.${mod}()`);
					}),
				ide && whitelist && ide.displayTutorialBlocks(coreList, whitelist);
		}, [ready]);
	const checkForWorld = () => {
		csnap.current.contentWindow.world.children && setIde(csnap.current.contentWindow.world.children[0]);
	};
	return jsxs(LoadContainer, {
		isLoading,
		isError,
		children: [
			jsx("div", {
				className: "border-4 border-dashed rounded-md h-full fifth-step my-auto border-gray-500",
				children: jsx(chakra.iframe, {
					src: source,
					frameBorder: "0",
					w: "100%",
					h: "100%",
					onLoad: () => checkForWorld(),
					ref: csnap,
				}),
			}),
			" ",
		],
	});
}
var lib$5 = {},
	Parser$1 = {},
	Tokenizer = {},
	decode$1 = {},
	decodeDataHtml = {};
Object.defineProperty(decodeDataHtml, "__esModule", { value: !0 });
decodeDataHtml.default = new Uint16Array(
	'\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'
		.split("")
		.map(function (_) {
			return _.charCodeAt(0);
		})
);
var decodeDataXml = {};
Object.defineProperty(decodeDataXml, "__esModule", { value: !0 });
decodeDataXml.default = new Uint16Array(
	"\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function (_) {
		return _.charCodeAt(0);
	})
);
var decode_codepoint = {};
(function (_) {
	var et;
	Object.defineProperty(_, "__esModule", { value: !0 }), (_.replaceCodePoint = _.fromCodePoint = void 0);
	var tt = new Map([
		[0, 65533],
		[128, 8364],
		[130, 8218],
		[131, 402],
		[132, 8222],
		[133, 8230],
		[134, 8224],
		[135, 8225],
		[136, 710],
		[137, 8240],
		[138, 352],
		[139, 8249],
		[140, 338],
		[142, 381],
		[145, 8216],
		[146, 8217],
		[147, 8220],
		[148, 8221],
		[149, 8226],
		[150, 8211],
		[151, 8212],
		[152, 732],
		[153, 8482],
		[154, 353],
		[155, 8250],
		[156, 339],
		[158, 382],
		[159, 376],
	]);
	_.fromCodePoint =
		(et = String.fromCodePoint) !== null && et !== void 0
			? et
			: function (it) {
					var ot = "";
					return (
						it > 65535 &&
							((it -= 65536), (ot += String.fromCharCode(((it >>> 10) & 1023) | 55296)), (it = 56320 | (it & 1023))),
						(ot += String.fromCharCode(it)),
						ot
					);
			  };
	function nt(it) {
		var ot;
		return (it >= 55296 && it <= 57343) || it > 1114111 ? 65533 : (ot = tt.get(it)) !== null && ot !== void 0 ? ot : it;
	}
	_.replaceCodePoint = nt;
	function rt(it) {
		return (0, _.fromCodePoint)(nt(it));
	}
	_.default = rt;
})(decode_codepoint);
(function (_) {
	var et =
		(commonjsGlobal && commonjsGlobal.__importDefault) ||
		function (pt) {
			return pt && pt.__esModule ? pt : { default: pt };
		};
	Object.defineProperty(_, "__esModule", { value: !0 }),
		(_.decodeXML =
			_.decodeHTMLStrict =
			_.decodeHTML =
			_.determineBranch =
			_.BinTrieFlags =
			_.fromCodePoint =
			_.replaceCodePoint =
			_.decodeCodePoint =
			_.xmlDecodeTree =
			_.htmlDecodeTree =
				void 0);
	var tt = et(decodeDataHtml);
	_.htmlDecodeTree = tt.default;
	var nt = et(decodeDataXml);
	_.xmlDecodeTree = nt.default;
	var rt = et(decode_codepoint);
	_.decodeCodePoint = rt.default;
	var it = decode_codepoint;
	Object.defineProperty(_, "replaceCodePoint", {
		enumerable: !0,
		get: function () {
			return it.replaceCodePoint;
		},
	}),
		Object.defineProperty(_, "fromCodePoint", {
			enumerable: !0,
			get: function () {
				return it.fromCodePoint;
			},
		});
	var ot;
	(function (pt) {
		(pt[(pt.NUM = 35)] = "NUM"),
			(pt[(pt.SEMI = 59)] = "SEMI"),
			(pt[(pt.ZERO = 48)] = "ZERO"),
			(pt[(pt.NINE = 57)] = "NINE"),
			(pt[(pt.LOWER_A = 97)] = "LOWER_A"),
			(pt[(pt.LOWER_F = 102)] = "LOWER_F"),
			(pt[(pt.LOWER_X = 120)] = "LOWER_X"),
			(pt[(pt.To_LOWER_BIT = 32)] = "To_LOWER_BIT");
	})(ot || (ot = {}));
	var at;
	(function (pt) {
		(pt[(pt.VALUE_LENGTH = 49152)] = "VALUE_LENGTH"),
			(pt[(pt.BRANCH_LENGTH = 16256)] = "BRANCH_LENGTH"),
			(pt[(pt.JUMP_TABLE = 127)] = "JUMP_TABLE");
	})((at = _.BinTrieFlags || (_.BinTrieFlags = {})));
	function st(pt) {
		return function (ht, gt) {
			for (var yt = "", xt = 0, St = 0; (St = ht.indexOf("&", St)) >= 0; ) {
				if (((yt += ht.slice(xt, St)), (xt = St), (St += 1), ht.charCodeAt(St) === ot.NUM)) {
					var wt = St + 1,
						Ct = 10,
						Et = ht.charCodeAt(wt);
					(Et | ot.To_LOWER_BIT) === ot.LOWER_X && ((Ct = 16), (St += 1), (wt += 1));
					do Et = ht.charCodeAt(++St);
					while (
						(Et >= ot.ZERO && Et <= ot.NINE) ||
						(Ct === 16 && (Et | ot.To_LOWER_BIT) >= ot.LOWER_A && (Et | ot.To_LOWER_BIT) <= ot.LOWER_F)
					);
					if (wt !== St) {
						var _t = ht.substring(wt, St),
							$t = parseInt(_t, Ct);
						if (ht.charCodeAt(St) === ot.SEMI) St += 1;
						else if (gt) continue;
						(yt += (0, rt.default)($t)), (xt = St);
					}
					continue;
				}
				for (
					var At = 0, Lt = 1, Nt = 0, Ft = pt[Nt];
					St < ht.length && ((Nt = lt(pt, Ft, Nt + 1, ht.charCodeAt(St))), !(Nt < 0));
					St++, Lt++
				) {
					Ft = pt[Nt];
					var Gt = Ft & at.VALUE_LENGTH;
					if (Gt) {
						(!gt || ht.charCodeAt(St) === ot.SEMI) && ((At = Nt), (Lt = 0));
						var Bt = (Gt >> 14) - 1;
						if (Bt === 0) break;
						Nt += Bt;
					}
				}
				if (At !== 0) {
					var Bt = (pt[At] & at.VALUE_LENGTH) >> 14;
					(yt +=
						Bt === 1
							? String.fromCharCode(pt[At] & ~at.VALUE_LENGTH)
							: Bt === 2
							? String.fromCharCode(pt[At + 1])
							: String.fromCharCode(pt[At + 1], pt[At + 2])),
						(xt = St - Lt + 1);
				}
			}
			return yt + ht.slice(xt);
		};
	}
	function lt(pt, vt, ht, gt) {
		var yt = (vt & at.BRANCH_LENGTH) >> 7,
			xt = vt & at.JUMP_TABLE;
		if (yt === 0) return xt !== 0 && gt === xt ? ht : -1;
		if (xt) {
			var St = gt - xt;
			return St < 0 || St >= yt ? -1 : pt[ht + St] - 1;
		}
		for (var wt = ht, Ct = wt + yt - 1; wt <= Ct; ) {
			var Et = (wt + Ct) >>> 1,
				_t = pt[Et];
			if (_t < gt) wt = Et + 1;
			else if (_t > gt) Ct = Et - 1;
			else return pt[Et + yt];
		}
		return -1;
	}
	_.determineBranch = lt;
	var ut = st(tt.default),
		dt = st(nt.default);
	function ct(pt) {
		return ut(pt, !1);
	}
	_.decodeHTML = ct;
	function ft(pt) {
		return ut(pt, !0);
	}
	_.decodeHTMLStrict = ft;
	function mt(pt) {
		return dt(pt, !0);
	}
	_.decodeXML = mt;
})(decode$1);
(function (_) {
	Object.defineProperty(_, "__esModule", { value: !0 }), (_.QuoteType = void 0);
	var et = decode$1,
		tt;
	(function (ct) {
		(ct[(ct.Tab = 9)] = "Tab"),
			(ct[(ct.NewLine = 10)] = "NewLine"),
			(ct[(ct.FormFeed = 12)] = "FormFeed"),
			(ct[(ct.CarriageReturn = 13)] = "CarriageReturn"),
			(ct[(ct.Space = 32)] = "Space"),
			(ct[(ct.ExclamationMark = 33)] = "ExclamationMark"),
			(ct[(ct.Num = 35)] = "Num"),
			(ct[(ct.Amp = 38)] = "Amp"),
			(ct[(ct.SingleQuote = 39)] = "SingleQuote"),
			(ct[(ct.DoubleQuote = 34)] = "DoubleQuote"),
			(ct[(ct.Dash = 45)] = "Dash"),
			(ct[(ct.Slash = 47)] = "Slash"),
			(ct[(ct.Zero = 48)] = "Zero"),
			(ct[(ct.Nine = 57)] = "Nine"),
			(ct[(ct.Semi = 59)] = "Semi"),
			(ct[(ct.Lt = 60)] = "Lt"),
			(ct[(ct.Eq = 61)] = "Eq"),
			(ct[(ct.Gt = 62)] = "Gt"),
			(ct[(ct.Questionmark = 63)] = "Questionmark"),
			(ct[(ct.UpperA = 65)] = "UpperA"),
			(ct[(ct.LowerA = 97)] = "LowerA"),
			(ct[(ct.UpperF = 70)] = "UpperF"),
			(ct[(ct.LowerF = 102)] = "LowerF"),
			(ct[(ct.UpperZ = 90)] = "UpperZ"),
			(ct[(ct.LowerZ = 122)] = "LowerZ"),
			(ct[(ct.LowerX = 120)] = "LowerX"),
			(ct[(ct.OpeningSquareBracket = 91)] = "OpeningSquareBracket");
	})(tt || (tt = {}));
	var nt;
	(function (ct) {
		(ct[(ct.Text = 1)] = "Text"),
			(ct[(ct.BeforeTagName = 2)] = "BeforeTagName"),
			(ct[(ct.InTagName = 3)] = "InTagName"),
			(ct[(ct.InSelfClosingTag = 4)] = "InSelfClosingTag"),
			(ct[(ct.BeforeClosingTagName = 5)] = "BeforeClosingTagName"),
			(ct[(ct.InClosingTagName = 6)] = "InClosingTagName"),
			(ct[(ct.AfterClosingTagName = 7)] = "AfterClosingTagName"),
			(ct[(ct.BeforeAttributeName = 8)] = "BeforeAttributeName"),
			(ct[(ct.InAttributeName = 9)] = "InAttributeName"),
			(ct[(ct.AfterAttributeName = 10)] = "AfterAttributeName"),
			(ct[(ct.BeforeAttributeValue = 11)] = "BeforeAttributeValue"),
			(ct[(ct.InAttributeValueDq = 12)] = "InAttributeValueDq"),
			(ct[(ct.InAttributeValueSq = 13)] = "InAttributeValueSq"),
			(ct[(ct.InAttributeValueNq = 14)] = "InAttributeValueNq"),
			(ct[(ct.BeforeDeclaration = 15)] = "BeforeDeclaration"),
			(ct[(ct.InDeclaration = 16)] = "InDeclaration"),
			(ct[(ct.InProcessingInstruction = 17)] = "InProcessingInstruction"),
			(ct[(ct.BeforeComment = 18)] = "BeforeComment"),
			(ct[(ct.CDATASequence = 19)] = "CDATASequence"),
			(ct[(ct.InSpecialComment = 20)] = "InSpecialComment"),
			(ct[(ct.InCommentLike = 21)] = "InCommentLike"),
			(ct[(ct.BeforeSpecialS = 22)] = "BeforeSpecialS"),
			(ct[(ct.SpecialStartSequence = 23)] = "SpecialStartSequence"),
			(ct[(ct.InSpecialTag = 24)] = "InSpecialTag"),
			(ct[(ct.BeforeEntity = 25)] = "BeforeEntity"),
			(ct[(ct.BeforeNumericEntity = 26)] = "BeforeNumericEntity"),
			(ct[(ct.InNamedEntity = 27)] = "InNamedEntity"),
			(ct[(ct.InNumericEntity = 28)] = "InNumericEntity"),
			(ct[(ct.InHexEntity = 29)] = "InHexEntity");
	})(nt || (nt = {}));
	function rt(ct) {
		return ct === tt.Space || ct === tt.NewLine || ct === tt.Tab || ct === tt.FormFeed || ct === tt.CarriageReturn;
	}
	function it(ct) {
		return ct === tt.Slash || ct === tt.Gt || rt(ct);
	}
	function ot(ct) {
		return ct >= tt.Zero && ct <= tt.Nine;
	}
	function at(ct) {
		return (ct >= tt.LowerA && ct <= tt.LowerZ) || (ct >= tt.UpperA && ct <= tt.UpperZ);
	}
	function st(ct) {
		return (ct >= tt.UpperA && ct <= tt.UpperF) || (ct >= tt.LowerA && ct <= tt.LowerF);
	}
	var lt;
	(function (ct) {
		(ct[(ct.NoValue = 0)] = "NoValue"),
			(ct[(ct.Unquoted = 1)] = "Unquoted"),
			(ct[(ct.Single = 2)] = "Single"),
			(ct[(ct.Double = 3)] = "Double");
	})((lt = _.QuoteType || (_.QuoteType = {})));
	var ut = {
			Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
			CdataEnd: new Uint8Array([93, 93, 62]),
			CommentEnd: new Uint8Array([45, 45, 62]),
			ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
			StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
			TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
		},
		dt = (function () {
			function ct(ft, mt) {
				var pt = ft.xmlMode,
					vt = pt === void 0 ? !1 : pt,
					ht = ft.decodeEntities,
					gt = ht === void 0 ? !0 : ht;
				(this.cbs = mt),
					(this.state = nt.Text),
					(this.buffer = ""),
					(this.sectionStart = 0),
					(this.index = 0),
					(this.baseState = nt.Text),
					(this.isSpecial = !1),
					(this.running = !0),
					(this.offset = 0),
					(this.sequenceIndex = 0),
					(this.trieIndex = 0),
					(this.trieCurrent = 0),
					(this.entityResult = 0),
					(this.entityExcess = 0),
					(this.xmlMode = vt),
					(this.decodeEntities = gt),
					(this.entityTrie = vt ? et.xmlDecodeTree : et.htmlDecodeTree);
			}
			return (
				(ct.prototype.reset = function () {
					(this.state = nt.Text),
						(this.buffer = ""),
						(this.sectionStart = 0),
						(this.index = 0),
						(this.baseState = nt.Text),
						(this.currentSequence = void 0),
						(this.running = !0),
						(this.offset = 0);
				}),
				(ct.prototype.write = function (ft) {
					(this.offset += this.buffer.length), (this.buffer = ft), this.parse();
				}),
				(ct.prototype.end = function () {
					this.running && this.finish();
				}),
				(ct.prototype.pause = function () {
					this.running = !1;
				}),
				(ct.prototype.resume = function () {
					(this.running = !0), this.index < this.buffer.length + this.offset && this.parse();
				}),
				(ct.prototype.getIndex = function () {
					return this.index;
				}),
				(ct.prototype.getSectionStart = function () {
					return this.sectionStart;
				}),
				(ct.prototype.stateText = function (ft) {
					ft === tt.Lt || (!this.decodeEntities && this.fastForwardTo(tt.Lt))
						? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index),
						  (this.state = nt.BeforeTagName),
						  (this.sectionStart = this.index))
						: this.decodeEntities && ft === tt.Amp && (this.state = nt.BeforeEntity);
				}),
				(ct.prototype.stateSpecialStartSequence = function (ft) {
					var mt = this.sequenceIndex === this.currentSequence.length,
						pt = mt ? it(ft) : (ft | 32) === this.currentSequence[this.sequenceIndex];
					if (!pt) this.isSpecial = !1;
					else if (!mt) {
						this.sequenceIndex++;
						return;
					}
					(this.sequenceIndex = 0), (this.state = nt.InTagName), this.stateInTagName(ft);
				}),
				(ct.prototype.stateInSpecialTag = function (ft) {
					if (this.sequenceIndex === this.currentSequence.length) {
						if (ft === tt.Gt || rt(ft)) {
							var mt = this.index - this.currentSequence.length;
							if (this.sectionStart < mt) {
								var pt = this.index;
								(this.index = mt), this.cbs.ontext(this.sectionStart, mt), (this.index = pt);
							}
							(this.isSpecial = !1), (this.sectionStart = mt + 2), this.stateInClosingTagName(ft);
							return;
						}
						this.sequenceIndex = 0;
					}
					(ft | 32) === this.currentSequence[this.sequenceIndex]
						? (this.sequenceIndex += 1)
						: this.sequenceIndex === 0
						? this.currentSequence === ut.TitleEnd
							? this.decodeEntities && ft === tt.Amp && (this.state = nt.BeforeEntity)
							: this.fastForwardTo(tt.Lt) && (this.sequenceIndex = 1)
						: (this.sequenceIndex = Number(ft === tt.Lt));
				}),
				(ct.prototype.stateCDATASequence = function (ft) {
					ft === ut.Cdata[this.sequenceIndex]
						? ++this.sequenceIndex === ut.Cdata.length &&
						  ((this.state = nt.InCommentLike),
						  (this.currentSequence = ut.CdataEnd),
						  (this.sequenceIndex = 0),
						  (this.sectionStart = this.index + 1))
						: ((this.sequenceIndex = 0), (this.state = nt.InDeclaration), this.stateInDeclaration(ft));
				}),
				(ct.prototype.fastForwardTo = function (ft) {
					for (; ++this.index < this.buffer.length + this.offset; )
						if (this.buffer.charCodeAt(this.index - this.offset) === ft) return !0;
					return (this.index = this.buffer.length + this.offset - 1), !1;
				}),
				(ct.prototype.stateInCommentLike = function (ft) {
					ft === this.currentSequence[this.sequenceIndex]
						? ++this.sequenceIndex === this.currentSequence.length &&
						  (this.currentSequence === ut.CdataEnd
								? this.cbs.oncdata(this.sectionStart, this.index, 2)
								: this.cbs.oncomment(this.sectionStart, this.index, 2),
						  (this.sequenceIndex = 0),
						  (this.sectionStart = this.index + 1),
						  (this.state = nt.Text))
						: this.sequenceIndex === 0
						? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1)
						: ft !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
				}),
				(ct.prototype.isTagStartChar = function (ft) {
					return this.xmlMode ? !it(ft) : at(ft);
				}),
				(ct.prototype.startSpecial = function (ft, mt) {
					(this.isSpecial = !0),
						(this.currentSequence = ft),
						(this.sequenceIndex = mt),
						(this.state = nt.SpecialStartSequence);
				}),
				(ct.prototype.stateBeforeTagName = function (ft) {
					if (ft === tt.ExclamationMark) (this.state = nt.BeforeDeclaration), (this.sectionStart = this.index + 1);
					else if (ft === tt.Questionmark)
						(this.state = nt.InProcessingInstruction), (this.sectionStart = this.index + 1);
					else if (this.isTagStartChar(ft)) {
						var mt = ft | 32;
						(this.sectionStart = this.index),
							!this.xmlMode && mt === ut.TitleEnd[2]
								? this.startSpecial(ut.TitleEnd, 3)
								: (this.state = !this.xmlMode && mt === ut.ScriptEnd[2] ? nt.BeforeSpecialS : nt.InTagName);
					} else
						ft === tt.Slash ? (this.state = nt.BeforeClosingTagName) : ((this.state = nt.Text), this.stateText(ft));
				}),
				(ct.prototype.stateInTagName = function (ft) {
					it(ft) &&
						(this.cbs.onopentagname(this.sectionStart, this.index),
						(this.sectionStart = -1),
						(this.state = nt.BeforeAttributeName),
						this.stateBeforeAttributeName(ft));
				}),
				(ct.prototype.stateBeforeClosingTagName = function (ft) {
					rt(ft) ||
						(ft === tt.Gt
							? (this.state = nt.Text)
							: ((this.state = this.isTagStartChar(ft) ? nt.InClosingTagName : nt.InSpecialComment),
							  (this.sectionStart = this.index)));
				}),
				(ct.prototype.stateInClosingTagName = function (ft) {
					(ft === tt.Gt || rt(ft)) &&
						(this.cbs.onclosetag(this.sectionStart, this.index),
						(this.sectionStart = -1),
						(this.state = nt.AfterClosingTagName),
						this.stateAfterClosingTagName(ft));
				}),
				(ct.prototype.stateAfterClosingTagName = function (ft) {
					(ft === tt.Gt || this.fastForwardTo(tt.Gt)) && ((this.state = nt.Text), (this.sectionStart = this.index + 1));
				}),
				(ct.prototype.stateBeforeAttributeName = function (ft) {
					ft === tt.Gt
						? (this.cbs.onopentagend(this.index),
						  this.isSpecial ? ((this.state = nt.InSpecialTag), (this.sequenceIndex = 0)) : (this.state = nt.Text),
						  (this.baseState = this.state),
						  (this.sectionStart = this.index + 1))
						: ft === tt.Slash
						? (this.state = nt.InSelfClosingTag)
						: rt(ft) || ((this.state = nt.InAttributeName), (this.sectionStart = this.index));
				}),
				(ct.prototype.stateInSelfClosingTag = function (ft) {
					ft === tt.Gt
						? (this.cbs.onselfclosingtag(this.index),
						  (this.state = nt.Text),
						  (this.baseState = nt.Text),
						  (this.sectionStart = this.index + 1),
						  (this.isSpecial = !1))
						: rt(ft) || ((this.state = nt.BeforeAttributeName), this.stateBeforeAttributeName(ft));
				}),
				(ct.prototype.stateInAttributeName = function (ft) {
					(ft === tt.Eq || it(ft)) &&
						(this.cbs.onattribname(this.sectionStart, this.index),
						(this.sectionStart = -1),
						(this.state = nt.AfterAttributeName),
						this.stateAfterAttributeName(ft));
				}),
				(ct.prototype.stateAfterAttributeName = function (ft) {
					ft === tt.Eq
						? (this.state = nt.BeforeAttributeValue)
						: ft === tt.Slash || ft === tt.Gt
						? (this.cbs.onattribend(lt.NoValue, this.index),
						  (this.state = nt.BeforeAttributeName),
						  this.stateBeforeAttributeName(ft))
						: rt(ft) ||
						  (this.cbs.onattribend(lt.NoValue, this.index),
						  (this.state = nt.InAttributeName),
						  (this.sectionStart = this.index));
				}),
				(ct.prototype.stateBeforeAttributeValue = function (ft) {
					ft === tt.DoubleQuote
						? ((this.state = nt.InAttributeValueDq), (this.sectionStart = this.index + 1))
						: ft === tt.SingleQuote
						? ((this.state = nt.InAttributeValueSq), (this.sectionStart = this.index + 1))
						: rt(ft) ||
						  ((this.sectionStart = this.index),
						  (this.state = nt.InAttributeValueNq),
						  this.stateInAttributeValueNoQuotes(ft));
				}),
				(ct.prototype.handleInAttributeValue = function (ft, mt) {
					ft === mt || (!this.decodeEntities && this.fastForwardTo(mt))
						? (this.cbs.onattribdata(this.sectionStart, this.index),
						  (this.sectionStart = -1),
						  this.cbs.onattribend(mt === tt.DoubleQuote ? lt.Double : lt.Single, this.index),
						  (this.state = nt.BeforeAttributeName))
						: this.decodeEntities && ft === tt.Amp && ((this.baseState = this.state), (this.state = nt.BeforeEntity));
				}),
				(ct.prototype.stateInAttributeValueDoubleQuotes = function (ft) {
					this.handleInAttributeValue(ft, tt.DoubleQuote);
				}),
				(ct.prototype.stateInAttributeValueSingleQuotes = function (ft) {
					this.handleInAttributeValue(ft, tt.SingleQuote);
				}),
				(ct.prototype.stateInAttributeValueNoQuotes = function (ft) {
					rt(ft) || ft === tt.Gt
						? (this.cbs.onattribdata(this.sectionStart, this.index),
						  (this.sectionStart = -1),
						  this.cbs.onattribend(lt.Unquoted, this.index),
						  (this.state = nt.BeforeAttributeName),
						  this.stateBeforeAttributeName(ft))
						: this.decodeEntities && ft === tt.Amp && ((this.baseState = this.state), (this.state = nt.BeforeEntity));
				}),
				(ct.prototype.stateBeforeDeclaration = function (ft) {
					ft === tt.OpeningSquareBracket
						? ((this.state = nt.CDATASequence), (this.sequenceIndex = 0))
						: (this.state = ft === tt.Dash ? nt.BeforeComment : nt.InDeclaration);
				}),
				(ct.prototype.stateInDeclaration = function (ft) {
					(ft === tt.Gt || this.fastForwardTo(tt.Gt)) &&
						(this.cbs.ondeclaration(this.sectionStart, this.index),
						(this.state = nt.Text),
						(this.sectionStart = this.index + 1));
				}),
				(ct.prototype.stateInProcessingInstruction = function (ft) {
					(ft === tt.Gt || this.fastForwardTo(tt.Gt)) &&
						(this.cbs.onprocessinginstruction(this.sectionStart, this.index),
						(this.state = nt.Text),
						(this.sectionStart = this.index + 1));
				}),
				(ct.prototype.stateBeforeComment = function (ft) {
					ft === tt.Dash
						? ((this.state = nt.InCommentLike),
						  (this.currentSequence = ut.CommentEnd),
						  (this.sequenceIndex = 2),
						  (this.sectionStart = this.index + 1))
						: (this.state = nt.InDeclaration);
				}),
				(ct.prototype.stateInSpecialComment = function (ft) {
					(ft === tt.Gt || this.fastForwardTo(tt.Gt)) &&
						(this.cbs.oncomment(this.sectionStart, this.index, 0),
						(this.state = nt.Text),
						(this.sectionStart = this.index + 1));
				}),
				(ct.prototype.stateBeforeSpecialS = function (ft) {
					var mt = ft | 32;
					mt === ut.ScriptEnd[3]
						? this.startSpecial(ut.ScriptEnd, 4)
						: mt === ut.StyleEnd[3]
						? this.startSpecial(ut.StyleEnd, 4)
						: ((this.state = nt.InTagName), this.stateInTagName(ft));
				}),
				(ct.prototype.stateBeforeEntity = function (ft) {
					(this.entityExcess = 1),
						(this.entityResult = 0),
						ft === tt.Num
							? (this.state = nt.BeforeNumericEntity)
							: ft === tt.Amp ||
							  ((this.trieIndex = 0),
							  (this.trieCurrent = this.entityTrie[0]),
							  (this.state = nt.InNamedEntity),
							  this.stateInNamedEntity(ft));
				}),
				(ct.prototype.stateInNamedEntity = function (ft) {
					if (
						((this.entityExcess += 1),
						(this.trieIndex = (0, et.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, ft)),
						this.trieIndex < 0)
					) {
						this.emitNamedEntity(), this.index--;
						return;
					}
					this.trieCurrent = this.entityTrie[this.trieIndex];
					var mt = this.trieCurrent & et.BinTrieFlags.VALUE_LENGTH;
					if (mt) {
						var pt = (mt >> 14) - 1;
						if (!this.allowLegacyEntity() && ft !== tt.Semi) this.trieIndex += pt;
						else {
							var vt = this.index - this.entityExcess + 1;
							vt > this.sectionStart && this.emitPartial(this.sectionStart, vt),
								(this.entityResult = this.trieIndex),
								(this.trieIndex += pt),
								(this.entityExcess = 0),
								(this.sectionStart = this.index + 1),
								pt === 0 && this.emitNamedEntity();
						}
					}
				}),
				(ct.prototype.emitNamedEntity = function () {
					if (((this.state = this.baseState), this.entityResult !== 0)) {
						var ft = (this.entityTrie[this.entityResult] & et.BinTrieFlags.VALUE_LENGTH) >> 14;
						switch (ft) {
							case 1:
								this.emitCodePoint(this.entityTrie[this.entityResult] & ~et.BinTrieFlags.VALUE_LENGTH);
								break;
							case 2:
								this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
								break;
							case 3:
								this.emitCodePoint(this.entityTrie[this.entityResult + 1]),
									this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
						}
					}
				}),
				(ct.prototype.stateBeforeNumericEntity = function (ft) {
					(ft | 32) === tt.LowerX
						? (this.entityExcess++, (this.state = nt.InHexEntity))
						: ((this.state = nt.InNumericEntity), this.stateInNumericEntity(ft));
				}),
				(ct.prototype.emitNumericEntity = function (ft) {
					var mt = this.index - this.entityExcess - 1,
						pt = mt + 2 + Number(this.state === nt.InHexEntity);
					pt !== this.index &&
						(mt > this.sectionStart && this.emitPartial(this.sectionStart, mt),
						(this.sectionStart = this.index + Number(ft)),
						this.emitCodePoint((0, et.replaceCodePoint)(this.entityResult))),
						(this.state = this.baseState);
				}),
				(ct.prototype.stateInNumericEntity = function (ft) {
					ft === tt.Semi
						? this.emitNumericEntity(!0)
						: ot(ft)
						? ((this.entityResult = this.entityResult * 10 + (ft - tt.Zero)), this.entityExcess++)
						: (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : (this.state = this.baseState), this.index--);
				}),
				(ct.prototype.stateInHexEntity = function (ft) {
					ft === tt.Semi
						? this.emitNumericEntity(!0)
						: ot(ft)
						? ((this.entityResult = this.entityResult * 16 + (ft - tt.Zero)), this.entityExcess++)
						: st(ft)
						? ((this.entityResult = this.entityResult * 16 + ((ft | 32) - tt.LowerA + 10)), this.entityExcess++)
						: (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : (this.state = this.baseState), this.index--);
				}),
				(ct.prototype.allowLegacyEntity = function () {
					return !this.xmlMode && (this.baseState === nt.Text || this.baseState === nt.InSpecialTag);
				}),
				(ct.prototype.cleanup = function () {
					this.running &&
						this.sectionStart !== this.index &&
						(this.state === nt.Text || (this.state === nt.InSpecialTag && this.sequenceIndex === 0)
							? (this.cbs.ontext(this.sectionStart, this.index), (this.sectionStart = this.index))
							: (this.state === nt.InAttributeValueDq ||
									this.state === nt.InAttributeValueSq ||
									this.state === nt.InAttributeValueNq) &&
							  (this.cbs.onattribdata(this.sectionStart, this.index), (this.sectionStart = this.index)));
				}),
				(ct.prototype.shouldContinue = function () {
					return this.index < this.buffer.length + this.offset && this.running;
				}),
				(ct.prototype.parse = function () {
					for (; this.shouldContinue(); ) {
						var ft = this.buffer.charCodeAt(this.index - this.offset);
						this.state === nt.Text
							? this.stateText(ft)
							: this.state === nt.SpecialStartSequence
							? this.stateSpecialStartSequence(ft)
							: this.state === nt.InSpecialTag
							? this.stateInSpecialTag(ft)
							: this.state === nt.CDATASequence
							? this.stateCDATASequence(ft)
							: this.state === nt.InAttributeValueDq
							? this.stateInAttributeValueDoubleQuotes(ft)
							: this.state === nt.InAttributeName
							? this.stateInAttributeName(ft)
							: this.state === nt.InCommentLike
							? this.stateInCommentLike(ft)
							: this.state === nt.InSpecialComment
							? this.stateInSpecialComment(ft)
							: this.state === nt.BeforeAttributeName
							? this.stateBeforeAttributeName(ft)
							: this.state === nt.InTagName
							? this.stateInTagName(ft)
							: this.state === nt.InClosingTagName
							? this.stateInClosingTagName(ft)
							: this.state === nt.BeforeTagName
							? this.stateBeforeTagName(ft)
							: this.state === nt.AfterAttributeName
							? this.stateAfterAttributeName(ft)
							: this.state === nt.InAttributeValueSq
							? this.stateInAttributeValueSingleQuotes(ft)
							: this.state === nt.BeforeAttributeValue
							? this.stateBeforeAttributeValue(ft)
							: this.state === nt.BeforeClosingTagName
							? this.stateBeforeClosingTagName(ft)
							: this.state === nt.AfterClosingTagName
							? this.stateAfterClosingTagName(ft)
							: this.state === nt.BeforeSpecialS
							? this.stateBeforeSpecialS(ft)
							: this.state === nt.InAttributeValueNq
							? this.stateInAttributeValueNoQuotes(ft)
							: this.state === nt.InSelfClosingTag
							? this.stateInSelfClosingTag(ft)
							: this.state === nt.InDeclaration
							? this.stateInDeclaration(ft)
							: this.state === nt.BeforeDeclaration
							? this.stateBeforeDeclaration(ft)
							: this.state === nt.BeforeComment
							? this.stateBeforeComment(ft)
							: this.state === nt.InProcessingInstruction
							? this.stateInProcessingInstruction(ft)
							: this.state === nt.InNamedEntity
							? this.stateInNamedEntity(ft)
							: this.state === nt.BeforeEntity
							? this.stateBeforeEntity(ft)
							: this.state === nt.InHexEntity
							? this.stateInHexEntity(ft)
							: this.state === nt.InNumericEntity
							? this.stateInNumericEntity(ft)
							: this.stateBeforeNumericEntity(ft),
							this.index++;
					}
					this.cleanup();
				}),
				(ct.prototype.finish = function () {
					this.state === nt.InNamedEntity && this.emitNamedEntity(),
						this.sectionStart < this.index && this.handleTrailingData(),
						this.cbs.onend();
				}),
				(ct.prototype.handleTrailingData = function () {
					var ft = this.buffer.length + this.offset;
					this.state === nt.InCommentLike
						? this.currentSequence === ut.CdataEnd
							? this.cbs.oncdata(this.sectionStart, ft, 0)
							: this.cbs.oncomment(this.sectionStart, ft, 0)
						: this.state === nt.InNumericEntity && this.allowLegacyEntity()
						? this.emitNumericEntity(!1)
						: this.state === nt.InHexEntity && this.allowLegacyEntity()
						? this.emitNumericEntity(!1)
						: this.state === nt.InTagName ||
						  this.state === nt.BeforeAttributeName ||
						  this.state === nt.BeforeAttributeValue ||
						  this.state === nt.AfterAttributeName ||
						  this.state === nt.InAttributeName ||
						  this.state === nt.InAttributeValueSq ||
						  this.state === nt.InAttributeValueDq ||
						  this.state === nt.InAttributeValueNq ||
						  this.state === nt.InClosingTagName ||
						  this.cbs.ontext(this.sectionStart, ft);
				}),
				(ct.prototype.emitPartial = function (ft, mt) {
					this.baseState !== nt.Text && this.baseState !== nt.InSpecialTag
						? this.cbs.onattribdata(ft, mt)
						: this.cbs.ontext(ft, mt);
				}),
				(ct.prototype.emitCodePoint = function (ft) {
					this.baseState !== nt.Text && this.baseState !== nt.InSpecialTag
						? this.cbs.onattribentity(ft)
						: this.cbs.ontextentity(ft);
				}),
				ct
			);
		})();
	_.default = dt;
})(Tokenizer);
var __createBinding$1 =
		(commonjsGlobal && commonjsGlobal.__createBinding) ||
		(Object.create
			? function (_, et, tt, nt) {
					nt === void 0 && (nt = tt);
					var rt = Object.getOwnPropertyDescriptor(et, tt);
					(!rt || ("get" in rt ? !et.__esModule : rt.writable || rt.configurable)) &&
						(rt = {
							enumerable: !0,
							get: function () {
								return et[tt];
							},
						}),
						Object.defineProperty(_, nt, rt);
			  }
			: function (_, et, tt, nt) {
					nt === void 0 && (nt = tt), (_[nt] = et[tt]);
			  }),
	__setModuleDefault$1 =
		(commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
		(Object.create
			? function (_, et) {
					Object.defineProperty(_, "default", { enumerable: !0, value: et });
			  }
			: function (_, et) {
					_.default = et;
			  }),
	__importStar$1 =
		(commonjsGlobal && commonjsGlobal.__importStar) ||
		function (_) {
			if (_ && _.__esModule) return _;
			var et = {};
			if (_ != null)
				for (var tt in _)
					tt !== "default" && Object.prototype.hasOwnProperty.call(_, tt) && __createBinding$1(et, _, tt);
			return __setModuleDefault$1(et, _), et;
		};
Object.defineProperty(Parser$1, "__esModule", { value: !0 });
Parser$1.Parser = void 0;
var Tokenizer_js_1 = __importStar$1(Tokenizer),
	decode_js_1 = decode$1,
	formTags = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]),
	pTag = new Set(["p"]),
	tableSectionTags = new Set(["thead", "tbody"]),
	ddtTags = new Set(["dd", "dt"]),
	rtpTags = new Set(["rt", "rp"]),
	openImpliesClose = new Map([
		["tr", new Set(["tr", "th", "td"])],
		["th", new Set(["th"])],
		["td", new Set(["thead", "th", "td"])],
		["body", new Set(["head", "link", "script"])],
		["li", new Set(["li"])],
		["p", pTag],
		["h1", pTag],
		["h2", pTag],
		["h3", pTag],
		["h4", pTag],
		["h5", pTag],
		["h6", pTag],
		["select", formTags],
		["input", formTags],
		["output", formTags],
		["button", formTags],
		["datalist", formTags],
		["textarea", formTags],
		["option", new Set(["option"])],
		["optgroup", new Set(["optgroup", "option"])],
		["dd", ddtTags],
		["dt", ddtTags],
		["address", pTag],
		["article", pTag],
		["aside", pTag],
		["blockquote", pTag],
		["details", pTag],
		["div", pTag],
		["dl", pTag],
		["fieldset", pTag],
		["figcaption", pTag],
		["figure", pTag],
		["footer", pTag],
		["form", pTag],
		["header", pTag],
		["hr", pTag],
		["main", pTag],
		["nav", pTag],
		["ol", pTag],
		["pre", pTag],
		["section", pTag],
		["table", pTag],
		["ul", pTag],
		["rt", rtpTags],
		["rp", rtpTags],
		["tbody", tableSectionTags],
		["tfoot", tableSectionTags],
	]),
	voidElements = new Set([
		"area",
		"base",
		"basefont",
		"br",
		"col",
		"command",
		"embed",
		"frame",
		"hr",
		"img",
		"input",
		"isindex",
		"keygen",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
	]),
	foreignContextElements = new Set(["math", "svg"]),
	htmlIntegrationElements = new Set([
		"mi",
		"mo",
		"mn",
		"ms",
		"mtext",
		"annotation-xml",
		"foreignobject",
		"desc",
		"title",
	]),
	reNameEnd = /\s|\//,
	Parser = (function () {
		function _(et, tt) {
			tt === void 0 && (tt = {});
			var nt, rt, it, ot, at;
			(this.options = tt),
				(this.startIndex = 0),
				(this.endIndex = 0),
				(this.openTagStart = 0),
				(this.tagname = ""),
				(this.attribname = ""),
				(this.attribvalue = ""),
				(this.attribs = null),
				(this.stack = []),
				(this.foreignContext = []),
				(this.buffers = []),
				(this.bufferOffset = 0),
				(this.writeIndex = 0),
				(this.ended = !1),
				(this.cbs = et != null ? et : {}),
				(this.lowerCaseTagNames = (nt = tt.lowerCaseTags) !== null && nt !== void 0 ? nt : !tt.xmlMode),
				(this.lowerCaseAttributeNames = (rt = tt.lowerCaseAttributeNames) !== null && rt !== void 0 ? rt : !tt.xmlMode),
				(this.tokenizer = new ((it = tt.Tokenizer) !== null && it !== void 0 ? it : Tokenizer_js_1.default)(
					this.options,
					this
				)),
				(at = (ot = this.cbs).onparserinit) === null || at === void 0 || at.call(ot, this);
		}
		return (
			(_.prototype.ontext = function (et, tt) {
				var nt,
					rt,
					it = this.getSlice(et, tt);
				(this.endIndex = tt - 1),
					(rt = (nt = this.cbs).ontext) === null || rt === void 0 || rt.call(nt, it),
					(this.startIndex = tt);
			}),
			(_.prototype.ontextentity = function (et) {
				var tt,
					nt,
					rt = this.tokenizer.getSectionStart();
				(this.endIndex = rt - 1),
					(nt = (tt = this.cbs).ontext) === null || nt === void 0 || nt.call(tt, (0, decode_js_1.fromCodePoint)(et)),
					(this.startIndex = rt);
			}),
			(_.prototype.isVoidElement = function (et) {
				return !this.options.xmlMode && voidElements.has(et);
			}),
			(_.prototype.onopentagname = function (et, tt) {
				this.endIndex = tt;
				var nt = this.getSlice(et, tt);
				this.lowerCaseTagNames && (nt = nt.toLowerCase()), this.emitOpenTag(nt);
			}),
			(_.prototype.emitOpenTag = function (et) {
				var tt, nt, rt, it;
				(this.openTagStart = this.startIndex), (this.tagname = et);
				var ot = !this.options.xmlMode && openImpliesClose.get(et);
				if (ot)
					for (; this.stack.length > 0 && ot.has(this.stack[this.stack.length - 1]); ) {
						var at = this.stack.pop();
						(nt = (tt = this.cbs).onclosetag) === null || nt === void 0 || nt.call(tt, at, !0);
					}
				this.isVoidElement(et) ||
					(this.stack.push(et),
					foreignContextElements.has(et)
						? this.foreignContext.push(!0)
						: htmlIntegrationElements.has(et) && this.foreignContext.push(!1)),
					(it = (rt = this.cbs).onopentagname) === null || it === void 0 || it.call(rt, et),
					this.cbs.onopentag && (this.attribs = {});
			}),
			(_.prototype.endOpenTag = function (et) {
				var tt, nt;
				(this.startIndex = this.openTagStart),
					this.attribs &&
						((nt = (tt = this.cbs).onopentag) === null || nt === void 0 || nt.call(tt, this.tagname, this.attribs, et),
						(this.attribs = null)),
					this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0),
					(this.tagname = "");
			}),
			(_.prototype.onopentagend = function (et) {
				(this.endIndex = et), this.endOpenTag(!1), (this.startIndex = et + 1);
			}),
			(_.prototype.onclosetag = function (et, tt) {
				var nt, rt, it, ot, at, st;
				this.endIndex = tt;
				var lt = this.getSlice(et, tt);
				if (
					(this.lowerCaseTagNames && (lt = lt.toLowerCase()),
					(foreignContextElements.has(lt) || htmlIntegrationElements.has(lt)) && this.foreignContext.pop(),
					this.isVoidElement(lt))
				)
					!this.options.xmlMode &&
						lt === "br" &&
						((rt = (nt = this.cbs).onopentagname) === null || rt === void 0 || rt.call(nt, "br"),
						(ot = (it = this.cbs).onopentag) === null || ot === void 0 || ot.call(it, "br", {}, !0),
						(st = (at = this.cbs).onclosetag) === null || st === void 0 || st.call(at, "br", !1));
				else {
					var ut = this.stack.lastIndexOf(lt);
					if (ut !== -1)
						if (this.cbs.onclosetag)
							for (var dt = this.stack.length - ut; dt--; ) this.cbs.onclosetag(this.stack.pop(), dt !== 0);
						else this.stack.length = ut;
					else !this.options.xmlMode && lt === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
				}
				this.startIndex = tt + 1;
			}),
			(_.prototype.onselfclosingtag = function (et) {
				(this.endIndex = et),
					this.options.xmlMode ||
					this.options.recognizeSelfClosing ||
					this.foreignContext[this.foreignContext.length - 1]
						? (this.closeCurrentTag(!1), (this.startIndex = et + 1))
						: this.onopentagend(et);
			}),
			(_.prototype.closeCurrentTag = function (et) {
				var tt,
					nt,
					rt = this.tagname;
				this.endOpenTag(et),
					this.stack[this.stack.length - 1] === rt &&
						((nt = (tt = this.cbs).onclosetag) === null || nt === void 0 || nt.call(tt, rt, !et), this.stack.pop());
			}),
			(_.prototype.onattribname = function (et, tt) {
				this.startIndex = et;
				var nt = this.getSlice(et, tt);
				this.attribname = this.lowerCaseAttributeNames ? nt.toLowerCase() : nt;
			}),
			(_.prototype.onattribdata = function (et, tt) {
				this.attribvalue += this.getSlice(et, tt);
			}),
			(_.prototype.onattribentity = function (et) {
				this.attribvalue += (0, decode_js_1.fromCodePoint)(et);
			}),
			(_.prototype.onattribend = function (et, tt) {
				var nt, rt;
				(this.endIndex = tt),
					(rt = (nt = this.cbs).onattribute) === null ||
						rt === void 0 ||
						rt.call(
							nt,
							this.attribname,
							this.attribvalue,
							et === Tokenizer_js_1.QuoteType.Double
								? '"'
								: et === Tokenizer_js_1.QuoteType.Single
								? "'"
								: et === Tokenizer_js_1.QuoteType.NoValue
								? void 0
								: null
						),
					this.attribs &&
						!Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) &&
						(this.attribs[this.attribname] = this.attribvalue),
					(this.attribvalue = "");
			}),
			(_.prototype.getInstructionName = function (et) {
				var tt = et.search(reNameEnd),
					nt = tt < 0 ? et : et.substr(0, tt);
				return this.lowerCaseTagNames && (nt = nt.toLowerCase()), nt;
			}),
			(_.prototype.ondeclaration = function (et, tt) {
				this.endIndex = tt;
				var nt = this.getSlice(et, tt);
				if (this.cbs.onprocessinginstruction) {
					var rt = this.getInstructionName(nt);
					this.cbs.onprocessinginstruction("!".concat(rt), "!".concat(nt));
				}
				this.startIndex = tt + 1;
			}),
			(_.prototype.onprocessinginstruction = function (et, tt) {
				this.endIndex = tt;
				var nt = this.getSlice(et, tt);
				if (this.cbs.onprocessinginstruction) {
					var rt = this.getInstructionName(nt);
					this.cbs.onprocessinginstruction("?".concat(rt), "?".concat(nt));
				}
				this.startIndex = tt + 1;
			}),
			(_.prototype.oncomment = function (et, tt, nt) {
				var rt, it, ot, at;
				(this.endIndex = tt),
					(it = (rt = this.cbs).oncomment) === null || it === void 0 || it.call(rt, this.getSlice(et, tt - nt)),
					(at = (ot = this.cbs).oncommentend) === null || at === void 0 || at.call(ot),
					(this.startIndex = tt + 1);
			}),
			(_.prototype.oncdata = function (et, tt, nt) {
				var rt, it, ot, at, st, lt, ut, dt, ct, ft;
				this.endIndex = tt;
				var mt = this.getSlice(et, tt - nt);
				this.options.xmlMode || this.options.recognizeCDATA
					? ((it = (rt = this.cbs).oncdatastart) === null || it === void 0 || it.call(rt),
					  (at = (ot = this.cbs).ontext) === null || at === void 0 || at.call(ot, mt),
					  (lt = (st = this.cbs).oncdataend) === null || lt === void 0 || lt.call(st))
					: ((dt = (ut = this.cbs).oncomment) === null || dt === void 0 || dt.call(ut, "[CDATA[".concat(mt, "]]")),
					  (ft = (ct = this.cbs).oncommentend) === null || ft === void 0 || ft.call(ct)),
					(this.startIndex = tt + 1);
			}),
			(_.prototype.onend = function () {
				var et, tt;
				if (this.cbs.onclosetag) {
					this.endIndex = this.startIndex;
					for (var nt = this.stack.length; nt > 0; this.cbs.onclosetag(this.stack[--nt], !0));
				}
				(tt = (et = this.cbs).onend) === null || tt === void 0 || tt.call(et);
			}),
			(_.prototype.reset = function () {
				var et, tt, nt, rt;
				(tt = (et = this.cbs).onreset) === null || tt === void 0 || tt.call(et),
					this.tokenizer.reset(),
					(this.tagname = ""),
					(this.attribname = ""),
					(this.attribs = null),
					(this.stack.length = 0),
					(this.startIndex = 0),
					(this.endIndex = 0),
					(rt = (nt = this.cbs).onparserinit) === null || rt === void 0 || rt.call(nt, this),
					(this.buffers.length = 0),
					(this.bufferOffset = 0),
					(this.writeIndex = 0),
					(this.ended = !1);
			}),
			(_.prototype.parseComplete = function (et) {
				this.reset(), this.end(et);
			}),
			(_.prototype.getSlice = function (et, tt) {
				for (; et - this.bufferOffset >= this.buffers[0].length; ) this.shiftBuffer();
				for (
					var nt = this.buffers[0].slice(et - this.bufferOffset, tt - this.bufferOffset);
					tt - this.bufferOffset > this.buffers[0].length;

				)
					this.shiftBuffer(), (nt += this.buffers[0].slice(0, tt - this.bufferOffset));
				return nt;
			}),
			(_.prototype.shiftBuffer = function () {
				(this.bufferOffset += this.buffers[0].length), this.writeIndex--, this.buffers.shift();
			}),
			(_.prototype.write = function (et) {
				var tt, nt;
				if (this.ended) {
					(nt = (tt = this.cbs).onerror) === null || nt === void 0 || nt.call(tt, new Error(".write() after done!"));
					return;
				}
				this.buffers.push(et), this.tokenizer.running && (this.tokenizer.write(et), this.writeIndex++);
			}),
			(_.prototype.end = function (et) {
				var tt, nt;
				if (this.ended) {
					(nt = (tt = this.cbs).onerror) === null || nt === void 0 || nt.call(tt, Error(".end() after done!"));
					return;
				}
				et && this.write(et), (this.ended = !0), this.tokenizer.end();
			}),
			(_.prototype.pause = function () {
				this.tokenizer.pause();
			}),
			(_.prototype.resume = function () {
				for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
					this.tokenizer.write(this.buffers[this.writeIndex++]);
				this.ended && this.tokenizer.end();
			}),
			(_.prototype.parseChunk = function (et) {
				this.write(et);
			}),
			(_.prototype.done = function (et) {
				this.end(et);
			}),
			_
		);
	})();
Parser$1.Parser = Parser;
var lib$4 = {},
	lib$3 = {};
(function (_) {
	Object.defineProperty(_, "__esModule", { value: !0 }),
		(_.Doctype =
			_.CDATA =
			_.Tag =
			_.Style =
			_.Script =
			_.Comment =
			_.Directive =
			_.Text =
			_.Root =
			_.isTag =
			_.ElementType =
				void 0);
	var et;
	(function (nt) {
		(nt.Root = "root"),
			(nt.Text = "text"),
			(nt.Directive = "directive"),
			(nt.Comment = "comment"),
			(nt.Script = "script"),
			(nt.Style = "style"),
			(nt.Tag = "tag"),
			(nt.CDATA = "cdata"),
			(nt.Doctype = "doctype");
	})((et = _.ElementType || (_.ElementType = {})));
	function tt(nt) {
		return nt.type === et.Tag || nt.type === et.Script || nt.type === et.Style;
	}
	(_.isTag = tt),
		(_.Root = et.Root),
		(_.Text = et.Text),
		(_.Directive = et.Directive),
		(_.Comment = et.Comment),
		(_.Script = et.Script),
		(_.Style = et.Style),
		(_.Tag = et.Tag),
		(_.CDATA = et.CDATA),
		(_.Doctype = et.Doctype);
})(lib$3);
var node = {},
	__extends =
		(commonjsGlobal && commonjsGlobal.__extends) ||
		(function () {
			var _ = function (et, tt) {
				return (
					(_ =
						Object.setPrototypeOf ||
						({ __proto__: [] } instanceof Array &&
							function (nt, rt) {
								nt.__proto__ = rt;
							}) ||
						function (nt, rt) {
							for (var it in rt) Object.prototype.hasOwnProperty.call(rt, it) && (nt[it] = rt[it]);
						}),
					_(et, tt)
				);
			};
			return function (et, tt) {
				if (typeof tt != "function" && tt !== null)
					throw new TypeError("Class extends value " + String(tt) + " is not a constructor or null");
				_(et, tt);
				function nt() {
					this.constructor = et;
				}
				et.prototype = tt === null ? Object.create(tt) : ((nt.prototype = tt.prototype), new nt());
			};
		})(),
	__assign$1 =
		(commonjsGlobal && commonjsGlobal.__assign) ||
		function () {
			return (
				(__assign$1 =
					Object.assign ||
					function (_) {
						for (var et, tt = 1, nt = arguments.length; tt < nt; tt++) {
							et = arguments[tt];
							for (var rt in et) Object.prototype.hasOwnProperty.call(et, rt) && (_[rt] = et[rt]);
						}
						return _;
					}),
				__assign$1.apply(this, arguments)
			);
		};
Object.defineProperty(node, "__esModule", { value: !0 });
node.cloneNode =
	node.hasChildren =
	node.isDocument =
	node.isDirective =
	node.isComment =
	node.isText =
	node.isCDATA =
	node.isTag =
	node.Element =
	node.Document =
	node.CDATA =
	node.NodeWithChildren =
	node.ProcessingInstruction =
	node.Comment =
	node.Text =
	node.DataNode =
	node.Node =
		void 0;
var domelementtype_1$1 = lib$3,
	Node$1 = (function () {
		function _() {
			(this.parent = null), (this.prev = null), (this.next = null), (this.startIndex = null), (this.endIndex = null);
		}
		return (
			Object.defineProperty(_.prototype, "parentNode", {
				get: function () {
					return this.parent;
				},
				set: function (et) {
					this.parent = et;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(_.prototype, "previousSibling", {
				get: function () {
					return this.prev;
				},
				set: function (et) {
					this.prev = et;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(_.prototype, "nextSibling", {
				get: function () {
					return this.next;
				},
				set: function (et) {
					this.next = et;
				},
				enumerable: !1,
				configurable: !0,
			}),
			(_.prototype.cloneNode = function (et) {
				return et === void 0 && (et = !1), cloneNode(this, et);
			}),
			_
		);
	})();
node.Node = Node$1;
var DataNode = (function (_) {
	__extends(et, _);
	function et(tt) {
		var nt = _.call(this) || this;
		return (nt.data = tt), nt;
	}
	return (
		Object.defineProperty(et.prototype, "nodeValue", {
			get: function () {
				return this.data;
			},
			set: function (tt) {
				this.data = tt;
			},
			enumerable: !1,
			configurable: !0,
		}),
		et
	);
})(Node$1);
node.DataNode = DataNode;
var Text$1 = (function (_) {
	__extends(et, _);
	function et() {
		var tt = (_ !== null && _.apply(this, arguments)) || this;
		return (tt.type = domelementtype_1$1.ElementType.Text), tt;
	}
	return (
		Object.defineProperty(et.prototype, "nodeType", {
			get: function () {
				return 3;
			},
			enumerable: !1,
			configurable: !0,
		}),
		et
	);
})(DataNode);
node.Text = Text$1;
var Comment = (function (_) {
	__extends(et, _);
	function et() {
		var tt = (_ !== null && _.apply(this, arguments)) || this;
		return (tt.type = domelementtype_1$1.ElementType.Comment), tt;
	}
	return (
		Object.defineProperty(et.prototype, "nodeType", {
			get: function () {
				return 8;
			},
			enumerable: !1,
			configurable: !0,
		}),
		et
	);
})(DataNode);
node.Comment = Comment;
var ProcessingInstruction = (function (_) {
	__extends(et, _);
	function et(tt, nt) {
		var rt = _.call(this, nt) || this;
		return (rt.name = tt), (rt.type = domelementtype_1$1.ElementType.Directive), rt;
	}
	return (
		Object.defineProperty(et.prototype, "nodeType", {
			get: function () {
				return 1;
			},
			enumerable: !1,
			configurable: !0,
		}),
		et
	);
})(DataNode);
node.ProcessingInstruction = ProcessingInstruction;
var NodeWithChildren = (function (_) {
	__extends(et, _);
	function et(tt) {
		var nt = _.call(this) || this;
		return (nt.children = tt), nt;
	}
	return (
		Object.defineProperty(et.prototype, "firstChild", {
			get: function () {
				var tt;
				return (tt = this.children[0]) !== null && tt !== void 0 ? tt : null;
			},
			enumerable: !1,
			configurable: !0,
		}),
		Object.defineProperty(et.prototype, "lastChild", {
			get: function () {
				return this.children.length > 0 ? this.children[this.children.length - 1] : null;
			},
			enumerable: !1,
			configurable: !0,
		}),
		Object.defineProperty(et.prototype, "childNodes", {
			get: function () {
				return this.children;
			},
			set: function (tt) {
				this.children = tt;
			},
			enumerable: !1,
			configurable: !0,
		}),
		et
	);
})(Node$1);
node.NodeWithChildren = NodeWithChildren;
var CDATA = (function (_) {
	__extends(et, _);
	function et() {
		var tt = (_ !== null && _.apply(this, arguments)) || this;
		return (tt.type = domelementtype_1$1.ElementType.CDATA), tt;
	}
	return (
		Object.defineProperty(et.prototype, "nodeType", {
			get: function () {
				return 4;
			},
			enumerable: !1,
			configurable: !0,
		}),
		et
	);
})(NodeWithChildren);
node.CDATA = CDATA;
var Document = (function (_) {
	__extends(et, _);
	function et() {
		var tt = (_ !== null && _.apply(this, arguments)) || this;
		return (tt.type = domelementtype_1$1.ElementType.Root), tt;
	}
	return (
		Object.defineProperty(et.prototype, "nodeType", {
			get: function () {
				return 9;
			},
			enumerable: !1,
			configurable: !0,
		}),
		et
	);
})(NodeWithChildren);
node.Document = Document;
var Element$1 = (function (_) {
	__extends(et, _);
	function et(tt, nt, rt, it) {
		rt === void 0 && (rt = []),
			it === void 0 &&
				(it =
					tt === "script"
						? domelementtype_1$1.ElementType.Script
						: tt === "style"
						? domelementtype_1$1.ElementType.Style
						: domelementtype_1$1.ElementType.Tag);
		var ot = _.call(this, rt) || this;
		return (ot.name = tt), (ot.attribs = nt), (ot.type = it), ot;
	}
	return (
		Object.defineProperty(et.prototype, "nodeType", {
			get: function () {
				return 1;
			},
			enumerable: !1,
			configurable: !0,
		}),
		Object.defineProperty(et.prototype, "tagName", {
			get: function () {
				return this.name;
			},
			set: function (tt) {
				this.name = tt;
			},
			enumerable: !1,
			configurable: !0,
		}),
		Object.defineProperty(et.prototype, "attributes", {
			get: function () {
				var tt = this;
				return Object.keys(this.attribs).map(function (nt) {
					var rt, it;
					return {
						name: nt,
						value: tt.attribs[nt],
						namespace: (rt = tt["x-attribsNamespace"]) === null || rt === void 0 ? void 0 : rt[nt],
						prefix: (it = tt["x-attribsPrefix"]) === null || it === void 0 ? void 0 : it[nt],
					};
				});
			},
			enumerable: !1,
			configurable: !0,
		}),
		et
	);
})(NodeWithChildren);
node.Element = Element$1;
function isTag(_) {
	return (0, domelementtype_1$1.isTag)(_);
}
node.isTag = isTag;
function isCDATA(_) {
	return _.type === domelementtype_1$1.ElementType.CDATA;
}
node.isCDATA = isCDATA;
function isText(_) {
	return _.type === domelementtype_1$1.ElementType.Text;
}
node.isText = isText;
function isComment(_) {
	return _.type === domelementtype_1$1.ElementType.Comment;
}
node.isComment = isComment;
function isDirective(_) {
	return _.type === domelementtype_1$1.ElementType.Directive;
}
node.isDirective = isDirective;
function isDocument(_) {
	return _.type === domelementtype_1$1.ElementType.Root;
}
node.isDocument = isDocument;
function hasChildren(_) {
	return Object.prototype.hasOwnProperty.call(_, "children");
}
node.hasChildren = hasChildren;
function cloneNode(_, et) {
	et === void 0 && (et = !1);
	var tt;
	if (isText(_)) tt = new Text$1(_.data);
	else if (isComment(_)) tt = new Comment(_.data);
	else if (isTag(_)) {
		var nt = et ? cloneChildren(_.children) : [],
			rt = new Element$1(_.name, __assign$1({}, _.attribs), nt);
		nt.forEach(function (st) {
			return (st.parent = rt);
		}),
			_.namespace != null && (rt.namespace = _.namespace),
			_["x-attribsNamespace"] && (rt["x-attribsNamespace"] = __assign$1({}, _["x-attribsNamespace"])),
			_["x-attribsPrefix"] && (rt["x-attribsPrefix"] = __assign$1({}, _["x-attribsPrefix"])),
			(tt = rt);
	} else if (isCDATA(_)) {
		var nt = et ? cloneChildren(_.children) : [],
			it = new CDATA(nt);
		nt.forEach(function (lt) {
			return (lt.parent = it);
		}),
			(tt = it);
	} else if (isDocument(_)) {
		var nt = et ? cloneChildren(_.children) : [],
			ot = new Document(nt);
		nt.forEach(function (lt) {
			return (lt.parent = ot);
		}),
			_["x-mode"] && (ot["x-mode"] = _["x-mode"]),
			(tt = ot);
	} else if (isDirective(_)) {
		var at = new ProcessingInstruction(_.name, _.data);
		_["x-name"] != null &&
			((at["x-name"] = _["x-name"]), (at["x-publicId"] = _["x-publicId"]), (at["x-systemId"] = _["x-systemId"])),
			(tt = at);
	} else throw new Error("Not implemented yet: ".concat(_.type));
	return (
		(tt.startIndex = _.startIndex),
		(tt.endIndex = _.endIndex),
		_.sourceCodeLocation != null && (tt.sourceCodeLocation = _.sourceCodeLocation),
		tt
	);
}
node.cloneNode = cloneNode;
function cloneChildren(_) {
	for (
		var et = _.map(function (nt) {
				return cloneNode(nt, !0);
			}),
			tt = 1;
		tt < et.length;
		tt++
	)
		(et[tt].prev = et[tt - 1]), (et[tt - 1].next = et[tt]);
	return et;
}
(function (_) {
	var et =
			(commonjsGlobal && commonjsGlobal.__createBinding) ||
			(Object.create
				? function (at, st, lt, ut) {
						ut === void 0 && (ut = lt);
						var dt = Object.getOwnPropertyDescriptor(st, lt);
						(!dt || ("get" in dt ? !st.__esModule : dt.writable || dt.configurable)) &&
							(dt = {
								enumerable: !0,
								get: function () {
									return st[lt];
								},
							}),
							Object.defineProperty(at, ut, dt);
				  }
				: function (at, st, lt, ut) {
						ut === void 0 && (ut = lt), (at[ut] = st[lt]);
				  }),
		tt =
			(commonjsGlobal && commonjsGlobal.__exportStar) ||
			function (at, st) {
				for (var lt in at) lt !== "default" && !Object.prototype.hasOwnProperty.call(st, lt) && et(st, at, lt);
			};
	Object.defineProperty(_, "__esModule", { value: !0 }), (_.DomHandler = void 0);
	var nt = lib$3,
		rt = node;
	tt(node, _);
	var it = { withStartIndices: !1, withEndIndices: !1, xmlMode: !1 },
		ot = (function () {
			function at(st, lt, ut) {
				(this.dom = []),
					(this.root = new rt.Document(this.dom)),
					(this.done = !1),
					(this.tagStack = [this.root]),
					(this.lastNode = null),
					(this.parser = null),
					typeof lt == "function" && ((ut = lt), (lt = it)),
					typeof st == "object" && ((lt = st), (st = void 0)),
					(this.callback = st != null ? st : null),
					(this.options = lt != null ? lt : it),
					(this.elementCB = ut != null ? ut : null);
			}
			return (
				(at.prototype.onparserinit = function (st) {
					this.parser = st;
				}),
				(at.prototype.onreset = function () {
					(this.dom = []),
						(this.root = new rt.Document(this.dom)),
						(this.done = !1),
						(this.tagStack = [this.root]),
						(this.lastNode = null),
						(this.parser = null);
				}),
				(at.prototype.onend = function () {
					this.done || ((this.done = !0), (this.parser = null), this.handleCallback(null));
				}),
				(at.prototype.onerror = function (st) {
					this.handleCallback(st);
				}),
				(at.prototype.onclosetag = function () {
					this.lastNode = null;
					var st = this.tagStack.pop();
					this.options.withEndIndices && (st.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(st);
				}),
				(at.prototype.onopentag = function (st, lt) {
					var ut = this.options.xmlMode ? nt.ElementType.Tag : void 0,
						dt = new rt.Element(st, lt, void 0, ut);
					this.addNode(dt), this.tagStack.push(dt);
				}),
				(at.prototype.ontext = function (st) {
					var lt = this.lastNode;
					if (lt && lt.type === nt.ElementType.Text)
						(lt.data += st), this.options.withEndIndices && (lt.endIndex = this.parser.endIndex);
					else {
						var ut = new rt.Text(st);
						this.addNode(ut), (this.lastNode = ut);
					}
				}),
				(at.prototype.oncomment = function (st) {
					if (this.lastNode && this.lastNode.type === nt.ElementType.Comment) {
						this.lastNode.data += st;
						return;
					}
					var lt = new rt.Comment(st);
					this.addNode(lt), (this.lastNode = lt);
				}),
				(at.prototype.oncommentend = function () {
					this.lastNode = null;
				}),
				(at.prototype.oncdatastart = function () {
					var st = new rt.Text(""),
						lt = new rt.CDATA([st]);
					this.addNode(lt), (st.parent = lt), (this.lastNode = st);
				}),
				(at.prototype.oncdataend = function () {
					this.lastNode = null;
				}),
				(at.prototype.onprocessinginstruction = function (st, lt) {
					var ut = new rt.ProcessingInstruction(st, lt);
					this.addNode(ut);
				}),
				(at.prototype.handleCallback = function (st) {
					if (typeof this.callback == "function") this.callback(st, this.dom);
					else if (st) throw st;
				}),
				(at.prototype.addNode = function (st) {
					var lt = this.tagStack[this.tagStack.length - 1],
						ut = lt.children[lt.children.length - 1];
					this.options.withStartIndices && (st.startIndex = this.parser.startIndex),
						this.options.withEndIndices && (st.endIndex = this.parser.endIndex),
						lt.children.push(st),
						ut && ((st.prev = ut), (ut.next = st)),
						(st.parent = lt),
						(this.lastNode = null);
				}),
				at
			);
		})();
	(_.DomHandler = ot), (_.default = ot);
})(lib$4);
var lib$2 = {},
	stringify$2 = {},
	lib$1 = {},
	lib = {},
	encode = {},
	encodeHtml = {};
Object.defineProperty(encodeHtml, "__esModule", { value: !0 });
function restoreDiff(_) {
	for (var et = 1; et < _.length; et++) _[et][0] += _[et - 1][0] + 1;
	return _;
}
encodeHtml.default = new Map(
	restoreDiff([
		[9, "&Tab;"],
		[0, "&NewLine;"],
		[22, "&excl;"],
		[0, "&quot;"],
		[0, "&num;"],
		[0, "&dollar;"],
		[0, "&percnt;"],
		[0, "&amp;"],
		[0, "&apos;"],
		[0, "&lpar;"],
		[0, "&rpar;"],
		[0, "&ast;"],
		[0, "&plus;"],
		[0, "&comma;"],
		[1, "&period;"],
		[0, "&sol;"],
		[10, "&colon;"],
		[0, "&semi;"],
		[0, { v: "&lt;", n: 8402, o: "&nvlt;" }],
		[0, { v: "&equals;", n: 8421, o: "&bne;" }],
		[0, { v: "&gt;", n: 8402, o: "&nvgt;" }],
		[0, "&quest;"],
		[0, "&commat;"],
		[26, "&lbrack;"],
		[0, "&bsol;"],
		[0, "&rbrack;"],
		[0, "&Hat;"],
		[0, "&lowbar;"],
		[0, "&DiacriticalGrave;"],
		[5, { n: 106, o: "&fjlig;" }],
		[20, "&lbrace;"],
		[0, "&verbar;"],
		[0, "&rbrace;"],
		[34, "&nbsp;"],
		[0, "&iexcl;"],
		[0, "&cent;"],
		[0, "&pound;"],
		[0, "&curren;"],
		[0, "&yen;"],
		[0, "&brvbar;"],
		[0, "&sect;"],
		[0, "&die;"],
		[0, "&copy;"],
		[0, "&ordf;"],
		[0, "&laquo;"],
		[0, "&not;"],
		[0, "&shy;"],
		[0, "&circledR;"],
		[0, "&macr;"],
		[0, "&deg;"],
		[0, "&PlusMinus;"],
		[0, "&sup2;"],
		[0, "&sup3;"],
		[0, "&acute;"],
		[0, "&micro;"],
		[0, "&para;"],
		[0, "&centerdot;"],
		[0, "&cedil;"],
		[0, "&sup1;"],
		[0, "&ordm;"],
		[0, "&raquo;"],
		[0, "&frac14;"],
		[0, "&frac12;"],
		[0, "&frac34;"],
		[0, "&iquest;"],
		[0, "&Agrave;"],
		[0, "&Aacute;"],
		[0, "&Acirc;"],
		[0, "&Atilde;"],
		[0, "&Auml;"],
		[0, "&angst;"],
		[0, "&AElig;"],
		[0, "&Ccedil;"],
		[0, "&Egrave;"],
		[0, "&Eacute;"],
		[0, "&Ecirc;"],
		[0, "&Euml;"],
		[0, "&Igrave;"],
		[0, "&Iacute;"],
		[0, "&Icirc;"],
		[0, "&Iuml;"],
		[0, "&ETH;"],
		[0, "&Ntilde;"],
		[0, "&Ograve;"],
		[0, "&Oacute;"],
		[0, "&Ocirc;"],
		[0, "&Otilde;"],
		[0, "&Ouml;"],
		[0, "&times;"],
		[0, "&Oslash;"],
		[0, "&Ugrave;"],
		[0, "&Uacute;"],
		[0, "&Ucirc;"],
		[0, "&Uuml;"],
		[0, "&Yacute;"],
		[0, "&THORN;"],
		[0, "&szlig;"],
		[0, "&agrave;"],
		[0, "&aacute;"],
		[0, "&acirc;"],
		[0, "&atilde;"],
		[0, "&auml;"],
		[0, "&aring;"],
		[0, "&aelig;"],
		[0, "&ccedil;"],
		[0, "&egrave;"],
		[0, "&eacute;"],
		[0, "&ecirc;"],
		[0, "&euml;"],
		[0, "&igrave;"],
		[0, "&iacute;"],
		[0, "&icirc;"],
		[0, "&iuml;"],
		[0, "&eth;"],
		[0, "&ntilde;"],
		[0, "&ograve;"],
		[0, "&oacute;"],
		[0, "&ocirc;"],
		[0, "&otilde;"],
		[0, "&ouml;"],
		[0, "&div;"],
		[0, "&oslash;"],
		[0, "&ugrave;"],
		[0, "&uacute;"],
		[0, "&ucirc;"],
		[0, "&uuml;"],
		[0, "&yacute;"],
		[0, "&thorn;"],
		[0, "&yuml;"],
		[0, "&Amacr;"],
		[0, "&amacr;"],
		[0, "&Abreve;"],
		[0, "&abreve;"],
		[0, "&Aogon;"],
		[0, "&aogon;"],
		[0, "&Cacute;"],
		[0, "&cacute;"],
		[0, "&Ccirc;"],
		[0, "&ccirc;"],
		[0, "&Cdot;"],
		[0, "&cdot;"],
		[0, "&Ccaron;"],
		[0, "&ccaron;"],
		[0, "&Dcaron;"],
		[0, "&dcaron;"],
		[0, "&Dstrok;"],
		[0, "&dstrok;"],
		[0, "&Emacr;"],
		[0, "&emacr;"],
		[2, "&Edot;"],
		[0, "&edot;"],
		[0, "&Eogon;"],
		[0, "&eogon;"],
		[0, "&Ecaron;"],
		[0, "&ecaron;"],
		[0, "&Gcirc;"],
		[0, "&gcirc;"],
		[0, "&Gbreve;"],
		[0, "&gbreve;"],
		[0, "&Gdot;"],
		[0, "&gdot;"],
		[0, "&Gcedil;"],
		[1, "&Hcirc;"],
		[0, "&hcirc;"],
		[0, "&Hstrok;"],
		[0, "&hstrok;"],
		[0, "&Itilde;"],
		[0, "&itilde;"],
		[0, "&Imacr;"],
		[0, "&imacr;"],
		[2, "&Iogon;"],
		[0, "&iogon;"],
		[0, "&Idot;"],
		[0, "&imath;"],
		[0, "&IJlig;"],
		[0, "&ijlig;"],
		[0, "&Jcirc;"],
		[0, "&jcirc;"],
		[0, "&Kcedil;"],
		[0, "&kcedil;"],
		[0, "&kgreen;"],
		[0, "&Lacute;"],
		[0, "&lacute;"],
		[0, "&Lcedil;"],
		[0, "&lcedil;"],
		[0, "&Lcaron;"],
		[0, "&lcaron;"],
		[0, "&Lmidot;"],
		[0, "&lmidot;"],
		[0, "&Lstrok;"],
		[0, "&lstrok;"],
		[0, "&Nacute;"],
		[0, "&nacute;"],
		[0, "&Ncedil;"],
		[0, "&ncedil;"],
		[0, "&Ncaron;"],
		[0, "&ncaron;"],
		[0, "&napos;"],
		[0, "&ENG;"],
		[0, "&eng;"],
		[0, "&Omacr;"],
		[0, "&omacr;"],
		[2, "&Odblac;"],
		[0, "&odblac;"],
		[0, "&OElig;"],
		[0, "&oelig;"],
		[0, "&Racute;"],
		[0, "&racute;"],
		[0, "&Rcedil;"],
		[0, "&rcedil;"],
		[0, "&Rcaron;"],
		[0, "&rcaron;"],
		[0, "&Sacute;"],
		[0, "&sacute;"],
		[0, "&Scirc;"],
		[0, "&scirc;"],
		[0, "&Scedil;"],
		[0, "&scedil;"],
		[0, "&Scaron;"],
		[0, "&scaron;"],
		[0, "&Tcedil;"],
		[0, "&tcedil;"],
		[0, "&Tcaron;"],
		[0, "&tcaron;"],
		[0, "&Tstrok;"],
		[0, "&tstrok;"],
		[0, "&Utilde;"],
		[0, "&utilde;"],
		[0, "&Umacr;"],
		[0, "&umacr;"],
		[0, "&Ubreve;"],
		[0, "&ubreve;"],
		[0, "&Uring;"],
		[0, "&uring;"],
		[0, "&Udblac;"],
		[0, "&udblac;"],
		[0, "&Uogon;"],
		[0, "&uogon;"],
		[0, "&Wcirc;"],
		[0, "&wcirc;"],
		[0, "&Ycirc;"],
		[0, "&ycirc;"],
		[0, "&Yuml;"],
		[0, "&Zacute;"],
		[0, "&zacute;"],
		[0, "&Zdot;"],
		[0, "&zdot;"],
		[0, "&Zcaron;"],
		[0, "&zcaron;"],
		[19, "&fnof;"],
		[34, "&imped;"],
		[63, "&gacute;"],
		[65, "&jmath;"],
		[142, "&circ;"],
		[0, "&caron;"],
		[16, "&breve;"],
		[0, "&DiacriticalDot;"],
		[0, "&ring;"],
		[0, "&ogon;"],
		[0, "&DiacriticalTilde;"],
		[0, "&dblac;"],
		[51, "&DownBreve;"],
		[127, "&Alpha;"],
		[0, "&Beta;"],
		[0, "&Gamma;"],
		[0, "&Delta;"],
		[0, "&Epsilon;"],
		[0, "&Zeta;"],
		[0, "&Eta;"],
		[0, "&Theta;"],
		[0, "&Iota;"],
		[0, "&Kappa;"],
		[0, "&Lambda;"],
		[0, "&Mu;"],
		[0, "&Nu;"],
		[0, "&Xi;"],
		[0, "&Omicron;"],
		[0, "&Pi;"],
		[0, "&Rho;"],
		[1, "&Sigma;"],
		[0, "&Tau;"],
		[0, "&Upsilon;"],
		[0, "&Phi;"],
		[0, "&Chi;"],
		[0, "&Psi;"],
		[0, "&ohm;"],
		[7, "&alpha;"],
		[0, "&beta;"],
		[0, "&gamma;"],
		[0, "&delta;"],
		[0, "&epsi;"],
		[0, "&zeta;"],
		[0, "&eta;"],
		[0, "&theta;"],
		[0, "&iota;"],
		[0, "&kappa;"],
		[0, "&lambda;"],
		[0, "&mu;"],
		[0, "&nu;"],
		[0, "&xi;"],
		[0, "&omicron;"],
		[0, "&pi;"],
		[0, "&rho;"],
		[0, "&sigmaf;"],
		[0, "&sigma;"],
		[0, "&tau;"],
		[0, "&upsi;"],
		[0, "&phi;"],
		[0, "&chi;"],
		[0, "&psi;"],
		[0, "&omega;"],
		[7, "&thetasym;"],
		[0, "&Upsi;"],
		[2, "&phiv;"],
		[0, "&piv;"],
		[5, "&Gammad;"],
		[0, "&digamma;"],
		[18, "&kappav;"],
		[0, "&rhov;"],
		[3, "&epsiv;"],
		[0, "&backepsilon;"],
		[10, "&IOcy;"],
		[0, "&DJcy;"],
		[0, "&GJcy;"],
		[0, "&Jukcy;"],
		[0, "&DScy;"],
		[0, "&Iukcy;"],
		[0, "&YIcy;"],
		[0, "&Jsercy;"],
		[0, "&LJcy;"],
		[0, "&NJcy;"],
		[0, "&TSHcy;"],
		[0, "&KJcy;"],
		[1, "&Ubrcy;"],
		[0, "&DZcy;"],
		[0, "&Acy;"],
		[0, "&Bcy;"],
		[0, "&Vcy;"],
		[0, "&Gcy;"],
		[0, "&Dcy;"],
		[0, "&IEcy;"],
		[0, "&ZHcy;"],
		[0, "&Zcy;"],
		[0, "&Icy;"],
		[0, "&Jcy;"],
		[0, "&Kcy;"],
		[0, "&Lcy;"],
		[0, "&Mcy;"],
		[0, "&Ncy;"],
		[0, "&Ocy;"],
		[0, "&Pcy;"],
		[0, "&Rcy;"],
		[0, "&Scy;"],
		[0, "&Tcy;"],
		[0, "&Ucy;"],
		[0, "&Fcy;"],
		[0, "&KHcy;"],
		[0, "&TScy;"],
		[0, "&CHcy;"],
		[0, "&SHcy;"],
		[0, "&SHCHcy;"],
		[0, "&HARDcy;"],
		[0, "&Ycy;"],
		[0, "&SOFTcy;"],
		[0, "&Ecy;"],
		[0, "&YUcy;"],
		[0, "&YAcy;"],
		[0, "&acy;"],
		[0, "&bcy;"],
		[0, "&vcy;"],
		[0, "&gcy;"],
		[0, "&dcy;"],
		[0, "&iecy;"],
		[0, "&zhcy;"],
		[0, "&zcy;"],
		[0, "&icy;"],
		[0, "&jcy;"],
		[0, "&kcy;"],
		[0, "&lcy;"],
		[0, "&mcy;"],
		[0, "&ncy;"],
		[0, "&ocy;"],
		[0, "&pcy;"],
		[0, "&rcy;"],
		[0, "&scy;"],
		[0, "&tcy;"],
		[0, "&ucy;"],
		[0, "&fcy;"],
		[0, "&khcy;"],
		[0, "&tscy;"],
		[0, "&chcy;"],
		[0, "&shcy;"],
		[0, "&shchcy;"],
		[0, "&hardcy;"],
		[0, "&ycy;"],
		[0, "&softcy;"],
		[0, "&ecy;"],
		[0, "&yucy;"],
		[0, "&yacy;"],
		[1, "&iocy;"],
		[0, "&djcy;"],
		[0, "&gjcy;"],
		[0, "&jukcy;"],
		[0, "&dscy;"],
		[0, "&iukcy;"],
		[0, "&yicy;"],
		[0, "&jsercy;"],
		[0, "&ljcy;"],
		[0, "&njcy;"],
		[0, "&tshcy;"],
		[0, "&kjcy;"],
		[1, "&ubrcy;"],
		[0, "&dzcy;"],
		[7074, "&ensp;"],
		[0, "&emsp;"],
		[0, "&emsp13;"],
		[0, "&emsp14;"],
		[1, "&numsp;"],
		[0, "&puncsp;"],
		[0, "&ThinSpace;"],
		[0, "&hairsp;"],
		[0, "&NegativeMediumSpace;"],
		[0, "&zwnj;"],
		[0, "&zwj;"],
		[0, "&lrm;"],
		[0, "&rlm;"],
		[0, "&dash;"],
		[2, "&ndash;"],
		[0, "&mdash;"],
		[0, "&horbar;"],
		[0, "&Verbar;"],
		[1, "&lsquo;"],
		[0, "&CloseCurlyQuote;"],
		[0, "&lsquor;"],
		[1, "&ldquo;"],
		[0, "&CloseCurlyDoubleQuote;"],
		[0, "&bdquo;"],
		[1, "&dagger;"],
		[0, "&Dagger;"],
		[0, "&bull;"],
		[2, "&nldr;"],
		[0, "&hellip;"],
		[9, "&permil;"],
		[0, "&pertenk;"],
		[0, "&prime;"],
		[0, "&Prime;"],
		[0, "&tprime;"],
		[0, "&backprime;"],
		[3, "&lsaquo;"],
		[0, "&rsaquo;"],
		[3, "&oline;"],
		[2, "&caret;"],
		[1, "&hybull;"],
		[0, "&frasl;"],
		[10, "&bsemi;"],
		[7, "&qprime;"],
		[7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }],
		[0, "&NoBreak;"],
		[0, "&af;"],
		[0, "&InvisibleTimes;"],
		[0, "&ic;"],
		[72, "&euro;"],
		[46, "&tdot;"],
		[0, "&DotDot;"],
		[37, "&complexes;"],
		[2, "&incare;"],
		[4, "&gscr;"],
		[0, "&hamilt;"],
		[0, "&Hfr;"],
		[0, "&Hopf;"],
		[0, "&planckh;"],
		[0, "&hbar;"],
		[0, "&imagline;"],
		[0, "&Ifr;"],
		[0, "&lagran;"],
		[0, "&ell;"],
		[1, "&naturals;"],
		[0, "&numero;"],
		[0, "&copysr;"],
		[0, "&weierp;"],
		[0, "&Popf;"],
		[0, "&Qopf;"],
		[0, "&realine;"],
		[0, "&real;"],
		[0, "&reals;"],
		[0, "&rx;"],
		[3, "&trade;"],
		[1, "&integers;"],
		[2, "&mho;"],
		[0, "&zeetrf;"],
		[0, "&iiota;"],
		[2, "&bernou;"],
		[0, "&Cayleys;"],
		[1, "&escr;"],
		[0, "&Escr;"],
		[0, "&Fouriertrf;"],
		[1, "&Mellintrf;"],
		[0, "&order;"],
		[0, "&alefsym;"],
		[0, "&beth;"],
		[0, "&gimel;"],
		[0, "&daleth;"],
		[12, "&CapitalDifferentialD;"],
		[0, "&dd;"],
		[0, "&ee;"],
		[0, "&ii;"],
		[10, "&frac13;"],
		[0, "&frac23;"],
		[0, "&frac15;"],
		[0, "&frac25;"],
		[0, "&frac35;"],
		[0, "&frac45;"],
		[0, "&frac16;"],
		[0, "&frac56;"],
		[0, "&frac18;"],
		[0, "&frac38;"],
		[0, "&frac58;"],
		[0, "&frac78;"],
		[49, "&larr;"],
		[0, "&ShortUpArrow;"],
		[0, "&rarr;"],
		[0, "&darr;"],
		[0, "&harr;"],
		[0, "&updownarrow;"],
		[0, "&nwarr;"],
		[0, "&nearr;"],
		[0, "&LowerRightArrow;"],
		[0, "&LowerLeftArrow;"],
		[0, "&nlarr;"],
		[0, "&nrarr;"],
		[1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }],
		[0, "&Larr;"],
		[0, "&Uarr;"],
		[0, "&Rarr;"],
		[0, "&Darr;"],
		[0, "&larrtl;"],
		[0, "&rarrtl;"],
		[0, "&LeftTeeArrow;"],
		[0, "&mapstoup;"],
		[0, "&map;"],
		[0, "&DownTeeArrow;"],
		[1, "&hookleftarrow;"],
		[0, "&hookrightarrow;"],
		[0, "&larrlp;"],
		[0, "&looparrowright;"],
		[0, "&harrw;"],
		[0, "&nharr;"],
		[1, "&lsh;"],
		[0, "&rsh;"],
		[0, "&ldsh;"],
		[0, "&rdsh;"],
		[1, "&crarr;"],
		[0, "&cularr;"],
		[0, "&curarr;"],
		[2, "&circlearrowleft;"],
		[0, "&circlearrowright;"],
		[0, "&leftharpoonup;"],
		[0, "&DownLeftVector;"],
		[0, "&RightUpVector;"],
		[0, "&LeftUpVector;"],
		[0, "&rharu;"],
		[0, "&DownRightVector;"],
		[0, "&dharr;"],
		[0, "&dharl;"],
		[0, "&RightArrowLeftArrow;"],
		[0, "&udarr;"],
		[0, "&LeftArrowRightArrow;"],
		[0, "&leftleftarrows;"],
		[0, "&upuparrows;"],
		[0, "&rightrightarrows;"],
		[0, "&ddarr;"],
		[0, "&leftrightharpoons;"],
		[0, "&Equilibrium;"],
		[0, "&nlArr;"],
		[0, "&nhArr;"],
		[0, "&nrArr;"],
		[0, "&DoubleLeftArrow;"],
		[0, "&DoubleUpArrow;"],
		[0, "&DoubleRightArrow;"],
		[0, "&dArr;"],
		[0, "&DoubleLeftRightArrow;"],
		[0, "&DoubleUpDownArrow;"],
		[0, "&nwArr;"],
		[0, "&neArr;"],
		[0, "&seArr;"],
		[0, "&swArr;"],
		[0, "&lAarr;"],
		[0, "&rAarr;"],
		[1, "&zigrarr;"],
		[6, "&larrb;"],
		[0, "&rarrb;"],
		[15, "&DownArrowUpArrow;"],
		[7, "&loarr;"],
		[0, "&roarr;"],
		[0, "&hoarr;"],
		[0, "&forall;"],
		[0, "&comp;"],
		[0, { v: "&part;", n: 824, o: "&npart;" }],
		[0, "&exist;"],
		[0, "&nexist;"],
		[0, "&empty;"],
		[1, "&Del;"],
		[0, "&Element;"],
		[0, "&NotElement;"],
		[1, "&ni;"],
		[0, "&notni;"],
		[2, "&prod;"],
		[0, "&coprod;"],
		[0, "&sum;"],
		[0, "&minus;"],
		[0, "&MinusPlus;"],
		[0, "&dotplus;"],
		[1, "&Backslash;"],
		[0, "&lowast;"],
		[0, "&compfn;"],
		[1, "&radic;"],
		[2, "&prop;"],
		[0, "&infin;"],
		[0, "&angrt;"],
		[0, { v: "&ang;", n: 8402, o: "&nang;" }],
		[0, "&angmsd;"],
		[0, "&angsph;"],
		[0, "&mid;"],
		[0, "&nmid;"],
		[0, "&DoubleVerticalBar;"],
		[0, "&NotDoubleVerticalBar;"],
		[0, "&and;"],
		[0, "&or;"],
		[0, { v: "&cap;", n: 65024, o: "&caps;" }],
		[0, { v: "&cup;", n: 65024, o: "&cups;" }],
		[0, "&int;"],
		[0, "&Int;"],
		[0, "&iiint;"],
		[0, "&conint;"],
		[0, "&Conint;"],
		[0, "&Cconint;"],
		[0, "&cwint;"],
		[0, "&ClockwiseContourIntegral;"],
		[0, "&awconint;"],
		[0, "&there4;"],
		[0, "&becaus;"],
		[0, "&ratio;"],
		[0, "&Colon;"],
		[0, "&dotminus;"],
		[1, "&mDDot;"],
		[0, "&homtht;"],
		[0, { v: "&sim;", n: 8402, o: "&nvsim;" }],
		[0, { v: "&backsim;", n: 817, o: "&race;" }],
		[0, { v: "&ac;", n: 819, o: "&acE;" }],
		[0, "&acd;"],
		[0, "&VerticalTilde;"],
		[0, "&NotTilde;"],
		[0, { v: "&eqsim;", n: 824, o: "&nesim;" }],
		[0, "&sime;"],
		[0, "&NotTildeEqual;"],
		[0, "&cong;"],
		[0, "&simne;"],
		[0, "&ncong;"],
		[0, "&ap;"],
		[0, "&nap;"],
		[0, "&ape;"],
		[0, { v: "&apid;", n: 824, o: "&napid;" }],
		[0, "&backcong;"],
		[0, { v: "&asympeq;", n: 8402, o: "&nvap;" }],
		[0, { v: "&bump;", n: 824, o: "&nbump;" }],
		[0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }],
		[0, { v: "&doteq;", n: 824, o: "&nedot;" }],
		[0, "&doteqdot;"],
		[0, "&efDot;"],
		[0, "&erDot;"],
		[0, "&Assign;"],
		[0, "&ecolon;"],
		[0, "&ecir;"],
		[0, "&circeq;"],
		[1, "&wedgeq;"],
		[0, "&veeeq;"],
		[1, "&triangleq;"],
		[2, "&equest;"],
		[0, "&ne;"],
		[0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }],
		[0, "&nequiv;"],
		[1, { v: "&le;", n: 8402, o: "&nvle;" }],
		[0, { v: "&ge;", n: 8402, o: "&nvge;" }],
		[0, { v: "&lE;", n: 824, o: "&nlE;" }],
		[0, { v: "&gE;", n: 824, o: "&ngE;" }],
		[0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }],
		[0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }],
		[
			0,
			{
				v: "&ll;",
				n: new Map(
					restoreDiff([
						[824, "&nLtv;"],
						[7577, "&nLt;"],
					])
				),
			},
		],
		[
			0,
			{
				v: "&gg;",
				n: new Map(
					restoreDiff([
						[824, "&nGtv;"],
						[7577, "&nGt;"],
					])
				),
			},
		],
		[0, "&between;"],
		[0, "&NotCupCap;"],
		[0, "&nless;"],
		[0, "&ngt;"],
		[0, "&nle;"],
		[0, "&nge;"],
		[0, "&lesssim;"],
		[0, "&GreaterTilde;"],
		[0, "&nlsim;"],
		[0, "&ngsim;"],
		[0, "&LessGreater;"],
		[0, "&gl;"],
		[0, "&NotLessGreater;"],
		[0, "&NotGreaterLess;"],
		[0, "&pr;"],
		[0, "&sc;"],
		[0, "&prcue;"],
		[0, "&sccue;"],
		[0, "&PrecedesTilde;"],
		[0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }],
		[0, "&NotPrecedes;"],
		[0, "&NotSucceeds;"],
		[0, { v: "&sub;", n: 8402, o: "&NotSubset;" }],
		[0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }],
		[0, "&nsub;"],
		[0, "&nsup;"],
		[0, "&sube;"],
		[0, "&supe;"],
		[0, "&NotSubsetEqual;"],
		[0, "&NotSupersetEqual;"],
		[0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }],
		[0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }],
		[1, "&cupdot;"],
		[0, "&UnionPlus;"],
		[0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }],
		[0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }],
		[0, "&sqsube;"],
		[0, "&sqsupe;"],
		[0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }],
		[0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }],
		[0, "&CirclePlus;"],
		[0, "&CircleMinus;"],
		[0, "&CircleTimes;"],
		[0, "&osol;"],
		[0, "&CircleDot;"],
		[0, "&circledcirc;"],
		[0, "&circledast;"],
		[1, "&circleddash;"],
		[0, "&boxplus;"],
		[0, "&boxminus;"],
		[0, "&boxtimes;"],
		[0, "&dotsquare;"],
		[0, "&RightTee;"],
		[0, "&dashv;"],
		[0, "&DownTee;"],
		[0, "&bot;"],
		[1, "&models;"],
		[0, "&DoubleRightTee;"],
		[0, "&Vdash;"],
		[0, "&Vvdash;"],
		[0, "&VDash;"],
		[0, "&nvdash;"],
		[0, "&nvDash;"],
		[0, "&nVdash;"],
		[0, "&nVDash;"],
		[0, "&prurel;"],
		[1, "&LeftTriangle;"],
		[0, "&RightTriangle;"],
		[0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }],
		[0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }],
		[0, "&origof;"],
		[0, "&imof;"],
		[0, "&multimap;"],
		[0, "&hercon;"],
		[0, "&intcal;"],
		[0, "&veebar;"],
		[1, "&barvee;"],
		[0, "&angrtvb;"],
		[0, "&lrtri;"],
		[0, "&bigwedge;"],
		[0, "&bigvee;"],
		[0, "&bigcap;"],
		[0, "&bigcup;"],
		[0, "&diam;"],
		[0, "&sdot;"],
		[0, "&sstarf;"],
		[0, "&divideontimes;"],
		[0, "&bowtie;"],
		[0, "&ltimes;"],
		[0, "&rtimes;"],
		[0, "&leftthreetimes;"],
		[0, "&rightthreetimes;"],
		[0, "&backsimeq;"],
		[0, "&curlyvee;"],
		[0, "&curlywedge;"],
		[0, "&Sub;"],
		[0, "&Sup;"],
		[0, "&Cap;"],
		[0, "&Cup;"],
		[0, "&fork;"],
		[0, "&epar;"],
		[0, "&lessdot;"],
		[0, "&gtdot;"],
		[0, { v: "&Ll;", n: 824, o: "&nLl;" }],
		[0, { v: "&Gg;", n: 824, o: "&nGg;" }],
		[0, { v: "&leg;", n: 65024, o: "&lesg;" }],
		[0, { v: "&gel;", n: 65024, o: "&gesl;" }],
		[2, "&cuepr;"],
		[0, "&cuesc;"],
		[0, "&NotPrecedesSlantEqual;"],
		[0, "&NotSucceedsSlantEqual;"],
		[0, "&NotSquareSubsetEqual;"],
		[0, "&NotSquareSupersetEqual;"],
		[2, "&lnsim;"],
		[0, "&gnsim;"],
		[0, "&precnsim;"],
		[0, "&scnsim;"],
		[0, "&nltri;"],
		[0, "&NotRightTriangle;"],
		[0, "&nltrie;"],
		[0, "&NotRightTriangleEqual;"],
		[0, "&vellip;"],
		[0, "&ctdot;"],
		[0, "&utdot;"],
		[0, "&dtdot;"],
		[0, "&disin;"],
		[0, "&isinsv;"],
		[0, "&isins;"],
		[0, { v: "&isindot;", n: 824, o: "&notindot;" }],
		[0, "&notinvc;"],
		[0, "&notinvb;"],
		[1, { v: "&isinE;", n: 824, o: "&notinE;" }],
		[0, "&nisd;"],
		[0, "&xnis;"],
		[0, "&nis;"],
		[0, "&notnivc;"],
		[0, "&notnivb;"],
		[6, "&barwed;"],
		[0, "&Barwed;"],
		[1, "&lceil;"],
		[0, "&rceil;"],
		[0, "&LeftFloor;"],
		[0, "&rfloor;"],
		[0, "&drcrop;"],
		[0, "&dlcrop;"],
		[0, "&urcrop;"],
		[0, "&ulcrop;"],
		[0, "&bnot;"],
		[1, "&profline;"],
		[0, "&profsurf;"],
		[1, "&telrec;"],
		[0, "&target;"],
		[5, "&ulcorn;"],
		[0, "&urcorn;"],
		[0, "&dlcorn;"],
		[0, "&drcorn;"],
		[2, "&frown;"],
		[0, "&smile;"],
		[9, "&cylcty;"],
		[0, "&profalar;"],
		[7, "&topbot;"],
		[6, "&ovbar;"],
		[1, "&solbar;"],
		[60, "&angzarr;"],
		[51, "&lmoustache;"],
		[0, "&rmoustache;"],
		[2, "&OverBracket;"],
		[0, "&bbrk;"],
		[0, "&bbrktbrk;"],
		[37, "&OverParenthesis;"],
		[0, "&UnderParenthesis;"],
		[0, "&OverBrace;"],
		[0, "&UnderBrace;"],
		[2, "&trpezium;"],
		[4, "&elinters;"],
		[59, "&blank;"],
		[164, "&circledS;"],
		[55, "&boxh;"],
		[1, "&boxv;"],
		[9, "&boxdr;"],
		[3, "&boxdl;"],
		[3, "&boxur;"],
		[3, "&boxul;"],
		[3, "&boxvr;"],
		[7, "&boxvl;"],
		[7, "&boxhd;"],
		[7, "&boxhu;"],
		[7, "&boxvh;"],
		[19, "&boxH;"],
		[0, "&boxV;"],
		[0, "&boxdR;"],
		[0, "&boxDr;"],
		[0, "&boxDR;"],
		[0, "&boxdL;"],
		[0, "&boxDl;"],
		[0, "&boxDL;"],
		[0, "&boxuR;"],
		[0, "&boxUr;"],
		[0, "&boxUR;"],
		[0, "&boxuL;"],
		[0, "&boxUl;"],
		[0, "&boxUL;"],
		[0, "&boxvR;"],
		[0, "&boxVr;"],
		[0, "&boxVR;"],
		[0, "&boxvL;"],
		[0, "&boxVl;"],
		[0, "&boxVL;"],
		[0, "&boxHd;"],
		[0, "&boxhD;"],
		[0, "&boxHD;"],
		[0, "&boxHu;"],
		[0, "&boxhU;"],
		[0, "&boxHU;"],
		[0, "&boxvH;"],
		[0, "&boxVh;"],
		[0, "&boxVH;"],
		[19, "&uhblk;"],
		[3, "&lhblk;"],
		[3, "&block;"],
		[8, "&blk14;"],
		[0, "&blk12;"],
		[0, "&blk34;"],
		[13, "&square;"],
		[8, "&blacksquare;"],
		[0, "&EmptyVerySmallSquare;"],
		[1, "&rect;"],
		[0, "&marker;"],
		[2, "&fltns;"],
		[1, "&bigtriangleup;"],
		[0, "&blacktriangle;"],
		[0, "&triangle;"],
		[2, "&blacktriangleright;"],
		[0, "&rtri;"],
		[3, "&bigtriangledown;"],
		[0, "&blacktriangledown;"],
		[0, "&dtri;"],
		[2, "&blacktriangleleft;"],
		[0, "&ltri;"],
		[6, "&loz;"],
		[0, "&cir;"],
		[32, "&tridot;"],
		[2, "&bigcirc;"],
		[8, "&ultri;"],
		[0, "&urtri;"],
		[0, "&lltri;"],
		[0, "&EmptySmallSquare;"],
		[0, "&FilledSmallSquare;"],
		[8, "&bigstar;"],
		[0, "&star;"],
		[7, "&phone;"],
		[49, "&female;"],
		[1, "&male;"],
		[29, "&spades;"],
		[2, "&clubs;"],
		[1, "&hearts;"],
		[0, "&diamondsuit;"],
		[3, "&sung;"],
		[2, "&flat;"],
		[0, "&natural;"],
		[0, "&sharp;"],
		[163, "&check;"],
		[3, "&cross;"],
		[8, "&malt;"],
		[21, "&sext;"],
		[33, "&VerticalSeparator;"],
		[25, "&lbbrk;"],
		[0, "&rbbrk;"],
		[84, "&bsolhsub;"],
		[0, "&suphsol;"],
		[28, "&LeftDoubleBracket;"],
		[0, "&RightDoubleBracket;"],
		[0, "&lang;"],
		[0, "&rang;"],
		[0, "&Lang;"],
		[0, "&Rang;"],
		[0, "&loang;"],
		[0, "&roang;"],
		[7, "&longleftarrow;"],
		[0, "&longrightarrow;"],
		[0, "&longleftrightarrow;"],
		[0, "&DoubleLongLeftArrow;"],
		[0, "&DoubleLongRightArrow;"],
		[0, "&DoubleLongLeftRightArrow;"],
		[1, "&longmapsto;"],
		[2, "&dzigrarr;"],
		[258, "&nvlArr;"],
		[0, "&nvrArr;"],
		[0, "&nvHarr;"],
		[0, "&Map;"],
		[6, "&lbarr;"],
		[0, "&bkarow;"],
		[0, "&lBarr;"],
		[0, "&dbkarow;"],
		[0, "&drbkarow;"],
		[0, "&DDotrahd;"],
		[0, "&UpArrowBar;"],
		[0, "&DownArrowBar;"],
		[2, "&Rarrtl;"],
		[2, "&latail;"],
		[0, "&ratail;"],
		[0, "&lAtail;"],
		[0, "&rAtail;"],
		[0, "&larrfs;"],
		[0, "&rarrfs;"],
		[0, "&larrbfs;"],
		[0, "&rarrbfs;"],
		[2, "&nwarhk;"],
		[0, "&nearhk;"],
		[0, "&hksearow;"],
		[0, "&hkswarow;"],
		[0, "&nwnear;"],
		[0, "&nesear;"],
		[0, "&seswar;"],
		[0, "&swnwar;"],
		[8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }],
		[1, "&cudarrr;"],
		[0, "&ldca;"],
		[0, "&rdca;"],
		[0, "&cudarrl;"],
		[0, "&larrpl;"],
		[2, "&curarrm;"],
		[0, "&cularrp;"],
		[7, "&rarrpl;"],
		[2, "&harrcir;"],
		[0, "&Uarrocir;"],
		[0, "&lurdshar;"],
		[0, "&ldrushar;"],
		[2, "&LeftRightVector;"],
		[0, "&RightUpDownVector;"],
		[0, "&DownLeftRightVector;"],
		[0, "&LeftUpDownVector;"],
		[0, "&LeftVectorBar;"],
		[0, "&RightVectorBar;"],
		[0, "&RightUpVectorBar;"],
		[0, "&RightDownVectorBar;"],
		[0, "&DownLeftVectorBar;"],
		[0, "&DownRightVectorBar;"],
		[0, "&LeftUpVectorBar;"],
		[0, "&LeftDownVectorBar;"],
		[0, "&LeftTeeVector;"],
		[0, "&RightTeeVector;"],
		[0, "&RightUpTeeVector;"],
		[0, "&RightDownTeeVector;"],
		[0, "&DownLeftTeeVector;"],
		[0, "&DownRightTeeVector;"],
		[0, "&LeftUpTeeVector;"],
		[0, "&LeftDownTeeVector;"],
		[0, "&lHar;"],
		[0, "&uHar;"],
		[0, "&rHar;"],
		[0, "&dHar;"],
		[0, "&luruhar;"],
		[0, "&ldrdhar;"],
		[0, "&ruluhar;"],
		[0, "&rdldhar;"],
		[0, "&lharul;"],
		[0, "&llhard;"],
		[0, "&rharul;"],
		[0, "&lrhard;"],
		[0, "&udhar;"],
		[0, "&duhar;"],
		[0, "&RoundImplies;"],
		[0, "&erarr;"],
		[0, "&simrarr;"],
		[0, "&larrsim;"],
		[0, "&rarrsim;"],
		[0, "&rarrap;"],
		[0, "&ltlarr;"],
		[1, "&gtrarr;"],
		[0, "&subrarr;"],
		[1, "&suplarr;"],
		[0, "&lfisht;"],
		[0, "&rfisht;"],
		[0, "&ufisht;"],
		[0, "&dfisht;"],
		[5, "&lopar;"],
		[0, "&ropar;"],
		[4, "&lbrke;"],
		[0, "&rbrke;"],
		[0, "&lbrkslu;"],
		[0, "&rbrksld;"],
		[0, "&lbrksld;"],
		[0, "&rbrkslu;"],
		[0, "&langd;"],
		[0, "&rangd;"],
		[0, "&lparlt;"],
		[0, "&rpargt;"],
		[0, "&gtlPar;"],
		[0, "&ltrPar;"],
		[3, "&vzigzag;"],
		[1, "&vangrt;"],
		[0, "&angrtvbd;"],
		[6, "&ange;"],
		[0, "&range;"],
		[0, "&dwangle;"],
		[0, "&uwangle;"],
		[0, "&angmsdaa;"],
		[0, "&angmsdab;"],
		[0, "&angmsdac;"],
		[0, "&angmsdad;"],
		[0, "&angmsdae;"],
		[0, "&angmsdaf;"],
		[0, "&angmsdag;"],
		[0, "&angmsdah;"],
		[0, "&bemptyv;"],
		[0, "&demptyv;"],
		[0, "&cemptyv;"],
		[0, "&raemptyv;"],
		[0, "&laemptyv;"],
		[0, "&ohbar;"],
		[0, "&omid;"],
		[0, "&opar;"],
		[1, "&operp;"],
		[1, "&olcross;"],
		[0, "&odsold;"],
		[1, "&olcir;"],
		[0, "&ofcir;"],
		[0, "&olt;"],
		[0, "&ogt;"],
		[0, "&cirscir;"],
		[0, "&cirE;"],
		[0, "&solb;"],
		[0, "&bsolb;"],
		[3, "&boxbox;"],
		[3, "&trisb;"],
		[0, "&rtriltri;"],
		[0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }],
		[0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }],
		[11, "&iinfin;"],
		[0, "&infintie;"],
		[0, "&nvinfin;"],
		[4, "&eparsl;"],
		[0, "&smeparsl;"],
		[0, "&eqvparsl;"],
		[5, "&blacklozenge;"],
		[8, "&RuleDelayed;"],
		[1, "&dsol;"],
		[9, "&bigodot;"],
		[0, "&bigoplus;"],
		[0, "&bigotimes;"],
		[1, "&biguplus;"],
		[1, "&bigsqcup;"],
		[5, "&iiiint;"],
		[0, "&fpartint;"],
		[2, "&cirfnint;"],
		[0, "&awint;"],
		[0, "&rppolint;"],
		[0, "&scpolint;"],
		[0, "&npolint;"],
		[0, "&pointint;"],
		[0, "&quatint;"],
		[0, "&intlarhk;"],
		[10, "&pluscir;"],
		[0, "&plusacir;"],
		[0, "&simplus;"],
		[0, "&plusdu;"],
		[0, "&plussim;"],
		[0, "&plustwo;"],
		[1, "&mcomma;"],
		[0, "&minusdu;"],
		[2, "&loplus;"],
		[0, "&roplus;"],
		[0, "&Cross;"],
		[0, "&timesd;"],
		[0, "&timesbar;"],
		[1, "&smashp;"],
		[0, "&lotimes;"],
		[0, "&rotimes;"],
		[0, "&otimesas;"],
		[0, "&Otimes;"],
		[0, "&odiv;"],
		[0, "&triplus;"],
		[0, "&triminus;"],
		[0, "&tritime;"],
		[0, "&intprod;"],
		[2, "&amalg;"],
		[0, "&capdot;"],
		[1, "&ncup;"],
		[0, "&ncap;"],
		[0, "&capand;"],
		[0, "&cupor;"],
		[0, "&cupcap;"],
		[0, "&capcup;"],
		[0, "&cupbrcap;"],
		[0, "&capbrcup;"],
		[0, "&cupcup;"],
		[0, "&capcap;"],
		[0, "&ccups;"],
		[0, "&ccaps;"],
		[2, "&ccupssm;"],
		[2, "&And;"],
		[0, "&Or;"],
		[0, "&andand;"],
		[0, "&oror;"],
		[0, "&orslope;"],
		[0, "&andslope;"],
		[1, "&andv;"],
		[0, "&orv;"],
		[0, "&andd;"],
		[0, "&ord;"],
		[1, "&wedbar;"],
		[6, "&sdote;"],
		[3, "&simdot;"],
		[2, { v: "&congdot;", n: 824, o: "&ncongdot;" }],
		[0, "&easter;"],
		[0, "&apacir;"],
		[0, { v: "&apE;", n: 824, o: "&napE;" }],
		[0, "&eplus;"],
		[0, "&pluse;"],
		[0, "&Esim;"],
		[0, "&Colone;"],
		[0, "&Equal;"],
		[1, "&ddotseq;"],
		[0, "&equivDD;"],
		[0, "&ltcir;"],
		[0, "&gtcir;"],
		[0, "&ltquest;"],
		[0, "&gtquest;"],
		[0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }],
		[0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }],
		[0, "&lesdot;"],
		[0, "&gesdot;"],
		[0, "&lesdoto;"],
		[0, "&gesdoto;"],
		[0, "&lesdotor;"],
		[0, "&gesdotol;"],
		[0, "&lap;"],
		[0, "&gap;"],
		[0, "&lne;"],
		[0, "&gne;"],
		[0, "&lnap;"],
		[0, "&gnap;"],
		[0, "&lEg;"],
		[0, "&gEl;"],
		[0, "&lsime;"],
		[0, "&gsime;"],
		[0, "&lsimg;"],
		[0, "&gsiml;"],
		[0, "&lgE;"],
		[0, "&glE;"],
		[0, "&lesges;"],
		[0, "&gesles;"],
		[0, "&els;"],
		[0, "&egs;"],
		[0, "&elsdot;"],
		[0, "&egsdot;"],
		[0, "&el;"],
		[0, "&eg;"],
		[2, "&siml;"],
		[0, "&simg;"],
		[0, "&simlE;"],
		[0, "&simgE;"],
		[0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }],
		[0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }],
		[1, "&glj;"],
		[0, "&gla;"],
		[0, "&ltcc;"],
		[0, "&gtcc;"],
		[0, "&lescc;"],
		[0, "&gescc;"],
		[0, "&smt;"],
		[0, "&lat;"],
		[0, { v: "&smte;", n: 65024, o: "&smtes;" }],
		[0, { v: "&late;", n: 65024, o: "&lates;" }],
		[0, "&bumpE;"],
		[0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }],
		[0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }],
		[2, "&prE;"],
		[0, "&scE;"],
		[0, "&precneqq;"],
		[0, "&scnE;"],
		[0, "&prap;"],
		[0, "&scap;"],
		[0, "&precnapprox;"],
		[0, "&scnap;"],
		[0, "&Pr;"],
		[0, "&Sc;"],
		[0, "&subdot;"],
		[0, "&supdot;"],
		[0, "&subplus;"],
		[0, "&supplus;"],
		[0, "&submult;"],
		[0, "&supmult;"],
		[0, "&subedot;"],
		[0, "&supedot;"],
		[0, { v: "&subE;", n: 824, o: "&nsubE;" }],
		[0, { v: "&supE;", n: 824, o: "&nsupE;" }],
		[0, "&subsim;"],
		[0, "&supsim;"],
		[2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }],
		[0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }],
		[2, "&csub;"],
		[0, "&csup;"],
		[0, "&csube;"],
		[0, "&csupe;"],
		[0, "&subsup;"],
		[0, "&supsub;"],
		[0, "&subsub;"],
		[0, "&supsup;"],
		[0, "&suphsub;"],
		[0, "&supdsub;"],
		[0, "&forkv;"],
		[0, "&topfork;"],
		[0, "&mlcp;"],
		[8, "&Dashv;"],
		[1, "&Vdashl;"],
		[0, "&Barv;"],
		[0, "&vBar;"],
		[0, "&vBarv;"],
		[1, "&Vbar;"],
		[0, "&Not;"],
		[0, "&bNot;"],
		[0, "&rnmid;"],
		[0, "&cirmid;"],
		[0, "&midcir;"],
		[0, "&topcir;"],
		[0, "&nhpar;"],
		[0, "&parsim;"],
		[9, { v: "&parsl;", n: 8421, o: "&nparsl;" }],
		[
			44343,
			{
				n: new Map(
					restoreDiff([
						[56476, "&Ascr;"],
						[1, "&Cscr;"],
						[0, "&Dscr;"],
						[2, "&Gscr;"],
						[2, "&Jscr;"],
						[0, "&Kscr;"],
						[2, "&Nscr;"],
						[0, "&Oscr;"],
						[0, "&Pscr;"],
						[0, "&Qscr;"],
						[1, "&Sscr;"],
						[0, "&Tscr;"],
						[0, "&Uscr;"],
						[0, "&Vscr;"],
						[0, "&Wscr;"],
						[0, "&Xscr;"],
						[0, "&Yscr;"],
						[0, "&Zscr;"],
						[0, "&ascr;"],
						[0, "&bscr;"],
						[0, "&cscr;"],
						[0, "&dscr;"],
						[1, "&fscr;"],
						[1, "&hscr;"],
						[0, "&iscr;"],
						[0, "&jscr;"],
						[0, "&kscr;"],
						[0, "&lscr;"],
						[0, "&mscr;"],
						[0, "&nscr;"],
						[1, "&pscr;"],
						[0, "&qscr;"],
						[0, "&rscr;"],
						[0, "&sscr;"],
						[0, "&tscr;"],
						[0, "&uscr;"],
						[0, "&vscr;"],
						[0, "&wscr;"],
						[0, "&xscr;"],
						[0, "&yscr;"],
						[0, "&zscr;"],
						[52, "&Afr;"],
						[0, "&Bfr;"],
						[1, "&Dfr;"],
						[0, "&Efr;"],
						[0, "&Ffr;"],
						[0, "&Gfr;"],
						[2, "&Jfr;"],
						[0, "&Kfr;"],
						[0, "&Lfr;"],
						[0, "&Mfr;"],
						[0, "&Nfr;"],
						[0, "&Ofr;"],
						[0, "&Pfr;"],
						[0, "&Qfr;"],
						[1, "&Sfr;"],
						[0, "&Tfr;"],
						[0, "&Ufr;"],
						[0, "&Vfr;"],
						[0, "&Wfr;"],
						[0, "&Xfr;"],
						[0, "&Yfr;"],
						[1, "&afr;"],
						[0, "&bfr;"],
						[0, "&cfr;"],
						[0, "&dfr;"],
						[0, "&efr;"],
						[0, "&ffr;"],
						[0, "&gfr;"],
						[0, "&hfr;"],
						[0, "&ifr;"],
						[0, "&jfr;"],
						[0, "&kfr;"],
						[0, "&lfr;"],
						[0, "&mfr;"],
						[0, "&nfr;"],
						[0, "&ofr;"],
						[0, "&pfr;"],
						[0, "&qfr;"],
						[0, "&rfr;"],
						[0, "&sfr;"],
						[0, "&tfr;"],
						[0, "&ufr;"],
						[0, "&vfr;"],
						[0, "&wfr;"],
						[0, "&xfr;"],
						[0, "&yfr;"],
						[0, "&zfr;"],
						[0, "&Aopf;"],
						[0, "&Bopf;"],
						[1, "&Dopf;"],
						[0, "&Eopf;"],
						[0, "&Fopf;"],
						[0, "&Gopf;"],
						[1, "&Iopf;"],
						[0, "&Jopf;"],
						[0, "&Kopf;"],
						[0, "&Lopf;"],
						[0, "&Mopf;"],
						[1, "&Oopf;"],
						[3, "&Sopf;"],
						[0, "&Topf;"],
						[0, "&Uopf;"],
						[0, "&Vopf;"],
						[0, "&Wopf;"],
						[0, "&Xopf;"],
						[0, "&Yopf;"],
						[1, "&aopf;"],
						[0, "&bopf;"],
						[0, "&copf;"],
						[0, "&dopf;"],
						[0, "&eopf;"],
						[0, "&fopf;"],
						[0, "&gopf;"],
						[0, "&hopf;"],
						[0, "&iopf;"],
						[0, "&jopf;"],
						[0, "&kopf;"],
						[0, "&lopf;"],
						[0, "&mopf;"],
						[0, "&nopf;"],
						[0, "&oopf;"],
						[0, "&popf;"],
						[0, "&qopf;"],
						[0, "&ropf;"],
						[0, "&sopf;"],
						[0, "&topf;"],
						[0, "&uopf;"],
						[0, "&vopf;"],
						[0, "&wopf;"],
						[0, "&xopf;"],
						[0, "&yopf;"],
						[0, "&zopf;"],
					])
				),
			},
		],
		[8906, "&fflig;"],
		[0, "&filig;"],
		[0, "&fllig;"],
		[0, "&ffilig;"],
		[0, "&ffllig;"],
	])
);
var _escape = {};
(function (_) {
	Object.defineProperty(_, "__esModule", { value: !0 }),
		(_.escapeText =
			_.escapeAttribute =
			_.escapeUTF8 =
			_.escape =
			_.encodeXML =
			_.getCodePoint =
			_.xmlReplacer =
				void 0),
		(_.xmlReplacer = /["&'<>$\x80-\uFFFF]/g);
	var et = new Map([
		[34, "&quot;"],
		[38, "&amp;"],
		[39, "&apos;"],
		[60, "&lt;"],
		[62, "&gt;"],
	]);
	_.getCodePoint =
		String.prototype.codePointAt != null
			? function (rt, it) {
					return rt.codePointAt(it);
			  }
			: function (rt, it) {
					return (rt.charCodeAt(it) & 64512) === 55296
						? (rt.charCodeAt(it) - 55296) * 1024 + rt.charCodeAt(it + 1) - 56320 + 65536
						: rt.charCodeAt(it);
			  };
	function tt(rt) {
		for (var it = "", ot = 0, at; (at = _.xmlReplacer.exec(rt)) !== null; ) {
			var st = at.index,
				lt = rt.charCodeAt(st),
				ut = et.get(lt);
			ut !== void 0
				? ((it += rt.substring(ot, st) + ut), (ot = st + 1))
				: ((it += "".concat(rt.substring(ot, st), "&#x").concat((0, _.getCodePoint)(rt, st).toString(16), ";")),
				  (ot = _.xmlReplacer.lastIndex += Number((lt & 64512) === 55296)));
		}
		return it + rt.substr(ot);
	}
	(_.encodeXML = tt), (_.escape = tt);
	function nt(rt, it) {
		return function (at) {
			for (var st, lt = 0, ut = ""; (st = rt.exec(at)); )
				lt !== st.index && (ut += at.substring(lt, st.index)), (ut += it.get(st[0].charCodeAt(0))), (lt = st.index + 1);
			return ut + at.substring(lt);
		};
	}
	(_.escapeUTF8 = nt(/[&<>'"]/g, et)),
		(_.escapeAttribute = nt(
			/["&\u00A0]/g,
			new Map([
				[34, "&quot;"],
				[38, "&amp;"],
				[160, "&nbsp;"],
			])
		)),
		(_.escapeText = nt(
			/[&<>\u00A0]/g,
			new Map([
				[38, "&amp;"],
				[60, "&lt;"],
				[62, "&gt;"],
				[160, "&nbsp;"],
			])
		));
})(_escape);
var __importDefault$1 =
	(commonjsGlobal && commonjsGlobal.__importDefault) ||
	function (_) {
		return _ && _.__esModule ? _ : { default: _ };
	};
Object.defineProperty(encode, "__esModule", { value: !0 });
encode.encodeNonAsciiHTML = encode.encodeHTML = void 0;
var encode_html_js_1 = __importDefault$1(encodeHtml),
	escape_js_1 = _escape,
	htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML(_) {
	return encodeHTMLTrieRe(htmlReplacer, _);
}
encode.encodeHTML = encodeHTML;
function encodeNonAsciiHTML(_) {
	return encodeHTMLTrieRe(escape_js_1.xmlReplacer, _);
}
encode.encodeNonAsciiHTML = encodeNonAsciiHTML;
function encodeHTMLTrieRe(_, et) {
	for (var tt = "", nt = 0, rt; (rt = _.exec(et)) !== null; ) {
		var it = rt.index;
		tt += et.substring(nt, it);
		var ot = et.charCodeAt(it),
			at = encode_html_js_1.default.get(ot);
		if (typeof at == "object") {
			if (it + 1 < et.length) {
				var st = et.charCodeAt(it + 1),
					lt = typeof at.n == "number" ? (at.n === st ? at.o : void 0) : at.n.get(st);
				if (lt !== void 0) {
					(tt += lt), (nt = _.lastIndex += 1);
					continue;
				}
			}
			at = at.v;
		}
		if (at !== void 0) (tt += at), (nt = it + 1);
		else {
			var ut = (0, escape_js_1.getCodePoint)(et, it);
			(tt += "&#x".concat(ut.toString(16), ";")), (nt = _.lastIndex += Number(ut !== ot));
		}
	}
	return tt + et.substr(nt);
}
(function (_) {
	Object.defineProperty(_, "__esModule", { value: !0 }),
		(_.decodeXMLStrict =
			_.decodeHTML5Strict =
			_.decodeHTML4Strict =
			_.decodeHTML5 =
			_.decodeHTML4 =
			_.decodeHTMLStrict =
			_.decodeHTML =
			_.decodeXML =
			_.encodeHTML5 =
			_.encodeHTML4 =
			_.encodeNonAsciiHTML =
			_.encodeHTML =
			_.escapeText =
			_.escapeAttribute =
			_.escapeUTF8 =
			_.escape =
			_.encodeXML =
			_.encode =
			_.decodeStrict =
			_.decode =
			_.EncodingMode =
			_.DecodingMode =
			_.EntityLevel =
				void 0);
	var et = decode$1,
		tt = encode,
		nt = _escape,
		rt;
	(function (ft) {
		(ft[(ft.XML = 0)] = "XML"), (ft[(ft.HTML = 1)] = "HTML");
	})((rt = _.EntityLevel || (_.EntityLevel = {})));
	var it;
	(function (ft) {
		(ft[(ft.Legacy = 0)] = "Legacy"), (ft[(ft.Strict = 1)] = "Strict");
	})((it = _.DecodingMode || (_.DecodingMode = {})));
	var ot;
	(function (ft) {
		(ft[(ft.UTF8 = 0)] = "UTF8"),
			(ft[(ft.ASCII = 1)] = "ASCII"),
			(ft[(ft.Extensive = 2)] = "Extensive"),
			(ft[(ft.Attribute = 3)] = "Attribute"),
			(ft[(ft.Text = 4)] = "Text");
	})((ot = _.EncodingMode || (_.EncodingMode = {})));
	function at(ft, mt) {
		mt === void 0 && (mt = rt.XML);
		var pt = typeof mt == "number" ? { level: mt } : mt;
		return pt.level === rt.HTML
			? pt.mode === it.Strict
				? (0, et.decodeHTMLStrict)(ft)
				: (0, et.decodeHTML)(ft)
			: (0, et.decodeXML)(ft);
	}
	_.decode = at;
	function st(ft, mt) {
		mt === void 0 && (mt = rt.XML);
		var pt = typeof mt == "number" ? { level: mt } : mt;
		return pt.level === rt.HTML
			? pt.mode === it.Legacy
				? (0, et.decodeHTML)(ft)
				: (0, et.decodeHTMLStrict)(ft)
			: (0, et.decodeXML)(ft);
	}
	_.decodeStrict = st;
	function lt(ft, mt) {
		mt === void 0 && (mt = rt.XML);
		var pt = typeof mt == "number" ? { level: mt } : mt;
		return pt.mode === ot.UTF8
			? (0, nt.escapeUTF8)(ft)
			: pt.mode === ot.Attribute
			? (0, nt.escapeAttribute)(ft)
			: pt.mode === ot.Text
			? (0, nt.escapeText)(ft)
			: pt.level === rt.HTML
			? pt.mode === ot.ASCII
				? (0, tt.encodeNonAsciiHTML)(ft)
				: (0, tt.encodeHTML)(ft)
			: (0, nt.encodeXML)(ft);
	}
	_.encode = lt;
	var ut = _escape;
	Object.defineProperty(_, "encodeXML", {
		enumerable: !0,
		get: function () {
			return ut.encodeXML;
		},
	}),
		Object.defineProperty(_, "escape", {
			enumerable: !0,
			get: function () {
				return ut.escape;
			},
		}),
		Object.defineProperty(_, "escapeUTF8", {
			enumerable: !0,
			get: function () {
				return ut.escapeUTF8;
			},
		}),
		Object.defineProperty(_, "escapeAttribute", {
			enumerable: !0,
			get: function () {
				return ut.escapeAttribute;
			},
		}),
		Object.defineProperty(_, "escapeText", {
			enumerable: !0,
			get: function () {
				return ut.escapeText;
			},
		});
	var dt = encode;
	Object.defineProperty(_, "encodeHTML", {
		enumerable: !0,
		get: function () {
			return dt.encodeHTML;
		},
	}),
		Object.defineProperty(_, "encodeNonAsciiHTML", {
			enumerable: !0,
			get: function () {
				return dt.encodeNonAsciiHTML;
			},
		}),
		Object.defineProperty(_, "encodeHTML4", {
			enumerable: !0,
			get: function () {
				return dt.encodeHTML;
			},
		}),
		Object.defineProperty(_, "encodeHTML5", {
			enumerable: !0,
			get: function () {
				return dt.encodeHTML;
			},
		});
	var ct = decode$1;
	Object.defineProperty(_, "decodeXML", {
		enumerable: !0,
		get: function () {
			return ct.decodeXML;
		},
	}),
		Object.defineProperty(_, "decodeHTML", {
			enumerable: !0,
			get: function () {
				return ct.decodeHTML;
			},
		}),
		Object.defineProperty(_, "decodeHTMLStrict", {
			enumerable: !0,
			get: function () {
				return ct.decodeHTMLStrict;
			},
		}),
		Object.defineProperty(_, "decodeHTML4", {
			enumerable: !0,
			get: function () {
				return ct.decodeHTML;
			},
		}),
		Object.defineProperty(_, "decodeHTML5", {
			enumerable: !0,
			get: function () {
				return ct.decodeHTML;
			},
		}),
		Object.defineProperty(_, "decodeHTML4Strict", {
			enumerable: !0,
			get: function () {
				return ct.decodeHTMLStrict;
			},
		}),
		Object.defineProperty(_, "decodeHTML5Strict", {
			enumerable: !0,
			get: function () {
				return ct.decodeHTMLStrict;
			},
		}),
		Object.defineProperty(_, "decodeXMLStrict", {
			enumerable: !0,
			get: function () {
				return ct.decodeXML;
			},
		});
})(lib);
var foreignNames = {};
Object.defineProperty(foreignNames, "__esModule", { value: !0 });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map(
	[
		"altGlyph",
		"altGlyphDef",
		"altGlyphItem",
		"animateColor",
		"animateMotion",
		"animateTransform",
		"clipPath",
		"feBlend",
		"feColorMatrix",
		"feComponentTransfer",
		"feComposite",
		"feConvolveMatrix",
		"feDiffuseLighting",
		"feDisplacementMap",
		"feDistantLight",
		"feDropShadow",
		"feFlood",
		"feFuncA",
		"feFuncB",
		"feFuncG",
		"feFuncR",
		"feGaussianBlur",
		"feImage",
		"feMerge",
		"feMergeNode",
		"feMorphology",
		"feOffset",
		"fePointLight",
		"feSpecularLighting",
		"feSpotLight",
		"feTile",
		"feTurbulence",
		"foreignObject",
		"glyphRef",
		"linearGradient",
		"radialGradient",
		"textPath",
	].map(function (_) {
		return [_.toLowerCase(), _];
	})
);
foreignNames.attributeNames = new Map(
	[
		"definitionURL",
		"attributeName",
		"attributeType",
		"baseFrequency",
		"baseProfile",
		"calcMode",
		"clipPathUnits",
		"diffuseConstant",
		"edgeMode",
		"filterUnits",
		"glyphRef",
		"gradientTransform",
		"gradientUnits",
		"kernelMatrix",
		"kernelUnitLength",
		"keyPoints",
		"keySplines",
		"keyTimes",
		"lengthAdjust",
		"limitingConeAngle",
		"markerHeight",
		"markerUnits",
		"markerWidth",
		"maskContentUnits",
		"maskUnits",
		"numOctaves",
		"pathLength",
		"patternContentUnits",
		"patternTransform",
		"patternUnits",
		"pointsAtX",
		"pointsAtY",
		"pointsAtZ",
		"preserveAlpha",
		"preserveAspectRatio",
		"primitiveUnits",
		"refX",
		"refY",
		"repeatCount",
		"repeatDur",
		"requiredExtensions",
		"requiredFeatures",
		"specularConstant",
		"specularExponent",
		"spreadMethod",
		"startOffset",
		"stdDeviation",
		"stitchTiles",
		"surfaceScale",
		"systemLanguage",
		"tableValues",
		"targetX",
		"targetY",
		"textLength",
		"viewBox",
		"viewTarget",
		"xChannelSelector",
		"yChannelSelector",
		"zoomAndPan",
	].map(function (_) {
		return [_.toLowerCase(), _];
	})
);
var __assign =
		(commonjsGlobal && commonjsGlobal.__assign) ||
		function () {
			return (
				(__assign =
					Object.assign ||
					function (_) {
						for (var et, tt = 1, nt = arguments.length; tt < nt; tt++) {
							et = arguments[tt];
							for (var rt in et) Object.prototype.hasOwnProperty.call(et, rt) && (_[rt] = et[rt]);
						}
						return _;
					}),
				__assign.apply(this, arguments)
			);
		},
	__createBinding =
		(commonjsGlobal && commonjsGlobal.__createBinding) ||
		(Object.create
			? function (_, et, tt, nt) {
					nt === void 0 && (nt = tt);
					var rt = Object.getOwnPropertyDescriptor(et, tt);
					(!rt || ("get" in rt ? !et.__esModule : rt.writable || rt.configurable)) &&
						(rt = {
							enumerable: !0,
							get: function () {
								return et[tt];
							},
						}),
						Object.defineProperty(_, nt, rt);
			  }
			: function (_, et, tt, nt) {
					nt === void 0 && (nt = tt), (_[nt] = et[tt]);
			  }),
	__setModuleDefault =
		(commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
		(Object.create
			? function (_, et) {
					Object.defineProperty(_, "default", { enumerable: !0, value: et });
			  }
			: function (_, et) {
					_.default = et;
			  }),
	__importStar =
		(commonjsGlobal && commonjsGlobal.__importStar) ||
		function (_) {
			if (_ && _.__esModule) return _;
			var et = {};
			if (_ != null)
				for (var tt in _) tt !== "default" && Object.prototype.hasOwnProperty.call(_, tt) && __createBinding(et, _, tt);
			return __setModuleDefault(et, _), et;
		};
Object.defineProperty(lib$1, "__esModule", { value: !0 });
lib$1.render = void 0;
var ElementType = __importStar(lib$3),
	entities_1 = lib,
	foreignNames_js_1 = foreignNames,
	unencodedElements = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
function replaceQuotes(_) {
	return _.replace(/"/g, "&quot;");
}
function formatAttributes(_, et) {
	var tt;
	if (!!_) {
		var nt =
			((tt = et.encodeEntities) !== null && tt !== void 0 ? tt : et.decodeEntities) === !1
				? replaceQuotes
				: et.xmlMode || et.encodeEntities !== "utf8"
				? entities_1.encodeXML
				: entities_1.escapeAttribute;
		return Object.keys(_)
			.map(function (rt) {
				var it,
					ot,
					at = (it = _[rt]) !== null && it !== void 0 ? it : "";
				return (
					et.xmlMode === "foreign" &&
						(rt = (ot = foreignNames_js_1.attributeNames.get(rt)) !== null && ot !== void 0 ? ot : rt),
					!et.emptyAttrs && !et.xmlMode && at === "" ? rt : "".concat(rt, '="').concat(nt(at), '"')
				);
			})
			.join(" ");
	}
}
var singleTag = new Set([
	"area",
	"base",
	"basefont",
	"br",
	"col",
	"command",
	"embed",
	"frame",
	"hr",
	"img",
	"input",
	"isindex",
	"keygen",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr",
]);
function render(_, et) {
	et === void 0 && (et = {});
	for (var tt = ("length" in _) ? _ : [_], nt = "", rt = 0; rt < tt.length; rt++) nt += renderNode(tt[rt], et);
	return nt;
}
lib$1.render = render;
lib$1.default = render;
function renderNode(_, et) {
	switch (_.type) {
		case ElementType.Root:
			return render(_.children, et);
		case ElementType.Doctype:
		case ElementType.Directive:
			return renderDirective(_);
		case ElementType.Comment:
			return renderComment(_);
		case ElementType.CDATA:
			return renderCdata(_);
		case ElementType.Script:
		case ElementType.Style:
		case ElementType.Tag:
			return renderTag(_, et);
		case ElementType.Text:
			return renderText(_, et);
	}
}
var foreignModeIntegrationPoints = new Set([
		"mi",
		"mo",
		"mn",
		"ms",
		"mtext",
		"annotation-xml",
		"foreignObject",
		"desc",
		"title",
	]),
	foreignElements = new Set(["svg", "math"]);
function renderTag(_, et) {
	var tt;
	et.xmlMode === "foreign" &&
		((_.name = (tt = foreignNames_js_1.elementNames.get(_.name)) !== null && tt !== void 0 ? tt : _.name),
		_.parent && foreignModeIntegrationPoints.has(_.parent.name) && (et = __assign(__assign({}, et), { xmlMode: !1 }))),
		!et.xmlMode && foreignElements.has(_.name) && (et = __assign(__assign({}, et), { xmlMode: "foreign" }));
	var nt = "<".concat(_.name),
		rt = formatAttributes(_.attribs, et);
	return (
		rt && (nt += " ".concat(rt)),
		_.children.length === 0 && (et.xmlMode ? et.selfClosingTags !== !1 : et.selfClosingTags && singleTag.has(_.name))
			? (et.xmlMode || (nt += " "), (nt += "/>"))
			: ((nt += ">"),
			  _.children.length > 0 && (nt += render(_.children, et)),
			  (et.xmlMode || !singleTag.has(_.name)) && (nt += "</".concat(_.name, ">"))),
		nt
	);
}
function renderDirective(_) {
	return "<".concat(_.data, ">");
}
function renderText(_, et) {
	var tt,
		nt = _.data || "";
	return (
		((tt = et.encodeEntities) !== null && tt !== void 0 ? tt : et.decodeEntities) !== !1 &&
			!(!et.xmlMode && _.parent && unencodedElements.has(_.parent.name)) &&
			(nt =
				et.xmlMode || et.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(nt) : (0, entities_1.escapeText)(nt)),
		nt
	);
}
function renderCdata(_) {
	return "<![CDATA[".concat(_.children[0].data, "]]>");
}
function renderComment(_) {
	return "<!--".concat(_.data, "-->");
}
var __importDefault =
	(commonjsGlobal && commonjsGlobal.__importDefault) ||
	function (_) {
		return _ && _.__esModule ? _ : { default: _ };
	};
Object.defineProperty(stringify$2, "__esModule", { value: !0 });
stringify$2.innerText =
	stringify$2.textContent =
	stringify$2.getText =
	stringify$2.getInnerHTML =
	stringify$2.getOuterHTML =
		void 0;
var domhandler_1$3 = lib$4,
	dom_serializer_1 = __importDefault(lib$1),
	domelementtype_1 = lib$3;
function getOuterHTML(_, et) {
	return (0, dom_serializer_1.default)(_, et);
}
stringify$2.getOuterHTML = getOuterHTML;
function getInnerHTML(_, et) {
	return (0, domhandler_1$3.hasChildren)(_)
		? _.children
				.map(function (tt) {
					return getOuterHTML(tt, et);
				})
				.join("")
		: "";
}
stringify$2.getInnerHTML = getInnerHTML;
function getText(_) {
	return Array.isArray(_)
		? _.map(getText).join("")
		: (0, domhandler_1$3.isTag)(_)
		? _.name === "br"
			? `
`
			: getText(_.children)
		: (0, domhandler_1$3.isCDATA)(_)
		? getText(_.children)
		: (0, domhandler_1$3.isText)(_)
		? _.data
		: "";
}
stringify$2.getText = getText;
function textContent(_) {
	return Array.isArray(_)
		? _.map(textContent).join("")
		: (0, domhandler_1$3.hasChildren)(_) && !(0, domhandler_1$3.isComment)(_)
		? textContent(_.children)
		: (0, domhandler_1$3.isText)(_)
		? _.data
		: "";
}
stringify$2.textContent = textContent;
function innerText(_) {
	return Array.isArray(_)
		? _.map(innerText).join("")
		: (0, domhandler_1$3.hasChildren)(_) &&
		  (_.type === domelementtype_1.ElementType.Tag || (0, domhandler_1$3.isCDATA)(_))
		? innerText(_.children)
		: (0, domhandler_1$3.isText)(_)
		? _.data
		: "";
}
stringify$2.innerText = innerText;
var traversal = {};
Object.defineProperty(traversal, "__esModule", { value: !0 });
traversal.prevElementSibling =
	traversal.nextElementSibling =
	traversal.getName =
	traversal.hasAttrib =
	traversal.getAttributeValue =
	traversal.getSiblings =
	traversal.getParent =
	traversal.getChildren =
		void 0;
var domhandler_1$2 = lib$4;
function getChildren(_) {
	return (0, domhandler_1$2.hasChildren)(_) ? _.children : [];
}
traversal.getChildren = getChildren;
function getParent(_) {
	return _.parent || null;
}
traversal.getParent = getParent;
function getSiblings(_) {
	var et,
		tt,
		nt = getParent(_);
	if (nt != null) return getChildren(nt);
	for (var rt = [_], it = _.prev, ot = _.next; it != null; ) rt.unshift(it), (et = it), (it = et.prev);
	for (; ot != null; ) rt.push(ot), (tt = ot), (ot = tt.next);
	return rt;
}
traversal.getSiblings = getSiblings;
function getAttributeValue(_, et) {
	var tt;
	return (tt = _.attribs) === null || tt === void 0 ? void 0 : tt[et];
}
traversal.getAttributeValue = getAttributeValue;
function hasAttrib(_, et) {
	return _.attribs != null && Object.prototype.hasOwnProperty.call(_.attribs, et) && _.attribs[et] != null;
}
traversal.hasAttrib = hasAttrib;
function getName(_) {
	return _.name;
}
traversal.getName = getName;
function nextElementSibling(_) {
	for (var et, tt = _.next; tt !== null && !(0, domhandler_1$2.isTag)(tt); ) (et = tt), (tt = et.next);
	return tt;
}
traversal.nextElementSibling = nextElementSibling;
function prevElementSibling(_) {
	for (var et, tt = _.prev; tt !== null && !(0, domhandler_1$2.isTag)(tt); ) (et = tt), (tt = et.prev);
	return tt;
}
traversal.prevElementSibling = prevElementSibling;
var manipulation = {};
Object.defineProperty(manipulation, "__esModule", { value: !0 });
manipulation.prepend =
	manipulation.prependChild =
	manipulation.append =
	manipulation.appendChild =
	manipulation.replaceElement =
	manipulation.removeElement =
		void 0;
function removeElement$1(_) {
	if ((_.prev && (_.prev.next = _.next), _.next && (_.next.prev = _.prev), _.parent)) {
		var et = _.parent.children;
		et.splice(et.lastIndexOf(_), 1);
	}
}
manipulation.removeElement = removeElement$1;
function replaceElement$1(_, et) {
	var tt = (et.prev = _.prev);
	tt && (tt.next = et);
	var nt = (et.next = _.next);
	nt && (nt.prev = et);
	var rt = (et.parent = _.parent);
	if (rt) {
		var it = rt.children;
		(it[it.lastIndexOf(_)] = et), (_.parent = null);
	}
}
manipulation.replaceElement = replaceElement$1;
function appendChild(_, et) {
	if ((removeElement$1(et), (et.next = null), (et.parent = _), _.children.push(et) > 1)) {
		var tt = _.children[_.children.length - 2];
		(tt.next = et), (et.prev = tt);
	} else et.prev = null;
}
manipulation.appendChild = appendChild;
function append(_, et) {
	removeElement$1(et);
	var tt = _.parent,
		nt = _.next;
	if (((et.next = nt), (et.prev = _), (_.next = et), (et.parent = tt), nt)) {
		if (((nt.prev = et), tt)) {
			var rt = tt.children;
			rt.splice(rt.lastIndexOf(nt), 0, et);
		}
	} else tt && tt.children.push(et);
}
manipulation.append = append;
function prependChild(_, et) {
	if ((removeElement$1(et), (et.parent = _), (et.prev = null), _.children.unshift(et) !== 1)) {
		var tt = _.children[1];
		(tt.prev = et), (et.next = tt);
	} else et.next = null;
}
manipulation.prependChild = prependChild;
function prepend(_, et) {
	removeElement$1(et);
	var tt = _.parent;
	if (tt) {
		var nt = tt.children;
		nt.splice(nt.indexOf(_), 0, et);
	}
	_.prev && (_.prev.next = et), (et.parent = tt), (et.prev = _.prev), (et.next = _), (_.prev = et);
}
manipulation.prepend = prepend;
var querying = {};
Object.defineProperty(querying, "__esModule", { value: !0 });
querying.findAll =
	querying.existsOne =
	querying.findOne =
	querying.findOneChild =
	querying.find =
	querying.filter =
		void 0;
var domhandler_1$1 = lib$4;
function filter(_, et, tt, nt) {
	return (
		tt === void 0 && (tt = !0), nt === void 0 && (nt = 1 / 0), Array.isArray(et) || (et = [et]), find$1(_, et, tt, nt)
	);
}
querying.filter = filter;
function find$1(_, et, tt, nt) {
	for (var rt = [], it = 0, ot = et; it < ot.length; it++) {
		var at = ot[it];
		if (_(at) && (rt.push(at), --nt <= 0)) break;
		if (tt && (0, domhandler_1$1.hasChildren)(at) && at.children.length > 0) {
			var st = find$1(_, at.children, tt, nt);
			if ((rt.push.apply(rt, st), (nt -= st.length), nt <= 0)) break;
		}
	}
	return rt;
}
querying.find = find$1;
function findOneChild(_, et) {
	return et.find(_);
}
querying.findOneChild = findOneChild;
function findOne(_, et, tt) {
	tt === void 0 && (tt = !0);
	for (var nt = null, rt = 0; rt < et.length && !nt; rt++) {
		var it = et[rt];
		if ((0, domhandler_1$1.isTag)(it))
			_(it) ? (nt = it) : tt && it.children.length > 0 && (nt = findOne(_, it.children, !0));
		else continue;
	}
	return nt;
}
querying.findOne = findOne;
function existsOne(_, et) {
	return et.some(function (tt) {
		return (0, domhandler_1$1.isTag)(tt) && (_(tt) || (tt.children.length > 0 && existsOne(_, tt.children)));
	});
}
querying.existsOne = existsOne;
function findAll(_, et) {
	for (var tt, nt = [], rt = et.filter(domhandler_1$1.isTag), it; (it = rt.shift()); ) {
		var ot = (tt = it.children) === null || tt === void 0 ? void 0 : tt.filter(domhandler_1$1.isTag);
		ot && ot.length > 0 && rt.unshift.apply(rt, ot), _(it) && nt.push(it);
	}
	return nt;
}
querying.findAll = findAll;
var legacy = {};
Object.defineProperty(legacy, "__esModule", { value: !0 });
legacy.getElementsByTagType =
	legacy.getElementsByTagName =
	legacy.getElementById =
	legacy.getElements =
	legacy.testElement =
		void 0;
var domhandler_1 = lib$4,
	querying_js_1 = querying,
	Checks = {
		tag_name: function (_) {
			return typeof _ == "function"
				? function (et) {
						return (0, domhandler_1.isTag)(et) && _(et.name);
				  }
				: _ === "*"
				? domhandler_1.isTag
				: function (et) {
						return (0, domhandler_1.isTag)(et) && et.name === _;
				  };
		},
		tag_type: function (_) {
			return typeof _ == "function"
				? function (et) {
						return _(et.type);
				  }
				: function (et) {
						return et.type === _;
				  };
		},
		tag_contains: function (_) {
			return typeof _ == "function"
				? function (et) {
						return (0, domhandler_1.isText)(et) && _(et.data);
				  }
				: function (et) {
						return (0, domhandler_1.isText)(et) && et.data === _;
				  };
		},
	};
function getAttribCheck(_, et) {
	return typeof et == "function"
		? function (tt) {
				return (0, domhandler_1.isTag)(tt) && et(tt.attribs[_]);
		  }
		: function (tt) {
				return (0, domhandler_1.isTag)(tt) && tt.attribs[_] === et;
		  };
}
function combineFuncs(_, et) {
	return function (tt) {
		return _(tt) || et(tt);
	};
}
function compileTest(_) {
	var et = Object.keys(_).map(function (tt) {
		var nt = _[tt];
		return Object.prototype.hasOwnProperty.call(Checks, tt) ? Checks[tt](nt) : getAttribCheck(tt, nt);
	});
	return et.length === 0 ? null : et.reduce(combineFuncs);
}
function testElement(_, et) {
	var tt = compileTest(_);
	return tt ? tt(et) : !0;
}
legacy.testElement = testElement;
function getElements$1(_, et, tt, nt) {
	nt === void 0 && (nt = 1 / 0);
	var rt = compileTest(_);
	return rt ? (0, querying_js_1.filter)(rt, et, tt, nt) : [];
}
legacy.getElements = getElements$1;
function getElementById(_, et, tt) {
	return (
		tt === void 0 && (tt = !0),
		Array.isArray(et) || (et = [et]),
		(0, querying_js_1.findOne)(getAttribCheck("id", _), et, tt)
	);
}
legacy.getElementById = getElementById;
function getElementsByTagName(_, et, tt, nt) {
	return (
		tt === void 0 && (tt = !0), nt === void 0 && (nt = 1 / 0), (0, querying_js_1.filter)(Checks.tag_name(_), et, tt, nt)
	);
}
legacy.getElementsByTagName = getElementsByTagName;
function getElementsByTagType(_, et, tt, nt) {
	return (
		tt === void 0 && (tt = !0), nt === void 0 && (nt = 1 / 0), (0, querying_js_1.filter)(Checks.tag_type(_), et, tt, nt)
	);
}
legacy.getElementsByTagType = getElementsByTagType;
var helpers = {};
(function (_) {
	Object.defineProperty(_, "__esModule", { value: !0 }),
		(_.uniqueSort = _.compareDocumentPosition = _.DocumentPosition = _.removeSubsets = void 0);
	var et = lib$4;
	function tt(ot) {
		for (var at = ot.length; --at >= 0; ) {
			var st = ot[at];
			if (at > 0 && ot.lastIndexOf(st, at - 1) >= 0) {
				ot.splice(at, 1);
				continue;
			}
			for (var lt = st.parent; lt; lt = lt.parent)
				if (ot.includes(lt)) {
					ot.splice(at, 1);
					break;
				}
		}
		return ot;
	}
	_.removeSubsets = tt;
	var nt;
	(function (ot) {
		(ot[(ot.DISCONNECTED = 1)] = "DISCONNECTED"),
			(ot[(ot.PRECEDING = 2)] = "PRECEDING"),
			(ot[(ot.FOLLOWING = 4)] = "FOLLOWING"),
			(ot[(ot.CONTAINS = 8)] = "CONTAINS"),
			(ot[(ot.CONTAINED_BY = 16)] = "CONTAINED_BY");
	})((nt = _.DocumentPosition || (_.DocumentPosition = {})));
	function rt(ot, at) {
		var st = [],
			lt = [];
		if (ot === at) return 0;
		for (var ut = (0, et.hasChildren)(ot) ? ot : ot.parent; ut; ) st.unshift(ut), (ut = ut.parent);
		for (ut = (0, et.hasChildren)(at) ? at : at.parent; ut; ) lt.unshift(ut), (ut = ut.parent);
		for (var dt = Math.min(st.length, lt.length), ct = 0; ct < dt && st[ct] === lt[ct]; ) ct++;
		if (ct === 0) return nt.DISCONNECTED;
		var ft = st[ct - 1],
			mt = ft.children,
			pt = st[ct],
			vt = lt[ct];
		return mt.indexOf(pt) > mt.indexOf(vt)
			? ft === at
				? nt.FOLLOWING | nt.CONTAINED_BY
				: nt.FOLLOWING
			: ft === ot
			? nt.PRECEDING | nt.CONTAINS
			: nt.PRECEDING;
	}
	_.compareDocumentPosition = rt;
	function it(ot) {
		return (
			(ot = ot.filter(function (at, st, lt) {
				return !lt.includes(at, st + 1);
			})),
			ot.sort(function (at, st) {
				var lt = rt(at, st);
				return lt & nt.PRECEDING ? -1 : lt & nt.FOLLOWING ? 1 : 0;
			}),
			ot
		);
	}
	_.uniqueSort = it;
})(helpers);
var feeds = {};
Object.defineProperty(feeds, "__esModule", { value: !0 });
feeds.getFeed = void 0;
var stringify_js_1 = stringify$2,
	legacy_js_1 = legacy;
function getFeed(_) {
	var et = getOneElement(isValidFeed, _);
	return et ? (et.name === "feed" ? getAtomFeed(et) : getRssFeed(et)) : null;
}
feeds.getFeed = getFeed;
function getAtomFeed(_) {
	var et,
		tt = _.children,
		nt = {
			type: "atom",
			items: (0, legacy_js_1.getElementsByTagName)("entry", tt).map(function (ot) {
				var at,
					st = ot.children,
					lt = { media: getMediaElements(st) };
				addConditionally(lt, "id", "id", st), addConditionally(lt, "title", "title", st);
				var ut = (at = getOneElement("link", st)) === null || at === void 0 ? void 0 : at.attribs.href;
				ut && (lt.link = ut);
				var dt = fetch$2("summary", st) || fetch$2("content", st);
				dt && (lt.description = dt);
				var ct = fetch$2("updated", st);
				return ct && (lt.pubDate = new Date(ct)), lt;
			}),
		};
	addConditionally(nt, "id", "id", tt), addConditionally(nt, "title", "title", tt);
	var rt = (et = getOneElement("link", tt)) === null || et === void 0 ? void 0 : et.attribs.href;
	rt && (nt.link = rt), addConditionally(nt, "description", "subtitle", tt);
	var it = fetch$2("updated", tt);
	return it && (nt.updated = new Date(it)), addConditionally(nt, "author", "email", tt, !0), nt;
}
function getRssFeed(_) {
	var et,
		tt,
		nt =
			(tt = (et = getOneElement("channel", _.children)) === null || et === void 0 ? void 0 : et.children) !== null &&
			tt !== void 0
				? tt
				: [],
		rt = {
			type: _.name.substr(0, 3),
			id: "",
			items: (0, legacy_js_1.getElementsByTagName)("item", _.children).map(function (ot) {
				var at = ot.children,
					st = { media: getMediaElements(at) };
				addConditionally(st, "id", "guid", at),
					addConditionally(st, "title", "title", at),
					addConditionally(st, "link", "link", at),
					addConditionally(st, "description", "description", at);
				var lt = fetch$2("pubDate", at);
				return lt && (st.pubDate = new Date(lt)), st;
			}),
		};
	addConditionally(rt, "title", "title", nt),
		addConditionally(rt, "link", "link", nt),
		addConditionally(rt, "description", "description", nt);
	var it = fetch$2("lastBuildDate", nt);
	return it && (rt.updated = new Date(it)), addConditionally(rt, "author", "managingEditor", nt, !0), rt;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"],
	MEDIA_KEYS_INT = ["fileSize", "bitrate", "framerate", "samplingrate", "channels", "duration", "height", "width"];
function getMediaElements(_) {
	return (0, legacy_js_1.getElementsByTagName)("media:content", _).map(function (et) {
		for (
			var tt = et.attribs, nt = { medium: tt.medium, isDefault: !!tt.isDefault }, rt = 0, it = MEDIA_KEYS_STRING;
			rt < it.length;
			rt++
		) {
			var ot = it[rt];
			tt[ot] && (nt[ot] = tt[ot]);
		}
		for (var at = 0, st = MEDIA_KEYS_INT; at < st.length; at++) {
			var ot = st[at];
			tt[ot] && (nt[ot] = parseInt(tt[ot], 10));
		}
		return tt.expression && (nt.expression = tt.expression), nt;
	});
}
function getOneElement(_, et) {
	return (0, legacy_js_1.getElementsByTagName)(_, et, !0, 1)[0];
}
function fetch$2(_, et, tt) {
	return (
		tt === void 0 && (tt = !1),
		(0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(_, et, tt, 1)).trim()
	);
}
function addConditionally(_, et, tt, nt, rt) {
	rt === void 0 && (rt = !1);
	var it = fetch$2(tt, nt, rt);
	it && (_[et] = it);
}
function isValidFeed(_) {
	return _ === "rss" || _ === "feed" || _ === "rdf:RDF";
}
(function (_) {
	var et =
			(commonjsGlobal && commonjsGlobal.__createBinding) ||
			(Object.create
				? function (rt, it, ot, at) {
						at === void 0 && (at = ot);
						var st = Object.getOwnPropertyDescriptor(it, ot);
						(!st || ("get" in st ? !it.__esModule : st.writable || st.configurable)) &&
							(st = {
								enumerable: !0,
								get: function () {
									return it[ot];
								},
							}),
							Object.defineProperty(rt, at, st);
				  }
				: function (rt, it, ot, at) {
						at === void 0 && (at = ot), (rt[at] = it[ot]);
				  }),
		tt =
			(commonjsGlobal && commonjsGlobal.__exportStar) ||
			function (rt, it) {
				for (var ot in rt) ot !== "default" && !Object.prototype.hasOwnProperty.call(it, ot) && et(it, rt, ot);
			};
	Object.defineProperty(_, "__esModule", { value: !0 }),
		(_.hasChildren = _.isDocument = _.isComment = _.isText = _.isCDATA = _.isTag = void 0),
		tt(stringify$2, _),
		tt(traversal, _),
		tt(manipulation, _),
		tt(querying, _),
		tt(legacy, _),
		tt(helpers, _),
		tt(feeds, _);
	var nt = lib$4;
	Object.defineProperty(_, "isTag", {
		enumerable: !0,
		get: function () {
			return nt.isTag;
		},
	}),
		Object.defineProperty(_, "isCDATA", {
			enumerable: !0,
			get: function () {
				return nt.isCDATA;
			},
		}),
		Object.defineProperty(_, "isText", {
			enumerable: !0,
			get: function () {
				return nt.isText;
			},
		}),
		Object.defineProperty(_, "isComment", {
			enumerable: !0,
			get: function () {
				return nt.isComment;
			},
		}),
		Object.defineProperty(_, "isDocument", {
			enumerable: !0,
			get: function () {
				return nt.isDocument;
			},
		}),
		Object.defineProperty(_, "hasChildren", {
			enumerable: !0,
			get: function () {
				return nt.hasChildren;
			},
		});
})(lib$2);
(function (_) {
	var et =
			(commonjsGlobal && commonjsGlobal.__createBinding) ||
			(Object.create
				? function (mt, pt, vt, ht) {
						ht === void 0 && (ht = vt);
						var gt = Object.getOwnPropertyDescriptor(pt, vt);
						(!gt || ("get" in gt ? !pt.__esModule : gt.writable || gt.configurable)) &&
							(gt = {
								enumerable: !0,
								get: function () {
									return pt[vt];
								},
							}),
							Object.defineProperty(mt, ht, gt);
				  }
				: function (mt, pt, vt, ht) {
						ht === void 0 && (ht = vt), (mt[ht] = pt[vt]);
				  }),
		tt =
			(commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
			(Object.create
				? function (mt, pt) {
						Object.defineProperty(mt, "default", { enumerable: !0, value: pt });
				  }
				: function (mt, pt) {
						mt.default = pt;
				  }),
		nt =
			(commonjsGlobal && commonjsGlobal.__importStar) ||
			function (mt) {
				if (mt && mt.__esModule) return mt;
				var pt = {};
				if (mt != null)
					for (var vt in mt) vt !== "default" && Object.prototype.hasOwnProperty.call(mt, vt) && et(pt, mt, vt);
				return tt(pt, mt), pt;
			},
		rt =
			(commonjsGlobal && commonjsGlobal.__importDefault) ||
			function (mt) {
				return mt && mt.__esModule ? mt : { default: mt };
			};
	Object.defineProperty(_, "__esModule", { value: !0 }),
		(_.DefaultHandler =
			_.DomUtils =
			_.parseFeed =
			_.getFeed =
			_.ElementType =
			_.Tokenizer =
			_.createDomStream =
			_.parseDOM =
			_.parseDocument =
			_.DomHandler =
			_.Parser =
				void 0);
	var it = Parser$1;
	Object.defineProperty(_, "Parser", {
		enumerable: !0,
		get: function () {
			return it.Parser;
		},
	});
	var ot = lib$4;
	Object.defineProperty(_, "DomHandler", {
		enumerable: !0,
		get: function () {
			return ot.DomHandler;
		},
	}),
		Object.defineProperty(_, "DefaultHandler", {
			enumerable: !0,
			get: function () {
				return ot.DomHandler;
			},
		});
	function at(mt, pt) {
		var vt = new ot.DomHandler(void 0, pt);
		return new it.Parser(vt, pt).end(mt), vt.root;
	}
	_.parseDocument = at;
	function st(mt, pt) {
		return at(mt, pt).children;
	}
	_.parseDOM = st;
	function lt(mt, pt, vt) {
		var ht = new ot.DomHandler(mt, pt, vt);
		return new it.Parser(ht, pt);
	}
	_.createDomStream = lt;
	var ut = Tokenizer;
	Object.defineProperty(_, "Tokenizer", {
		enumerable: !0,
		get: function () {
			return rt(ut).default;
		},
	});
	var dt = nt(lib$3);
	_.ElementType = dt;
	var ct = lib$2;
	Object.defineProperty(_, "getFeed", {
		enumerable: !0,
		get: function () {
			return ct.getFeed;
		},
	});
	function ft(mt, pt) {
		return pt === void 0 && (pt = { xmlMode: !0 }), (0, ct.getFeed)(st(mt, pt));
	}
	(_.parseFeed = ft), (_.DomUtils = nt(lib$2));
})(lib$5);
function shouldProcessEveryNode(_) {
	return !0;
}
var shouldProcessNodeDefinitions = { shouldProcessEveryNode },
	INFINITY = 1 / 0,
	symbolTag = "[object Symbol]",
	reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
	reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
	rsAstralRange = "\\ud800-\\udfff",
	rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23",
	rsComboSymbolsRange = "\\u20d0-\\u20f0",
	rsDingbatRange = "\\u2700-\\u27bf",
	rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
	rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
	rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
	rsPunctuationRange = "\\u2000-\\u206f",
	rsSpaceRange =
		" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
	rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
	rsVarRange = "\\ufe0e\\ufe0f",
	rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange,
	rsApos = "['\u2019]",
	rsAstral = "[" + rsAstralRange + "]",
	rsBreak = "[" + rsBreakRange + "]",
	rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]",
	rsDigits = "\\d+",
	rsDingbat = "[" + rsDingbatRange + "]",
	rsLower = "[" + rsLowerRange + "]",
	rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]",
	rsFitz = "\\ud83c[\\udffb-\\udfff]",
	rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
	rsNonAstral = "[^" + rsAstralRange + "]",
	rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
	rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
	rsUpper = "[" + rsUpperRange + "]",
	rsZWJ = "\\u200d",
	rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")",
	rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")",
	rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
	rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
	reOptMod = rsModifier + "?",
	rsOptVar = "[" + rsVarRange + "]?",
	rsOptJoin =
		"(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*",
	rsSeq = rsOptVar + reOptMod + rsOptJoin,
	rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
	rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")",
	reApos = RegExp(rsApos, "g"),
	reComboMark = RegExp(rsCombo, "g"),
	reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"),
	reUnicodeWord = RegExp(
		[
			rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
			rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
			rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
			rsUpper + "+" + rsOptUpperContr,
			rsDigits,
			rsEmoji,
		].join("|"),
		"g"
	),
	reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]"),
	reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
	deburredLetters = {
		À: "A",
		Á: "A",
		Â: "A",
		Ã: "A",
		Ä: "A",
		Å: "A",
		à: "a",
		á: "a",
		â: "a",
		ã: "a",
		ä: "a",
		å: "a",
		Ç: "C",
		ç: "c",
		Ð: "D",
		ð: "d",
		È: "E",
		É: "E",
		Ê: "E",
		Ë: "E",
		è: "e",
		é: "e",
		ê: "e",
		ë: "e",
		Ì: "I",
		Í: "I",
		Î: "I",
		Ï: "I",
		ì: "i",
		í: "i",
		î: "i",
		ï: "i",
		Ñ: "N",
		ñ: "n",
		Ò: "O",
		Ó: "O",
		Ô: "O",
		Õ: "O",
		Ö: "O",
		Ø: "O",
		ò: "o",
		ó: "o",
		ô: "o",
		õ: "o",
		ö: "o",
		ø: "o",
		Ù: "U",
		Ú: "U",
		Û: "U",
		Ü: "U",
		ù: "u",
		ú: "u",
		û: "u",
		ü: "u",
		Ý: "Y",
		ý: "y",
		ÿ: "y",
		Æ: "Ae",
		æ: "ae",
		Þ: "Th",
		þ: "th",
		ß: "ss",
		Ā: "A",
		Ă: "A",
		Ą: "A",
		ā: "a",
		ă: "a",
		ą: "a",
		Ć: "C",
		Ĉ: "C",
		Ċ: "C",
		Č: "C",
		ć: "c",
		ĉ: "c",
		ċ: "c",
		č: "c",
		Ď: "D",
		Đ: "D",
		ď: "d",
		đ: "d",
		Ē: "E",
		Ĕ: "E",
		Ė: "E",
		Ę: "E",
		Ě: "E",
		ē: "e",
		ĕ: "e",
		ė: "e",
		ę: "e",
		ě: "e",
		Ĝ: "G",
		Ğ: "G",
		Ġ: "G",
		Ģ: "G",
		ĝ: "g",
		ğ: "g",
		ġ: "g",
		ģ: "g",
		Ĥ: "H",
		Ħ: "H",
		ĥ: "h",
		ħ: "h",
		Ĩ: "I",
		Ī: "I",
		Ĭ: "I",
		Į: "I",
		İ: "I",
		ĩ: "i",
		ī: "i",
		ĭ: "i",
		į: "i",
		ı: "i",
		Ĵ: "J",
		ĵ: "j",
		Ķ: "K",
		ķ: "k",
		ĸ: "k",
		Ĺ: "L",
		Ļ: "L",
		Ľ: "L",
		Ŀ: "L",
		Ł: "L",
		ĺ: "l",
		ļ: "l",
		ľ: "l",
		ŀ: "l",
		ł: "l",
		Ń: "N",
		Ņ: "N",
		Ň: "N",
		Ŋ: "N",
		ń: "n",
		ņ: "n",
		ň: "n",
		ŋ: "n",
		Ō: "O",
		Ŏ: "O",
		Ő: "O",
		ō: "o",
		ŏ: "o",
		ő: "o",
		Ŕ: "R",
		Ŗ: "R",
		Ř: "R",
		ŕ: "r",
		ŗ: "r",
		ř: "r",
		Ś: "S",
		Ŝ: "S",
		Ş: "S",
		Š: "S",
		ś: "s",
		ŝ: "s",
		ş: "s",
		š: "s",
		Ţ: "T",
		Ť: "T",
		Ŧ: "T",
		ţ: "t",
		ť: "t",
		ŧ: "t",
		Ũ: "U",
		Ū: "U",
		Ŭ: "U",
		Ů: "U",
		Ű: "U",
		Ų: "U",
		ũ: "u",
		ū: "u",
		ŭ: "u",
		ů: "u",
		ű: "u",
		ų: "u",
		Ŵ: "W",
		ŵ: "w",
		Ŷ: "Y",
		ŷ: "y",
		Ÿ: "Y",
		Ź: "Z",
		Ż: "Z",
		Ž: "Z",
		ź: "z",
		ż: "z",
		ž: "z",
		Ĳ: "IJ",
		ĳ: "ij",
		Œ: "Oe",
		œ: "oe",
		ŉ: "'n",
		ſ: "ss",
	},
	freeGlobal =
		typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal,
	freeSelf = typeof self == "object" && self && self.Object === Object && self,
	root$1 = freeGlobal || freeSelf || Function("return this")();
function arrayReduce(_, et, tt, nt) {
	var rt = -1,
		it = _ ? _.length : 0;
	for (nt && it && (tt = _[++rt]); ++rt < it; ) tt = et(tt, _[rt], rt, _);
	return tt;
}
function asciiToArray(_) {
	return _.split("");
}
function asciiWords(_) {
	return _.match(reAsciiWord) || [];
}
function basePropertyOf(_) {
	return function (et) {
		return _ == null ? void 0 : _[et];
	};
}
var deburrLetter = basePropertyOf(deburredLetters);
function hasUnicode(_) {
	return reHasUnicode.test(_);
}
function hasUnicodeWord(_) {
	return reHasUnicodeWord.test(_);
}
function stringToArray(_) {
	return hasUnicode(_) ? unicodeToArray(_) : asciiToArray(_);
}
function unicodeToArray(_) {
	return _.match(reUnicode) || [];
}
function unicodeWords(_) {
	return _.match(reUnicodeWord) || [];
}
var objectProto = Object.prototype,
	objectToString = objectProto.toString,
	Symbol$1 = root$1.Symbol,
	symbolProto = Symbol$1 ? Symbol$1.prototype : void 0,
	symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseSlice(_, et, tt) {
	var nt = -1,
		rt = _.length;
	et < 0 && (et = -et > rt ? 0 : rt + et),
		(tt = tt > rt ? rt : tt),
		tt < 0 && (tt += rt),
		(rt = et > tt ? 0 : (tt - et) >>> 0),
		(et >>>= 0);
	for (var it = Array(rt); ++nt < rt; ) it[nt] = _[nt + et];
	return it;
}
function baseToString(_) {
	if (typeof _ == "string") return _;
	if (isSymbol(_)) return symbolToString ? symbolToString.call(_) : "";
	var et = _ + "";
	return et == "0" && 1 / _ == -INFINITY ? "-0" : et;
}
function castSlice(_, et, tt) {
	var nt = _.length;
	return (tt = tt === void 0 ? nt : tt), !et && tt >= nt ? _ : baseSlice(_, et, tt);
}
function createCaseFirst(_) {
	return function (et) {
		et = toString$1(et);
		var tt = hasUnicode(et) ? stringToArray(et) : void 0,
			nt = tt ? tt[0] : et.charAt(0),
			rt = tt ? castSlice(tt, 1).join("") : et.slice(1);
		return nt[_]() + rt;
	};
}
function createCompounder(_) {
	return function (et) {
		return arrayReduce(words(deburr(et).replace(reApos, "")), _, "");
	};
}
function isObjectLike(_) {
	return !!_ && typeof _ == "object";
}
function isSymbol(_) {
	return typeof _ == "symbol" || (isObjectLike(_) && objectToString.call(_) == symbolTag);
}
function toString$1(_) {
	return _ == null ? "" : baseToString(_);
}
var camelCase$1 = createCompounder(function (_, et, tt) {
	return (et = et.toLowerCase()), _ + (tt ? capitalize(et) : et);
});
function capitalize(_) {
	return upperFirst(toString$1(_).toLowerCase());
}
function deburr(_) {
	return (_ = toString$1(_)), _ && _.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var upperFirst = createCaseFirst("toUpperCase");
function words(_, et, tt) {
	return (
		(_ = toString$1(_)),
		(et = tt ? void 0 : et),
		et === void 0 ? (hasUnicodeWord(_) ? unicodeWords(_) : asciiWords(_)) : _.match(et) || []
	);
}
var lodash_camelcase = camelCase$1;
const HTML_ATTRIBUTES = [
		"accept",
		"acceptCharset",
		"accessKey",
		"action",
		"allowFullScreen",
		"allowTransparency",
		"alt",
		"async",
		"autoComplete",
		"autoFocus",
		"autoPlay",
		"capture",
		"cellPadding",
		"cellSpacing",
		"challenge",
		"charSet",
		"checked",
		"cite",
		"classID",
		"className",
		"colSpan",
		"cols",
		"content",
		"contentEditable",
		"contextMenu",
		"controls",
		"coords",
		"crossOrigin",
		"data",
		"dateTime",
		"default",
		"defer",
		"dir",
		"disabled",
		"download",
		"draggable",
		"encType",
		"form",
		"formAction",
		"formEncType",
		"formMethod",
		"formNoValidate",
		"formTarget",
		"frameBorder",
		"headers",
		"height",
		"hidden",
		"high",
		"href",
		"hrefLang",
		"htmlFor",
		"httpEquiv",
		"icon",
		"id",
		"inputMode",
		"integrity",
		"is",
		"keyParams",
		"keyType",
		"kind",
		"label",
		"lang",
		"list",
		"loop",
		"low",
		"manifest",
		"marginHeight",
		"marginWidth",
		"max",
		"maxLength",
		"media",
		"mediaGroup",
		"method",
		"min",
		"minLength",
		"multiple",
		"muted",
		"name",
		"noValidate",
		"nonce",
		"open",
		"optimum",
		"pattern",
		"placeholder",
		"poster",
		"preload",
		"profile",
		"radioGroup",
		"readOnly",
		"rel",
		"required",
		"reversed",
		"role",
		"rowSpan",
		"rows",
		"sandbox",
		"scope",
		"scoped",
		"scrolling",
		"seamless",
		"selected",
		"shape",
		"size",
		"sizes",
		"span",
		"spellCheck",
		"src",
		"srcDoc",
		"srcLang",
		"srcSet",
		"start",
		"step",
		"style",
		"summary",
		"tabIndex",
		"target",
		"title",
		"type",
		"useMap",
		"value",
		"width",
		"wmode",
		"wrap",
		"onClick",
	],
	NON_STANDARD_ATTRIBUTES = [
		"autoCapitalize",
		"autoCorrect",
		"color",
		"itemProp",
		"itemScope",
		"itemType",
		"itemRef",
		"itemID",
		"security",
		"unselectable",
		"results",
		"autoSave",
	],
	SVG_ATTRIBUTES = [
		"accentHeight",
		"accumulate",
		"additive",
		"alignmentBaseline",
		"allowReorder",
		"alphabetic",
		"amplitude",
		"arabicForm",
		"ascent",
		"attributeName",
		"attributeType",
		"autoReverse",
		"azimuth",
		"baseFrequency",
		"baseProfile",
		"baselineShift",
		"bbox",
		"begin",
		"bias",
		"by",
		"calcMode",
		"capHeight",
		"clip",
		"clipPath",
		"clipPathUnits",
		"clipRule",
		"colorInterpolation",
		"colorInterpolationFilters",
		"colorProfile",
		"colorRendering",
		"contentScriptType",
		"contentStyleType",
		"cursor",
		"cx",
		"cy",
		"d",
		"decelerate",
		"descent",
		"diffuseConstant",
		"direction",
		"display",
		"divisor",
		"dominantBaseline",
		"dur",
		"dx",
		"dy",
		"edgeMode",
		"elevation",
		"enableBackground",
		"end",
		"exponent",
		"externalResourcesRequired",
		"fill",
		"fillOpacity",
		"fillRule",
		"filter",
		"filterRes",
		"filterUnits",
		"floodColor",
		"floodOpacity",
		"focusable",
		"fontFamily",
		"fontSize",
		"fontSizeAdjust",
		"fontStretch",
		"fontStyle",
		"fontVariant",
		"fontWeight",
		"format",
		"from",
		"fx",
		"fy",
		"g1",
		"g2",
		"glyphName",
		"glyphOrientationHorizontal",
		"glyphOrientationVertical",
		"glyphRef",
		"gradientTransform",
		"gradientUnits",
		"hanging",
		"horizAdvX",
		"horizOriginX",
		"ideographic",
		"imageRendering",
		"in",
		"in2",
		"intercept",
		"k",
		"k1",
		"k2",
		"k3",
		"k4",
		"kernelMatrix",
		"kernelUnitLength",
		"kerning",
		"keyPoints",
		"keySplines",
		"keyTimes",
		"lengthAdjust",
		"letterSpacing",
		"lightingColor",
		"limitingConeAngle",
		"local",
		"markerEnd",
		"markerHeight",
		"markerMid",
		"markerStart",
		"markerUnits",
		"markerWidth",
		"mask",
		"maskContentUnits",
		"maskUnits",
		"mathematical",
		"mode",
		"numOctaves",
		"offset",
		"opacity",
		"operator",
		"order",
		"orient",
		"orientation",
		"origin",
		"overflow",
		"overlinePosition",
		"overlineThickness",
		"paintOrder",
		"panose1",
		"pathLength",
		"patternContentUnits",
		"patternTransform",
		"patternUnits",
		"pointerEvents",
		"points",
		"pointsAtX",
		"pointsAtY",
		"pointsAtZ",
		"preserveAlpha",
		"preserveAspectRatio",
		"primitiveUnits",
		"r",
		"radius",
		"refX",
		"refY",
		"renderingIntent",
		"repeatCount",
		"repeatDur",
		"requiredExtensions",
		"requiredFeatures",
		"restart",
		"result",
		"rotate",
		"rx",
		"ry",
		"scale",
		"seed",
		"shapeRendering",
		"slope",
		"spacing",
		"specularConstant",
		"specularExponent",
		"speed",
		"spreadMethod",
		"startOffset",
		"stdDeviation",
		"stemh",
		"stemv",
		"stitchTiles",
		"stopColor",
		"stopOpacity",
		"strikethroughPosition",
		"strikethroughThickness",
		"string",
		"stroke",
		"strokeDasharray",
		"strokeDashoffset",
		"strokeLinecap",
		"strokeLinejoin",
		"strokeMiterlimit",
		"strokeOpacity",
		"strokeWidth",
		"surfaceScale",
		"systemLanguage",
		"tableValues",
		"targetX",
		"targetY",
		"textAnchor",
		"textDecoration",
		"textLength",
		"textRendering",
		"to",
		"transform",
		"u1",
		"u2",
		"underlinePosition",
		"underlineThickness",
		"unicode",
		"unicodeBidi",
		"unicodeRange",
		"unitsPerEm",
		"vAlphabetic",
		"vHanging",
		"vIdeographic",
		"vMathematical",
		"values",
		"vectorEffect",
		"version",
		"vertAdvY",
		"vertOriginX",
		"vertOriginY",
		"viewBox",
		"viewTarget",
		"visibility",
		"widths",
		"wordSpacing",
		"writingMode",
		"x",
		"x1",
		"x2",
		"xChannelSelector",
		"xHeight",
		"xlinkActuate",
		"xlinkArcrole",
		"xlinkHref",
		"xlinkRole",
		"xlinkShow",
		"xlinkTitle",
		"xlinkType",
		"xmlns",
		"xmlnsXlink",
		"xmlBase",
		"xmlLang",
		"xmlSpace",
		"y",
		"y1",
		"y2",
		"yChannelSelector",
		"z",
		"zoomAndPan",
	],
	camelCaseMap = HTML_ATTRIBUTES.concat(NON_STANDARD_ATTRIBUTES)
		.concat(SVG_ATTRIBUTES)
		.reduce(function (_, et) {
			const tt = et.toLowerCase();
			return tt !== et && (_[tt] = et), _;
		}, {});
var camelCaseAttributeNames = camelCaseMap;
const camelCase = lodash_camelcase,
	React = react.exports,
	camelCaseAttrMap = camelCaseAttributeNames;
function createStyleJsonFromString(_) {
	_ = _ || "";
	const et = _.split(/;(?!base64)/);
	let tt,
		nt,
		rt,
		it = {};
	for (let ot = 0; ot < et.length; ++ot)
		(tt = et[ot].split(":")),
			tt.length > 2 && (tt[1] = tt.slice(1).join(":")),
			(nt = tt[0]),
			(rt = tt[1]),
			typeof rt == "string" && (rt = rt.trim()),
			nt != null && rt != null && nt.length > 0 && rt.length > 0 && (it[camelCase(nt)] = rt);
	return it;
}
const booleanAttrs = [
	"allowFullScreen",
	"allowpaymentrequest",
	"async",
	"autoFocus",
	"autoPlay",
	"checked",
	"controls",
	"default",
	"disabled",
	"formNoValidate",
	"hidden",
	"ismap",
	"itemScope",
	"loop",
	"multiple",
	"muted",
	"nomodule",
	"noValidate",
	"open",
	"playsinline",
	"readOnly",
	"required",
	"reversed",
	"selected",
	"truespeed",
];
function createElement$1(_, et, tt, nt) {
	let rt = { key: et };
	_.attribs &&
		(rt = Object.entries(_.attribs).reduce(
			(ot, [at, st]) => (
				(at = camelCaseAttrMap[at.replace(/[-:]/, "")] || at),
				at === "style"
					? (st = createStyleJsonFromString(st))
					: at === "class"
					? (at = "className")
					: at === "for"
					? (at = "htmlFor")
					: at.startsWith("on") && (st = Function(st)),
				booleanAttrs.includes(at) && (st || "") === "" && (st = at),
				(ot[at] = st),
				ot
			),
			rt
		)),
		(nt = nt || []);
	const it = tt != null ? [tt].concat(nt) : nt;
	return React.createElement.apply(null, [_.name, rt].concat(it));
}
var utils$2 = { createElement: createElement$1 };
const utils$1 = utils$2,
	voidElementTags = [
		"area",
		"base",
		"br",
		"col",
		"embed",
		"hr",
		"img",
		"input",
		"keygen",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
		"menuitem",
		"textarea",
	];
function ProcessNodeDefinitions$1() {
	function _(et, tt, nt) {
		return et.type === "text"
			? et.data
			: et.type === "comment"
			? !1
			: voidElementTags.indexOf(et.name) > -1
			? utils$1.createElement(et, nt)
			: utils$1.createElement(et, nt, et.data, tt);
	}
	return { processDefaultNode: _ };
}
var processNodeDefinitions$1 = ProcessNodeDefinitions$1;
const ShouldProcessNodeDefinitions = shouldProcessNodeDefinitions,
	ProcessNodeDefinitions = processNodeDefinitions$1;
function ProcessingInstructions$1() {
	const _ = new ProcessNodeDefinitions();
	return {
		defaultProcessingInstructions: [
			{ shouldProcessNode: ShouldProcessNodeDefinitions.shouldProcessEveryNode, processNode: _.processDefaultNode },
		],
	};
}
var processingInstructions$1 = ProcessingInstructions$1;
function alwaysValid() {
	return !0;
}
var isValidNodeDefinitions$1 = { alwaysValid };
const HtmlParser = lib$5.Parser,
	DomHandler = lib$4.DomHandler,
	ProcessingInstructions = processingInstructions$1,
	IsValidNodeDefinitions = isValidNodeDefinitions$1,
	utils = utils$2;
function Html2ReactParser(_) {
	function et(it) {
		(_ = _ || {}), (_.decodeEntities = !0);
		const ot = new DomHandler();
		return (
			new HtmlParser(ot, _).parseComplete(it),
			ot.dom.filter(function (st) {
				return st.type !== "directive";
			})
		);
	}
	function tt(it, ot, at, st, lt) {
		if (ot(it)) {
			(st || []).forEach((dt) => {
				dt.shouldPreprocessNode(it) && dt.preprocessNode(it, lt);
			});
			const ut = (at || []).find((dt) => dt.shouldProcessNode(it));
			if (ut != null) {
				const dt = (it.children || []).map((ct, ft) => tt(ct, ot, at, st, ft)).filter((ct) => ct != null && ct !== !1);
				return ut.replaceChildren
					? utils.createElement(it, lt, it.data, [ut.processNode(it, dt, lt)])
					: ut.processNode(it, dt, lt);
			} else return !1;
		} else return !1;
	}
	function nt(it, ot, at, st) {
		const ut = et(it).map(function (dt, ct) {
			return tt(dt, ot, at, st, ct);
		});
		return ut.length <= 1 ? ut[0] : ut;
	}
	function rt(it) {
		const ot = new ProcessingInstructions();
		return nt(it, IsValidNodeDefinitions.alwaysValid, ot.defaultProcessingInstructions);
	}
	return { parse: rt, parseWithInstructions: nt };
}
var parser$1 = Html2ReactParser;
const parser = parser$1,
	processingInstructions = processingInstructions$1,
	isValidNodeDefinitions = isValidNodeDefinitions$1,
	processNodeDefinitions = processNodeDefinitions$1;
var htmlToReact = {
	Parser: parser,
	ProcessingInstructions: processingInstructions,
	IsValidNodeDefinitions: isValidNodeDefinitions,
	ProcessNodeDefinitions: processNodeDefinitions,
};
function SlideEx({ short: _, description: et }) {
	const { isOpen: tt, onToggle: nt } = useDisclosure$1();
	return jsxs(Box, {
		w: "100%",
		children: [
			jsxs(Heading, {
				onClick: nt,
				cursor: "pointer",
				size: "sm",
				w: "100%",
				color: useColorModeValue("gray.600", "gray.300"),
				background: useColorModeValue("gray.100", "gray.700"),
				p: 2,
				borderRadius: "5px",
				_hover: { background: useColorModeValue("gray.200", "gray.600") },
				transition: ".3s ease",
				children: [" ", _],
			}),
			jsx(Collapse, {
				in: tt,
				animateOpacityw: "100%",
				children: jsx(Box, {
					p: "40px",
					color: useColorModeValue("gray.800", "gray.200"),
					mt: "4",
					bg: useColorModeValue("gray.100", "gray.700"),
					rounded: "md",
					shadow: "md",
					children: et,
				}),
			}),
		],
	});
}
function StepDescription({ short: _, description: et }) {
	return jsx(Fragment, {
		children: jsx(Flex, {
			boxShadow: "lg",
			maxW: "640px",
			direction: { base: "column-reverse", md: "row" },
			width: "100%",
			rounded: "xl",
			p: 5,
			mb: 4,
			justifyContent: "space-between",
			position: "relative",
			bg: useColorModeValue("white", "gray.800"),
			_after: {
				content: '""',
				position: "absolute",
				height: "21px",
				width: "29px",
				left: "35px",
				top: "-10px",
				backgroundSize: "cover",
			},
			_before: {
				content: '""',
				position: "absolute",
				zIndex: "-1",
				height: "full",
				maxW: "640px",
				width: "full",
				filter: "blur(40px)",
				transform: "scale(0.98)",
				backgroundRepeat: "no-repeat",
				backgroundSize: "cover",
				top: 0,
				left: 0,
			},
			children: jsxs(Flex, {
				direction: "column",
				textAlign: "left",
				justifyContent: "space-between",
				width: "100%",
				children: [
					jsx(Heading, {
						size: "sm",
						color: useColorModeValue("gray.800", "gray.100"),
						pb: 2,
						children: "Description",
					}),
					jsx(SlideEx, { short: _, description: htmlToReact.Parser().parse(et) }),
				],
			}),
		}),
	});
}
function _defineProperty$1(_, et, tt) {
	return (
		et in _
			? Object.defineProperty(_, et, { value: tt, enumerable: !0, configurable: !0, writable: !0 })
			: (_[et] = tt),
		_
	);
}
function _classCallCheck(_, et) {
	if (!(_ instanceof et)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(_, et) {
	for (var tt = 0; tt < et.length; tt++) {
		var nt = et[tt];
		(nt.enumerable = nt.enumerable || !1),
			(nt.configurable = !0),
			"value" in nt && (nt.writable = !0),
			Object.defineProperty(_, nt.key, nt);
	}
}
function _createClass(_, et, tt) {
	return et && _defineProperties(_.prototype, et), tt && _defineProperties(_, tt), _;
}
function _defineProperty(_, et, tt) {
	return (
		et in _
			? Object.defineProperty(_, et, { value: tt, enumerable: !0, configurable: !0, writable: !0 })
			: (_[et] = tt),
		_
	);
}
function ownKeys(_, et) {
	var tt = Object.keys(_);
	if (Object.getOwnPropertySymbols) {
		var nt = Object.getOwnPropertySymbols(_);
		et &&
			(nt = nt.filter(function (rt) {
				return Object.getOwnPropertyDescriptor(_, rt).enumerable;
			})),
			tt.push.apply(tt, nt);
	}
	return tt;
}
function _objectSpread2(_) {
	for (var et = 1; et < arguments.length; et++) {
		var tt = arguments[et] != null ? arguments[et] : {};
		et % 2
			? ownKeys(Object(tt), !0).forEach(function (nt) {
					_defineProperty(_, nt, tt[nt]);
			  })
			: Object.getOwnPropertyDescriptors
			? Object.defineProperties(_, Object.getOwnPropertyDescriptors(tt))
			: ownKeys(Object(tt)).forEach(function (nt) {
					Object.defineProperty(_, nt, Object.getOwnPropertyDescriptor(tt, nt));
			  });
	}
	return _;
}
var defaults$1 = { addCSS: !0, thumbWidth: 15, watch: !0 };
function matches$1(_, et) {
	return function () {
		return Array.from(document.querySelectorAll(et)).includes(this);
	}.call(_, et);
}
function trigger(_, et) {
	if (_ && et) {
		var tt = new Event(et, { bubbles: !0 });
		_.dispatchEvent(tt);
	}
}
var getConstructor$1 = function (_) {
		return _ != null ? _.constructor : null;
	},
	instanceOf$1 = function (_, et) {
		return !!(_ && et && _ instanceof et);
	},
	isNullOrUndefined$1 = function (_) {
		return _ == null;
	},
	isObject$1 = function (_) {
		return getConstructor$1(_) === Object;
	},
	isNumber$1 = function (_) {
		return getConstructor$1(_) === Number && !Number.isNaN(_);
	},
	isString$1 = function (_) {
		return getConstructor$1(_) === String;
	},
	isBoolean$1 = function (_) {
		return getConstructor$1(_) === Boolean;
	},
	isFunction$1 = function (_) {
		return getConstructor$1(_) === Function;
	},
	isArray$1 = function (_) {
		return Array.isArray(_);
	},
	isNodeList$1 = function (_) {
		return instanceOf$1(_, NodeList);
	},
	isElement$1 = function (_) {
		return instanceOf$1(_, Element);
	},
	isEvent$1 = function (_) {
		return instanceOf$1(_, Event);
	},
	isEmpty$1 = function (_) {
		return (
			isNullOrUndefined$1(_) ||
			((isString$1(_) || isArray$1(_) || isNodeList$1(_)) && !_.length) ||
			(isObject$1(_) && !Object.keys(_).length)
		);
	},
	is$1 = {
		nullOrUndefined: isNullOrUndefined$1,
		object: isObject$1,
		number: isNumber$1,
		string: isString$1,
		boolean: isBoolean$1,
		function: isFunction$1,
		array: isArray$1,
		nodeList: isNodeList$1,
		element: isElement$1,
		event: isEvent$1,
		empty: isEmpty$1,
	};
function getDecimalPlaces(_) {
	var et = "".concat(_).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
	return et ? Math.max(0, (et[1] ? et[1].length : 0) - (et[2] ? +et[2] : 0)) : 0;
}
function round(_, et) {
	if (1 > et) {
		var tt = getDecimalPlaces(et);
		return parseFloat(_.toFixed(tt));
	}
	return Math.round(_ / et) * et;
}
var RangeTouch = (function () {
	function _(et, tt) {
		_classCallCheck(this, _),
			is$1.element(et) ? (this.element = et) : is$1.string(et) && (this.element = document.querySelector(et)),
			is$1.element(this.element) &&
				is$1.empty(this.element.rangeTouch) &&
				((this.config = _objectSpread2({}, defaults$1, {}, tt)), this.init());
	}
	return (
		_createClass(
			_,
			[
				{
					key: "init",
					value: function () {
						_.enabled &&
							(this.config.addCSS &&
								((this.element.style.userSelect = "none"),
								(this.element.style.webKitUserSelect = "none"),
								(this.element.style.touchAction = "manipulation")),
							this.listeners(!0),
							(this.element.rangeTouch = this));
					},
				},
				{
					key: "destroy",
					value: function () {
						_.enabled &&
							(this.config.addCSS &&
								((this.element.style.userSelect = ""),
								(this.element.style.webKitUserSelect = ""),
								(this.element.style.touchAction = "")),
							this.listeners(!1),
							(this.element.rangeTouch = null));
					},
				},
				{
					key: "listeners",
					value: function (et) {
						var tt = this,
							nt = et ? "addEventListener" : "removeEventListener";
						["touchstart", "touchmove", "touchend"].forEach(function (rt) {
							tt.element[nt](
								rt,
								function (it) {
									return tt.set(it);
								},
								!1
							);
						});
					},
				},
				{
					key: "get",
					value: function (et) {
						if (!_.enabled || !is$1.event(et)) return null;
						var tt,
							nt = et.target,
							rt = et.changedTouches[0],
							it = parseFloat(nt.getAttribute("min")) || 0,
							ot = parseFloat(nt.getAttribute("max")) || 100,
							at = parseFloat(nt.getAttribute("step")) || 1,
							st = nt.getBoundingClientRect(),
							lt = ((100 / st.width) * (this.config.thumbWidth / 2)) / 100;
						return (
							0 > (tt = (100 / st.width) * (rt.clientX - st.left)) ? (tt = 0) : 100 < tt && (tt = 100),
							50 > tt ? (tt -= (100 - 2 * tt) * lt) : 50 < tt && (tt += 2 * (tt - 50) * lt),
							it + round((tt / 100) * (ot - it), at)
						);
					},
				},
				{
					key: "set",
					value: function (et) {
						_.enabled &&
							is$1.event(et) &&
							!et.target.disabled &&
							(et.preventDefault(),
							(et.target.value = this.get(et)),
							trigger(et.target, et.type === "touchend" ? "change" : "input"));
					},
				},
			],
			[
				{
					key: "setup",
					value: function (et) {
						var tt = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {},
							nt = null;
						if (
							(is$1.empty(et) || is$1.string(et)
								? (nt = Array.from(document.querySelectorAll(is$1.string(et) ? et : 'input[type="range"]')))
								: is$1.element(et)
								? (nt = [et])
								: is$1.nodeList(et)
								? (nt = Array.from(et))
								: is$1.array(et) && (nt = et.filter(is$1.element)),
							is$1.empty(nt))
						)
							return null;
						var rt = _objectSpread2({}, defaults$1, {}, tt);
						if (is$1.string(et) && rt.watch) {
							var it = new MutationObserver(function (ot) {
								Array.from(ot).forEach(function (at) {
									Array.from(at.addedNodes).forEach(function (st) {
										is$1.element(st) && matches$1(st, et) && new _(st, rt);
									});
								});
							});
							it.observe(document.body, { childList: !0, subtree: !0 });
						}
						return nt.map(function (ot) {
							return new _(ot, tt);
						});
					},
				},
				{
					key: "enabled",
					get: function () {
						return "ontouchstart" in document.documentElement;
					},
				},
			]
		),
		_
	);
})();
const getConstructor = (_) => (_ != null ? _.constructor : null),
	instanceOf = (_, et) => Boolean(_ && et && _ instanceof et),
	isNullOrUndefined = (_) => _ == null,
	isObject = (_) => getConstructor(_) === Object,
	isNumber = (_) => getConstructor(_) === Number && !Number.isNaN(_),
	isString = (_) => getConstructor(_) === String,
	isBoolean = (_) => getConstructor(_) === Boolean,
	isFunction = (_) => typeof _ == "function",
	isArray$2 = (_) => Array.isArray(_),
	isWeakMap = (_) => instanceOf(_, WeakMap),
	isNodeList = (_) => instanceOf(_, NodeList),
	isTextNode = (_) => getConstructor(_) === Text,
	isEvent = (_) => instanceOf(_, Event),
	isKeyboardEvent = (_) => instanceOf(_, KeyboardEvent),
	isCue = (_) => instanceOf(_, window.TextTrackCue) || instanceOf(_, window.VTTCue),
	isTrack = (_) => instanceOf(_, TextTrack) || (!isNullOrUndefined(_) && isString(_.kind)),
	isPromise = (_) => instanceOf(_, Promise) && isFunction(_.then),
	isElement = (_) =>
		_ !== null &&
		typeof _ == "object" &&
		_.nodeType === 1 &&
		typeof _.style == "object" &&
		typeof _.ownerDocument == "object",
	isEmpty = (_) =>
		isNullOrUndefined(_) ||
		((isString(_) || isArray$2(_) || isNodeList(_)) && !_.length) ||
		(isObject(_) && !Object.keys(_).length),
	isUrl$1 = (_) => {
		if (instanceOf(_, window.URL)) return !0;
		if (!isString(_)) return !1;
		let et = _;
		(_.startsWith("http://") && _.startsWith("https://")) || (et = `http://${_}`);
		try {
			return !isEmpty(new URL(et).hostname);
		} catch {
			return !1;
		}
	};
var is = {
	nullOrUndefined: isNullOrUndefined,
	object: isObject,
	number: isNumber,
	string: isString,
	boolean: isBoolean,
	function: isFunction,
	array: isArray$2,
	weakMap: isWeakMap,
	nodeList: isNodeList,
	element: isElement,
	textNode: isTextNode,
	event: isEvent,
	keyboardEvent: isKeyboardEvent,
	cue: isCue,
	track: isTrack,
	promise: isPromise,
	url: isUrl$1,
	empty: isEmpty,
};
const transitionEndEvent = (() => {
	const _ = document.createElement("span"),
		et = {
			WebkitTransition: "webkitTransitionEnd",
			MozTransition: "transitionend",
			OTransition: "oTransitionEnd otransitionend",
			transition: "transitionend",
		},
		tt = Object.keys(et).find((nt) => _.style[nt] !== void 0);
	return !!is.string(tt) && et[tt];
})();
function repaint(_, et) {
	setTimeout(() => {
		try {
			(_.hidden = !0), _.offsetHeight, (_.hidden = !1);
		} catch {}
	}, et);
}
const browser = {
	isIE: Boolean(window.document.documentMode),
	isEdge: /Edge/g.test(navigator.userAgent),
	isWebkit: "WebkitAppearance" in document.documentElement.style && !/Edge/g.test(navigator.userAgent),
	isIPhone: /iPhone|iPod/gi.test(navigator.userAgent) && navigator.maxTouchPoints > 1,
	isIos: /iPad|iPhone|iPod/gi.test(navigator.userAgent) && navigator.maxTouchPoints > 1,
};
function cloneDeep(_) {
	return JSON.parse(JSON.stringify(_));
}
function getDeep(_, et) {
	return et.split(".").reduce((tt, nt) => tt && tt[nt], _);
}
function extend$1(_ = {}, ...et) {
	if (!et.length) return _;
	const tt = et.shift();
	return is.object(tt)
		? (Object.keys(tt).forEach((nt) => {
				is.object(tt[nt])
					? (Object.keys(_).includes(nt) || Object.assign(_, { [nt]: {} }), extend$1(_[nt], tt[nt]))
					: Object.assign(_, { [nt]: tt[nt] });
		  }),
		  extend$1(_, ...et))
		: _;
}
function wrap$2(_, et) {
	const tt = _.length ? _ : [_];
	Array.from(tt)
		.reverse()
		.forEach((nt, rt) => {
			const it = rt > 0 ? et.cloneNode(!0) : et,
				ot = nt.parentNode,
				at = nt.nextSibling;
			it.appendChild(nt), at ? ot.insertBefore(it, at) : ot.appendChild(it);
		});
}
function setAttributes(_, et) {
	is.element(_) &&
		!is.empty(et) &&
		Object.entries(et)
			.filter(([, tt]) => !is.nullOrUndefined(tt))
			.forEach(([tt, nt]) => _.setAttribute(tt, nt));
}
function createElement(_, et, tt) {
	const nt = document.createElement(_);
	return is.object(et) && setAttributes(nt, et), is.string(tt) && (nt.innerText = tt), nt;
}
function insertAfter(_, et) {
	is.element(_) && is.element(et) && et.parentNode.insertBefore(_, et.nextSibling);
}
function insertElement(_, et, tt, nt) {
	is.element(et) && et.appendChild(createElement(_, tt, nt));
}
function removeElement(_) {
	is.nodeList(_) || is.array(_)
		? Array.from(_).forEach(removeElement)
		: is.element(_) && is.element(_.parentNode) && _.parentNode.removeChild(_);
}
function emptyElement(_) {
	if (!is.element(_)) return;
	let { length: et } = _.childNodes;
	for (; et > 0; ) _.removeChild(_.lastChild), (et -= 1);
}
function replaceElement(_, et) {
	return is.element(et) && is.element(et.parentNode) && is.element(_) ? (et.parentNode.replaceChild(_, et), _) : null;
}
function getAttributesFromSelector(_, et) {
	if (!is.string(_) || is.empty(_)) return {};
	const tt = {},
		nt = extend$1({}, et);
	return (
		_.split(",").forEach((rt) => {
			const it = rt.trim(),
				ot = it.replace(".", ""),
				at = it.replace(/[[\]]/g, "").split("="),
				[st] = at,
				lt = at.length > 1 ? at[1].replace(/["']/g, "") : "";
			switch (it.charAt(0)) {
				case ".":
					is.string(nt.class) ? (tt.class = `${nt.class} ${ot}`) : (tt.class = ot);
					break;
				case "#":
					tt.id = it.replace("#", "");
					break;
				case "[":
					tt[st] = lt;
			}
		}),
		extend$1(nt, tt)
	);
}
function toggleHidden(_, et) {
	if (!is.element(_)) return;
	let tt = et;
	is.boolean(tt) || (tt = !_.hidden), (_.hidden = tt);
}
function toggleClass(_, et, tt) {
	if (is.nodeList(_)) return Array.from(_).map((nt) => toggleClass(nt, et, tt));
	if (is.element(_)) {
		let nt = "toggle";
		return tt !== void 0 && (nt = tt ? "add" : "remove"), _.classList[nt](et), _.classList.contains(et);
	}
	return !1;
}
function hasClass(_, et) {
	return is.element(_) && _.classList.contains(et);
}
function matches(_, et) {
	const { prototype: tt } = Element;
	return (
		tt.matches ||
		tt.webkitMatchesSelector ||
		tt.mozMatchesSelector ||
		tt.msMatchesSelector ||
		function () {
			return Array.from(document.querySelectorAll(et)).includes(this);
		}
	).call(_, et);
}
function closest$1(_, et) {
	const { prototype: tt } = Element;
	return (
		tt.closest ||
		function () {
			let nt = this;
			do {
				if (matches.matches(nt, et)) return nt;
				nt = nt.parentElement || nt.parentNode;
			} while (nt !== null && nt.nodeType === 1);
			return null;
		}
	).call(_, et);
}
function getElements(_) {
	return this.elements.container.querySelectorAll(_);
}
function getElement(_) {
	return this.elements.container.querySelector(_);
}
function setFocus(_ = null, et = !1) {
	is.element(_) && (_.focus({ preventScroll: !0 }), et && toggleClass(_, this.config.classNames.tabFocus));
}
const defaultCodecs = {
		"audio/ogg": "vorbis",
		"audio/wav": "1",
		"video/webm": "vp8, vorbis",
		"video/mp4": "avc1.42E01E, mp4a.40.2",
		"video/ogg": "theora",
	},
	support = {
		audio: "canPlayType" in document.createElement("audio"),
		video: "canPlayType" in document.createElement("video"),
		check(_, et, tt) {
			const nt = browser.isIPhone && tt && support.playsinline,
				rt = support[_] || et !== "html5";
			return { api: rt, ui: rt && support.rangeInput && (_ !== "video" || !browser.isIPhone || nt) };
		},
		pip: !(
			browser.isIPhone ||
			(!is.function(createElement("video").webkitSetPresentationMode) &&
				(!document.pictureInPictureEnabled || createElement("video").disablePictureInPicture))
		),
		airplay: is.function(window.WebKitPlaybackTargetAvailabilityEvent),
		playsinline: "playsInline" in document.createElement("video"),
		mime(_) {
			if (is.empty(_)) return !1;
			const [et] = _.split("/");
			let tt = _;
			if (!this.isHTML5 || et !== this.type) return !1;
			Object.keys(defaultCodecs).includes(tt) && (tt += `; codecs="${defaultCodecs[_]}"`);
			try {
				return Boolean(tt && this.media.canPlayType(tt).replace(/no/, ""));
			} catch {
				return !1;
			}
		},
		textTracks: "textTracks" in document.createElement("video"),
		rangeInput: (() => {
			const _ = document.createElement("input");
			return (_.type = "range"), _.type === "range";
		})(),
		touch: "ontouchstart" in document.documentElement,
		transitions: transitionEndEvent !== !1,
		reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches,
	},
	supportsPassiveListeners = (() => {
		let _ = !1;
		try {
			const et = Object.defineProperty({}, "passive", { get: () => ((_ = !0), null) });
			window.addEventListener("test", null, et), window.removeEventListener("test", null, et);
		} catch {}
		return _;
	})();
function toggleListener(_, et, tt, nt = !1, rt = !0, it = !1) {
	if (!_ || !("addEventListener" in _) || is.empty(et) || !is.function(tt)) return;
	const ot = et.split(" ");
	let at = it;
	supportsPassiveListeners && (at = { passive: rt, capture: it }),
		ot.forEach((st) => {
			this &&
				this.eventListeners &&
				nt &&
				this.eventListeners.push({ element: _, type: st, callback: tt, options: at }),
				_[nt ? "addEventListener" : "removeEventListener"](st, tt, at);
		});
}
function on(_, et = "", tt, nt = !0, rt = !1) {
	toggleListener.call(this, _, et, tt, !0, nt, rt);
}
function off(_, et = "", tt, nt = !0, rt = !1) {
	toggleListener.call(this, _, et, tt, !1, nt, rt);
}
function once(_, et = "", tt, nt = !0, rt = !1) {
	const it = (...ot) => {
		off(_, et, it, nt, rt), tt.apply(this, ot);
	};
	toggleListener.call(this, _, et, it, !0, nt, rt);
}
function triggerEvent(_, et = "", tt = !1, nt = {}) {
	if (!is.element(_) || is.empty(et)) return;
	const rt = new CustomEvent(et, { bubbles: tt, detail: { ...nt, plyr: this } });
	_.dispatchEvent(rt);
}
function unbindListeners() {
	this &&
		this.eventListeners &&
		(this.eventListeners.forEach((_) => {
			const { element: et, type: tt, callback: nt, options: rt } = _;
			et.removeEventListener(tt, nt, rt);
		}),
		(this.eventListeners = []));
}
function ready() {
	return new Promise((_) => (this.ready ? setTimeout(_, 0) : on.call(this, this.elements.container, "ready", _))).then(
		() => {}
	);
}
function silencePromise(_) {
	is.promise(_) && _.then(null, () => {});
}
function dedupe(_) {
	return is.array(_) ? _.filter((et, tt) => _.indexOf(et) === tt) : _;
}
function closest(_, et) {
	return is.array(_) && _.length ? _.reduce((tt, nt) => (Math.abs(nt - et) < Math.abs(tt - et) ? nt : tt)) : null;
}
function supportsCSS(_) {
	return !(!window || !window.CSS) && window.CSS.supports(_);
}
const standardRatios = [
	[1, 1],
	[4, 3],
	[3, 4],
	[5, 4],
	[4, 5],
	[3, 2],
	[2, 3],
	[16, 10],
	[10, 16],
	[16, 9],
	[9, 16],
	[21, 9],
	[9, 21],
	[32, 9],
	[9, 32],
].reduce((_, [et, tt]) => ({ ..._, [et / tt]: [et, tt] }), {});
function validateAspectRatio(_) {
	return is.array(_) || (is.string(_) && _.includes(":"))
		? (is.array(_) ? _ : _.split(":")).map(Number).every(is.number)
		: !1;
}
function reduceAspectRatio(_) {
	if (!is.array(_) || !_.every(is.number)) return null;
	const [et, tt] = _,
		nt = (it, ot) => (ot === 0 ? it : nt(ot, it % ot)),
		rt = nt(et, tt);
	return [et / rt, tt / rt];
}
function getAspectRatio(_) {
	const et = (nt) => (validateAspectRatio(nt) ? nt.split(":").map(Number) : null);
	let tt = et(_);
	if (
		(tt === null && (tt = et(this.config.ratio)),
		tt === null && !is.empty(this.embed) && is.array(this.embed.ratio) && ({ ratio: tt } = this.embed),
		tt === null && this.isHTML5)
	) {
		const { videoWidth: nt, videoHeight: rt } = this.media;
		tt = [nt, rt];
	}
	return reduceAspectRatio(tt);
}
function setAspectRatio(_) {
	if (!this.isVideo) return {};
	const { wrapper: et } = this.elements,
		tt = getAspectRatio.call(this, _);
	if (!is.array(tt)) return {};
	const [nt, rt] = reduceAspectRatio(tt),
		it = (100 / nt) * rt;
	if (
		(supportsCSS(`aspect-ratio: ${nt}/${rt}`)
			? (et.style.aspectRatio = `${nt}/${rt}`)
			: (et.style.paddingBottom = `${it}%`),
		this.isVimeo && !this.config.vimeo.premium && this.supported.ui)
	) {
		const ot = (100 / this.media.offsetWidth) * parseInt(window.getComputedStyle(this.media).paddingBottom, 10),
			at = (ot - it) / (ot / 50);
		this.fullscreen.active ? (et.style.paddingBottom = null) : (this.media.style.transform = `translateY(-${at}%)`);
	} else this.isHTML5 && et.classList.add(this.config.classNames.videoFixedRatio);
	return { padding: it, ratio: tt };
}
function roundAspectRatio(_, et, tt = 0.05) {
	const nt = _ / et,
		rt = closest(Object.keys(standardRatios), nt);
	return Math.abs(rt - nt) <= tt ? standardRatios[rt] : [_, et];
}
function getViewportSize() {
	return [
		Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
		Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0),
	];
}
const html5 = {
	getSources() {
		return this.isHTML5
			? Array.from(this.media.querySelectorAll("source")).filter((_) => {
					const et = _.getAttribute("type");
					return !!is.empty(et) || support.mime.call(this, et);
			  })
			: [];
	},
	getQualityOptions() {
		return this.config.quality.forced
			? this.config.quality.options
			: html5.getSources
					.call(this)
					.map((_) => Number(_.getAttribute("size")))
					.filter(Boolean);
	},
	setup() {
		if (!this.isHTML5) return;
		const _ = this;
		(_.options.speed = _.config.speed.options),
			is.empty(this.config.ratio) || setAspectRatio.call(_),
			Object.defineProperty(_.media, "quality", {
				get() {
					const et = html5.getSources.call(_).find((tt) => tt.getAttribute("src") === _.source);
					return et && Number(et.getAttribute("size"));
				},
				set(et) {
					if (_.quality !== et) {
						if (_.config.quality.forced && is.function(_.config.quality.onChange)) _.config.quality.onChange(et);
						else {
							const tt = html5.getSources.call(_).find((st) => Number(st.getAttribute("size")) === et);
							if (!tt) return;
							const { currentTime: nt, paused: rt, preload: it, readyState: ot, playbackRate: at } = _.media;
							(_.media.src = tt.getAttribute("src")),
								(it !== "none" || ot) &&
									(_.once("loadedmetadata", () => {
										(_.speed = at), (_.currentTime = nt), rt || silencePromise(_.play());
									}),
									_.media.load());
						}
						triggerEvent.call(_, _.media, "qualitychange", !1, { quality: et });
					}
				},
			});
	},
	cancelRequests() {
		this.isHTML5 &&
			(removeElement(html5.getSources.call(this)),
			this.media.setAttribute("src", this.config.blankVideo),
			this.media.load(),
			this.debug.log("Cancelled network requests"));
	},
};
function generateId(_) {
	return `${_}-${Math.floor(1e4 * Math.random())}`;
}
function format(_, ...et) {
	return is.empty(_) ? _ : _.toString().replace(/{(\d+)}/g, (tt, nt) => et[nt].toString());
}
function getPercentage(_, et) {
	return _ === 0 || et === 0 || Number.isNaN(_) || Number.isNaN(et) ? 0 : ((_ / et) * 100).toFixed(2);
}
const replaceAll = (_ = "", et = "", tt = "") =>
		_.replace(new RegExp(et.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), tt.toString()),
	toTitleCase = (_ = "") =>
		_.toString().replace(/\w\S*/g, (et) => et.charAt(0).toUpperCase() + et.slice(1).toLowerCase());
function toPascalCase(_ = "") {
	let et = _.toString();
	return (
		(et = replaceAll(et, "-", " ")), (et = replaceAll(et, "_", " ")), (et = toTitleCase(et)), replaceAll(et, " ", "")
	);
}
function toCamelCase(_ = "") {
	let et = _.toString();
	return (et = toPascalCase(et)), et.charAt(0).toLowerCase() + et.slice(1);
}
function stripHTML(_) {
	const et = document.createDocumentFragment(),
		tt = document.createElement("div");
	return et.appendChild(tt), (tt.innerHTML = _), et.firstChild.innerText;
}
function getHTML(_) {
	const et = document.createElement("div");
	return et.appendChild(_), et.innerHTML;
}
const resources = { pip: "PIP", airplay: "AirPlay", html5: "HTML5", vimeo: "Vimeo", youtube: "YouTube" },
	i18n = {
		get(_ = "", et = {}) {
			if (is.empty(_) || is.empty(et)) return "";
			let tt = getDeep(et.i18n, _);
			if (is.empty(tt)) return Object.keys(resources).includes(_) ? resources[_] : "";
			const nt = { "{seektime}": et.seekTime, "{title}": et.title };
			return (
				Object.entries(nt).forEach(([rt, it]) => {
					tt = replaceAll(tt, rt, it);
				}),
				tt
			);
		},
	};
class Storage {
	constructor(et) {
		_defineProperty$1(this, "get", (tt) => {
			if (!Storage.supported || !this.enabled) return null;
			const nt = window.localStorage.getItem(this.key);
			if (is.empty(nt)) return null;
			const rt = JSON.parse(nt);
			return is.string(tt) && tt.length ? rt[tt] : rt;
		}),
			_defineProperty$1(this, "set", (tt) => {
				if (!Storage.supported || !this.enabled || !is.object(tt)) return;
				let nt = this.get();
				is.empty(nt) && (nt = {}), extend$1(nt, tt);
				try {
					window.localStorage.setItem(this.key, JSON.stringify(nt));
				} catch {}
			}),
			(this.enabled = et.config.storage.enabled),
			(this.key = et.config.storage.key);
	}
	static get supported() {
		try {
			if (!("localStorage" in window)) return !1;
			const et = "___test";
			return window.localStorage.setItem(et, et), window.localStorage.removeItem(et), !0;
		} catch {
			return !1;
		}
	}
}
function fetch$1(_, et = "text") {
	return new Promise((tt, nt) => {
		try {
			const rt = new XMLHttpRequest();
			if (!("withCredentials" in rt)) return;
			rt.addEventListener("load", () => {
				if (et === "text")
					try {
						tt(JSON.parse(rt.responseText));
					} catch {
						tt(rt.responseText);
					}
				else tt(rt.response);
			}),
				rt.addEventListener("error", () => {
					throw new Error(rt.status);
				}),
				rt.open("GET", _, !0),
				(rt.responseType = et),
				rt.send();
		} catch (rt) {
			nt(rt);
		}
	});
}
function loadSprite(_, et) {
	if (!is.string(_)) return;
	const tt = is.string(et);
	let nt = !1;
	const rt = () => document.getElementById(et) !== null,
		it = (ot, at) => {
			(ot.innerHTML = at), (tt && rt()) || document.body.insertAdjacentElement("afterbegin", ot);
		};
	if (!tt || !rt()) {
		const ot = Storage.supported,
			at = document.createElement("div");
		if ((at.setAttribute("hidden", ""), tt && at.setAttribute("id", et), ot)) {
			const st = window.localStorage.getItem(`cache-${et}`);
			if (((nt = st !== null), nt)) {
				const lt = JSON.parse(st);
				it(at, lt.content);
			}
		}
		fetch$1(_)
			.then((st) => {
				if (!is.empty(st)) {
					if (ot)
						try {
							window.localStorage.setItem(`cache-${et}`, JSON.stringify({ content: st }));
						} catch {}
					it(at, st);
				}
			})
			.catch(() => {});
	}
}
const getHours = (_) => Math.trunc((_ / 60 / 60) % 60, 10),
	getSeconds = (_) => Math.trunc(_ % 60, 10);
function formatTime(_ = 0, et = !1, tt = !1) {
	if (!is.number(_)) return formatTime(void 0, et, tt);
	const nt = (st) => `0${st}`.slice(-2);
	let rt = getHours(_);
	const it = ((ot = _), Math.trunc((ot / 60) % 60, 10));
	var ot;
	const at = getSeconds(_);
	return (rt = et || rt > 0 ? `${rt}:` : ""), `${tt && _ > 0 ? "-" : ""}${rt}${nt(it)}:${nt(at)}`;
}
const controls = {
	getIconUrl() {
		const _ = new URL(this.config.iconUrl, window.location),
			et = window.location.host ? window.location.host : window.top.location.host,
			tt = _.host !== et || (browser.isIE && !window.svg4everybody);
		return { url: this.config.iconUrl, cors: tt };
	},
	findElements() {
		try {
			return (
				(this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper)),
				(this.elements.buttons = {
					play: getElements.call(this, this.config.selectors.buttons.play),
					pause: getElement.call(this, this.config.selectors.buttons.pause),
					restart: getElement.call(this, this.config.selectors.buttons.restart),
					rewind: getElement.call(this, this.config.selectors.buttons.rewind),
					fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),
					mute: getElement.call(this, this.config.selectors.buttons.mute),
					pip: getElement.call(this, this.config.selectors.buttons.pip),
					airplay: getElement.call(this, this.config.selectors.buttons.airplay),
					settings: getElement.call(this, this.config.selectors.buttons.settings),
					captions: getElement.call(this, this.config.selectors.buttons.captions),
					fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen),
				}),
				(this.elements.progress = getElement.call(this, this.config.selectors.progress)),
				(this.elements.inputs = {
					seek: getElement.call(this, this.config.selectors.inputs.seek),
					volume: getElement.call(this, this.config.selectors.inputs.volume),
				}),
				(this.elements.display = {
					buffer: getElement.call(this, this.config.selectors.display.buffer),
					currentTime: getElement.call(this, this.config.selectors.display.currentTime),
					duration: getElement.call(this, this.config.selectors.display.duration),
				}),
				is.element(this.elements.progress) &&
					(this.elements.display.seekTooltip = this.elements.progress.querySelector(
						`.${this.config.classNames.tooltip}`
					)),
				!0
			);
		} catch (_) {
			return (
				this.debug.warn("It looks like there is a problem with your custom controls HTML", _),
				this.toggleNativeControls(!0),
				!1
			);
		}
	},
	createIcon(_, et) {
		const tt = "http://www.w3.org/2000/svg",
			nt = controls.getIconUrl.call(this),
			rt = `${nt.cors ? "" : nt.url}#${this.config.iconPrefix}`,
			it = document.createElementNS(tt, "svg");
		setAttributes(it, extend$1(et, { "aria-hidden": "true", focusable: "false" }));
		const ot = document.createElementNS(tt, "use"),
			at = `${rt}-${_}`;
		return (
			"href" in ot && ot.setAttributeNS("http://www.w3.org/1999/xlink", "href", at),
			ot.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", at),
			it.appendChild(ot),
			it
		);
	},
	createLabel(_, et = {}) {
		const tt = i18n.get(_, this.config);
		return createElement(
			"span",
			{ ...et, class: [et.class, this.config.classNames.hidden].filter(Boolean).join(" ") },
			tt
		);
	},
	createBadge(_) {
		if (is.empty(_)) return null;
		const et = createElement("span", { class: this.config.classNames.menu.value });
		return et.appendChild(createElement("span", { class: this.config.classNames.menu.badge }, _)), et;
	},
	createButton(_, et) {
		const tt = extend$1({}, et);
		let nt = toCamelCase(_);
		const rt = { element: "button", toggle: !1, label: null, icon: null, labelPressed: null, iconPressed: null };
		switch (
			(["element", "icon", "label"].forEach((ot) => {
				Object.keys(tt).includes(ot) && ((rt[ot] = tt[ot]), delete tt[ot]);
			}),
			rt.element !== "button" || Object.keys(tt).includes("type") || (tt.type = "button"),
			Object.keys(tt).includes("class")
				? tt.class.split(" ").some((ot) => ot === this.config.classNames.control) ||
				  extend$1(tt, { class: `${tt.class} ${this.config.classNames.control}` })
				: (tt.class = this.config.classNames.control),
			_)
		) {
			case "play":
				(rt.toggle = !0),
					(rt.label = "play"),
					(rt.labelPressed = "pause"),
					(rt.icon = "play"),
					(rt.iconPressed = "pause");
				break;
			case "mute":
				(rt.toggle = !0),
					(rt.label = "mute"),
					(rt.labelPressed = "unmute"),
					(rt.icon = "volume"),
					(rt.iconPressed = "muted");
				break;
			case "captions":
				(rt.toggle = !0),
					(rt.label = "enableCaptions"),
					(rt.labelPressed = "disableCaptions"),
					(rt.icon = "captions-off"),
					(rt.iconPressed = "captions-on");
				break;
			case "fullscreen":
				(rt.toggle = !0),
					(rt.label = "enterFullscreen"),
					(rt.labelPressed = "exitFullscreen"),
					(rt.icon = "enter-fullscreen"),
					(rt.iconPressed = "exit-fullscreen");
				break;
			case "play-large":
				(tt.class += ` ${this.config.classNames.control}--overlaid`),
					(nt = "play"),
					(rt.label = "play"),
					(rt.icon = "play");
				break;
			default:
				is.empty(rt.label) && (rt.label = nt), is.empty(rt.icon) && (rt.icon = _);
		}
		const it = createElement(rt.element);
		return (
			rt.toggle
				? (it.appendChild(controls.createIcon.call(this, rt.iconPressed, { class: "icon--pressed" })),
				  it.appendChild(controls.createIcon.call(this, rt.icon, { class: "icon--not-pressed" })),
				  it.appendChild(controls.createLabel.call(this, rt.labelPressed, { class: "label--pressed" })),
				  it.appendChild(controls.createLabel.call(this, rt.label, { class: "label--not-pressed" })))
				: (it.appendChild(controls.createIcon.call(this, rt.icon)),
				  it.appendChild(controls.createLabel.call(this, rt.label))),
			extend$1(tt, getAttributesFromSelector(this.config.selectors.buttons[nt], tt)),
			setAttributes(it, tt),
			nt === "play"
				? (is.array(this.elements.buttons[nt]) || (this.elements.buttons[nt] = []), this.elements.buttons[nt].push(it))
				: (this.elements.buttons[nt] = it),
			it
		);
	},
	createRange(_, et) {
		const tt = createElement(
			"input",
			extend$1(
				getAttributesFromSelector(this.config.selectors.inputs[_]),
				{
					type: "range",
					min: 0,
					max: 100,
					step: 0.01,
					value: 0,
					autocomplete: "off",
					role: "slider",
					"aria-label": i18n.get(_, this.config),
					"aria-valuemin": 0,
					"aria-valuemax": 100,
					"aria-valuenow": 0,
				},
				et
			)
		);
		return (this.elements.inputs[_] = tt), controls.updateRangeFill.call(this, tt), RangeTouch.setup(tt), tt;
	},
	createProgress(_, et) {
		const tt = createElement(
			"progress",
			extend$1(
				getAttributesFromSelector(this.config.selectors.display[_]),
				{ min: 0, max: 100, value: 0, role: "progressbar", "aria-hidden": !0 },
				et
			)
		);
		if (_ !== "volume") {
			tt.appendChild(createElement("span", null, "0"));
			const nt = { played: "played", buffer: "buffered" }[_],
				rt = nt ? i18n.get(nt, this.config) : "";
			tt.innerText = `% ${rt.toLowerCase()}`;
		}
		return (this.elements.display[_] = tt), tt;
	},
	createTime(_, et) {
		const tt = getAttributesFromSelector(this.config.selectors.display[_], et),
			nt = createElement(
				"div",
				extend$1(tt, {
					class: `${tt.class ? tt.class : ""} ${this.config.classNames.display.time} `.trim(),
					"aria-label": i18n.get(_, this.config),
				}),
				"00:00"
			);
		return (this.elements.display[_] = nt), nt;
	},
	bindMenuItemShortcuts(_, et) {
		on.call(
			this,
			_,
			"keydown keyup",
			(tt) => {
				if (
					!["Space", "ArrowUp", "ArrowDown", "ArrowRight"].includes(tt.key) ||
					(tt.preventDefault(), tt.stopPropagation(), tt.type === "keydown")
				)
					return;
				const nt = matches(_, '[role="menuitemradio"]');
				if (!nt && ["Space", "ArrowRight"].includes(tt.key)) controls.showMenuPanel.call(this, et, !0);
				else {
					let rt;
					tt.key !== "Space" &&
						(tt.key === "ArrowDown" || (nt && tt.key === "ArrowRight")
							? ((rt = _.nextElementSibling), is.element(rt) || (rt = _.parentNode.firstElementChild))
							: ((rt = _.previousElementSibling), is.element(rt) || (rt = _.parentNode.lastElementChild)),
						setFocus.call(this, rt, !0));
				}
			},
			!1
		),
			on.call(this, _, "keyup", (tt) => {
				tt.key === "Return" && controls.focusFirstMenuItem.call(this, null, !0);
			});
	},
	createMenuItem({ value: _, list: et, type: tt, title: nt, badge: rt = null, checked: it = !1 }) {
		const ot = getAttributesFromSelector(this.config.selectors.inputs[tt]),
			at = createElement(
				"button",
				extend$1(ot, {
					type: "button",
					role: "menuitemradio",
					class: `${this.config.classNames.control} ${ot.class ? ot.class : ""}`.trim(),
					"aria-checked": it,
					value: _,
				})
			),
			st = createElement("span");
		(st.innerHTML = nt),
			is.element(rt) && st.appendChild(rt),
			at.appendChild(st),
			Object.defineProperty(at, "checked", {
				enumerable: !0,
				get: () => at.getAttribute("aria-checked") === "true",
				set(lt) {
					lt &&
						Array.from(at.parentNode.children)
							.filter((ut) => matches(ut, '[role="menuitemradio"]'))
							.forEach((ut) => ut.setAttribute("aria-checked", "false")),
						at.setAttribute("aria-checked", lt ? "true" : "false");
				},
			}),
			this.listeners.bind(
				at,
				"click keyup",
				(lt) => {
					if (!is.keyboardEvent(lt) || lt.key === "Space") {
						switch ((lt.preventDefault(), lt.stopPropagation(), (at.checked = !0), tt)) {
							case "language":
								this.currentTrack = Number(_);
								break;
							case "quality":
								this.quality = _;
								break;
							case "speed":
								this.speed = parseFloat(_);
						}
						controls.showMenuPanel.call(this, "home", is.keyboardEvent(lt));
					}
				},
				tt,
				!1
			),
			controls.bindMenuItemShortcuts.call(this, at, tt),
			et.appendChild(at);
	},
	formatTime(_ = 0, et = !1) {
		return is.number(_) ? formatTime(_, getHours(this.duration) > 0, et) : _;
	},
	updateTimeDisplay(_ = null, et = 0, tt = !1) {
		is.element(_) && is.number(et) && (_.innerText = controls.formatTime(et, tt));
	},
	updateVolume() {
		this.supported.ui &&
			(is.element(this.elements.inputs.volume) &&
				controls.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume),
			is.element(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || this.volume === 0));
	},
	setRange(_, et = 0) {
		is.element(_) && ((_.value = et), controls.updateRangeFill.call(this, _));
	},
	updateProgress(_) {
		if (!this.supported.ui || !is.event(_)) return;
		let et = 0;
		const tt = (nt, rt) => {
			const it = is.number(rt) ? rt : 0,
				ot = is.element(nt) ? nt : this.elements.display.buffer;
			if (is.element(ot)) {
				ot.value = it;
				const at = ot.getElementsByTagName("span")[0];
				is.element(at) && (at.childNodes[0].nodeValue = it);
			}
		};
		if (_)
			switch (_.type) {
				case "timeupdate":
				case "seeking":
				case "seeked":
					(et = getPercentage(this.currentTime, this.duration)),
						_.type === "timeupdate" && controls.setRange.call(this, this.elements.inputs.seek, et);
					break;
				case "playing":
				case "progress":
					tt(this.elements.display.buffer, 100 * this.buffered);
			}
	},
	updateRangeFill(_) {
		const et = is.event(_) ? _.target : _;
		if (is.element(et) && et.getAttribute("type") === "range") {
			if (matches(et, this.config.selectors.inputs.seek)) {
				et.setAttribute("aria-valuenow", this.currentTime);
				const tt = controls.formatTime(this.currentTime),
					nt = controls.formatTime(this.duration),
					rt = i18n.get("seekLabel", this.config);
				et.setAttribute("aria-valuetext", rt.replace("{currentTime}", tt).replace("{duration}", nt));
			} else if (matches(et, this.config.selectors.inputs.volume)) {
				const tt = 100 * et.value;
				et.setAttribute("aria-valuenow", tt), et.setAttribute("aria-valuetext", `${tt.toFixed(1)}%`);
			} else et.setAttribute("aria-valuenow", et.value);
			browser.isWebkit && et.style.setProperty("--value", (et.value / et.max) * 100 + "%");
		}
	},
	updateSeekTooltip(_) {
		var et, tt;
		if (
			!this.config.tooltips.seek ||
			!is.element(this.elements.inputs.seek) ||
			!is.element(this.elements.display.seekTooltip) ||
			this.duration === 0
		)
			return;
		const nt = this.elements.display.seekTooltip,
			rt = `${this.config.classNames.tooltip}--visible`,
			it = (ut) => toggleClass(nt, rt, ut);
		if (this.touch) return void it(!1);
		let ot = 0;
		const at = this.elements.progress.getBoundingClientRect();
		if (is.event(_)) ot = (100 / at.width) * (_.pageX - at.left);
		else {
			if (!hasClass(nt, rt)) return;
			ot = parseFloat(nt.style.left, 10);
		}
		ot < 0 ? (ot = 0) : ot > 100 && (ot = 100);
		const st = (this.duration / 100) * ot;
		nt.innerText = controls.formatTime(st);
		const lt =
			(et = this.config.markers) === null || et === void 0 || (tt = et.points) === null || tt === void 0
				? void 0
				: tt.find(({ time: ut }) => ut === Math.round(st));
		lt && nt.insertAdjacentHTML("afterbegin", `${lt.label}<br>`),
			(nt.style.left = `${ot}%`),
			is.event(_) && ["mouseenter", "mouseleave"].includes(_.type) && it(_.type === "mouseenter");
	},
	timeUpdate(_) {
		const et = !is.element(this.elements.display.duration) && this.config.invertTime;
		controls.updateTimeDisplay.call(
			this,
			this.elements.display.currentTime,
			et ? this.duration - this.currentTime : this.currentTime,
			et
		),
			(_ && _.type === "timeupdate" && this.media.seeking) || controls.updateProgress.call(this, _);
	},
	durationUpdate() {
		if (!this.supported.ui || (!this.config.invertTime && this.currentTime)) return;
		if (this.duration >= 2 ** 32)
			return toggleHidden(this.elements.display.currentTime, !0), void toggleHidden(this.elements.progress, !0);
		is.element(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
		const _ = is.element(this.elements.display.duration);
		!_ &&
			this.config.displayDuration &&
			this.paused &&
			controls.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration),
			_ && controls.updateTimeDisplay.call(this, this.elements.display.duration, this.duration),
			this.config.markers.enabled && controls.setMarkers.call(this),
			controls.updateSeekTooltip.call(this);
	},
	toggleMenuButton(_, et) {
		toggleHidden(this.elements.settings.buttons[_], !et);
	},
	updateSetting(_, et, tt) {
		const nt = this.elements.settings.panels[_];
		let rt = null,
			it = et;
		if (_ === "captions") rt = this.currentTrack;
		else {
			if (
				((rt = is.empty(tt) ? this[_] : tt),
				is.empty(rt) && (rt = this.config[_].default),
				!is.empty(this.options[_]) && !this.options[_].includes(rt))
			)
				return void this.debug.warn(`Unsupported value of '${rt}' for ${_}`);
			if (!this.config[_].options.includes(rt)) return void this.debug.warn(`Disabled value of '${rt}' for ${_}`);
		}
		if ((is.element(it) || (it = nt && nt.querySelector('[role="menu"]')), !is.element(it))) return;
		this.elements.settings.buttons[_].querySelector(`.${this.config.classNames.menu.value}`).innerHTML =
			controls.getLabel.call(this, _, rt);
		const ot = it && it.querySelector(`[value="${rt}"]`);
		is.element(ot) && (ot.checked = !0);
	},
	getLabel(_, et) {
		switch (_) {
			case "speed":
				return et === 1 ? i18n.get("normal", this.config) : `${et}&times;`;
			case "quality":
				if (is.number(et)) {
					const tt = i18n.get(`qualityLabel.${et}`, this.config);
					return tt.length ? tt : `${et}p`;
				}
				return toTitleCase(et);
			case "captions":
				return captions.getLabel.call(this);
			default:
				return null;
		}
	},
	setQualityMenu(_) {
		if (!is.element(this.elements.settings.panels.quality)) return;
		const et = "quality",
			tt = this.elements.settings.panels.quality.querySelector('[role="menu"]');
		is.array(_) && (this.options.quality = dedupe(_).filter((it) => this.config.quality.options.includes(it)));
		const nt = !is.empty(this.options.quality) && this.options.quality.length > 1;
		if ((controls.toggleMenuButton.call(this, et, nt), emptyElement(tt), controls.checkMenu.call(this), !nt)) return;
		const rt = (it) => {
			const ot = i18n.get(`qualityBadge.${it}`, this.config);
			return ot.length ? controls.createBadge.call(this, ot) : null;
		};
		this.options.quality
			.sort((it, ot) => {
				const at = this.config.quality.options;
				return at.indexOf(it) > at.indexOf(ot) ? 1 : -1;
			})
			.forEach((it) => {
				controls.createMenuItem.call(this, {
					value: it,
					list: tt,
					type: et,
					title: controls.getLabel.call(this, "quality", it),
					badge: rt(it),
				});
			}),
			controls.updateSetting.call(this, et, tt);
	},
	setCaptionsMenu() {
		if (!is.element(this.elements.settings.panels.captions)) return;
		const _ = "captions",
			et = this.elements.settings.panels.captions.querySelector('[role="menu"]'),
			tt = captions.getTracks.call(this),
			nt = Boolean(tt.length);
		if ((controls.toggleMenuButton.call(this, _, nt), emptyElement(et), controls.checkMenu.call(this), !nt)) return;
		const rt = tt.map((it, ot) => ({
			value: ot,
			checked: this.captions.toggled && this.currentTrack === ot,
			title: captions.getLabel.call(this, it),
			badge: it.language && controls.createBadge.call(this, it.language.toUpperCase()),
			list: et,
			type: "language",
		}));
		rt.unshift({
			value: -1,
			checked: !this.captions.toggled,
			title: i18n.get("disabled", this.config),
			list: et,
			type: "language",
		}),
			rt.forEach(controls.createMenuItem.bind(this)),
			controls.updateSetting.call(this, _, et);
	},
	setSpeedMenu() {
		if (!is.element(this.elements.settings.panels.speed)) return;
		const _ = "speed",
			et = this.elements.settings.panels.speed.querySelector('[role="menu"]');
		this.options.speed = this.options.speed.filter((nt) => nt >= this.minimumSpeed && nt <= this.maximumSpeed);
		const tt = !is.empty(this.options.speed) && this.options.speed.length > 1;
		controls.toggleMenuButton.call(this, _, tt),
			emptyElement(et),
			controls.checkMenu.call(this),
			tt &&
				(this.options.speed.forEach((nt) => {
					controls.createMenuItem.call(this, {
						value: nt,
						list: et,
						type: _,
						title: controls.getLabel.call(this, "speed", nt),
					});
				}),
				controls.updateSetting.call(this, _, et));
	},
	checkMenu() {
		const { buttons: _ } = this.elements.settings,
			et = !is.empty(_) && Object.values(_).some((tt) => !tt.hidden);
		toggleHidden(this.elements.settings.menu, !et);
	},
	focusFirstMenuItem(_, et = !1) {
		if (this.elements.settings.popup.hidden) return;
		let tt = _;
		is.element(tt) || (tt = Object.values(this.elements.settings.panels).find((rt) => !rt.hidden));
		const nt = tt.querySelector('[role^="menuitem"]');
		setFocus.call(this, nt, et);
	},
	toggleMenu(_) {
		const { popup: et } = this.elements.settings,
			tt = this.elements.buttons.settings;
		if (!is.element(et) || !is.element(tt)) return;
		const { hidden: nt } = et;
		let rt = nt;
		if (is.boolean(_)) rt = _;
		else if (is.keyboardEvent(_) && _.key === "Escape") rt = !1;
		else if (is.event(_)) {
			const it = is.function(_.composedPath) ? _.composedPath()[0] : _.target,
				ot = et.contains(it);
			if (ot || (!ot && _.target !== tt && rt)) return;
		}
		tt.setAttribute("aria-expanded", rt),
			toggleHidden(et, !rt),
			toggleClass(this.elements.container, this.config.classNames.menu.open, rt),
			rt && is.keyboardEvent(_)
				? controls.focusFirstMenuItem.call(this, null, !0)
				: rt || nt || setFocus.call(this, tt, is.keyboardEvent(_));
	},
	getMenuSize(_) {
		const et = _.cloneNode(!0);
		(et.style.position = "absolute"),
			(et.style.opacity = 0),
			et.removeAttribute("hidden"),
			_.parentNode.appendChild(et);
		const tt = et.scrollWidth,
			nt = et.scrollHeight;
		return removeElement(et), { width: tt, height: nt };
	},
	showMenuPanel(_ = "", et = !1) {
		const tt = this.elements.container.querySelector(`#plyr-settings-${this.id}-${_}`);
		if (!is.element(tt)) return;
		const nt = tt.parentNode,
			rt = Array.from(nt.children).find((it) => !it.hidden);
		if (support.transitions && !support.reducedMotion) {
			(nt.style.width = `${rt.scrollWidth}px`), (nt.style.height = `${rt.scrollHeight}px`);
			const it = controls.getMenuSize.call(this, tt),
				ot = (at) => {
					at.target === nt &&
						["width", "height"].includes(at.propertyName) &&
						((nt.style.width = ""), (nt.style.height = ""), off.call(this, nt, transitionEndEvent, ot));
				};
			on.call(this, nt, transitionEndEvent, ot),
				(nt.style.width = `${it.width}px`),
				(nt.style.height = `${it.height}px`);
		}
		toggleHidden(rt, !0), toggleHidden(tt, !1), controls.focusFirstMenuItem.call(this, tt, et);
	},
	setDownloadUrl() {
		const _ = this.elements.buttons.download;
		is.element(_) && _.setAttribute("href", this.download);
	},
	create(_) {
		const {
			bindMenuItemShortcuts: et,
			createButton: tt,
			createProgress: nt,
			createRange: rt,
			createTime: it,
			setQualityMenu: ot,
			setSpeedMenu: at,
			showMenuPanel: st,
		} = controls;
		(this.elements.controls = null),
			is.array(this.config.controls) &&
				this.config.controls.includes("play-large") &&
				this.elements.container.appendChild(tt.call(this, "play-large"));
		const lt = createElement("div", getAttributesFromSelector(this.config.selectors.controls.wrapper));
		this.elements.controls = lt;
		const ut = { class: "plyr__controls__item" };
		return (
			dedupe(is.array(this.config.controls) ? this.config.controls : []).forEach((dt) => {
				if (
					(dt === "restart" && lt.appendChild(tt.call(this, "restart", ut)),
					dt === "rewind" && lt.appendChild(tt.call(this, "rewind", ut)),
					dt === "play" && lt.appendChild(tt.call(this, "play", ut)),
					dt === "fast-forward" && lt.appendChild(tt.call(this, "fast-forward", ut)),
					dt === "progress")
				) {
					const ct = createElement("div", { class: `${ut.class} plyr__progress__container` }),
						ft = createElement("div", getAttributesFromSelector(this.config.selectors.progress));
					if (
						(ft.appendChild(rt.call(this, "seek", { id: `plyr-seek-${_.id}` })),
						ft.appendChild(nt.call(this, "buffer")),
						this.config.tooltips.seek)
					) {
						const mt = createElement("span", { class: this.config.classNames.tooltip }, "00:00");
						ft.appendChild(mt), (this.elements.display.seekTooltip = mt);
					}
					(this.elements.progress = ft), ct.appendChild(this.elements.progress), lt.appendChild(ct);
				}
				if (
					(dt === "current-time" && lt.appendChild(it.call(this, "currentTime", ut)),
					dt === "duration" && lt.appendChild(it.call(this, "duration", ut)),
					dt === "mute" || dt === "volume")
				) {
					let { volume: ct } = this.elements;
					if (
						((is.element(ct) && lt.contains(ct)) ||
							((ct = createElement("div", extend$1({}, ut, { class: `${ut.class} plyr__volume`.trim() }))),
							(this.elements.volume = ct),
							lt.appendChild(ct)),
						dt === "mute" && ct.appendChild(tt.call(this, "mute")),
						dt === "volume" && !browser.isIos)
					) {
						const ft = { max: 1, step: 0.05, value: this.config.volume };
						ct.appendChild(rt.call(this, "volume", extend$1(ft, { id: `plyr-volume-${_.id}` })));
					}
				}
				if (
					(dt === "captions" && lt.appendChild(tt.call(this, "captions", ut)),
					dt === "settings" && !is.empty(this.config.settings))
				) {
					const ct = createElement("div", extend$1({}, ut, { class: `${ut.class} plyr__menu`.trim(), hidden: "" }));
					ct.appendChild(
						tt.call(this, "settings", {
							"aria-haspopup": !0,
							"aria-controls": `plyr-settings-${_.id}`,
							"aria-expanded": !1,
						})
					);
					const ft = createElement("div", { class: "plyr__menu__container", id: `plyr-settings-${_.id}`, hidden: "" }),
						mt = createElement("div"),
						pt = createElement("div", { id: `plyr-settings-${_.id}-home` }),
						vt = createElement("div", { role: "menu" });
					pt.appendChild(vt),
						mt.appendChild(pt),
						(this.elements.settings.panels.home = pt),
						this.config.settings.forEach((ht) => {
							const gt = createElement(
								"button",
								extend$1(getAttributesFromSelector(this.config.selectors.buttons.settings), {
									type: "button",
									class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,
									role: "menuitem",
									"aria-haspopup": !0,
									hidden: "",
								})
							);
							et.call(this, gt, ht),
								on.call(this, gt, "click", () => {
									st.call(this, ht, !1);
								});
							const yt = createElement("span", null, i18n.get(ht, this.config)),
								xt = createElement("span", { class: this.config.classNames.menu.value });
							(xt.innerHTML = _[ht]), yt.appendChild(xt), gt.appendChild(yt), vt.appendChild(gt);
							const St = createElement("div", { id: `plyr-settings-${_.id}-${ht}`, hidden: "" }),
								wt = createElement("button", {
									type: "button",
									class: `${this.config.classNames.control} ${this.config.classNames.control}--back`,
								});
							wt.appendChild(createElement("span", { "aria-hidden": !0 }, i18n.get(ht, this.config))),
								wt.appendChild(
									createElement("span", { class: this.config.classNames.hidden }, i18n.get("menuBack", this.config))
								),
								on.call(
									this,
									St,
									"keydown",
									(Ct) => {
										Ct.key === "ArrowLeft" && (Ct.preventDefault(), Ct.stopPropagation(), st.call(this, "home", !0));
									},
									!1
								),
								on.call(this, wt, "click", () => {
									st.call(this, "home", !1);
								}),
								St.appendChild(wt),
								St.appendChild(createElement("div", { role: "menu" })),
								mt.appendChild(St),
								(this.elements.settings.buttons[ht] = gt),
								(this.elements.settings.panels[ht] = St);
						}),
						ft.appendChild(mt),
						ct.appendChild(ft),
						lt.appendChild(ct),
						(this.elements.settings.popup = ft),
						(this.elements.settings.menu = ct);
				}
				if (
					(dt === "pip" && support.pip && lt.appendChild(tt.call(this, "pip", ut)),
					dt === "airplay" && support.airplay && lt.appendChild(tt.call(this, "airplay", ut)),
					dt === "download")
				) {
					const ct = extend$1({}, ut, { element: "a", href: this.download, target: "_blank" });
					this.isHTML5 && (ct.download = "");
					const { download: ft } = this.config.urls;
					!is.url(ft) && this.isEmbed && extend$1(ct, { icon: `logo-${this.provider}`, label: this.provider }),
						lt.appendChild(tt.call(this, "download", ct));
				}
				dt === "fullscreen" && lt.appendChild(tt.call(this, "fullscreen", ut));
			}),
			this.isHTML5 && ot.call(this, html5.getQualityOptions.call(this)),
			at.call(this),
			lt
		);
	},
	inject() {
		if (this.config.loadSprite) {
			const rt = controls.getIconUrl.call(this);
			rt.cors && loadSprite(rt.url, "sprite-plyr");
		}
		this.id = Math.floor(1e4 * Math.random());
		let _ = null;
		this.elements.controls = null;
		const et = { id: this.id, seektime: this.config.seekTime, title: this.config.title };
		let tt = !0;
		is.function(this.config.controls) && (this.config.controls = this.config.controls.call(this, et)),
			this.config.controls || (this.config.controls = []),
			is.element(this.config.controls) || is.string(this.config.controls)
				? (_ = this.config.controls)
				: ((_ = controls.create.call(this, {
						id: this.id,
						seektime: this.config.seekTime,
						speed: this.speed,
						quality: this.quality,
						captions: captions.getLabel.call(this),
				  })),
				  (tt = !1));
		let nt;
		if (
			(tt &&
				is.string(this.config.controls) &&
				(_ = ((rt) => {
					let it = rt;
					return (
						Object.entries(et).forEach(([ot, at]) => {
							it = replaceAll(it, `{${ot}}`, at);
						}),
						it
					);
				})(_)),
			is.string(this.config.selectors.controls.container) &&
				(nt = document.querySelector(this.config.selectors.controls.container)),
			is.element(nt) || (nt = this.elements.container),
			nt[is.element(_) ? "insertAdjacentElement" : "insertAdjacentHTML"]("afterbegin", _),
			is.element(this.elements.controls) || controls.findElements.call(this),
			!is.empty(this.elements.buttons))
		) {
			const rt = (it) => {
				const ot = this.config.classNames.controlPressed;
				it.setAttribute("aria-pressed", "false"),
					Object.defineProperty(it, "pressed", {
						configurable: !0,
						enumerable: !0,
						get: () => hasClass(it, ot),
						set(at = !1) {
							toggleClass(it, ot, at), it.setAttribute("aria-pressed", at ? "true" : "false");
						},
					});
			};
			Object.values(this.elements.buttons)
				.filter(Boolean)
				.forEach((it) => {
					is.array(it) || is.nodeList(it) ? Array.from(it).filter(Boolean).forEach(rt) : rt(it);
				});
		}
		if ((browser.isEdge && repaint(nt), this.config.tooltips.controls)) {
			const { classNames: rt, selectors: it } = this.config,
				ot = `${it.controls.wrapper} ${it.labels} .${rt.hidden}`,
				at = getElements.call(this, ot);
			Array.from(at).forEach((st) => {
				toggleClass(st, this.config.classNames.hidden, !1), toggleClass(st, this.config.classNames.tooltip, !0);
			});
		}
	},
	setMediaMetadata() {
		try {
			"mediaSession" in navigator &&
				(navigator.mediaSession.metadata = new window.MediaMetadata({
					title: this.config.mediaMetadata.title,
					artist: this.config.mediaMetadata.artist,
					album: this.config.mediaMetadata.album,
					artwork: this.config.mediaMetadata.artwork,
				}));
		} catch {}
	},
	setMarkers() {
		var _, et;
		if (!this.duration || this.elements.markers) return;
		const tt =
			(_ = this.config.markers) === null || _ === void 0 || (et = _.points) === null || et === void 0
				? void 0
				: et.filter(({ time: st }) => st > 0 && st < this.duration);
		if (tt == null || !tt.length) return;
		const nt = document.createDocumentFragment(),
			rt = document.createDocumentFragment();
		let it = null;
		const ot = `${this.config.classNames.tooltip}--visible`,
			at = (st) => toggleClass(it, ot, st);
		tt.forEach((st) => {
			const lt = createElement("span", { class: this.config.classNames.marker }, ""),
				ut = (st.time / this.duration) * 100 + "%";
			it &&
				(lt.addEventListener("mouseenter", () => {
					st.label || ((it.style.left = ut), (it.innerHTML = st.label), at(!0));
				}),
				lt.addEventListener("mouseleave", () => {
					at(!1);
				})),
				lt.addEventListener("click", () => {
					this.currentTime = st.time;
				}),
				(lt.style.left = ut),
				rt.appendChild(lt);
		}),
			nt.appendChild(rt),
			this.config.tooltips.seek ||
				((it = createElement("span", { class: this.config.classNames.tooltip }, "")), nt.appendChild(it)),
			(this.elements.markers = { points: rt, tip: it }),
			this.elements.progress.appendChild(nt);
	},
};
function parseUrl(_, et = !0) {
	let tt = _;
	if (et) {
		const nt = document.createElement("a");
		(nt.href = tt), (tt = nt.href);
	}
	try {
		return new URL(tt);
	} catch {
		return null;
	}
}
function buildUrlParams(_) {
	const et = new URLSearchParams();
	return (
		is.object(_) &&
			Object.entries(_).forEach(([tt, nt]) => {
				et.set(tt, nt);
			}),
		et
	);
}
const captions = {
		setup() {
			if (!this.supported.ui) return;
			if (!this.isVideo || this.isYouTube || (this.isHTML5 && !support.textTracks))
				return void (
					is.array(this.config.controls) &&
					this.config.controls.includes("settings") &&
					this.config.settings.includes("captions") &&
					controls.setCaptionsMenu.call(this)
				);
			if (
				(is.element(this.elements.captions) ||
					((this.elements.captions = createElement("div", getAttributesFromSelector(this.config.selectors.captions))),
					this.elements.captions.setAttribute("dir", "auto"),
					insertAfter(this.elements.captions, this.elements.wrapper)),
				browser.isIE && window.URL)
			) {
				const nt = this.media.querySelectorAll("track");
				Array.from(nt).forEach((rt) => {
					const it = rt.getAttribute("src"),
						ot = parseUrl(it);
					ot !== null &&
						ot.hostname !== window.location.href.hostname &&
						["http:", "https:"].includes(ot.protocol) &&
						fetch$1(it, "blob")
							.then((at) => {
								rt.setAttribute("src", window.URL.createObjectURL(at));
							})
							.catch(() => {
								removeElement(rt);
							});
				});
			}
			const _ = dedupe(
				(navigator.languages || [navigator.language || navigator.userLanguage || "en"]).map((nt) => nt.split("-")[0])
			);
			let et = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase();
			et === "auto" && ([et] = _);
			let tt = this.storage.get("captions");
			if (
				(is.boolean(tt) || ({ active: tt } = this.config.captions),
				Object.assign(this.captions, { toggled: !1, active: tt, language: et, languages: _ }),
				this.isHTML5)
			) {
				const nt = this.config.captions.update ? "addtrack removetrack" : "removetrack";
				on.call(this, this.media.textTracks, nt, captions.update.bind(this));
			}
			setTimeout(captions.update.bind(this), 0);
		},
		update() {
			const _ = captions.getTracks.call(this, !0),
				{ active: et, language: tt, meta: nt, currentTrackNode: rt } = this.captions,
				it = Boolean(_.find((ot) => ot.language === tt));
			this.isHTML5 &&
				this.isVideo &&
				_.filter((ot) => !nt.get(ot)).forEach((ot) => {
					this.debug.log("Track added", ot),
						nt.set(ot, { default: ot.mode === "showing" }),
						ot.mode === "showing" && (ot.mode = "hidden"),
						on.call(this, ot, "cuechange", () => captions.updateCues.call(this));
				}),
				((it && this.language !== tt) || !_.includes(rt)) &&
					(captions.setLanguage.call(this, tt), captions.toggle.call(this, et && it)),
				this.elements && toggleClass(this.elements.container, this.config.classNames.captions.enabled, !is.empty(_)),
				is.array(this.config.controls) &&
					this.config.controls.includes("settings") &&
					this.config.settings.includes("captions") &&
					controls.setCaptionsMenu.call(this);
		},
		toggle(_, et = !0) {
			if (!this.supported.ui) return;
			const { toggled: tt } = this.captions,
				nt = this.config.classNames.captions.active,
				rt = is.nullOrUndefined(_) ? !tt : _;
			if (rt !== tt) {
				if ((et || ((this.captions.active = rt), this.storage.set({ captions: rt })), !this.language && rt && !et)) {
					const it = captions.getTracks.call(this),
						ot = captions.findTrack.call(this, [this.captions.language, ...this.captions.languages], !0);
					return (this.captions.language = ot.language), void captions.set.call(this, it.indexOf(ot));
				}
				this.elements.buttons.captions && (this.elements.buttons.captions.pressed = rt),
					toggleClass(this.elements.container, nt, rt),
					(this.captions.toggled = rt),
					controls.updateSetting.call(this, "captions"),
					triggerEvent.call(this, this.media, rt ? "captionsenabled" : "captionsdisabled");
			}
			setTimeout(() => {
				rt && this.captions.toggled && (this.captions.currentTrackNode.mode = "hidden");
			});
		},
		set(_, et = !0) {
			const tt = captions.getTracks.call(this);
			if (_ !== -1)
				if (is.number(_))
					if (_ in tt) {
						if (this.captions.currentTrack !== _) {
							this.captions.currentTrack = _;
							const nt = tt[_],
								{ language: rt } = nt || {};
							(this.captions.currentTrackNode = nt),
								controls.updateSetting.call(this, "captions"),
								et || ((this.captions.language = rt), this.storage.set({ language: rt })),
								this.isVimeo && this.embed.enableTextTrack(rt),
								triggerEvent.call(this, this.media, "languagechange");
						}
						captions.toggle.call(this, !0, et), this.isHTML5 && this.isVideo && captions.updateCues.call(this);
					} else this.debug.warn("Track not found", _);
				else this.debug.warn("Invalid caption argument", _);
			else captions.toggle.call(this, !1, et);
		},
		setLanguage(_, et = !0) {
			if (!is.string(_)) return void this.debug.warn("Invalid language argument", _);
			const tt = _.toLowerCase();
			this.captions.language = tt;
			const nt = captions.getTracks.call(this),
				rt = captions.findTrack.call(this, [tt]);
			captions.set.call(this, nt.indexOf(rt), et);
		},
		getTracks(_ = !1) {
			return Array.from((this.media || {}).textTracks || [])
				.filter((et) => !this.isHTML5 || _ || this.captions.meta.has(et))
				.filter((et) => ["captions", "subtitles"].includes(et.kind));
		},
		findTrack(_, et = !1) {
			const tt = captions.getTracks.call(this),
				nt = (ot) => Number((this.captions.meta.get(ot) || {}).default),
				rt = Array.from(tt).sort((ot, at) => nt(at) - nt(ot));
			let it;
			return _.every((ot) => ((it = rt.find((at) => at.language === ot)), !it)), it || (et ? rt[0] : void 0);
		},
		getCurrentTrack() {
			return captions.getTracks.call(this)[this.currentTrack];
		},
		getLabel(_) {
			let et = _;
			return (
				!is.track(et) && support.textTracks && this.captions.toggled && (et = captions.getCurrentTrack.call(this)),
				is.track(et)
					? is.empty(et.label)
						? is.empty(et.language)
							? i18n.get("enabled", this.config)
							: _.language.toUpperCase()
						: et.label
					: i18n.get("disabled", this.config)
			);
		},
		updateCues(_) {
			if (!this.supported.ui) return;
			if (!is.element(this.elements.captions)) return void this.debug.warn("No captions element to render to");
			if (!is.nullOrUndefined(_) && !Array.isArray(_)) return void this.debug.warn("updateCues: Invalid input", _);
			let et = _;
			if (!et) {
				const nt = captions.getCurrentTrack.call(this);
				et = Array.from((nt || {}).activeCues || [])
					.map((rt) => rt.getCueAsHTML())
					.map(getHTML);
			}
			const tt = et.map((nt) => nt.trim()).join(`
`);
			if (tt !== this.elements.captions.innerHTML) {
				emptyElement(this.elements.captions);
				const nt = createElement("span", getAttributesFromSelector(this.config.selectors.caption));
				(nt.innerHTML = tt), this.elements.captions.appendChild(nt), triggerEvent.call(this, this.media, "cuechange");
			}
		},
	},
	defaults = {
		enabled: !0,
		title: "",
		debug: !1,
		autoplay: !1,
		autopause: !0,
		playsinline: !0,
		seekTime: 10,
		volume: 1,
		muted: !1,
		duration: null,
		displayDuration: !0,
		invertTime: !0,
		toggleInvert: !0,
		ratio: null,
		clickToPlay: !0,
		hideControls: !0,
		resetOnEnd: !1,
		disableContextMenu: !0,
		loadSprite: !0,
		iconPrefix: "plyr",
		iconUrl: "https://cdn.plyr.io/3.7.3/plyr.svg",
		blankVideo: "https://cdn.plyr.io/static/blank.mp4",
		quality: {
			default: 576,
			options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
			forced: !1,
			onChange: null,
		},
		loop: { active: !1 },
		speed: { selected: 1, options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4] },
		keyboard: { focused: !0, global: !1 },
		tooltips: { controls: !1, seek: !0 },
		captions: { active: !1, language: "auto", update: !1 },
		fullscreen: { enabled: !0, fallback: !0, iosNative: !1 },
		storage: { enabled: !0, key: "plyr" },
		controls: [
			"play-large",
			"play",
			"progress",
			"current-time",
			"mute",
			"volume",
			"captions",
			"settings",
			"pip",
			"airplay",
			"fullscreen",
		],
		settings: ["captions", "quality", "speed"],
		i18n: {
			restart: "Restart",
			rewind: "Rewind {seektime}s",
			play: "Play",
			pause: "Pause",
			fastForward: "Forward {seektime}s",
			seek: "Seek",
			seekLabel: "{currentTime} of {duration}",
			played: "Played",
			buffered: "Buffered",
			currentTime: "Current time",
			duration: "Duration",
			volume: "Volume",
			mute: "Mute",
			unmute: "Unmute",
			enableCaptions: "Enable captions",
			disableCaptions: "Disable captions",
			download: "Download",
			enterFullscreen: "Enter fullscreen",
			exitFullscreen: "Exit fullscreen",
			frameTitle: "Player for {title}",
			captions: "Captions",
			settings: "Settings",
			pip: "PIP",
			menuBack: "Go back to previous menu",
			speed: "Speed",
			normal: "Normal",
			quality: "Quality",
			loop: "Loop",
			start: "Start",
			end: "End",
			all: "All",
			reset: "Reset",
			disabled: "Disabled",
			enabled: "Enabled",
			advertisement: "Ad",
			qualityBadge: { 2160: "4K", 1440: "HD", 1080: "HD", 720: "HD", 576: "SD", 480: "SD" },
		},
		urls: {
			download: null,
			vimeo: {
				sdk: "https://player.vimeo.com/api/player.js",
				iframe: "https://player.vimeo.com/video/{0}?{1}",
				api: "https://vimeo.com/api/oembed.json?url={0}",
			},
			youtube: {
				sdk: "https://www.youtube.com/iframe_api",
				api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}",
			},
			googleIMA: { sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js" },
		},
		listeners: {
			seek: null,
			play: null,
			pause: null,
			restart: null,
			rewind: null,
			fastForward: null,
			mute: null,
			volume: null,
			captions: null,
			download: null,
			fullscreen: null,
			pip: null,
			airplay: null,
			speed: null,
			quality: null,
			loop: null,
			language: null,
		},
		events: [
			"ended",
			"progress",
			"stalled",
			"playing",
			"waiting",
			"canplay",
			"canplaythrough",
			"loadstart",
			"loadeddata",
			"loadedmetadata",
			"timeupdate",
			"volumechange",
			"play",
			"pause",
			"error",
			"seeking",
			"seeked",
			"emptied",
			"ratechange",
			"cuechange",
			"download",
			"enterfullscreen",
			"exitfullscreen",
			"captionsenabled",
			"captionsdisabled",
			"languagechange",
			"controlshidden",
			"controlsshown",
			"ready",
			"statechange",
			"qualitychange",
			"adsloaded",
			"adscontentpause",
			"adscontentresume",
			"adstarted",
			"adsmidpoint",
			"adscomplete",
			"adsallcomplete",
			"adsimpression",
			"adsclick",
		],
		selectors: {
			editable: "input, textarea, select, [contenteditable]",
			container: ".plyr",
			controls: { container: null, wrapper: ".plyr__controls" },
			labels: "[data-plyr]",
			buttons: {
				play: '[data-plyr="play"]',
				pause: '[data-plyr="pause"]',
				restart: '[data-plyr="restart"]',
				rewind: '[data-plyr="rewind"]',
				fastForward: '[data-plyr="fast-forward"]',
				mute: '[data-plyr="mute"]',
				captions: '[data-plyr="captions"]',
				download: '[data-plyr="download"]',
				fullscreen: '[data-plyr="fullscreen"]',
				pip: '[data-plyr="pip"]',
				airplay: '[data-plyr="airplay"]',
				settings: '[data-plyr="settings"]',
				loop: '[data-plyr="loop"]',
			},
			inputs: {
				seek: '[data-plyr="seek"]',
				volume: '[data-plyr="volume"]',
				speed: '[data-plyr="speed"]',
				language: '[data-plyr="language"]',
				quality: '[data-plyr="quality"]',
			},
			display: {
				currentTime: ".plyr__time--current",
				duration: ".plyr__time--duration",
				buffer: ".plyr__progress__buffer",
				loop: ".plyr__progress__loop",
				volume: ".plyr__volume--display",
			},
			progress: ".plyr__progress",
			captions: ".plyr__captions",
			caption: ".plyr__caption",
		},
		classNames: {
			type: "plyr--{0}",
			provider: "plyr--{0}",
			video: "plyr__video-wrapper",
			embed: "plyr__video-embed",
			videoFixedRatio: "plyr__video-wrapper--fixed-ratio",
			embedContainer: "plyr__video-embed__container",
			poster: "plyr__poster",
			posterEnabled: "plyr__poster-enabled",
			ads: "plyr__ads",
			control: "plyr__control",
			controlPressed: "plyr__control--pressed",
			playing: "plyr--playing",
			paused: "plyr--paused",
			stopped: "plyr--stopped",
			loading: "plyr--loading",
			hover: "plyr--hover",
			tooltip: "plyr__tooltip",
			cues: "plyr__cues",
			marker: "plyr__progress__marker",
			hidden: "plyr__sr-only",
			hideControls: "plyr--hide-controls",
			isIos: "plyr--is-ios",
			isTouch: "plyr--is-touch",
			uiSupported: "plyr--full-ui",
			noTransition: "plyr--no-transition",
			display: { time: "plyr__time" },
			menu: { value: "plyr__menu__value", badge: "plyr__badge", open: "plyr--menu-open" },
			captions: { enabled: "plyr--captions-enabled", active: "plyr--captions-active" },
			fullscreen: { enabled: "plyr--fullscreen-enabled", fallback: "plyr--fullscreen-fallback" },
			pip: { supported: "plyr--pip-supported", active: "plyr--pip-active" },
			airplay: { supported: "plyr--airplay-supported", active: "plyr--airplay-active" },
			tabFocus: "plyr__tab-focus",
			previewThumbnails: {
				thumbContainer: "plyr__preview-thumb",
				thumbContainerShown: "plyr__preview-thumb--is-shown",
				imageContainer: "plyr__preview-thumb__image-container",
				timeContainer: "plyr__preview-thumb__time-container",
				scrubbingContainer: "plyr__preview-scrubbing",
				scrubbingContainerShown: "plyr__preview-scrubbing--is-shown",
			},
		},
		attributes: { embed: { provider: "data-plyr-provider", id: "data-plyr-embed-id", hash: "data-plyr-embed-hash" } },
		ads: { enabled: !1, publisherId: "", tagUrl: "" },
		previewThumbnails: { enabled: !1, src: "" },
		vimeo: {
			byline: !1,
			portrait: !1,
			title: !1,
			speed: !0,
			transparent: !1,
			customControls: !0,
			referrerPolicy: null,
			premium: !1,
		},
		youtube: { rel: 0, showinfo: 0, iv_load_policy: 3, modestbranding: 1, customControls: !0, noCookie: !1 },
		mediaMetadata: { title: "", artist: "", album: "", artwork: [] },
		markers: { enabled: !1, points: [] },
	},
	pip = { active: "picture-in-picture", inactive: "inline" },
	providers = { html5: "html5", youtube: "youtube", vimeo: "vimeo" },
	types$1 = { audio: "audio", video: "video" };
function getProviderByUrl(_) {
	return /^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(_)
		? providers.youtube
		: /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(_)
		? providers.vimeo
		: null;
}
const noop$1 = () => {};
class Console {
	constructor(et = !1) {
		(this.enabled = window.console && et), this.enabled && this.log("Debugging enabled");
	}
	get log() {
		return this.enabled ? Function.prototype.bind.call(console.log, console) : noop$1;
	}
	get warn() {
		return this.enabled ? Function.prototype.bind.call(console.warn, console) : noop$1;
	}
	get error() {
		return this.enabled ? Function.prototype.bind.call(console.error, console) : noop$1;
	}
}
class Fullscreen {
	constructor(et) {
		_defineProperty$1(this, "onChange", () => {
			if (!this.enabled) return;
			const tt = this.player.elements.buttons.fullscreen;
			is.element(tt) && (tt.pressed = this.active);
			const nt = this.target === this.player.media ? this.target : this.player.elements.container;
			triggerEvent.call(this.player, nt, this.active ? "enterfullscreen" : "exitfullscreen", !0);
		}),
			_defineProperty$1(this, "toggleFallback", (tt = !1) => {
				if (
					(tt
						? (this.scrollPosition = { x: window.scrollX || 0, y: window.scrollY || 0 })
						: window.scrollTo(this.scrollPosition.x, this.scrollPosition.y),
					(document.body.style.overflow = tt ? "hidden" : ""),
					toggleClass(this.target, this.player.config.classNames.fullscreen.fallback, tt),
					browser.isIos)
				) {
					let nt = document.head.querySelector('meta[name="viewport"]');
					const rt = "viewport-fit=cover";
					nt || ((nt = document.createElement("meta")), nt.setAttribute("name", "viewport"));
					const it = is.string(nt.content) && nt.content.includes(rt);
					tt
						? ((this.cleanupViewport = !it), it || (nt.content += `,${rt}`))
						: this.cleanupViewport &&
						  (nt.content = nt.content
								.split(",")
								.filter((ot) => ot.trim() !== rt)
								.join(","));
				}
				this.onChange();
			}),
			_defineProperty$1(this, "trapFocus", (tt) => {
				if (browser.isIos || !this.active || tt.key !== "Tab") return;
				const nt = document.activeElement,
					rt = getElements.call(this.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"),
					[it] = rt,
					ot = rt[rt.length - 1];
				nt !== ot || tt.shiftKey
					? nt === it && tt.shiftKey && (ot.focus(), tt.preventDefault())
					: (it.focus(), tt.preventDefault());
			}),
			_defineProperty$1(this, "update", () => {
				if (this.enabled) {
					let tt;
					(tt = this.forceFallback ? "Fallback (forced)" : Fullscreen.native ? "Native" : "Fallback"),
						this.player.debug.log(`${tt} fullscreen enabled`);
				} else this.player.debug.log("Fullscreen not supported and fallback disabled");
				toggleClass(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled);
			}),
			_defineProperty$1(this, "enter", () => {
				this.enabled &&
					(browser.isIos && this.player.config.fullscreen.iosNative
						? this.player.isVimeo
							? this.player.embed.requestFullscreen()
							: this.target.webkitEnterFullscreen()
						: !Fullscreen.native || this.forceFallback
						? this.toggleFallback(!0)
						: this.prefix
						? is.empty(this.prefix) || this.target[`${this.prefix}Request${this.property}`]()
						: this.target.requestFullscreen({ navigationUI: "hide" }));
			}),
			_defineProperty$1(this, "exit", () => {
				if (this.enabled)
					if (browser.isIos && this.player.config.fullscreen.iosNative)
						this.target.webkitExitFullscreen(), silencePromise(this.player.play());
					else if (!Fullscreen.native || this.forceFallback) this.toggleFallback(!1);
					else if (this.prefix) {
						if (!is.empty(this.prefix)) {
							const tt = this.prefix === "moz" ? "Cancel" : "Exit";
							document[`${this.prefix}${tt}${this.property}`]();
						}
					} else (document.cancelFullScreen || document.exitFullscreen).call(document);
			}),
			_defineProperty$1(this, "toggle", () => {
				this.active ? this.exit() : this.enter();
			}),
			(this.player = et),
			(this.prefix = Fullscreen.prefix),
			(this.property = Fullscreen.property),
			(this.scrollPosition = { x: 0, y: 0 }),
			(this.forceFallback = et.config.fullscreen.fallback === "force"),
			(this.player.elements.fullscreen =
				et.config.fullscreen.container && closest$1(this.player.elements.container, et.config.fullscreen.container)),
			on.call(
				this.player,
				document,
				this.prefix === "ms" ? "MSFullscreenChange" : `${this.prefix}fullscreenchange`,
				() => {
					this.onChange();
				}
			),
			on.call(this.player, this.player.elements.container, "dblclick", (tt) => {
				(is.element(this.player.elements.controls) && this.player.elements.controls.contains(tt.target)) ||
					this.player.listeners.proxy(tt, this.toggle, "fullscreen");
			}),
			on.call(this, this.player.elements.container, "keydown", (tt) => this.trapFocus(tt)),
			this.update();
	}
	static get native() {
		return !!(
			document.fullscreenEnabled ||
			document.webkitFullscreenEnabled ||
			document.mozFullScreenEnabled ||
			document.msFullscreenEnabled
		);
	}
	get usingNative() {
		return Fullscreen.native && !this.forceFallback;
	}
	static get prefix() {
		if (is.function(document.exitFullscreen)) return "";
		let et = "";
		return (
			["webkit", "moz", "ms"].some(
				(tt) =>
					!(!is.function(document[`${tt}ExitFullscreen`]) && !is.function(document[`${tt}CancelFullScreen`])) &&
					((et = tt), !0)
			),
			et
		);
	}
	static get property() {
		return this.prefix === "moz" ? "FullScreen" : "Fullscreen";
	}
	get enabled() {
		return (
			(Fullscreen.native || this.player.config.fullscreen.fallback) &&
			this.player.config.fullscreen.enabled &&
			this.player.supported.ui &&
			this.player.isVideo
		);
	}
	get active() {
		if (!this.enabled) return !1;
		if (!Fullscreen.native || this.forceFallback)
			return hasClass(this.target, this.player.config.classNames.fullscreen.fallback);
		const et = this.prefix
			? this.target.getRootNode()[`${this.prefix}${this.property}Element`]
			: this.target.getRootNode().fullscreenElement;
		return et && et.shadowRoot ? et === this.target.getRootNode().host : et === this.target;
	}
	get target() {
		return browser.isIos && this.player.config.fullscreen.iosNative
			? this.player.media
			: this.player.elements.fullscreen || this.player.elements.container;
	}
}
function loadImage(_, et = 1) {
	return new Promise((tt, nt) => {
		const rt = new Image(),
			it = () => {
				delete rt.onload, delete rt.onerror, (rt.naturalWidth >= et ? tt : nt)(rt);
			};
		Object.assign(rt, { onload: it, onerror: it, src: _ });
	});
}
const ui = {
	addStyleHook() {
		toggleClass(this.elements.container, this.config.selectors.container.replace(".", ""), !0),
			toggleClass(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);
	},
	toggleNativeControls(_ = !1) {
		_ && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls");
	},
	build() {
		if ((this.listeners.media(), !this.supported.ui))
			return (
				this.debug.warn(`Basic support only for ${this.provider} ${this.type}`),
				void ui.toggleNativeControls.call(this, !0)
			);
		is.element(this.elements.controls) || (controls.inject.call(this), this.listeners.controls()),
			ui.toggleNativeControls.call(this),
			this.isHTML5 && captions.setup.call(this),
			(this.volume = null),
			(this.muted = null),
			(this.loop = null),
			(this.quality = null),
			(this.speed = null),
			controls.updateVolume.call(this),
			controls.timeUpdate.call(this),
			controls.durationUpdate.call(this),
			ui.checkPlaying.call(this),
			toggleClass(
				this.elements.container,
				this.config.classNames.pip.supported,
				support.pip && this.isHTML5 && this.isVideo
			),
			toggleClass(this.elements.container, this.config.classNames.airplay.supported, support.airplay && this.isHTML5),
			toggleClass(this.elements.container, this.config.classNames.isIos, browser.isIos),
			toggleClass(this.elements.container, this.config.classNames.isTouch, this.touch),
			(this.ready = !0),
			setTimeout(() => {
				triggerEvent.call(this, this.media, "ready");
			}, 0),
			ui.setTitle.call(this),
			this.poster && ui.setPoster.call(this, this.poster, !1).catch(() => {}),
			this.config.duration && controls.durationUpdate.call(this),
			this.config.mediaMetadata && controls.setMediaMetadata.call(this);
	},
	setTitle() {
		let _ = i18n.get("play", this.config);
		if (
			(is.string(this.config.title) && !is.empty(this.config.title) && (_ += `, ${this.config.title}`),
			Array.from(this.elements.buttons.play || []).forEach((et) => {
				et.setAttribute("aria-label", _);
			}),
			this.isEmbed)
		) {
			const et = getElement.call(this, "iframe");
			if (!is.element(et)) return;
			const tt = is.empty(this.config.title) ? "video" : this.config.title,
				nt = i18n.get("frameTitle", this.config);
			et.setAttribute("title", nt.replace("{title}", tt));
		}
	},
	togglePoster(_) {
		toggleClass(this.elements.container, this.config.classNames.posterEnabled, _);
	},
	setPoster(_, et = !0) {
		return et && this.poster
			? Promise.reject(new Error("Poster already set"))
			: (this.media.setAttribute("data-poster", _),
			  this.elements.poster.removeAttribute("hidden"),
			  ready
					.call(this)
					.then(() => loadImage(_))
					.catch((tt) => {
						throw (_ === this.poster && ui.togglePoster.call(this, !1), tt);
					})
					.then(() => {
						if (_ !== this.poster) throw new Error("setPoster cancelled by later call to setPoster");
					})
					.then(
						() => (
							Object.assign(this.elements.poster.style, { backgroundImage: `url('${_}')`, backgroundSize: "" }),
							ui.togglePoster.call(this, !0),
							_
						)
					));
	},
	checkPlaying(_) {
		toggleClass(this.elements.container, this.config.classNames.playing, this.playing),
			toggleClass(this.elements.container, this.config.classNames.paused, this.paused),
			toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped),
			Array.from(this.elements.buttons.play || []).forEach((et) => {
				Object.assign(et, { pressed: this.playing }),
					et.setAttribute("aria-label", i18n.get(this.playing ? "pause" : "play", this.config));
			}),
			(is.event(_) && _.type === "timeupdate") || ui.toggleControls.call(this);
	},
	checkLoading(_) {
		(this.loading = ["stalled", "waiting"].includes(_.type)),
			clearTimeout(this.timers.loading),
			(this.timers.loading = setTimeout(
				() => {
					toggleClass(this.elements.container, this.config.classNames.loading, this.loading),
						ui.toggleControls.call(this);
				},
				this.loading ? 250 : 0
			));
	},
	toggleControls(_) {
		const { controls: et } = this.elements;
		if (et && this.config.hideControls) {
			const tt = this.touch && this.lastSeekTime + 2e3 > Date.now();
			this.toggleControls(Boolean(_ || this.loading || this.paused || et.pressed || et.hover || tt));
		}
	},
	migrateStyles() {
		Object.values({ ...this.media.style })
			.filter((_) => !is.empty(_) && is.string(_) && _.startsWith("--plyr"))
			.forEach((_) => {
				this.elements.container.style.setProperty(_, this.media.style.getPropertyValue(_)),
					this.media.style.removeProperty(_);
			}),
			is.empty(this.media.style) && this.media.removeAttribute("style");
	},
};
class Listeners {
	constructor(et) {
		_defineProperty$1(this, "firstTouch", () => {
			const { player: tt } = this,
				{ elements: nt } = tt;
			(tt.touch = !0), toggleClass(nt.container, tt.config.classNames.isTouch, !0);
		}),
			_defineProperty$1(this, "setTabFocus", (tt) => {
				const { player: nt } = this,
					{ elements: rt } = nt,
					{ key: it, type: ot, timeStamp: at } = tt;
				if ((clearTimeout(this.focusTimer), ot === "keydown" && it !== "Tab")) return;
				ot === "keydown" && (this.lastKeyDown = at);
				const st = at - this.lastKeyDown <= 20;
				(ot !== "focus" || st) &&
					((() => {
						const lt = nt.config.classNames.tabFocus;
						toggleClass(getElements.call(nt, `.${lt}`), lt, !1);
					})(),
					ot !== "focusout" &&
						(this.focusTimer = setTimeout(() => {
							const lt = document.activeElement;
							rt.container.contains(lt) && toggleClass(document.activeElement, nt.config.classNames.tabFocus, !0);
						}, 10)));
			}),
			_defineProperty$1(this, "global", (tt = !0) => {
				const { player: nt } = this;
				nt.config.keyboard.global && toggleListener.call(nt, window, "keydown keyup", this.handleKey, tt, !1),
					toggleListener.call(nt, document.body, "click", this.toggleMenu, tt),
					once.call(nt, document.body, "touchstart", this.firstTouch),
					toggleListener.call(nt, document.body, "keydown focus blur focusout", this.setTabFocus, tt, !1, !0);
			}),
			_defineProperty$1(this, "container", () => {
				const { player: tt } = this,
					{ config: nt, elements: rt, timers: it } = tt;
				!nt.keyboard.global && nt.keyboard.focused && on.call(tt, rt.container, "keydown keyup", this.handleKey, !1),
					on.call(
						tt,
						rt.container,
						"mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen",
						(st) => {
							const { controls: lt } = rt;
							lt && st.type === "enterfullscreen" && ((lt.pressed = !1), (lt.hover = !1));
							let ut = 0;
							["touchstart", "touchmove", "mousemove"].includes(st.type) &&
								(ui.toggleControls.call(tt, !0), (ut = tt.touch ? 3e3 : 2e3)),
								clearTimeout(it.controls),
								(it.controls = setTimeout(() => ui.toggleControls.call(tt, !1), ut));
						}
					);
				const ot = () => {
						if (!tt.isVimeo || tt.config.vimeo.premium) return;
						const st = rt.wrapper,
							{ active: lt } = tt.fullscreen,
							[ut, dt] = getAspectRatio.call(tt),
							ct = supportsCSS(`aspect-ratio: ${ut} / ${dt}`);
						if (!lt)
							return void (ct
								? ((st.style.width = null), (st.style.height = null))
								: ((st.style.maxWidth = null), (st.style.margin = null)));
						const [ft, mt] = getViewportSize(),
							pt = ft / mt > ut / dt;
						ct
							? ((st.style.width = pt ? "auto" : "100%"), (st.style.height = pt ? "100%" : "auto"))
							: ((st.style.maxWidth = pt ? (mt / dt) * ut + "px" : null), (st.style.margin = pt ? "0 auto" : null));
					},
					at = () => {
						clearTimeout(it.resized), (it.resized = setTimeout(ot, 50));
					};
				on.call(tt, rt.container, "enterfullscreen exitfullscreen", (st) => {
					const { target: lt } = tt.fullscreen;
					lt === rt.container &&
						((!tt.isEmbed && is.empty(tt.config.ratio)) ||
							(ot(), (st.type === "enterfullscreen" ? on : off).call(tt, window, "resize", at)));
				});
			}),
			_defineProperty$1(this, "media", () => {
				const { player: tt } = this,
					{ elements: nt } = tt;
				if (
					(on.call(tt, tt.media, "timeupdate seeking seeked", (it) => controls.timeUpdate.call(tt, it)),
					on.call(tt, tt.media, "durationchange loadeddata loadedmetadata", (it) =>
						controls.durationUpdate.call(tt, it)
					),
					on.call(tt, tt.media, "ended", () => {
						tt.isHTML5 && tt.isVideo && tt.config.resetOnEnd && (tt.restart(), tt.pause());
					}),
					on.call(tt, tt.media, "progress playing seeking seeked", (it) => controls.updateProgress.call(tt, it)),
					on.call(tt, tt.media, "volumechange", (it) => controls.updateVolume.call(tt, it)),
					on.call(tt, tt.media, "playing play pause ended emptied timeupdate", (it) => ui.checkPlaying.call(tt, it)),
					on.call(tt, tt.media, "waiting canplay seeked playing", (it) => ui.checkLoading.call(tt, it)),
					tt.supported.ui && tt.config.clickToPlay && !tt.isAudio)
				) {
					const it = getElement.call(tt, `.${tt.config.classNames.video}`);
					if (!is.element(it)) return;
					on.call(tt, nt.container, "click", (ot) => {
						([nt.container, it].includes(ot.target) || it.contains(ot.target)) &&
							((tt.touch && tt.config.hideControls) ||
								(tt.ended
									? (this.proxy(ot, tt.restart, "restart"),
									  this.proxy(
											ot,
											() => {
												silencePromise(tt.play());
											},
											"play"
									  ))
									: this.proxy(
											ot,
											() => {
												silencePromise(tt.togglePlay());
											},
											"play"
									  )));
					});
				}
				tt.supported.ui &&
					tt.config.disableContextMenu &&
					on.call(
						tt,
						nt.wrapper,
						"contextmenu",
						(it) => {
							it.preventDefault();
						},
						!1
					),
					on.call(tt, tt.media, "volumechange", () => {
						tt.storage.set({ volume: tt.volume, muted: tt.muted });
					}),
					on.call(tt, tt.media, "ratechange", () => {
						controls.updateSetting.call(tt, "speed"), tt.storage.set({ speed: tt.speed });
					}),
					on.call(tt, tt.media, "qualitychange", (it) => {
						controls.updateSetting.call(tt, "quality", null, it.detail.quality);
					}),
					on.call(tt, tt.media, "ready qualitychange", () => {
						controls.setDownloadUrl.call(tt);
					});
				const rt = tt.config.events.concat(["keyup", "keydown"]).join(" ");
				on.call(tt, tt.media, rt, (it) => {
					let { detail: ot = {} } = it;
					it.type === "error" && (ot = tt.media.error), triggerEvent.call(tt, nt.container, it.type, !0, ot);
				});
			}),
			_defineProperty$1(this, "proxy", (tt, nt, rt) => {
				const { player: it } = this,
					ot = it.config.listeners[rt];
				let at = !0;
				is.function(ot) && (at = ot.call(it, tt)), at !== !1 && is.function(nt) && nt.call(it, tt);
			}),
			_defineProperty$1(this, "bind", (tt, nt, rt, it, ot = !0) => {
				const { player: at } = this,
					st = at.config.listeners[it],
					lt = is.function(st);
				on.call(at, tt, nt, (ut) => this.proxy(ut, rt, it), ot && !lt);
			}),
			_defineProperty$1(this, "controls", () => {
				const { player: tt } = this,
					{ elements: nt } = tt,
					rt = browser.isIE ? "change" : "input";
				if (
					(nt.buttons.play &&
						Array.from(nt.buttons.play).forEach((it) => {
							this.bind(
								it,
								"click",
								() => {
									silencePromise(tt.togglePlay());
								},
								"play"
							);
						}),
					this.bind(nt.buttons.restart, "click", tt.restart, "restart"),
					this.bind(
						nt.buttons.rewind,
						"click",
						() => {
							(tt.lastSeekTime = Date.now()), tt.rewind();
						},
						"rewind"
					),
					this.bind(
						nt.buttons.fastForward,
						"click",
						() => {
							(tt.lastSeekTime = Date.now()), tt.forward();
						},
						"fastForward"
					),
					this.bind(
						nt.buttons.mute,
						"click",
						() => {
							tt.muted = !tt.muted;
						},
						"mute"
					),
					this.bind(nt.buttons.captions, "click", () => tt.toggleCaptions()),
					this.bind(
						nt.buttons.download,
						"click",
						() => {
							triggerEvent.call(tt, tt.media, "download");
						},
						"download"
					),
					this.bind(
						nt.buttons.fullscreen,
						"click",
						() => {
							tt.fullscreen.toggle();
						},
						"fullscreen"
					),
					this.bind(
						nt.buttons.pip,
						"click",
						() => {
							tt.pip = "toggle";
						},
						"pip"
					),
					this.bind(nt.buttons.airplay, "click", tt.airplay, "airplay"),
					this.bind(
						nt.buttons.settings,
						"click",
						(it) => {
							it.stopPropagation(), it.preventDefault(), controls.toggleMenu.call(tt, it);
						},
						null,
						!1
					),
					this.bind(
						nt.buttons.settings,
						"keyup",
						(it) => {
							["Space", "Enter"].includes(it.key) &&
								(it.key !== "Enter"
									? (it.preventDefault(), it.stopPropagation(), controls.toggleMenu.call(tt, it))
									: controls.focusFirstMenuItem.call(tt, null, !0));
						},
						null,
						!1
					),
					this.bind(nt.settings.menu, "keydown", (it) => {
						it.key === "Escape" && controls.toggleMenu.call(tt, it);
					}),
					this.bind(nt.inputs.seek, "mousedown mousemove", (it) => {
						const ot = nt.progress.getBoundingClientRect(),
							at = (100 / ot.width) * (it.pageX - ot.left);
						it.currentTarget.setAttribute("seek-value", at);
					}),
					this.bind(nt.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", (it) => {
						const ot = it.currentTarget,
							at = "play-on-seeked";
						if (is.keyboardEvent(it) && !["ArrowLeft", "ArrowRight"].includes(it.key)) return;
						tt.lastSeekTime = Date.now();
						const st = ot.hasAttribute(at),
							lt = ["mouseup", "touchend", "keyup"].includes(it.type);
						st && lt
							? (ot.removeAttribute(at), silencePromise(tt.play()))
							: !lt && tt.playing && (ot.setAttribute(at, ""), tt.pause());
					}),
					browser.isIos)
				) {
					const it = getElements.call(tt, 'input[type="range"]');
					Array.from(it).forEach((ot) => this.bind(ot, rt, (at) => repaint(at.target)));
				}
				this.bind(
					nt.inputs.seek,
					rt,
					(it) => {
						const ot = it.currentTarget;
						let at = ot.getAttribute("seek-value");
						is.empty(at) && (at = ot.value),
							ot.removeAttribute("seek-value"),
							(tt.currentTime = (at / ot.max) * tt.duration);
					},
					"seek"
				),
					this.bind(nt.progress, "mouseenter mouseleave mousemove", (it) => controls.updateSeekTooltip.call(tt, it)),
					this.bind(nt.progress, "mousemove touchmove", (it) => {
						const { previewThumbnails: ot } = tt;
						ot && ot.loaded && ot.startMove(it);
					}),
					this.bind(nt.progress, "mouseleave touchend click", () => {
						const { previewThumbnails: it } = tt;
						it && it.loaded && it.endMove(!1, !0);
					}),
					this.bind(nt.progress, "mousedown touchstart", (it) => {
						const { previewThumbnails: ot } = tt;
						ot && ot.loaded && ot.startScrubbing(it);
					}),
					this.bind(nt.progress, "mouseup touchend", (it) => {
						const { previewThumbnails: ot } = tt;
						ot && ot.loaded && ot.endScrubbing(it);
					}),
					browser.isWebkit &&
						Array.from(getElements.call(tt, 'input[type="range"]')).forEach((it) => {
							this.bind(it, "input", (ot) => controls.updateRangeFill.call(tt, ot.target));
						}),
					tt.config.toggleInvert &&
						!is.element(nt.display.duration) &&
						this.bind(nt.display.currentTime, "click", () => {
							tt.currentTime !== 0 && ((tt.config.invertTime = !tt.config.invertTime), controls.timeUpdate.call(tt));
						}),
					this.bind(
						nt.inputs.volume,
						rt,
						(it) => {
							tt.volume = it.target.value;
						},
						"volume"
					),
					this.bind(nt.controls, "mouseenter mouseleave", (it) => {
						nt.controls.hover = !tt.touch && it.type === "mouseenter";
					}),
					nt.fullscreen &&
						Array.from(nt.fullscreen.children)
							.filter((it) => !it.contains(nt.container))
							.forEach((it) => {
								this.bind(it, "mouseenter mouseleave", (ot) => {
									nt.controls && (nt.controls.hover = !tt.touch && ot.type === "mouseenter");
								});
							}),
					this.bind(nt.controls, "mousedown mouseup touchstart touchend touchcancel", (it) => {
						nt.controls.pressed = ["mousedown", "touchstart"].includes(it.type);
					}),
					this.bind(nt.controls, "focusin", () => {
						const { config: it, timers: ot } = tt;
						toggleClass(nt.controls, it.classNames.noTransition, !0),
							ui.toggleControls.call(tt, !0),
							setTimeout(() => {
								toggleClass(nt.controls, it.classNames.noTransition, !1);
							}, 0);
						const at = this.touch ? 3e3 : 4e3;
						clearTimeout(ot.controls), (ot.controls = setTimeout(() => ui.toggleControls.call(tt, !1), at));
					}),
					this.bind(
						nt.inputs.volume,
						"wheel",
						(it) => {
							const ot = it.webkitDirectionInvertedFromDevice,
								[at, st] = [it.deltaX, -it.deltaY].map((dt) => (ot ? -dt : dt)),
								lt = Math.sign(Math.abs(at) > Math.abs(st) ? at : st);
							tt.increaseVolume(lt / 50);
							const { volume: ut } = tt.media;
							((lt === 1 && ut < 1) || (lt === -1 && ut > 0)) && it.preventDefault();
						},
						"volume",
						!1
					);
			}),
			(this.player = et),
			(this.lastKey = null),
			(this.focusTimer = null),
			(this.lastKeyDown = null),
			(this.handleKey = this.handleKey.bind(this)),
			(this.toggleMenu = this.toggleMenu.bind(this)),
			(this.setTabFocus = this.setTabFocus.bind(this)),
			(this.firstTouch = this.firstTouch.bind(this));
	}
	handleKey(et) {
		const { player: tt } = this,
			{ elements: nt } = tt,
			{ key: rt, type: it, altKey: ot, ctrlKey: at, metaKey: st, shiftKey: lt } = et,
			ut = it === "keydown",
			dt = ut && rt === this.lastKey;
		if (!(ot || at || st || lt) && !!rt) {
			if (ut) {
				const ft = document.activeElement;
				if (is.element(ft)) {
					const { editable: mt } = tt.config.selectors,
						{ seek: pt } = nt.inputs;
					if ((ft !== pt && matches(ft, mt)) || (et.key === "Space" && matches(ft, 'button, [role^="menuitem"]')))
						return;
				}
				switch (
					([
						"Space",
						"ArrowLeft",
						"ArrowUp",
						"ArrowRight",
						"ArrowDown",
						"0",
						"1",
						"2",
						"3",
						"4",
						"5",
						"6",
						"7",
						"8",
						"9",
						"c",
						"f",
						"k",
						"l",
						"m",
					].includes(rt) && (et.preventDefault(), et.stopPropagation()),
					rt)
				) {
					case "0":
					case "1":
					case "2":
					case "3":
					case "4":
					case "5":
					case "6":
					case "7":
					case "8":
					case "9":
						dt || ((ct = parseInt(rt, 10)), (tt.currentTime = (tt.duration / 10) * ct));
						break;
					case "Space":
					case "k":
						dt || silencePromise(tt.togglePlay());
						break;
					case "ArrowUp":
						tt.increaseVolume(0.1);
						break;
					case "ArrowDown":
						tt.decreaseVolume(0.1);
						break;
					case "m":
						dt || (tt.muted = !tt.muted);
						break;
					case "ArrowRight":
						tt.forward();
						break;
					case "ArrowLeft":
						tt.rewind();
						break;
					case "f":
						tt.fullscreen.toggle();
						break;
					case "c":
						dt || tt.toggleCaptions();
						break;
					case "l":
						tt.loop = !tt.loop;
				}
				rt === "Escape" && !tt.fullscreen.usingNative && tt.fullscreen.active && tt.fullscreen.toggle(),
					(this.lastKey = rt);
			} else this.lastKey = null;
			var ct;
		}
	}
	toggleMenu(et) {
		controls.toggleMenu.call(this.player, et);
	}
}
function createCommonjsModule(_, et) {
	return _((et = { exports: {} }), et.exports), et.exports;
}
var loadjs_umd = createCommonjsModule(function (_, et) {
	_.exports = (function () {
		var tt = function () {},
			nt = {},
			rt = {},
			it = {};
		function ot(ct, ft) {
			ct = ct.push ? ct : [ct];
			var mt,
				pt,
				vt,
				ht = [],
				gt = ct.length,
				yt = gt;
			for (
				mt = function (xt, St) {
					St.length && ht.push(xt), --yt || ft(ht);
				};
				gt--;

			)
				(pt = ct[gt]), (vt = rt[pt]) ? mt(pt, vt) : (it[pt] = it[pt] || []).push(mt);
		}
		function at(ct, ft) {
			if (ct) {
				var mt = it[ct];
				if (((rt[ct] = ft), mt)) for (; mt.length; ) mt[0](ct, ft), mt.splice(0, 1);
			}
		}
		function st(ct, ft) {
			ct.call && (ct = { success: ct }), ft.length ? (ct.error || tt)(ft) : (ct.success || tt)(ct);
		}
		function lt(ct, ft, mt, pt) {
			var vt,
				ht,
				gt = document,
				yt = mt.async,
				xt = (mt.numRetries || 0) + 1,
				St = mt.before || tt,
				wt = ct.replace(/[\?|#].*$/, ""),
				Ct = ct.replace(/^(css|img)!/, "");
			(pt = pt || 0),
				/(^css!|\.css$)/.test(wt)
					? (((ht = gt.createElement("link")).rel = "stylesheet"),
					  (ht.href = Ct),
					  (vt = "hideFocus" in ht) && ht.relList && ((vt = 0), (ht.rel = "preload"), (ht.as = "style")))
					: /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(wt)
					? ((ht = gt.createElement("img")).src = Ct)
					: (((ht = gt.createElement("script")).src = ct), (ht.async = yt === void 0 || yt)),
				(ht.onload =
					ht.onerror =
					ht.onbeforeload =
						function (Et) {
							var _t = Et.type[0];
							if (vt)
								try {
									ht.sheet.cssText.length || (_t = "e");
								} catch ($t) {
									$t.code != 18 && (_t = "e");
								}
							if (_t == "e") {
								if ((pt += 1) < xt) return lt(ct, ft, mt, pt);
							} else if (ht.rel == "preload" && ht.as == "style") return (ht.rel = "stylesheet");
							ft(ct, _t, Et.defaultPrevented);
						}),
				St(ct, ht) !== !1 && gt.head.appendChild(ht);
		}
		function ut(ct, ft, mt) {
			var pt,
				vt,
				ht = (ct = ct.push ? ct : [ct]).length,
				gt = ht,
				yt = [];
			for (
				pt = function (xt, St, wt) {
					if ((St == "e" && yt.push(xt), St == "b")) {
						if (!wt) return;
						yt.push(xt);
					}
					--ht || ft(yt);
				},
					vt = 0;
				vt < gt;
				vt++
			)
				lt(ct[vt], pt, mt);
		}
		function dt(ct, ft, mt) {
			var pt, vt;
			if ((ft && ft.trim && (pt = ft), (vt = (pt ? mt : ft) || {}), pt)) {
				if (pt in nt) throw "LoadJS";
				nt[pt] = !0;
			}
			function ht(gt, yt) {
				ut(
					ct,
					function (xt) {
						st(vt, xt), gt && st({ success: gt, error: yt }, xt), at(pt, xt);
					},
					vt
				);
			}
			if (vt.returnPromise) return new Promise(ht);
			ht();
		}
		return (
			(dt.ready = function (ct, ft) {
				return (
					ot(ct, function (mt) {
						st(ft, mt);
					}),
					dt
				);
			}),
			(dt.done = function (ct) {
				at(ct, []);
			}),
			(dt.reset = function () {
				(nt = {}), (rt = {}), (it = {});
			}),
			(dt.isDefined = function (ct) {
				return ct in nt;
			}),
			dt
		);
	})();
});
function loadScript(_) {
	return new Promise((et, tt) => {
		loadjs_umd(_, { success: et, error: tt });
	});
}
function parseId$1(_) {
	return is.empty(_) ? null : is.number(Number(_)) ? _ : _.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : _;
}
function parseHash(_) {
	const et = _.match(/^.*(vimeo.com\/|video\/)(\d+)(\?.*&*h=|\/)+([\d,a-f]+)/);
	return et && et.length === 5 ? et[4] : null;
}
function assurePlaybackState$1(_) {
	_ && !this.embed.hasPlayed && (this.embed.hasPlayed = !0),
		this.media.paused === _ && ((this.media.paused = !_), triggerEvent.call(this, this.media, _ ? "play" : "pause"));
}
const vimeo = {
	setup() {
		const _ = this;
		toggleClass(_.elements.wrapper, _.config.classNames.embed, !0),
			(_.options.speed = _.config.speed.options),
			setAspectRatio.call(_),
			is.object(window.Vimeo)
				? vimeo.ready.call(_)
				: loadScript(_.config.urls.vimeo.sdk)
						.then(() => {
							vimeo.ready.call(_);
						})
						.catch((et) => {
							_.debug.warn("Vimeo SDK (player.js) failed to load", et);
						});
	},
	ready() {
		const _ = this,
			et = _.config.vimeo,
			{ premium: tt, referrerPolicy: nt, ...rt } = et;
		let it = _.media.getAttribute("src"),
			ot = "";
		is.empty(it)
			? ((it = _.media.getAttribute(_.config.attributes.embed.id)),
			  (ot = _.media.getAttribute(_.config.attributes.embed.hash)))
			: (ot = parseHash(it));
		const at = ot ? { h: ot } : {};
		tt && Object.assign(rt, { controls: !1, sidedock: !1 });
		const st = buildUrlParams({
				loop: _.config.loop.active,
				autoplay: _.autoplay,
				muted: _.muted,
				gesture: "media",
				playsinline: !this.config.fullscreen.iosNative,
				...at,
				...rt,
			}),
			lt = parseId$1(it),
			ut = createElement("iframe"),
			dt = format(_.config.urls.vimeo.iframe, lt, st);
		if (
			(ut.setAttribute("src", dt),
			ut.setAttribute("allowfullscreen", ""),
			ut.setAttribute(
				"allow",
				["autoplay", "fullscreen", "picture-in-picture", "encrypted-media", "accelerometer", "gyroscope"].join("; ")
			),
			is.empty(nt) || ut.setAttribute("referrerPolicy", nt),
			tt || !et.customControls)
		)
			ut.setAttribute("data-poster", _.poster), (_.media = replaceElement(ut, _.media));
		else {
			const gt = createElement("div", { class: _.config.classNames.embedContainer, "data-poster": _.poster });
			gt.appendChild(ut), (_.media = replaceElement(gt, _.media));
		}
		et.customControls ||
			fetch$1(format(_.config.urls.vimeo.api, dt)).then((gt) => {
				!is.empty(gt) && gt.thumbnail_url && ui.setPoster.call(_, gt.thumbnail_url).catch(() => {});
			}),
			(_.embed = new window.Vimeo.Player(ut, { autopause: _.config.autopause, muted: _.muted })),
			(_.media.paused = !0),
			(_.media.currentTime = 0),
			_.supported.ui && _.embed.disableTextTrack(),
			(_.media.play = () => (assurePlaybackState$1.call(_, !0), _.embed.play())),
			(_.media.pause = () => (assurePlaybackState$1.call(_, !1), _.embed.pause())),
			(_.media.stop = () => {
				_.pause(), (_.currentTime = 0);
			});
		let { currentTime: ct } = _.media;
		Object.defineProperty(_.media, "currentTime", {
			get: () => ct,
			set(gt) {
				const { embed: yt, media: xt, paused: St, volume: wt } = _,
					Ct = St && !yt.hasPlayed;
				(xt.seeking = !0),
					triggerEvent.call(_, xt, "seeking"),
					Promise.resolve(Ct && yt.setVolume(0))
						.then(() => yt.setCurrentTime(gt))
						.then(() => Ct && yt.pause())
						.then(() => Ct && yt.setVolume(wt))
						.catch(() => {});
			},
		});
		let ft = _.config.speed.selected;
		Object.defineProperty(_.media, "playbackRate", {
			get: () => ft,
			set(gt) {
				_.embed
					.setPlaybackRate(gt)
					.then(() => {
						(ft = gt), triggerEvent.call(_, _.media, "ratechange");
					})
					.catch(() => {
						_.options.speed = [1];
					});
			},
		});
		let { volume: mt } = _.config;
		Object.defineProperty(_.media, "volume", {
			get: () => mt,
			set(gt) {
				_.embed.setVolume(gt).then(() => {
					(mt = gt), triggerEvent.call(_, _.media, "volumechange");
				});
			},
		});
		let { muted: pt } = _.config;
		Object.defineProperty(_.media, "muted", {
			get: () => pt,
			set(gt) {
				const yt = !!is.boolean(gt) && gt;
				_.embed.setVolume(yt ? 0 : _.config.volume).then(() => {
					(pt = yt), triggerEvent.call(_, _.media, "volumechange");
				});
			},
		});
		let vt,
			{ loop: ht } = _.config;
		Object.defineProperty(_.media, "loop", {
			get: () => ht,
			set(gt) {
				const yt = is.boolean(gt) ? gt : _.config.loop.active;
				_.embed.setLoop(yt).then(() => {
					ht = yt;
				});
			},
		}),
			_.embed
				.getVideoUrl()
				.then((gt) => {
					(vt = gt), controls.setDownloadUrl.call(_);
				})
				.catch((gt) => {
					this.debug.warn(gt);
				}),
			Object.defineProperty(_.media, "currentSrc", { get: () => vt }),
			Object.defineProperty(_.media, "ended", { get: () => _.currentTime === _.duration }),
			Promise.all([_.embed.getVideoWidth(), _.embed.getVideoHeight()]).then((gt) => {
				const [yt, xt] = gt;
				(_.embed.ratio = roundAspectRatio(yt, xt)), setAspectRatio.call(this);
			}),
			_.embed.setAutopause(_.config.autopause).then((gt) => {
				_.config.autopause = gt;
			}),
			_.embed.getVideoTitle().then((gt) => {
				(_.config.title = gt), ui.setTitle.call(this);
			}),
			_.embed.getCurrentTime().then((gt) => {
				(ct = gt), triggerEvent.call(_, _.media, "timeupdate");
			}),
			_.embed.getDuration().then((gt) => {
				(_.media.duration = gt), triggerEvent.call(_, _.media, "durationchange");
			}),
			_.embed.getTextTracks().then((gt) => {
				(_.media.textTracks = gt), captions.setup.call(_);
			}),
			_.embed.on("cuechange", ({ cues: gt = [] }) => {
				const yt = gt.map((xt) => stripHTML(xt.text));
				captions.updateCues.call(_, yt);
			}),
			_.embed.on("loaded", () => {
				_.embed.getPaused().then((gt) => {
					assurePlaybackState$1.call(_, !gt), gt || triggerEvent.call(_, _.media, "playing");
				}),
					is.element(_.embed.element) && _.supported.ui && _.embed.element.setAttribute("tabindex", -1);
			}),
			_.embed.on("bufferstart", () => {
				triggerEvent.call(_, _.media, "waiting");
			}),
			_.embed.on("bufferend", () => {
				triggerEvent.call(_, _.media, "playing");
			}),
			_.embed.on("play", () => {
				assurePlaybackState$1.call(_, !0), triggerEvent.call(_, _.media, "playing");
			}),
			_.embed.on("pause", () => {
				assurePlaybackState$1.call(_, !1);
			}),
			_.embed.on("timeupdate", (gt) => {
				(_.media.seeking = !1), (ct = gt.seconds), triggerEvent.call(_, _.media, "timeupdate");
			}),
			_.embed.on("progress", (gt) => {
				(_.media.buffered = gt.percent),
					triggerEvent.call(_, _.media, "progress"),
					parseInt(gt.percent, 10) === 1 && triggerEvent.call(_, _.media, "canplaythrough"),
					_.embed.getDuration().then((yt) => {
						yt !== _.media.duration && ((_.media.duration = yt), triggerEvent.call(_, _.media, "durationchange"));
					});
			}),
			_.embed.on("seeked", () => {
				(_.media.seeking = !1), triggerEvent.call(_, _.media, "seeked");
			}),
			_.embed.on("ended", () => {
				(_.media.paused = !0), triggerEvent.call(_, _.media, "ended");
			}),
			_.embed.on("error", (gt) => {
				(_.media.error = gt), triggerEvent.call(_, _.media, "error");
			}),
			et.customControls && setTimeout(() => ui.build.call(_), 0);
	},
};
function parseId(_) {
	return is.empty(_) ? null : _.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : _;
}
function assurePlaybackState(_) {
	_ && !this.embed.hasPlayed && (this.embed.hasPlayed = !0),
		this.media.paused === _ && ((this.media.paused = !_), triggerEvent.call(this, this.media, _ ? "play" : "pause"));
}
function getHost(_) {
	return _.noCookie
		? "https://www.youtube-nocookie.com"
		: window.location.protocol === "http:"
		? "http://www.youtube.com"
		: void 0;
}
const youtube = {
		setup() {
			if (
				(toggleClass(this.elements.wrapper, this.config.classNames.embed, !0),
				is.object(window.YT) && is.function(window.YT.Player))
			)
				youtube.ready.call(this);
			else {
				const _ = window.onYouTubeIframeAPIReady;
				(window.onYouTubeIframeAPIReady = () => {
					is.function(_) && _(), youtube.ready.call(this);
				}),
					loadScript(this.config.urls.youtube.sdk).catch((et) => {
						this.debug.warn("YouTube API failed to load", et);
					});
			}
		},
		getTitle(_) {
			fetch$1(format(this.config.urls.youtube.api, _))
				.then((et) => {
					if (is.object(et)) {
						const { title: tt, height: nt, width: rt } = et;
						(this.config.title = tt), ui.setTitle.call(this), (this.embed.ratio = roundAspectRatio(rt, nt));
					}
					setAspectRatio.call(this);
				})
				.catch(() => {
					setAspectRatio.call(this);
				});
		},
		ready() {
			const _ = this,
				et = _.config.youtube,
				tt = _.media && _.media.getAttribute("id");
			if (!is.empty(tt) && tt.startsWith("youtube-")) return;
			let nt = _.media.getAttribute("src");
			is.empty(nt) && (nt = _.media.getAttribute(this.config.attributes.embed.id));
			const rt = parseId(nt),
				it = createElement("div", { id: generateId(_.provider), "data-poster": et.customControls ? _.poster : void 0 });
			if (((_.media = replaceElement(it, _.media)), et.customControls)) {
				const ot = (at) => `https://i.ytimg.com/vi/${rt}/${at}default.jpg`;
				loadImage(ot("maxres"), 121)
					.catch(() => loadImage(ot("sd"), 121))
					.catch(() => loadImage(ot("hq")))
					.then((at) => ui.setPoster.call(_, at.src))
					.then((at) => {
						at.includes("maxres") || (_.elements.poster.style.backgroundSize = "cover");
					})
					.catch(() => {});
			}
			_.embed = new window.YT.Player(_.media, {
				videoId: rt,
				host: getHost(et),
				playerVars: extend$1(
					{},
					{
						autoplay: _.config.autoplay ? 1 : 0,
						hl: _.config.hl,
						controls: _.supported.ui && et.customControls ? 0 : 1,
						disablekb: 1,
						playsinline: _.config.fullscreen.iosNative ? 0 : 1,
						cc_load_policy: _.captions.active ? 1 : 0,
						cc_lang_pref: _.config.captions.language,
						widget_referrer: window ? window.location.href : null,
					},
					et
				),
				events: {
					onError(ot) {
						if (!_.media.error) {
							const at = ot.data,
								st =
									{
										2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",
										5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",
										100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",
										101: "The owner of the requested video does not allow it to be played in embedded players.",
										150: "The owner of the requested video does not allow it to be played in embedded players.",
									}[at] || "An unknown error occured";
							(_.media.error = { code: at, message: st }), triggerEvent.call(_, _.media, "error");
						}
					},
					onPlaybackRateChange(ot) {
						const at = ot.target;
						(_.media.playbackRate = at.getPlaybackRate()), triggerEvent.call(_, _.media, "ratechange");
					},
					onReady(ot) {
						if (is.function(_.media.play)) return;
						const at = ot.target;
						youtube.getTitle.call(_, rt),
							(_.media.play = () => {
								assurePlaybackState.call(_, !0), at.playVideo();
							}),
							(_.media.pause = () => {
								assurePlaybackState.call(_, !1), at.pauseVideo();
							}),
							(_.media.stop = () => {
								at.stopVideo();
							}),
							(_.media.duration = at.getDuration()),
							(_.media.paused = !0),
							(_.media.currentTime = 0),
							Object.defineProperty(_.media, "currentTime", {
								get: () => Number(at.getCurrentTime()),
								set(dt) {
									_.paused && !_.embed.hasPlayed && _.embed.mute(),
										(_.media.seeking = !0),
										triggerEvent.call(_, _.media, "seeking"),
										at.seekTo(dt);
								},
							}),
							Object.defineProperty(_.media, "playbackRate", {
								get: () => at.getPlaybackRate(),
								set(dt) {
									at.setPlaybackRate(dt);
								},
							});
						let { volume: st } = _.config;
						Object.defineProperty(_.media, "volume", {
							get: () => st,
							set(dt) {
								(st = dt), at.setVolume(100 * st), triggerEvent.call(_, _.media, "volumechange");
							},
						});
						let { muted: lt } = _.config;
						Object.defineProperty(_.media, "muted", {
							get: () => lt,
							set(dt) {
								const ct = is.boolean(dt) ? dt : lt;
								(lt = ct),
									at[ct ? "mute" : "unMute"](),
									at.setVolume(100 * st),
									triggerEvent.call(_, _.media, "volumechange");
							},
						}),
							Object.defineProperty(_.media, "currentSrc", { get: () => at.getVideoUrl() }),
							Object.defineProperty(_.media, "ended", { get: () => _.currentTime === _.duration });
						const ut = at.getAvailablePlaybackRates();
						(_.options.speed = ut.filter((dt) => _.config.speed.options.includes(dt))),
							_.supported.ui && et.customControls && _.media.setAttribute("tabindex", -1),
							triggerEvent.call(_, _.media, "timeupdate"),
							triggerEvent.call(_, _.media, "durationchange"),
							clearInterval(_.timers.buffering),
							(_.timers.buffering = setInterval(() => {
								(_.media.buffered = at.getVideoLoadedFraction()),
									(_.media.lastBuffered === null || _.media.lastBuffered < _.media.buffered) &&
										triggerEvent.call(_, _.media, "progress"),
									(_.media.lastBuffered = _.media.buffered),
									_.media.buffered === 1 &&
										(clearInterval(_.timers.buffering), triggerEvent.call(_, _.media, "canplaythrough"));
							}, 200)),
							et.customControls && setTimeout(() => ui.build.call(_), 50);
					},
					onStateChange(ot) {
						const at = ot.target;
						switch (
							(clearInterval(_.timers.playing),
							_.media.seeking &&
								[1, 2].includes(ot.data) &&
								((_.media.seeking = !1), triggerEvent.call(_, _.media, "seeked")),
							ot.data)
						) {
							case -1:
								triggerEvent.call(_, _.media, "timeupdate"),
									(_.media.buffered = at.getVideoLoadedFraction()),
									triggerEvent.call(_, _.media, "progress");
								break;
							case 0:
								assurePlaybackState.call(_, !1),
									_.media.loop ? (at.stopVideo(), at.playVideo()) : triggerEvent.call(_, _.media, "ended");
								break;
							case 1:
								et.customControls && !_.config.autoplay && _.media.paused && !_.embed.hasPlayed
									? _.media.pause()
									: (assurePlaybackState.call(_, !0),
									  triggerEvent.call(_, _.media, "playing"),
									  (_.timers.playing = setInterval(() => {
											triggerEvent.call(_, _.media, "timeupdate");
									  }, 50)),
									  _.media.duration !== at.getDuration() &&
											((_.media.duration = at.getDuration()), triggerEvent.call(_, _.media, "durationchange")));
								break;
							case 2:
								_.muted || _.embed.unMute(), assurePlaybackState.call(_, !1);
								break;
							case 3:
								triggerEvent.call(_, _.media, "waiting");
						}
						triggerEvent.call(_, _.elements.container, "statechange", !1, { code: ot.data });
					},
				},
			});
		},
	},
	media = {
		setup() {
			this.media
				? (toggleClass(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0),
				  toggleClass(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0),
				  this.isEmbed && toggleClass(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0),
				  this.isVideo &&
						((this.elements.wrapper = createElement("div", { class: this.config.classNames.video })),
						wrap$2(this.media, this.elements.wrapper),
						(this.elements.poster = createElement("div", { class: this.config.classNames.poster })),
						this.elements.wrapper.appendChild(this.elements.poster)),
				  this.isHTML5
						? html5.setup.call(this)
						: this.isYouTube
						? youtube.setup.call(this)
						: this.isVimeo && vimeo.setup.call(this))
				: this.debug.warn("No media element found!");
		},
	};
class Ads {
	constructor(et) {
		_defineProperty$1(this, "load", () => {
			this.enabled &&
				(is.object(window.google) && is.object(window.google.ima)
					? this.ready()
					: loadScript(this.player.config.urls.googleIMA.sdk)
							.then(() => {
								this.ready();
							})
							.catch(() => {
								this.trigger("error", new Error("Google IMA SDK failed to load"));
							}));
		}),
			_defineProperty$1(this, "ready", () => {
				var tt;
				this.enabled ||
					((tt = this).manager && tt.manager.destroy(),
					tt.elements.displayContainer && tt.elements.displayContainer.destroy(),
					tt.elements.container.remove()),
					this.startSafetyTimer(12e3, "ready()"),
					this.managerPromise.then(() => {
						this.clearSafetyTimer("onAdsManagerLoaded()");
					}),
					this.listeners(),
					this.setupIMA();
			}),
			_defineProperty$1(this, "setupIMA", () => {
				(this.elements.container = createElement("div", { class: this.player.config.classNames.ads })),
					this.player.elements.container.appendChild(this.elements.container),
					google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED),
					google.ima.settings.setLocale(this.player.config.ads.language),
					google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline),
					(this.elements.displayContainer = new google.ima.AdDisplayContainer(
						this.elements.container,
						this.player.media
					)),
					(this.loader = new google.ima.AdsLoader(this.elements.displayContainer)),
					this.loader.addEventListener(
						google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED,
						(tt) => this.onAdsManagerLoaded(tt),
						!1
					),
					this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (tt) => this.onAdError(tt), !1),
					this.requestAds();
			}),
			_defineProperty$1(this, "requestAds", () => {
				const { container: tt } = this.player.elements;
				try {
					const nt = new google.ima.AdsRequest();
					(nt.adTagUrl = this.tagUrl),
						(nt.linearAdSlotWidth = tt.offsetWidth),
						(nt.linearAdSlotHeight = tt.offsetHeight),
						(nt.nonLinearAdSlotWidth = tt.offsetWidth),
						(nt.nonLinearAdSlotHeight = tt.offsetHeight),
						(nt.forceNonLinearFullSlot = !1),
						nt.setAdWillPlayMuted(!this.player.muted),
						this.loader.requestAds(nt);
				} catch (nt) {
					this.onAdError(nt);
				}
			}),
			_defineProperty$1(this, "pollCountdown", (tt = !1) => {
				if (!tt)
					return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute("data-badge-text");
				this.countdownTimer = setInterval(() => {
					const nt = formatTime(Math.max(this.manager.getRemainingTime(), 0)),
						rt = `${i18n.get("advertisement", this.player.config)} - ${nt}`;
					this.elements.container.setAttribute("data-badge-text", rt);
				}, 100);
			}),
			_defineProperty$1(this, "onAdsManagerLoaded", (tt) => {
				if (!this.enabled) return;
				const nt = new google.ima.AdsRenderingSettings();
				(nt.restoreCustomPlaybackStateOnAdBreakComplete = !0),
					(nt.enablePreloading = !0),
					(this.manager = tt.getAdsManager(this.player, nt)),
					(this.cuePoints = this.manager.getCuePoints()),
					this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (rt) => this.onAdError(rt)),
					Object.keys(google.ima.AdEvent.Type).forEach((rt) => {
						this.manager.addEventListener(google.ima.AdEvent.Type[rt], (it) => this.onAdEvent(it));
					}),
					this.trigger("loaded");
			}),
			_defineProperty$1(this, "addCuePoints", () => {
				is.empty(this.cuePoints) ||
					this.cuePoints.forEach((tt) => {
						if (tt !== 0 && tt !== -1 && tt < this.player.duration) {
							const nt = this.player.elements.progress;
							if (is.element(nt)) {
								const rt = (100 / this.player.duration) * tt,
									it = createElement("span", { class: this.player.config.classNames.cues });
								(it.style.left = `${rt.toString()}%`), nt.appendChild(it);
							}
						}
					});
			}),
			_defineProperty$1(this, "onAdEvent", (tt) => {
				const { container: nt } = this.player.elements,
					rt = tt.getAd(),
					it = tt.getAdData();
				switch (
					(((ot) => {
						triggerEvent.call(this.player, this.player.media, `ads${ot.replace(/_/g, "").toLowerCase()}`);
					})(tt.type),
					tt.type)
				) {
					case google.ima.AdEvent.Type.LOADED:
						this.trigger("loaded"),
							this.pollCountdown(!0),
							rt.isLinear() || ((rt.width = nt.offsetWidth), (rt.height = nt.offsetHeight));
						break;
					case google.ima.AdEvent.Type.STARTED:
						this.manager.setVolume(this.player.volume);
						break;
					case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
						this.player.ended ? this.loadAds() : this.loader.contentComplete();
						break;
					case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
						this.pauseContent();
						break;
					case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
						this.pollCountdown(), this.resumeContent();
						break;
					case google.ima.AdEvent.Type.LOG:
						it.adError && this.player.debug.warn(`Non-fatal ad error: ${it.adError.getMessage()}`);
				}
			}),
			_defineProperty$1(this, "onAdError", (tt) => {
				this.cancel(), this.player.debug.warn("Ads error", tt);
			}),
			_defineProperty$1(this, "listeners", () => {
				const { container: tt } = this.player.elements;
				let nt;
				this.player.on("canplay", () => {
					this.addCuePoints();
				}),
					this.player.on("ended", () => {
						this.loader.contentComplete();
					}),
					this.player.on("timeupdate", () => {
						nt = this.player.currentTime;
					}),
					this.player.on("seeked", () => {
						const rt = this.player.currentTime;
						is.empty(this.cuePoints) ||
							this.cuePoints.forEach((it, ot) => {
								nt < it && it < rt && (this.manager.discardAdBreak(), this.cuePoints.splice(ot, 1));
							});
					}),
					window.addEventListener("resize", () => {
						this.manager && this.manager.resize(tt.offsetWidth, tt.offsetHeight, google.ima.ViewMode.NORMAL);
					});
			}),
			_defineProperty$1(this, "play", () => {
				const { container: tt } = this.player.elements;
				this.managerPromise || this.resumeContent(),
					this.managerPromise
						.then(() => {
							this.manager.setVolume(this.player.volume), this.elements.displayContainer.initialize();
							try {
								this.initialized ||
									(this.manager.init(tt.offsetWidth, tt.offsetHeight, google.ima.ViewMode.NORMAL),
									this.manager.start()),
									(this.initialized = !0);
							} catch (nt) {
								this.onAdError(nt);
							}
						})
						.catch(() => {});
			}),
			_defineProperty$1(this, "resumeContent", () => {
				(this.elements.container.style.zIndex = ""), (this.playing = !1), silencePromise(this.player.media.play());
			}),
			_defineProperty$1(this, "pauseContent", () => {
				(this.elements.container.style.zIndex = 3), (this.playing = !0), this.player.media.pause();
			}),
			_defineProperty$1(this, "cancel", () => {
				this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds();
			}),
			_defineProperty$1(this, "loadAds", () => {
				this.managerPromise
					.then(() => {
						this.manager && this.manager.destroy(),
							(this.managerPromise = new Promise((tt) => {
								this.on("loaded", tt), this.player.debug.log(this.manager);
							})),
							(this.initialized = !1),
							this.requestAds();
					})
					.catch(() => {});
			}),
			_defineProperty$1(this, "trigger", (tt, ...nt) => {
				const rt = this.events[tt];
				is.array(rt) &&
					rt.forEach((it) => {
						is.function(it) && it.apply(this, nt);
					});
			}),
			_defineProperty$1(
				this,
				"on",
				(tt, nt) => (is.array(this.events[tt]) || (this.events[tt] = []), this.events[tt].push(nt), this)
			),
			_defineProperty$1(this, "startSafetyTimer", (tt, nt) => {
				this.player.debug.log(`Safety timer invoked from: ${nt}`),
					(this.safetyTimer = setTimeout(() => {
						this.cancel(), this.clearSafetyTimer("startSafetyTimer()");
					}, tt));
			}),
			_defineProperty$1(this, "clearSafetyTimer", (tt) => {
				is.nullOrUndefined(this.safetyTimer) ||
					(this.player.debug.log(`Safety timer cleared from: ${tt}`),
					clearTimeout(this.safetyTimer),
					(this.safetyTimer = null));
			}),
			(this.player = et),
			(this.config = et.config.ads),
			(this.playing = !1),
			(this.initialized = !1),
			(this.elements = { container: null, displayContainer: null }),
			(this.manager = null),
			(this.loader = null),
			(this.cuePoints = null),
			(this.events = {}),
			(this.safetyTimer = null),
			(this.countdownTimer = null),
			(this.managerPromise = new Promise((tt, nt) => {
				this.on("loaded", tt), this.on("error", nt);
			})),
			this.load();
	}
	get enabled() {
		const { config: et } = this;
		return this.player.isHTML5 && this.player.isVideo && et.enabled && (!is.empty(et.publisherId) || is.url(et.tagUrl));
	}
	get tagUrl() {
		const { config: et } = this;
		return is.url(et.tagUrl)
			? et.tagUrl
			: `https://go.aniview.com/api/adserver6/vast/?${buildUrlParams({
					AV_PUBLISHERID: "58c25bb0073ef448b1087ad6",
					AV_CHANNELID: "5a0458dc28a06145e4519d21",
					AV_URL: window.location.hostname,
					cb: Date.now(),
					AV_WIDTH: 640,
					AV_HEIGHT: 480,
					AV_CDIM2: et.publisherId,
			  })}`;
	}
}
function clamp(_ = 0, et = 0, tt = 255) {
	return Math.min(Math.max(_, et), tt);
}
const parseVtt = (_) => {
		const et = [];
		return (
			_.split(/\r\n\r\n|\n\n|\r\r/).forEach((tt) => {
				const nt = {};
				tt.split(/\r\n|\n|\r/).forEach((rt) => {
					if (is.number(nt.startTime)) {
						if (!is.empty(rt.trim()) && is.empty(nt.text)) {
							const it = rt.trim().split("#xywh=");
							([nt.text] = it), it[1] && ([nt.x, nt.y, nt.w, nt.h] = it[1].split(","));
						}
					} else {
						const it = rt.match(
							/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/
						);
						it &&
							((nt.startTime =
								60 * Number(it[1] || 0) * 60 + 60 * Number(it[2]) + Number(it[3]) + Number(`0.${it[4]}`)),
							(nt.endTime = 60 * Number(it[6] || 0) * 60 + 60 * Number(it[7]) + Number(it[8]) + Number(`0.${it[9]}`)));
					}
				}),
					nt.text && et.push(nt);
			}),
			et
		);
	},
	fitRatio = (_, et) => {
		const tt = {};
		return (
			_ > et.width / et.height
				? ((tt.width = et.width), (tt.height = (1 / _) * et.width))
				: ((tt.height = et.height), (tt.width = _ * et.height)),
			tt
		);
	};
class PreviewThumbnails {
	constructor(et) {
		_defineProperty$1(this, "load", () => {
			this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled),
				this.enabled &&
					this.getThumbnails().then(() => {
						this.enabled && (this.render(), this.determineContainerAutoSizing(), (this.loaded = !0));
					});
		}),
			_defineProperty$1(
				this,
				"getThumbnails",
				() =>
					new Promise((tt) => {
						const { src: nt } = this.player.config.previewThumbnails;
						if (is.empty(nt)) throw new Error("Missing previewThumbnails.src config attribute");
						const rt = () => {
							this.thumbnails.sort((it, ot) => it.height - ot.height),
								this.player.debug.log("Preview thumbnails", this.thumbnails),
								tt();
						};
						if (is.function(nt))
							nt((it) => {
								(this.thumbnails = it), rt();
							});
						else {
							const it = (is.string(nt) ? [nt] : nt).map((ot) => this.getThumbnail(ot));
							Promise.all(it).then(rt);
						}
					})
			),
			_defineProperty$1(
				this,
				"getThumbnail",
				(tt) =>
					new Promise((nt) => {
						fetch$1(tt).then((rt) => {
							const it = { frames: parseVtt(rt), height: null, urlPrefix: "" };
							it.frames[0].text.startsWith("/") ||
								it.frames[0].text.startsWith("http://") ||
								it.frames[0].text.startsWith("https://") ||
								(it.urlPrefix = tt.substring(0, tt.lastIndexOf("/") + 1));
							const ot = new Image();
							(ot.onload = () => {
								(it.height = ot.naturalHeight), (it.width = ot.naturalWidth), this.thumbnails.push(it), nt();
							}),
								(ot.src = it.urlPrefix + it.frames[0].text);
						});
					})
			),
			_defineProperty$1(this, "startMove", (tt) => {
				if (this.loaded && is.event(tt) && ["touchmove", "mousemove"].includes(tt.type) && this.player.media.duration) {
					if (tt.type === "touchmove")
						this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);
					else {
						var nt, rt;
						const it = this.player.elements.progress.getBoundingClientRect(),
							ot = (100 / it.width) * (tt.pageX - it.left);
						(this.seekTime = this.player.media.duration * (ot / 100)),
							this.seekTime < 0 && (this.seekTime = 0),
							this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1),
							(this.mousePosX = tt.pageX),
							(this.elements.thumb.time.innerText = formatTime(this.seekTime));
						const at =
							(nt = this.player.config.markers) === null || nt === void 0 || (rt = nt.points) === null || rt === void 0
								? void 0
								: rt.find(({ time: st }) => st === Math.round(this.seekTime));
						at && this.elements.thumb.time.insertAdjacentHTML("afterbegin", `${at.label}<br>`);
					}
					this.showImageAtCurrentTime();
				}
			}),
			_defineProperty$1(this, "endMove", () => {
				this.toggleThumbContainer(!1, !0);
			}),
			_defineProperty$1(this, "startScrubbing", (tt) => {
				(is.nullOrUndefined(tt.button) || tt.button === !1 || tt.button === 0) &&
					((this.mouseDown = !0),
					this.player.media.duration &&
						(this.toggleScrubbingContainer(!0), this.toggleThumbContainer(!1, !0), this.showImageAtCurrentTime()));
			}),
			_defineProperty$1(this, "endScrubbing", () => {
				(this.mouseDown = !1),
					Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime)
						? this.toggleScrubbingContainer(!1)
						: once.call(this.player, this.player.media, "timeupdate", () => {
								this.mouseDown || this.toggleScrubbingContainer(!1);
						  });
			}),
			_defineProperty$1(this, "listeners", () => {
				this.player.on("play", () => {
					this.toggleThumbContainer(!1, !0);
				}),
					this.player.on("seeked", () => {
						this.toggleThumbContainer(!1);
					}),
					this.player.on("timeupdate", () => {
						this.lastTime = this.player.media.currentTime;
					});
			}),
			_defineProperty$1(this, "render", () => {
				(this.elements.thumb.container = createElement("div", {
					class: this.player.config.classNames.previewThumbnails.thumbContainer,
				})),
					(this.elements.thumb.imageContainer = createElement("div", {
						class: this.player.config.classNames.previewThumbnails.imageContainer,
					})),
					this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);
				const tt = createElement("div", { class: this.player.config.classNames.previewThumbnails.timeContainer });
				(this.elements.thumb.time = createElement("span", {}, "00:00")),
					tt.appendChild(this.elements.thumb.time),
					this.elements.thumb.imageContainer.appendChild(tt),
					is.element(this.player.elements.progress) &&
						this.player.elements.progress.appendChild(this.elements.thumb.container),
					(this.elements.scrubbing.container = createElement("div", {
						class: this.player.config.classNames.previewThumbnails.scrubbingContainer,
					})),
					this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);
			}),
			_defineProperty$1(this, "destroy", () => {
				this.elements.thumb.container && this.elements.thumb.container.remove(),
					this.elements.scrubbing.container && this.elements.scrubbing.container.remove();
			}),
			_defineProperty$1(this, "showImageAtCurrentTime", () => {
				this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos();
				const tt = this.thumbnails[0].frames.findIndex(
						(it) => this.seekTime >= it.startTime && this.seekTime <= it.endTime
					),
					nt = tt >= 0;
				let rt = 0;
				this.mouseDown || this.toggleThumbContainer(nt),
					nt &&
						(this.thumbnails.forEach((it, ot) => {
							this.loadedImages.includes(it.frames[tt].text) && (rt = ot);
						}),
						tt !== this.showingThumb && ((this.showingThumb = tt), this.loadImage(rt)));
			}),
			_defineProperty$1(this, "loadImage", (tt = 0) => {
				const nt = this.showingThumb,
					rt = this.thumbnails[tt],
					{ urlPrefix: it } = rt,
					ot = rt.frames[nt],
					at = rt.frames[nt].text,
					st = it + at;
				if (this.currentImageElement && this.currentImageElement.dataset.filename === at)
					this.showImage(this.currentImageElement, ot, tt, nt, at, !1),
						(this.currentImageElement.dataset.index = nt),
						this.removeOldImages(this.currentImageElement);
				else {
					this.loadingImage && this.usingSprites && (this.loadingImage.onload = null);
					const lt = new Image();
					(lt.src = st),
						(lt.dataset.index = nt),
						(lt.dataset.filename = at),
						(this.showingThumbFilename = at),
						this.player.debug.log(`Loading image: ${st}`),
						(lt.onload = () => this.showImage(lt, ot, tt, nt, at, !0)),
						(this.loadingImage = lt),
						this.removeOldImages(lt);
				}
			}),
			_defineProperty$1(this, "showImage", (tt, nt, rt, it, ot, at = !0) => {
				this.player.debug.log(`Showing thumb: ${ot}. num: ${it}. qual: ${rt}. newimg: ${at}`),
					this.setImageSizeAndOffset(tt, nt),
					at &&
						(this.currentImageContainer.appendChild(tt),
						(this.currentImageElement = tt),
						this.loadedImages.includes(ot) || this.loadedImages.push(ot)),
					this.preloadNearby(it, !0).then(this.preloadNearby(it, !1)).then(this.getHigherQuality(rt, tt, nt, ot));
			}),
			_defineProperty$1(this, "removeOldImages", (tt) => {
				Array.from(this.currentImageContainer.children).forEach((nt) => {
					if (nt.tagName.toLowerCase() !== "img") return;
					const rt = this.usingSprites ? 500 : 1e3;
					if (nt.dataset.index !== tt.dataset.index && !nt.dataset.deleting) {
						nt.dataset.deleting = !0;
						const { currentImageContainer: it } = this;
						setTimeout(() => {
							it.removeChild(nt), this.player.debug.log(`Removing thumb: ${nt.dataset.filename}`);
						}, rt);
					}
				});
			}),
			_defineProperty$1(
				this,
				"preloadNearby",
				(tt, nt = !0) =>
					new Promise((rt) => {
						setTimeout(() => {
							const it = this.thumbnails[0].frames[tt].text;
							if (this.showingThumbFilename === it) {
								let ot;
								ot = nt ? this.thumbnails[0].frames.slice(tt) : this.thumbnails[0].frames.slice(0, tt).reverse();
								let at = !1;
								ot.forEach((st) => {
									const lt = st.text;
									if (lt !== it && !this.loadedImages.includes(lt)) {
										(at = !0), this.player.debug.log(`Preloading thumb filename: ${lt}`);
										const { urlPrefix: ut } = this.thumbnails[0],
											dt = ut + lt,
											ct = new Image();
										(ct.src = dt),
											(ct.onload = () => {
												this.player.debug.log(`Preloaded thumb filename: ${lt}`),
													this.loadedImages.includes(lt) || this.loadedImages.push(lt),
													rt();
											});
									}
								}),
									at || rt();
							}
						}, 300);
					})
			),
			_defineProperty$1(this, "getHigherQuality", (tt, nt, rt, it) => {
				if (tt < this.thumbnails.length - 1) {
					let ot = nt.naturalHeight;
					this.usingSprites && (ot = rt.h),
						ot < this.thumbContainerHeight &&
							setTimeout(() => {
								this.showingThumbFilename === it &&
									(this.player.debug.log(`Showing higher quality thumb for: ${it}`), this.loadImage(tt + 1));
							}, 300);
				}
			}),
			_defineProperty$1(this, "toggleThumbContainer", (tt = !1, nt = !1) => {
				const rt = this.player.config.classNames.previewThumbnails.thumbContainerShown;
				this.elements.thumb.container.classList.toggle(rt, tt),
					!tt && nt && ((this.showingThumb = null), (this.showingThumbFilename = null));
			}),
			_defineProperty$1(this, "toggleScrubbingContainer", (tt = !1) => {
				const nt = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
				this.elements.scrubbing.container.classList.toggle(nt, tt),
					tt || ((this.showingThumb = null), (this.showingThumbFilename = null));
			}),
			_defineProperty$1(this, "determineContainerAutoSizing", () => {
				(this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) &&
					(this.sizeSpecifiedInCSS = !0);
			}),
			_defineProperty$1(this, "setThumbContainerSizeAndPos", () => {
				const { imageContainer: tt } = this.elements.thumb;
				if (this.sizeSpecifiedInCSS) {
					if (tt.clientHeight > 20 && tt.clientWidth < 20) {
						const nt = Math.floor(tt.clientHeight * this.thumbAspectRatio);
						tt.style.width = `${nt}px`;
					} else if (tt.clientHeight < 20 && tt.clientWidth > 20) {
						const nt = Math.floor(tt.clientWidth / this.thumbAspectRatio);
						tt.style.height = `${nt}px`;
					}
				} else {
					const nt = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);
					(tt.style.height = `${this.thumbContainerHeight}px`), (tt.style.width = `${nt}px`);
				}
				this.setThumbContainerPos();
			}),
			_defineProperty$1(this, "setThumbContainerPos", () => {
				const tt = this.player.elements.progress.getBoundingClientRect(),
					nt = this.player.elements.container.getBoundingClientRect(),
					{ container: rt } = this.elements.thumb,
					it = nt.left - tt.left + 10,
					ot = nt.right - tt.left - rt.clientWidth - 10,
					at = this.mousePosX - tt.left - rt.clientWidth / 2,
					st = clamp(at, it, ot);
				(rt.style.left = `${st}px`), rt.style.setProperty("--preview-arrow-offset", at - st + "px");
			}),
			_defineProperty$1(this, "setScrubbingContainerSize", () => {
				const { width: tt, height: nt } = fitRatio(this.thumbAspectRatio, {
					width: this.player.media.clientWidth,
					height: this.player.media.clientHeight,
				});
				(this.elements.scrubbing.container.style.width = `${tt}px`),
					(this.elements.scrubbing.container.style.height = `${nt}px`);
			}),
			_defineProperty$1(this, "setImageSizeAndOffset", (tt, nt) => {
				if (!this.usingSprites) return;
				const rt = this.thumbContainerHeight / nt.h;
				(tt.style.height = tt.naturalHeight * rt + "px"),
					(tt.style.width = tt.naturalWidth * rt + "px"),
					(tt.style.left = `-${nt.x * rt}px`),
					(tt.style.top = `-${nt.y * rt}px`);
			}),
			(this.player = et),
			(this.thumbnails = []),
			(this.loaded = !1),
			(this.lastMouseMoveTime = Date.now()),
			(this.mouseDown = !1),
			(this.loadedImages = []),
			(this.elements = { thumb: {}, scrubbing: {} }),
			this.load();
	}
	get enabled() {
		return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;
	}
	get currentImageContainer() {
		return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer;
	}
	get usingSprites() {
		return Object.keys(this.thumbnails[0].frames[0]).includes("w");
	}
	get thumbAspectRatio() {
		return this.usingSprites
			? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h
			: this.thumbnails[0].width / this.thumbnails[0].height;
	}
	get thumbContainerHeight() {
		if (this.mouseDown) {
			const { height: et } = fitRatio(this.thumbAspectRatio, {
				width: this.player.media.clientWidth,
				height: this.player.media.clientHeight,
			});
			return et;
		}
		return this.sizeSpecifiedInCSS
			? this.elements.thumb.imageContainer.clientHeight
			: Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);
	}
	get currentImageElement() {
		return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement;
	}
	set currentImageElement(et) {
		this.mouseDown ? (this.currentScrubbingImageElement = et) : (this.currentThumbnailImageElement = et);
	}
}
const source = {
	insertElements(_, et) {
		is.string(et)
			? insertElement(_, this.media, { src: et })
			: is.array(et) &&
			  et.forEach((tt) => {
					insertElement(_, this.media, tt);
			  });
	},
	change(_) {
		getDeep(_, "sources.length")
			? (html5.cancelRequests.call(this),
			  this.destroy.call(
					this,
					() => {
						(this.options.quality = []),
							removeElement(this.media),
							(this.media = null),
							is.element(this.elements.container) && this.elements.container.removeAttribute("class");
						const { sources: et, type: tt } = _,
							[{ provider: nt = providers.html5, src: rt }] = et,
							it = nt === "html5" ? tt : "div",
							ot = nt === "html5" ? {} : { src: rt };
						Object.assign(this, {
							provider: nt,
							type: tt,
							supported: support.check(tt, nt, this.config.playsinline),
							media: createElement(it, ot),
						}),
							this.elements.container.appendChild(this.media),
							is.boolean(_.autoplay) && (this.config.autoplay = _.autoplay),
							this.isHTML5 &&
								(this.config.crossorigin && this.media.setAttribute("crossorigin", ""),
								this.config.autoplay && this.media.setAttribute("autoplay", ""),
								is.empty(_.poster) || (this.poster = _.poster),
								this.config.loop.active && this.media.setAttribute("loop", ""),
								this.config.muted && this.media.setAttribute("muted", ""),
								this.config.playsinline && this.media.setAttribute("playsinline", "")),
							ui.addStyleHook.call(this),
							this.isHTML5 && source.insertElements.call(this, "source", et),
							(this.config.title = _.title),
							media.setup.call(this),
							this.isHTML5 && Object.keys(_).includes("tracks") && source.insertElements.call(this, "track", _.tracks),
							(this.isHTML5 || (this.isEmbed && !this.supported.ui)) && ui.build.call(this),
							this.isHTML5 && this.media.load(),
							is.empty(_.previewThumbnails) ||
								(Object.assign(this.config.previewThumbnails, _.previewThumbnails),
								this.previewThumbnails &&
									this.previewThumbnails.loaded &&
									(this.previewThumbnails.destroy(), (this.previewThumbnails = null)),
								this.config.previewThumbnails.enabled && (this.previewThumbnails = new PreviewThumbnails(this))),
							this.fullscreen.update();
					},
					!0
			  ))
			: this.debug.warn("Invalid source format");
	},
};
class Plyr$1 {
	constructor(et, tt) {
		if (
			(_defineProperty$1(this, "play", () =>
				is.function(this.media.play)
					? (this.ads &&
							this.ads.enabled &&
							this.ads.managerPromise.then(() => this.ads.play()).catch(() => silencePromise(this.media.play())),
					  this.media.play())
					: null
			),
			_defineProperty$1(this, "pause", () =>
				this.playing && is.function(this.media.pause) ? this.media.pause() : null
			),
			_defineProperty$1(this, "togglePlay", (at) =>
				(is.boolean(at) ? at : !this.playing) ? this.play() : this.pause()
			),
			_defineProperty$1(this, "stop", () => {
				this.isHTML5 ? (this.pause(), this.restart()) : is.function(this.media.stop) && this.media.stop();
			}),
			_defineProperty$1(this, "restart", () => {
				this.currentTime = 0;
			}),
			_defineProperty$1(this, "rewind", (at) => {
				this.currentTime -= is.number(at) ? at : this.config.seekTime;
			}),
			_defineProperty$1(this, "forward", (at) => {
				this.currentTime += is.number(at) ? at : this.config.seekTime;
			}),
			_defineProperty$1(this, "increaseVolume", (at) => {
				const st = this.media.muted ? 0 : this.volume;
				this.volume = st + (is.number(at) ? at : 0);
			}),
			_defineProperty$1(this, "decreaseVolume", (at) => {
				this.increaseVolume(-at);
			}),
			_defineProperty$1(this, "airplay", () => {
				support.airplay && this.media.webkitShowPlaybackTargetPicker();
			}),
			_defineProperty$1(this, "toggleControls", (at) => {
				if (this.supported.ui && !this.isAudio) {
					const st = hasClass(this.elements.container, this.config.classNames.hideControls),
						lt = at === void 0 ? void 0 : !at,
						ut = toggleClass(this.elements.container, this.config.classNames.hideControls, lt);
					if (
						(ut &&
							is.array(this.config.controls) &&
							this.config.controls.includes("settings") &&
							!is.empty(this.config.settings) &&
							controls.toggleMenu.call(this, !1),
						ut !== st)
					) {
						const dt = ut ? "controlshidden" : "controlsshown";
						triggerEvent.call(this, this.media, dt);
					}
					return !ut;
				}
				return !1;
			}),
			_defineProperty$1(this, "on", (at, st) => {
				on.call(this, this.elements.container, at, st);
			}),
			_defineProperty$1(this, "once", (at, st) => {
				once.call(this, this.elements.container, at, st);
			}),
			_defineProperty$1(this, "off", (at, st) => {
				off(this.elements.container, at, st);
			}),
			_defineProperty$1(this, "destroy", (at, st = !1) => {
				if (!this.ready) return;
				const lt = () => {
					(document.body.style.overflow = ""),
						(this.embed = null),
						st
							? (Object.keys(this.elements).length &&
									(removeElement(this.elements.buttons.play),
									removeElement(this.elements.captions),
									removeElement(this.elements.controls),
									removeElement(this.elements.wrapper),
									(this.elements.buttons.play = null),
									(this.elements.captions = null),
									(this.elements.controls = null),
									(this.elements.wrapper = null)),
							  is.function(at) && at())
							: (unbindListeners.call(this),
							  html5.cancelRequests.call(this),
							  replaceElement(this.elements.original, this.elements.container),
							  triggerEvent.call(this, this.elements.original, "destroyed", !0),
							  is.function(at) && at.call(this.elements.original),
							  (this.ready = !1),
							  setTimeout(() => {
									(this.elements = null), (this.media = null);
							  }, 200));
				};
				this.stop(),
					clearTimeout(this.timers.loading),
					clearTimeout(this.timers.controls),
					clearTimeout(this.timers.resized),
					this.isHTML5
						? (ui.toggleNativeControls.call(this, !0), lt())
						: this.isYouTube
						? (clearInterval(this.timers.buffering),
						  clearInterval(this.timers.playing),
						  this.embed !== null && is.function(this.embed.destroy) && this.embed.destroy(),
						  lt())
						: this.isVimeo && (this.embed !== null && this.embed.unload().then(lt), setTimeout(lt, 200));
			}),
			_defineProperty$1(this, "supports", (at) => support.mime.call(this, at)),
			(this.timers = {}),
			(this.ready = !1),
			(this.loading = !1),
			(this.failed = !1),
			(this.touch = support.touch),
			(this.media = et),
			is.string(this.media) && (this.media = document.querySelectorAll(this.media)),
			((window.jQuery && this.media instanceof jQuery) || is.nodeList(this.media) || is.array(this.media)) &&
				(this.media = this.media[0]),
			(this.config = extend$1(
				{},
				defaults,
				Plyr$1.defaults,
				tt || {},
				(() => {
					try {
						return JSON.parse(this.media.getAttribute("data-plyr-config"));
					} catch {
						return {};
					}
				})()
			)),
			(this.elements = {
				container: null,
				fullscreen: null,
				captions: null,
				buttons: {},
				display: {},
				progress: {},
				inputs: {},
				settings: { popup: null, menu: null, panels: {}, buttons: {} },
			}),
			(this.captions = { active: null, currentTrack: -1, meta: new WeakMap() }),
			(this.fullscreen = { active: !1 }),
			(this.options = { speed: [], quality: [] }),
			(this.debug = new Console(this.config.debug)),
			this.debug.log("Config", this.config),
			this.debug.log("Support", support),
			is.nullOrUndefined(this.media) || !is.element(this.media))
		)
			return void this.debug.error("Setup failed: no suitable element passed");
		if (this.media.plyr) return void this.debug.warn("Target already setup");
		if (!this.config.enabled) return void this.debug.error("Setup failed: disabled by config");
		if (!support.check().api) return void this.debug.error("Setup failed: no support");
		const nt = this.media.cloneNode(!0);
		(nt.autoplay = !1), (this.elements.original = nt);
		const rt = this.media.tagName.toLowerCase();
		let it = null,
			ot = null;
		switch (rt) {
			case "div":
				if (((it = this.media.querySelector("iframe")), is.element(it))) {
					if (
						((ot = parseUrl(it.getAttribute("src"))),
						(this.provider = getProviderByUrl(ot.toString())),
						(this.elements.container = this.media),
						(this.media = it),
						(this.elements.container.className = ""),
						ot.search.length)
					) {
						const at = ["1", "true"];
						at.includes(ot.searchParams.get("autoplay")) && (this.config.autoplay = !0),
							at.includes(ot.searchParams.get("loop")) && (this.config.loop.active = !0),
							this.isYouTube
								? ((this.config.playsinline = at.includes(ot.searchParams.get("playsinline"))),
								  (this.config.youtube.hl = ot.searchParams.get("hl")))
								: (this.config.playsinline = !0);
					}
				} else
					(this.provider = this.media.getAttribute(this.config.attributes.embed.provider)),
						this.media.removeAttribute(this.config.attributes.embed.provider);
				if (is.empty(this.provider) || !Object.values(providers).includes(this.provider))
					return void this.debug.error("Setup failed: Invalid provider");
				this.type = types$1.video;
				break;
			case "video":
			case "audio":
				(this.type = rt),
					(this.provider = providers.html5),
					this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0),
					this.media.hasAttribute("autoplay") && (this.config.autoplay = !0),
					(this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) &&
						(this.config.playsinline = !0),
					this.media.hasAttribute("muted") && (this.config.muted = !0),
					this.media.hasAttribute("loop") && (this.config.loop.active = !0);
				break;
			default:
				return void this.debug.error("Setup failed: unsupported type");
		}
		(this.supported = support.check(this.type, this.provider, this.config.playsinline)),
			this.supported.api
				? ((this.eventListeners = []),
				  (this.listeners = new Listeners(this)),
				  (this.storage = new Storage(this)),
				  (this.media.plyr = this),
				  is.element(this.elements.container) ||
						((this.elements.container = createElement("div", { tabindex: 0 })),
						wrap$2(this.media, this.elements.container)),
				  ui.migrateStyles.call(this),
				  ui.addStyleHook.call(this),
				  media.setup.call(this),
				  this.config.debug &&
						on.call(this, this.elements.container, this.config.events.join(" "), (at) => {
							this.debug.log(`event: ${at.type}`);
						}),
				  (this.fullscreen = new Fullscreen(this)),
				  (this.isHTML5 || (this.isEmbed && !this.supported.ui)) && ui.build.call(this),
				  this.listeners.container(),
				  this.listeners.global(),
				  this.config.ads.enabled && (this.ads = new Ads(this)),
				  this.isHTML5 && this.config.autoplay && this.once("canplay", () => silencePromise(this.play())),
				  (this.lastSeekTime = 0),
				  this.config.previewThumbnails.enabled && (this.previewThumbnails = new PreviewThumbnails(this)))
				: this.debug.error("Setup failed: no support");
	}
	get isHTML5() {
		return this.provider === providers.html5;
	}
	get isEmbed() {
		return this.isYouTube || this.isVimeo;
	}
	get isYouTube() {
		return this.provider === providers.youtube;
	}
	get isVimeo() {
		return this.provider === providers.vimeo;
	}
	get isVideo() {
		return this.type === types$1.video;
	}
	get isAudio() {
		return this.type === types$1.audio;
	}
	get playing() {
		return Boolean(this.ready && !this.paused && !this.ended);
	}
	get paused() {
		return Boolean(this.media.paused);
	}
	get stopped() {
		return Boolean(this.paused && this.currentTime === 0);
	}
	get ended() {
		return Boolean(this.media.ended);
	}
	set currentTime(et) {
		if (!this.duration) return;
		const tt = is.number(et) && et > 0;
		(this.media.currentTime = tt ? Math.min(et, this.duration) : 0),
			this.debug.log(`Seeking to ${this.currentTime} seconds`);
	}
	get currentTime() {
		return Number(this.media.currentTime);
	}
	get buffered() {
		const { buffered: et } = this.media;
		return is.number(et) ? et : et && et.length && this.duration > 0 ? et.end(0) / this.duration : 0;
	}
	get seeking() {
		return Boolean(this.media.seeking);
	}
	get duration() {
		const et = parseFloat(this.config.duration),
			tt = (this.media || {}).duration,
			nt = is.number(tt) && tt !== 1 / 0 ? tt : 0;
		return et || nt;
	}
	set volume(et) {
		let tt = et;
		is.string(tt) && (tt = Number(tt)),
			is.number(tt) || (tt = this.storage.get("volume")),
			is.number(tt) || ({ volume: tt } = this.config),
			tt > 1 && (tt = 1),
			tt < 0 && (tt = 0),
			(this.config.volume = tt),
			(this.media.volume = tt),
			!is.empty(et) && this.muted && tt > 0 && (this.muted = !1);
	}
	get volume() {
		return Number(this.media.volume);
	}
	set muted(et) {
		let tt = et;
		is.boolean(tt) || (tt = this.storage.get("muted")),
			is.boolean(tt) || (tt = this.config.muted),
			(this.config.muted = tt),
			(this.media.muted = tt);
	}
	get muted() {
		return Boolean(this.media.muted);
	}
	get hasAudio() {
		return (
			!this.isHTML5 ||
			!!this.isAudio ||
			Boolean(this.media.mozHasAudio) ||
			Boolean(this.media.webkitAudioDecodedByteCount) ||
			Boolean(this.media.audioTracks && this.media.audioTracks.length)
		);
	}
	set speed(et) {
		let tt = null;
		is.number(et) && (tt = et),
			is.number(tt) || (tt = this.storage.get("speed")),
			is.number(tt) || (tt = this.config.speed.selected);
		const { minimumSpeed: nt, maximumSpeed: rt } = this;
		(tt = clamp(tt, nt, rt)),
			(this.config.speed.selected = tt),
			setTimeout(() => {
				this.media && (this.media.playbackRate = tt);
			}, 0);
	}
	get speed() {
		return Number(this.media.playbackRate);
	}
	get minimumSpeed() {
		return this.isYouTube ? Math.min(...this.options.speed) : this.isVimeo ? 0.5 : 0.0625;
	}
	get maximumSpeed() {
		return this.isYouTube ? Math.max(...this.options.speed) : this.isVimeo ? 2 : 16;
	}
	set quality(et) {
		const tt = this.config.quality,
			nt = this.options.quality;
		if (!nt.length) return;
		let rt = [!is.empty(et) && Number(et), this.storage.get("quality"), tt.selected, tt.default].find(is.number),
			it = !0;
		if (!nt.includes(rt)) {
			const ot = closest(nt, rt);
			this.debug.warn(`Unsupported quality option: ${rt}, using ${ot} instead`), (rt = ot), (it = !1);
		}
		(tt.selected = rt), (this.media.quality = rt), it && this.storage.set({ quality: rt });
	}
	get quality() {
		return this.media.quality;
	}
	set loop(et) {
		const tt = is.boolean(et) ? et : this.config.loop.active;
		(this.config.loop.active = tt), (this.media.loop = tt);
	}
	get loop() {
		return Boolean(this.media.loop);
	}
	set source(et) {
		source.change.call(this, et);
	}
	get source() {
		return this.media.currentSrc;
	}
	get download() {
		const { download: et } = this.config.urls;
		return is.url(et) ? et : this.source;
	}
	set download(et) {
		is.url(et) && ((this.config.urls.download = et), controls.setDownloadUrl.call(this));
	}
	set poster(et) {
		this.isVideo
			? ui.setPoster.call(this, et, !1).catch(() => {})
			: this.debug.warn("Poster can only be set for video");
	}
	get poster() {
		return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null;
	}
	get ratio() {
		if (!this.isVideo) return null;
		const et = reduceAspectRatio(getAspectRatio.call(this));
		return is.array(et) ? et.join(":") : et;
	}
	set ratio(et) {
		this.isVideo
			? is.string(et) && validateAspectRatio(et)
				? ((this.config.ratio = reduceAspectRatio(et)), setAspectRatio.call(this))
				: this.debug.error(`Invalid aspect ratio specified (${et})`)
			: this.debug.warn("Aspect ratio can only be set for video");
	}
	set autoplay(et) {
		this.config.autoplay = is.boolean(et) ? et : this.config.autoplay;
	}
	get autoplay() {
		return Boolean(this.config.autoplay);
	}
	toggleCaptions(et) {
		captions.toggle.call(this, et, !1);
	}
	set currentTrack(et) {
		captions.set.call(this, et, !1), captions.setup.call(this);
	}
	get currentTrack() {
		const { toggled: et, currentTrack: tt } = this.captions;
		return et ? tt : -1;
	}
	set language(et) {
		captions.setLanguage.call(this, et, !1);
	}
	get language() {
		return (captions.getCurrentTrack.call(this) || {}).language;
	}
	set pip(et) {
		if (!support.pip) return;
		const tt = is.boolean(et) ? et : !this.pip;
		is.function(this.media.webkitSetPresentationMode) &&
			this.media.webkitSetPresentationMode(tt ? pip.active : pip.inactive),
			is.function(this.media.requestPictureInPicture) &&
				(!this.pip && tt ? this.media.requestPictureInPicture() : this.pip && !tt && document.exitPictureInPicture());
	}
	get pip() {
		return support.pip
			? is.empty(this.media.webkitPresentationMode)
				? this.media === document.pictureInPictureElement
				: this.media.webkitPresentationMode === pip.active
			: null;
	}
	setPreviewThumbnails(et) {
		this.previewThumbnails &&
			this.previewThumbnails.loaded &&
			(this.previewThumbnails.destroy(), (this.previewThumbnails = null)),
			Object.assign(this.config.previewThumbnails, et),
			this.config.previewThumbnails.enabled && (this.previewThumbnails = new PreviewThumbnails(this));
	}
	static supported(et, tt, nt) {
		return support.check(et, tt, nt);
	}
	static loadSprite(et, tt) {
		return loadSprite(et, tt);
	}
	static setup(et, tt = {}) {
		let nt = null;
		return (
			is.string(et)
				? (nt = Array.from(document.querySelectorAll(et)))
				: is.nodeList(et)
				? (nt = Array.from(et))
				: is.array(et) && (nt = et.filter(is.element)),
			is.empty(nt) ? null : nt.map((rt) => new Plyr$1(rt, tt))
		);
	}
}
Plyr$1.defaults = cloneDeep(defaults);
function useAptor(_, et, tt = []) {
	const [nt, rt] = react.exports.useState(null),
		it = react.exports.useRef(null),
		{ instantiate: ot, destroy: at, getAPI: st, params: lt } = et;
	react.exports.useEffect(() => {
		const dt = ot(it.current, lt);
		return (
			rt(dt),
			() => {
				at && at(dt, lt);
			}
		);
	}, tt);
	const ut = react.exports.useMemo(() => st(nt, lt), [nt]);
	return react.exports.useImperativeHandle(_, ut, [ut]), it;
}
var __defProp = Object.defineProperty,
	__getOwnPropSymbols = Object.getOwnPropertySymbols,
	__hasOwnProp = Object.prototype.hasOwnProperty,
	__propIsEnum = Object.prototype.propertyIsEnumerable,
	__defNormalProp = (_, et, tt) =>
		et in _ ? __defProp(_, et, { enumerable: !0, configurable: !0, writable: !0, value: tt }) : (_[et] = tt),
	__spreadValues = (_, et) => {
		for (var tt in et || (et = {})) __hasOwnProp.call(et, tt) && __defNormalProp(_, tt, et[tt]);
		if (__getOwnPropSymbols)
			for (var tt of __getOwnPropSymbols(et)) __propIsEnum.call(et, tt) && __defNormalProp(_, tt, et[tt]);
		return _;
	},
	__objRest = (_, et) => {
		var tt = {};
		for (var nt in _) __hasOwnProp.call(_, nt) && et.indexOf(nt) < 0 && (tt[nt] = _[nt]);
		if (_ != null && __getOwnPropSymbols)
			for (var nt of __getOwnPropSymbols(_)) et.indexOf(nt) < 0 && __propIsEnum.call(_, nt) && (tt[nt] = _[nt]);
		return tt;
	};
const instantiate = (_, et) => {
		const tt = new Plyr$1(".plyr-react", et.options || {});
		return et.source && (tt.source = et.source), tt;
	},
	destroy = (_) => {
		_ && _.destroy();
	},
	noop = () => {},
	getAPI = (_) =>
		_
			? () => ({ plyr: _ })
			: () => new Proxy({ plyr: { source: null } }, { get: (et, tt) => (tt === "plyr" ? et[tt] : noop) });
function usePlyr(_, et, tt = null) {
	return useAptor(_, { instantiate, getAPI, destroy, params: et }, tt || [et.options, et.source]);
}
const Plyr = react.exports.forwardRef((_, et) => {
	const tt = _,
		{ source: nt, options: rt = null } = tt,
		it = __objRest(tt, ["source", "options"]),
		ot = usePlyr(et, { source: nt, options: rt });
	return jsx("video", { ...__spreadValues({ ref: ot, className: "plyr-react plyr" }, it) });
});
(({
	VITE_BACKGROUND_PREFIX: "/culture/",
	VITE_PRODUCTION_PREFIX: "'/static/tutorials/assets/",
	BASE_URL: "./",
	MODE: "production",
	DEV: !1,
	PROD: !0,
} && "production") !== "production" &&
	((Plyr.displayName = "Plyr"),
	(Plyr.defaultProps = {
		options: {
			controls: [
				"rewind",
				"play",
				"fast-forward",
				"progress",
				"current-time",
				"duration",
				"mute",
				"volume",
				"settings",
				"fullscreen",
			],
			i18n: {
				restart: "Restart",
				rewind: "Rewind {seektime}s",
				play: "Play",
				pause: "Pause",
				fastForward: "Forward {seektime}s",
				seek: "Seek",
				seekLabel: "{currentTime} of {duration}",
				played: "Played",
				buffered: "Buffered",
				currentTime: "Current time",
				duration: "Duration",
				volume: "Volume",
				mute: "Mute",
				unmute: "Unmute",
				enableCaptions: "Enable captions",
				disableCaptions: "Disable captions",
				download: "Download",
				enterFullscreen: "Enter fullscreen",
				exitFullscreen: "Exit fullscreen",
				frameTitle: "Player for {title}",
				captions: "Captions",
				settings: "Settings",
				menuBack: "Go back to previous menu",
				speed: "Speed",
				normal: "Normal",
				quality: "Quality",
				loop: "Loop",
			},
		},
		source: {
			type: "video",
			sources: [
				{ src: "https://cdn.plyr.io/static/blank.mp4", type: "video/mp4", size: 720 },
				{ src: "https://cdn.plyr.io/static/blank.mp4", type: "video/mp4", size: 1080 },
			],
		},
	}),
	(Plyr.propTypes = { options: propTypes.exports.object, source: propTypes.exports.any })));
const plyr = "";
function StepVideo$1({ url: _ }) {
	return jsx(Fragment, {
		children: jsx(Plyr, {
			options: {
				controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "settings", "fullscreen"],
			},
			source: { type: "video", sources: [{ src: "assets/" + _, type: "video/mp4" }] },
		}),
	});
}
const e$2 = typeof window > "u" || typeof document > "u";
let s$3 = e$2 ? react.exports.useEffect : react.exports.useLayoutEffect;
function s$2(_) {
	let et = react.exports.useRef(_);
	return (
		s$3(() => {
			et.current = _;
		}, [_]),
		et
	);
}
let o$2 = function (_) {
		let et = s$2(_);
		return React$1.useCallback((...tt) => et.current(...tt), [et]);
	},
	r$2 = { serverHandoffComplete: !1 };
function a() {
	let [_, et] = react.exports.useState(r$2.serverHandoffComplete);
	return (
		react.exports.useEffect(() => {
			_ !== !0 && et(!0);
		}, [_]),
		react.exports.useEffect(() => {
			r$2.serverHandoffComplete === !1 && (r$2.serverHandoffComplete = !0);
		}, []),
		_
	);
}
var u$4;
let l$1 = 0;
function r$1() {
	return ++l$1;
}
let I =
	(u$4 = React$1.useId) != null
		? u$4
		: function () {
				let _ = a(),
					[et, tt] = React$1.useState(_ ? r$1 : null);
				return (
					s$3(() => {
						et === null && tt(r$1());
					}, [et]),
					et != null ? "" + et : void 0
				);
		  };
function u$3(_, et, ...tt) {
	if (_ in et) {
		let rt = et[_];
		return typeof rt == "function" ? rt(...tt) : rt;
	}
	let nt = new Error(
		`Tried to handle "${_}" but there is no handler defined. Only defined handlers are: ${Object.keys(et)
			.map((rt) => `"${rt}"`)
			.join(", ")}.`
	);
	throw (Error.captureStackTrace && Error.captureStackTrace(nt, u$3), nt);
}
function e$1(_) {
	return e$2
		? null
		: _ instanceof Node
		? _.ownerDocument
		: _ != null && _.hasOwnProperty("current") && _.current instanceof Node
		? _.current.ownerDocument
		: document;
}
function i$1(_) {
	var et;
	if (_.type) return _.type;
	let tt = (et = _.as) != null ? et : "button";
	if (typeof tt == "string" && tt.toLowerCase() === "button") return "button";
}
function s$1(_, et) {
	let [tt, nt] = react.exports.useState(() => i$1(_));
	return (
		s$3(() => {
			nt(i$1(_));
		}, [_.type, _.as]),
		s$3(() => {
			tt ||
				!et.current ||
				(et.current instanceof HTMLButtonElement && !et.current.hasAttribute("type") && nt("button"));
		}, [tt, et]),
		tt
	);
}
let u$2 = Symbol();
function T$1(_, et = !0) {
	return Object.assign(_, { [u$2]: et });
}
function y$1(..._) {
	let et = react.exports.useRef(_);
	react.exports.useEffect(() => {
		et.current = _;
	}, [_]);
	let tt = o$2((nt) => {
		for (let rt of et.current) rt != null && (typeof rt == "function" ? rt(nt) : (rt.current = nt));
	});
	return _.every((nt) => nt == null || (nt == null ? void 0 : nt[u$2])) ? void 0 : tt;
}
var S = ((_) => (
		(_[(_.None = 0)] = "None"), (_[(_.RenderStrategy = 1)] = "RenderStrategy"), (_[(_.Static = 2)] = "Static"), _
	))(S || {}),
	j$1 = ((_) => ((_[(_.Unmount = 0)] = "Unmount"), (_[(_.Hidden = 1)] = "Hidden"), _))(j$1 || {});
function $({ ourProps: _, theirProps: et, slot: tt, defaultTag: nt, features: rt, visible: it = !0, name: ot }) {
	let at = T(et, _);
	if (it) return p$2(at, tt, nt, ot);
	let st = rt != null ? rt : 0;
	if (st & 2) {
		let { static: lt = !1, ...ut } = at;
		if (lt) return p$2(ut, tt, nt, ot);
	}
	if (st & 1) {
		let { unmount: lt = !0, ...ut } = at;
		return u$3(lt ? 0 : 1, {
			[0]() {
				return null;
			},
			[1]() {
				return p$2({ ...ut, hidden: !0, style: { display: "none" } }, tt, nt, ot);
			},
		});
	}
	return p$2(at, tt, nt, ot);
}
function p$2(_, et = {}, tt, nt) {
	let { as: rt = tt, children: it, refName: ot = "ref", ...at } = m$1(_, ["unmount", "static"]),
		st = _.ref !== void 0 ? { [ot]: _.ref } : {},
		lt = typeof it == "function" ? it(et) : it;
	at.className && typeof at.className == "function" && (at.className = at.className(et));
	let ut = {};
	if (et) {
		let dt = !1,
			ct = [];
		for (let [ft, mt] of Object.entries(et)) typeof mt == "boolean" && (dt = !0), mt === !0 && ct.push(ft);
		dt && (ut["data-headlessui-state"] = ct.join(" "));
	}
	if (rt === react.exports.Fragment && Object.keys(F(at)).length > 0) {
		if (!react.exports.isValidElement(lt) || (Array.isArray(lt) && lt.length > 1))
			throw new Error(
				[
					'Passing props on "Fragment"!',
					"",
					`The current component <${nt} /> is rendering a "Fragment".`,
					"However we need to passthrough the following props:",
					Object.keys(at).map((dt) => `  - ${dt}`).join(`
`),
					"",
					"You can apply a few solutions:",
					[
						'Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".',
						"Render a single element as the child so that we can forward the props onto that element.",
					].map((dt) => `  - ${dt}`).join(`
`),
				].join(`
`)
			);
		return react.exports.cloneElement(
			lt,
			Object.assign({}, T(lt.props, F(m$1(at, ["ref"]))), ut, st, w(lt.ref, st.ref))
		);
	}
	return react.exports.createElement(
		rt,
		Object.assign({}, m$1(at, ["ref"]), rt !== react.exports.Fragment && st, rt !== react.exports.Fragment && ut),
		lt
	);
}
function w(..._) {
	return {
		ref: _.every((et) => et == null)
			? void 0
			: (et) => {
					for (let tt of _) tt != null && (typeof tt == "function" ? tt(et) : (tt.current = et));
			  },
	};
}
function T(..._) {
	if (_.length === 0) return {};
	if (_.length === 1) return _[0];
	let et = {},
		tt = {};
	for (let nt of _)
		for (let rt in nt)
			rt.startsWith("on") && typeof nt[rt] == "function"
				? (tt[rt] != null || (tt[rt] = []), tt[rt].push(nt[rt]))
				: (et[rt] = nt[rt]);
	if (et.disabled || et["aria-disabled"])
		return Object.assign(et, Object.fromEntries(Object.keys(tt).map((nt) => [nt, void 0])));
	for (let nt in tt)
		Object.assign(et, {
			[nt](rt, ...it) {
				let ot = tt[nt];
				for (let at of ot) {
					if ((rt instanceof Event || (rt == null ? void 0 : rt.nativeEvent) instanceof Event) && rt.defaultPrevented)
						return;
					at(rt, ...it);
				}
			},
		});
	return et;
}
function C$1(_) {
	var et;
	return Object.assign(react.exports.forwardRef(_), { displayName: (et = _.displayName) != null ? et : _.name });
}
function F(_) {
	let et = Object.assign({}, _);
	for (let tt in et) et[tt] === void 0 && delete et[tt];
	return et;
}
function m$1(_, et = []) {
	let tt = Object.assign({}, _);
	for (let nt of et) nt in tt && delete tt[nt];
	return tt;
}
function r(_) {
	let et = _.parentElement,
		tt = null;
	for (; et && !(et instanceof HTMLFieldSetElement); )
		et instanceof HTMLLegendElement && (tt = et), (et = et.parentElement);
	let nt = (et == null ? void 0 : et.getAttribute("disabled")) === "";
	return nt && i(tt) ? !1 : nt;
}
function i(_) {
	if (!_) return !1;
	let et = _.previousElementSibling;
	for (; et !== null; ) {
		if (et instanceof HTMLLegendElement) return !1;
		et = et.previousElementSibling;
	}
	return !0;
}
let o$1 = react.exports.createContext(null);
o$1.displayName = "OpenClosedContext";
var p$1 = ((_) => ((_[(_.Open = 0)] = "Open"), (_[(_.Closed = 1)] = "Closed"), _))(p$1 || {});
function s() {
	return react.exports.useContext(o$1);
}
function C({ value: _, children: et }) {
	return React$1.createElement(o$1.Provider, { value: _ }, et);
}
var o = ((_) => (
		(_.Space = " "),
		(_.Enter = "Enter"),
		(_.Escape = "Escape"),
		(_.Backspace = "Backspace"),
		(_.Delete = "Delete"),
		(_.ArrowLeft = "ArrowLeft"),
		(_.ArrowUp = "ArrowUp"),
		(_.ArrowRight = "ArrowRight"),
		(_.ArrowDown = "ArrowDown"),
		(_.Home = "Home"),
		(_.End = "End"),
		(_.PageUp = "PageUp"),
		(_.PageDown = "PageDown"),
		(_.Tab = "Tab"),
		_
	))(o || {}),
	Q = ((_) => ((_[(_.Open = 0)] = "Open"), (_[(_.Closed = 1)] = "Closed"), _))(Q || {}),
	V = ((_) => (
		(_[(_.ToggleDisclosure = 0)] = "ToggleDisclosure"),
		(_[(_.CloseDisclosure = 1)] = "CloseDisclosure"),
		(_[(_.SetButtonId = 2)] = "SetButtonId"),
		(_[(_.SetPanelId = 3)] = "SetPanelId"),
		(_[(_.LinkPanel = 4)] = "LinkPanel"),
		(_[(_.UnlinkPanel = 5)] = "UnlinkPanel"),
		_
	))(V || {});
let X = {
		[0]: (_) => ({ ..._, disclosureState: u$3(_.disclosureState, { [0]: 1, [1]: 0 }) }),
		[1]: (_) => (_.disclosureState === 1 ? _ : { ..._, disclosureState: 1 }),
		[4](_) {
			return _.linkedPanel === !0 ? _ : { ..._, linkedPanel: !0 };
		},
		[5](_) {
			return _.linkedPanel === !1 ? _ : { ..._, linkedPanel: !1 };
		},
		[2](_, et) {
			return _.buttonId === et.buttonId ? _ : { ..._, buttonId: et.buttonId };
		},
		[3](_, et) {
			return _.panelId === et.panelId ? _ : { ..._, panelId: et.panelId };
		},
	},
	B = react.exports.createContext(null);
B.displayName = "DisclosureContext";
function h$1(_) {
	let et = react.exports.useContext(B);
	if (et === null) {
		let tt = new Error(`<${_} /> is missing a parent <Disclosure /> component.`);
		throw (Error.captureStackTrace && Error.captureStackTrace(tt, h$1), tt);
	}
	return et;
}
let H = react.exports.createContext(null);
H.displayName = "DisclosureAPIContext";
function j(_) {
	let et = react.exports.useContext(H);
	if (et === null) {
		let tt = new Error(`<${_} /> is missing a parent <Disclosure /> component.`);
		throw (Error.captureStackTrace && Error.captureStackTrace(tt, j), tt);
	}
	return et;
}
let U = react.exports.createContext(null);
U.displayName = "DisclosurePanelContext";
function Y() {
	return react.exports.useContext(U);
}
function Z(_, et) {
	return u$3(et.type, X, _, et);
}
let ee = react.exports.Fragment,
	te = C$1(function (_, et) {
		let { defaultOpen: tt = !1, ...nt } = _,
			rt = `headlessui-disclosure-button-${I()}`,
			it = `headlessui-disclosure-panel-${I()}`,
			ot = react.exports.useRef(null),
			at = y$1(
				et,
				T$1((ht) => {
					ot.current = ht;
				}, _.as === void 0 || _.as === react.exports.Fragment)
			),
			st = react.exports.useRef(null),
			lt = react.exports.useRef(null),
			ut = react.exports.useReducer(Z, {
				disclosureState: tt ? 0 : 1,
				linkedPanel: !1,
				buttonRef: lt,
				panelRef: st,
				buttonId: rt,
				panelId: it,
			}),
			[{ disclosureState: dt }, ct] = ut;
		react.exports.useEffect(() => ct({ type: 2, buttonId: rt }), [rt, ct]),
			react.exports.useEffect(() => ct({ type: 3, panelId: it }), [it, ct]);
		let ft = o$2((ht) => {
				ct({ type: 1 });
				let gt = e$1(ot);
				if (!gt) return;
				let yt = (() =>
					ht
						? ht instanceof HTMLElement
							? ht
							: ht.current instanceof HTMLElement
							? ht.current
							: gt.getElementById(rt)
						: gt.getElementById(rt))();
				yt == null || yt.focus();
			}),
			mt = react.exports.useMemo(() => ({ close: ft }), [ft]),
			pt = react.exports.useMemo(() => ({ open: dt === 0, close: ft }), [dt, ft]),
			vt = { ref: at };
		return React$1.createElement(
			B.Provider,
			{ value: ut },
			React$1.createElement(
				H.Provider,
				{ value: mt },
				React$1.createElement(
					C,
					{ value: u$3(dt, { [0]: p$1.Open, [1]: p$1.Closed }) },
					$({ ourProps: vt, theirProps: nt, slot: pt, defaultTag: ee, name: "Disclosure" })
				)
			)
		);
	}),
	ne = "button",
	le = C$1(function (_, et) {
		let [tt, nt] = h$1("Disclosure.Button"),
			rt = Y(),
			it = rt === null ? !1 : rt === tt.panelId,
			ot = react.exports.useRef(null),
			at = y$1(ot, et, it ? null : tt.buttonRef),
			st = o$2((pt) => {
				var vt;
				if (it) {
					if (tt.disclosureState === 1) return;
					switch (pt.key) {
						case o.Space:
						case o.Enter:
							pt.preventDefault(),
								pt.stopPropagation(),
								nt({ type: 0 }),
								(vt = tt.buttonRef.current) == null || vt.focus();
							break;
					}
				} else
					switch (pt.key) {
						case o.Space:
						case o.Enter:
							pt.preventDefault(), pt.stopPropagation(), nt({ type: 0 });
							break;
					}
			}),
			lt = o$2((pt) => {
				switch (pt.key) {
					case o.Space:
						pt.preventDefault();
						break;
				}
			}),
			ut = o$2((pt) => {
				var vt;
				r(pt.currentTarget) ||
					_.disabled ||
					(it ? (nt({ type: 0 }), (vt = tt.buttonRef.current) == null || vt.focus()) : nt({ type: 0 }));
			}),
			dt = react.exports.useMemo(() => ({ open: tt.disclosureState === 0 }), [tt]),
			ct = s$1(_, ot),
			ft = _,
			mt = it
				? { ref: at, type: ct, onKeyDown: st, onClick: ut }
				: {
						ref: at,
						id: tt.buttonId,
						type: ct,
						"aria-expanded": _.disabled ? void 0 : tt.disclosureState === 0,
						"aria-controls": tt.linkedPanel ? tt.panelId : void 0,
						onKeyDown: st,
						onKeyUp: lt,
						onClick: ut,
				  };
		return $({ ourProps: mt, theirProps: ft, slot: dt, defaultTag: ne, name: "Disclosure.Button" });
	}),
	oe = "div",
	re = S.RenderStrategy | S.Static,
	se = C$1(function (_, et) {
		let [tt, nt] = h$1("Disclosure.Panel"),
			{ close: rt } = j("Disclosure.Panel"),
			it = y$1(et, tt.panelRef, (dt) => {
				nt({ type: dt ? 4 : 5 });
			}),
			ot = s(),
			at = (() => (ot !== null ? ot === p$1.Open : tt.disclosureState === 0))(),
			st = react.exports.useMemo(() => ({ open: tt.disclosureState === 0, close: rt }), [tt, rt]),
			lt = _,
			ut = { ref: it, id: tt.panelId };
		return jsx(U.Provider, {
			value: tt.panelId,
			children: $({
				ourProps: ut,
				theirProps: lt,
				slot: st,
				defaultTag: oe,
				features: re,
				visible: at,
				name: "Disclosure.Panel",
			}),
		});
	}),
	Oe = Object.assign(te, { Button: le, Panel: se });
const StepNavigation = ({ current: _, available: et }) => {
		const tt = react.exports.useRef(null),
			nt = react.exports.useRef(null),
			rt = (it) => {
				const ot = _.get() + it;
				_.set(ot);
			};
		return jsx(Fragment, {
			children: jsxs("section", {
				className: "py-5 items-center third-step justify-between w-full mt-auto flex",
				children: [
					jsxs("p", {
						className: " text-gray-50",
						children: [
							" ",
							jsx("span", { className: "font-medium", children: "Step" }),
							" ",
							jsx("span", { children: _.get() + 1 }),
							"/" + et.length,
						],
					}),
					" ",
					jsxs("div", {
						className: "text-right w-full",
						children: [
							jsx("button", {
								className:
									"mx-2 border-blue-200 border text-blue-200 font-semibold px-5 py-2 rounded-md enabled:hover:bg-blue-300  transition ease-linear disabled:text-opacity-50 disabled:cursor-not-allowed disabled:border-opacity-50 enabled:hover:bg-opacity-10  ",
								colorScheme: "blue",
								px: 5,
								mx: 2,
								id: "prev",
								ref: tt,
								onClick: () => {
									rt(-1);
								},
								disabled: _.get() == 0,
								children: "Prev",
							}),
							jsx("button", {
								className:
									"bg-blue-200 text-gray-900 font-semibold px-5 py-2 rounded-md enabled:hover:bg-blue-300 transition ease-linear disabled:bg-opacity-50 disabled:cursor-not-allowed",
								id: "next",
								ref: nt,
								onClick: () => {
									rt(1);
								},
								disabled: _.get() == et.length - 1,
								children: "Next",
							}),
						],
					}),
				],
			}),
		});
	},
	FinalModal = ({ isOpen: _, onOpen: et, onClose: tt, nextSteps: nt, outcome: rt, background: it, software: ot }) => (
		useNavigate(),
		jsx(DarkMode, {
			children: jsxs(Modal, {
				onClose: tt,
				isOpen: _,
				size: "xl",
				isCentered: !0,
				children: [
					jsx(ModalOverlay, {}),
					jsxs(ModalContent, {
						color: "white",
						children: [
							jsx(ModalHeader, { children: "Congratulations!" }),
							jsx(ModalCloseButton, {}),
							jsx(ModalBody, {
								children: jsxs(Stack, {
									spacing: 4,
									children: [
										jsx("p", {
											className: "mb-5 mt-2",
											children:
												nt ||
												"You completed the tutorial. You are now ready to move on to the simulation where you create your own designs!",
										}),
										jsxs(Stack, {
											spacing: 5,
											children: [
												jsxs(Stack, {
													direction: { base: "column", sm: "row" },
													align: "start",
													justify: "space-between",
													children: [
														it &&
															jsx(Button, {
																onClick: () => {
																	window.location.href = "/culture/" + it;
																},
																w: { base: "100%", sm: "50%" },
																children: "Review the background",
															}),
														jsx(Button, {
															onClick: () => {
																window.location.href = "/static/tutorials/index.html";
															},
															w: { base: "100%", sm: "50%" },
															children: "Try another tutorial",
														}),
													],
												}),
												ot &&
													jsx(Button, {
														bg: "blue.400",
														color: "white",
														onClick: () => {
															window.location.href = "/culture/" + ot;
														},
														_hover: { bg: "blue.500" },
														children: "Jump into the software",
													}),
											],
										}),
									],
								}),
							}),
							jsx(ModalFooter, {}),
						],
					}),
				],
			}),
		})
	);
function StepProgressBar({ current: _, available: et }) {
	const tt = react.exports.useRef([]),
		nt = (rt) => {
			_.set(rt);
		};
	return jsx(Flex, {
		pt: "5",
		align: "center",
		children: jsx(Box, {
			textAlign: "center",
			w: "100%",
			children: jsxs(Box, {
				className: "progress-container  fourth-step",
				children: [
					jsx(Box, { className: "progress", id: "progress", w: `${(_.get() / (et.length - 1)) * 100 + "%"}` }),
					et.map((rt, it) =>
						jsx(
							"div",
							{
								className: `circle ${it <= _.get() ? "active" : ""} cursor-pointer`,
								ref: (ot) => {
									tt.current[it] = ot;
								},
								onClick: () => nt(rt),
								children: it + 1,
							},
							it
						)
					),
				],
			}),
		}),
	});
}
function SidebarContent(_) {
	const { info: et, step: tt, setStep: nt, available: rt, isCodeShown: it, ...ot } = _,
		[at, st] = react.exports.useState(0);
	return jsxs(Box, {
		as: "nav",
		pos: "fixed",
		top: "0",
		left: "0",
		h: "full",
		px: "8",
		pt: "5",
		pb: "10",
		overflowX: "hidden",
		overflowY: "auto",
		borderColor: "blackAlpha.300",
		borderRightWidth: "1px",
		w: 96,
		transition: ".3s ease",
		zIndex: "auto",
		bg: useColorModeValue("gray.50", "gray.900"),
		...ot,
		children: [
			jsxs(Box, {
				py: "5",
				children: [
					jsx("header", { className: "font-semibold text-xl", children: et == null ? void 0 : et.tutorial_title }),
					jsx("p", { children: "En Espanol " }),
				],
			}),
			rt &&
				rt.length > 0 &&
				jsx(StepProgressBar, {
					current: {
						get: () => at,
						set: (lt) => {
							st(lt.id), nt(lt);
						},
					},
					available: rt,
				}),
			jsx(Stack, {
				direction: "column",
				justifyContent: "space-between",
				spacing: 96,
				children: jsxs(Flex, {
					direction: "column",
					fontSize: "sm",
					color: "teal",
					"aria-label": "Main Navigation",
					children: [
						(tt == null ? void 0 : tt.description) &&
							jsx(StepDescription, {
								description: tt == null ? void 0 : tt.description,
								short: tt == null ? void 0 : tt.short,
							}),
						(tt == null ? void 0 : tt.video) &&
							jsx(StepVideo$1, { url: (et == null ? void 0 : et.prefix) + (tt == null ? void 0 : tt.video) }),
						(tt == null ? void 0 : tt.outcome) &&
							jsx(Image2, { src: "assets/" + (et == null ? void 0 : et.prefix) + (tt == null ? void 0 : tt.outcome) }),
						(tt == null ? void 0 : tt.code) &&
							it &&
							jsx(Image2, { src: "assets/" + (et == null ? void 0 : et.prefix) + (tt == null ? void 0 : tt.code) }),
					],
				}),
			}),
			rt &&
				rt.length > 0 &&
				jsx(StepNavigation, {
					current: {
						get: () => at,
						set: (lt) => {
							st(lt), nt(rt[lt]);
						},
					},
					available: rt,
				}),
		],
	});
}
function Homepage() {
	return (
		useNavigate(),
		useSearchParams(),
		jsxs("section", {
			className: "bg-gray-700 min-h-screen",
			children: [
				jsx(Navigation, {}),
				jsxs("main", {
					className: "p-4  container mx-auto h-[calc(100vh - 120px)] overflow-y-auto",
					children: [
						jsx("header", { className: "font-bold text-4xl text-gray-50", children: "CSDT Tutorials" }),
						jsx("section", {
							className: "border-4 border-dashed rounded-md",
							children: jsx(SimpleGrid, {
								columns: 4,
								children: data$1 && data$1.map((_) => jsx(HomepageCard, { ..._ })),
							}),
						}),
					],
				}),
				" ",
				jsx(Footer, { tool: "Tutorials" }),
			],
		})
	);
}
var isMergeableObject = function _(et) {
	return isNonNullObject(et) && !isSpecial(et);
};
function isNonNullObject(_) {
	return !!_ && typeof _ == "object";
}
function isSpecial(_) {
	var et = Object.prototype.toString.call(_);
	return et === "[object RegExp]" || et === "[object Date]" || isReactElement(_);
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for,
	REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(_) {
	return _.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(_) {
	return Array.isArray(_) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(_, et) {
	return et.clone !== !1 && et.isMergeableObject(_) ? deepmerge(emptyTarget(_), _, et) : _;
}
function defaultArrayMerge(_, et, tt) {
	return _.concat(et).map(function (nt) {
		return cloneUnlessOtherwiseSpecified(nt, tt);
	});
}
function getMergeFunction(_, et) {
	if (!et.customMerge) return deepmerge;
	var tt = et.customMerge(_);
	return typeof tt == "function" ? tt : deepmerge;
}
function getEnumerableOwnPropertySymbols(_) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(_).filter(function (et) {
				return _.propertyIsEnumerable(et);
		  })
		: [];
}
function getKeys(_) {
	return Object.keys(_).concat(getEnumerableOwnPropertySymbols(_));
}
function propertyIsOnObject(_, et) {
	try {
		return et in _;
	} catch {
		return !1;
	}
}
function propertyIsUnsafe(_, et) {
	return propertyIsOnObject(_, et) && !(Object.hasOwnProperty.call(_, et) && Object.propertyIsEnumerable.call(_, et));
}
function mergeObject(_, et, tt) {
	var nt = {};
	return (
		tt.isMergeableObject(_) &&
			getKeys(_).forEach(function (rt) {
				nt[rt] = cloneUnlessOtherwiseSpecified(_[rt], tt);
			}),
		getKeys(et).forEach(function (rt) {
			propertyIsUnsafe(_, rt) ||
				(propertyIsOnObject(_, rt) && tt.isMergeableObject(et[rt])
					? (nt[rt] = getMergeFunction(rt, tt)(_[rt], et[rt], tt))
					: (nt[rt] = cloneUnlessOtherwiseSpecified(et[rt], tt)));
		}),
		nt
	);
}
function deepmerge(_, et, tt) {
	(tt = tt || {}),
		(tt.arrayMerge = tt.arrayMerge || defaultArrayMerge),
		(tt.isMergeableObject = tt.isMergeableObject || isMergeableObject),
		(tt.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified);
	var nt = Array.isArray(et),
		rt = Array.isArray(_),
		it = nt === rt;
	return it ? (nt ? tt.arrayMerge(_, et, tt) : mergeObject(_, et, tt)) : cloneUnlessOtherwiseSpecified(et, tt);
}
deepmerge.all = function _(et, tt) {
	if (!Array.isArray(et)) throw new Error("first argument should be an array");
	return et.reduce(function (nt, rt) {
		return deepmerge(nt, rt, tt);
	}, {});
};
var deepmerge_1 = deepmerge,
	cjs = deepmerge_1;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var y = function () {
	return (y =
		Object.assign ||
		function (_) {
			for (var et, tt = 1, nt = arguments.length; tt < nt; tt++)
				for (var rt in (et = arguments[tt])) Object.prototype.hasOwnProperty.call(et, rt) && (_[rt] = et[rt]);
			return _;
		}).apply(this, arguments);
};
function k$1(_) {
	return _["data-sourcepos"] ? { "data-sourcepos": _["data-sourcepos"] } : {};
}
var x = {
	p: function (_) {
		var et = _.children;
		return jsx(Text$2, y({ mb: 2 }, { children: et }), void 0);
	},
	em: function (_) {
		var et = _.children;
		return jsx(Text$2, y({ as: "em" }, { children: et }), void 0);
	},
	blockquote: function (_) {
		var et = _.children;
		return jsx(Code, y({ as: "blockquote", p: 2 }, { children: et }), void 0);
	},
	code: function (_) {
		var et = _.inline,
			tt = _.children,
			nt = _.className;
		return jsx(
			Code,
			et
				? { p: 2, children: tt }
				: { className: nt, whiteSpace: "break-spaces", display: "block", w: "full", p: 2, children: tt },
			void 0
		);
	},
	del: function (_) {
		var et = _.children;
		return jsx(Text$2, y({ as: "del" }, { children: et }), void 0);
	},
	hr: function (_) {
		return jsx(Divider, {}, void 0);
	},
	a: Link,
	img: Image2,
	text: function (_) {
		var et = _.children;
		return jsx(Text$2, y({ as: "span" }, { children: et }), void 0);
	},
	ul: function (_) {
		var et = _.ordered,
			tt = _.children,
			nt = _.depth,
			rt = k$1(_),
			it = UnorderedList,
			ot = "disc";
		return (
			et && ((it = OrderedList), (ot = "decimal")),
			nt === 1 && (ot = "circle"),
			jsx(it, y({ spacing: 2, as: et ? "ol" : "ul", styleType: ot, pl: 4 }, rt, { children: tt }), void 0)
		);
	},
	ol: function (_) {
		var et = _.ordered,
			tt = _.children,
			nt = _.depth,
			rt = k$1(_),
			it = UnorderedList,
			ot = "disc";
		return (
			et && ((it = OrderedList), (ot = "decimal")),
			nt === 1 && (ot = "circle"),
			jsx(it, y({ spacing: 2, as: et ? "ol" : "ul", styleType: ot, pl: 4 }, rt, { children: tt }), void 0)
		);
	},
	li: function (_) {
		var et = _.children,
			tt = _.checked,
			nt = null;
		return (
			tt != null && (nt = jsx(Checkbox, y({ isChecked: tt, isReadOnly: !0 }, { children: et }), void 0)),
			jsx(ListItem, y({}, k$1(_), { listStyleType: tt !== null ? "none" : "inherit" }, { children: nt || et }), void 0)
		);
	},
	heading: function (_) {
		var et = _.level,
			tt = _.children;
		return jsx(
			Heading,
			y({ my: 4, as: "h".concat(et), size: ["2xl", "xl", "lg", "md", "sm", "xs"]["".concat(et - 1)] }, k$1(_), {
				children: tt,
			}),
			void 0
		);
	},
	pre: function (_) {
		var et = _.children;
		return jsx(chakra.pre, y({}, k$1(_), { children: et }), void 0);
	},
	table: Table,
	thead: Thead,
	tbody: Tbody,
	tr: function (_) {
		return jsx(Tr, { children: _.children }, void 0);
	},
	td: function (_) {
		return jsx(Td, { children: _.children }, void 0);
	},
	th: function (_) {
		return jsx(Th, { children: _.children }, void 0);
	},
};
function q$1(_, et) {
	et === void 0 && (et = !0);
	var tt = {
		p: x.p,
		em: x.em,
		blockquote: x.blockquote,
		code: x.code,
		del: x.del,
		hr: x.hr,
		a: x.a,
		img: x.img,
		text: x.text,
		ul: x.ul,
		ol: x.ol,
		li: x.li,
		h1: x.heading,
		h2: x.heading,
		h3: x.heading,
		h4: x.heading,
		h5: x.heading,
		h6: x.heading,
		pre: x.pre,
		table: x.table,
		thead: x.thead,
		tbody: x.tbody,
		tr: x.tr,
		td: x.td,
		th: x.th,
	};
	return _ && et ? cjs(tt, _) : tt;
}
const protocols = ["http", "https", "mailto", "tel"];
function uriTransformer(_) {
	const et = (_ || "").trim(),
		tt = et.charAt(0);
	if (tt === "#" || tt === "/") return et;
	const nt = et.indexOf(":");
	if (nt === -1) return et;
	let rt = -1;
	for (; ++rt < protocols.length; ) {
		const it = protocols[rt];
		if (nt === it.length && et.slice(0, it.length).toLowerCase() === it) return et;
	}
	return (
		(rt = et.indexOf("?")),
		(rt !== -1 && nt > rt) || ((rt = et.indexOf("#")), rt !== -1 && nt > rt) ? et : "javascript:void(0)"
	);
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var isBuffer = function _(et) {
	return (
		et != null && et.constructor != null && typeof et.constructor.isBuffer == "function" && et.constructor.isBuffer(et)
	);
};
function stringifyPosition(_) {
	return !_ || typeof _ != "object"
		? ""
		: "position" in _ || "type" in _
		? position(_.position)
		: "start" in _ || "end" in _
		? position(_)
		: "line" in _ || "column" in _
		? point$1(_)
		: "";
}
function point$1(_) {
	return index$1(_ && _.line) + ":" + index$1(_ && _.column);
}
function position(_) {
	return point$1(_ && _.start) + "-" + point$1(_ && _.end);
}
function index$1(_) {
	return _ && typeof _ == "number" ? _ : 1;
}
class VFileMessage extends Error {
	constructor(et, tt, nt) {
		const rt = [null, null];
		let it = { start: { line: null, column: null }, end: { line: null, column: null } };
		if ((super(), typeof tt == "string" && ((nt = tt), (tt = void 0)), typeof nt == "string")) {
			const ot = nt.indexOf(":");
			ot === -1 ? (rt[1] = nt) : ((rt[0] = nt.slice(0, ot)), (rt[1] = nt.slice(ot + 1)));
		}
		tt &&
			("type" in tt || "position" in tt
				? tt.position && (it = tt.position)
				: "start" in tt || "end" in tt
				? (it = tt)
				: ("line" in tt || "column" in tt) && (it.start = tt)),
			(this.name = stringifyPosition(tt) || "1:1"),
			(this.message = typeof et == "object" ? et.message : et),
			(this.stack = typeof et == "object" ? et.stack : ""),
			(this.reason = this.message),
			this.fatal,
			(this.line = it.start.line),
			(this.column = it.start.column),
			(this.source = rt[0]),
			(this.ruleId = rt[1]),
			(this.position = it),
			this.actual,
			this.expected,
			this.file,
			this.url,
			this.note;
	}
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;
const path = { basename, dirname, extname, join, sep: "/" };
function basename(_, et) {
	if (et !== void 0 && typeof et != "string") throw new TypeError('"ext" argument must be a string');
	assertPath$1(_);
	let tt = 0,
		nt = -1,
		rt = _.length,
		it;
	if (et === void 0 || et.length === 0 || et.length > _.length) {
		for (; rt--; )
			if (_.charCodeAt(rt) === 47) {
				if (it) {
					tt = rt + 1;
					break;
				}
			} else nt < 0 && ((it = !0), (nt = rt + 1));
		return nt < 0 ? "" : _.slice(tt, nt);
	}
	if (et === _) return "";
	let ot = -1,
		at = et.length - 1;
	for (; rt--; )
		if (_.charCodeAt(rt) === 47) {
			if (it) {
				tt = rt + 1;
				break;
			}
		} else
			ot < 0 && ((it = !0), (ot = rt + 1)),
				at > -1 && (_.charCodeAt(rt) === et.charCodeAt(at--) ? at < 0 && (nt = rt) : ((at = -1), (nt = ot)));
	return tt === nt ? (nt = ot) : nt < 0 && (nt = _.length), _.slice(tt, nt);
}
function dirname(_) {
	if ((assertPath$1(_), _.length === 0)) return ".";
	let et = -1,
		tt = _.length,
		nt;
	for (; --tt; )
		if (_.charCodeAt(tt) === 47) {
			if (nt) {
				et = tt;
				break;
			}
		} else nt || (nt = !0);
	return et < 0 ? (_.charCodeAt(0) === 47 ? "/" : ".") : et === 1 && _.charCodeAt(0) === 47 ? "//" : _.slice(0, et);
}
function extname(_) {
	assertPath$1(_);
	let et = _.length,
		tt = -1,
		nt = 0,
		rt = -1,
		it = 0,
		ot;
	for (; et--; ) {
		const at = _.charCodeAt(et);
		if (at === 47) {
			if (ot) {
				nt = et + 1;
				break;
			}
			continue;
		}
		tt < 0 && ((ot = !0), (tt = et + 1)),
			at === 46 ? (rt < 0 ? (rt = et) : it !== 1 && (it = 1)) : rt > -1 && (it = -1);
	}
	return rt < 0 || tt < 0 || it === 0 || (it === 1 && rt === tt - 1 && rt === nt + 1) ? "" : _.slice(rt, tt);
}
function join(..._) {
	let et = -1,
		tt;
	for (; ++et < _.length; ) assertPath$1(_[et]), _[et] && (tt = tt === void 0 ? _[et] : tt + "/" + _[et]);
	return tt === void 0 ? "." : normalize$1(tt);
}
function normalize$1(_) {
	assertPath$1(_);
	const et = _.charCodeAt(0) === 47;
	let tt = normalizeString(_, !et);
	return (
		tt.length === 0 && !et && (tt = "."),
		tt.length > 0 && _.charCodeAt(_.length - 1) === 47 && (tt += "/"),
		et ? "/" + tt : tt
	);
}
function normalizeString(_, et) {
	let tt = "",
		nt = 0,
		rt = -1,
		it = 0,
		ot = -1,
		at,
		st;
	for (; ++ot <= _.length; ) {
		if (ot < _.length) at = _.charCodeAt(ot);
		else {
			if (at === 47) break;
			at = 47;
		}
		if (at === 47) {
			if (!(rt === ot - 1 || it === 1))
				if (rt !== ot - 1 && it === 2) {
					if (tt.length < 2 || nt !== 2 || tt.charCodeAt(tt.length - 1) !== 46 || tt.charCodeAt(tt.length - 2) !== 46) {
						if (tt.length > 2) {
							if (((st = tt.lastIndexOf("/")), st !== tt.length - 1)) {
								st < 0 ? ((tt = ""), (nt = 0)) : ((tt = tt.slice(0, st)), (nt = tt.length - 1 - tt.lastIndexOf("/"))),
									(rt = ot),
									(it = 0);
								continue;
							}
						} else if (tt.length > 0) {
							(tt = ""), (nt = 0), (rt = ot), (it = 0);
							continue;
						}
					}
					et && ((tt = tt.length > 0 ? tt + "/.." : ".."), (nt = 2));
				} else tt.length > 0 ? (tt += "/" + _.slice(rt + 1, ot)) : (tt = _.slice(rt + 1, ot)), (nt = ot - rt - 1);
			(rt = ot), (it = 0);
		} else at === 46 && it > -1 ? it++ : (it = -1);
	}
	return tt;
}
function assertPath$1(_) {
	if (typeof _ != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(_));
}
const proc = { cwd };
function cwd() {
	return "/";
}
function isUrl(_) {
	return _ !== null && typeof _ == "object" && _.href && _.origin;
}
function urlToPath(_) {
	if (typeof _ == "string") _ = new URL(_);
	else if (!isUrl(_)) {
		const et = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + _ + "`");
		throw ((et.code = "ERR_INVALID_ARG_TYPE"), et);
	}
	if (_.protocol !== "file:") {
		const et = new TypeError("The URL must be of scheme file");
		throw ((et.code = "ERR_INVALID_URL_SCHEME"), et);
	}
	return getPathFromURLPosix(_);
}
function getPathFromURLPosix(_) {
	if (_.hostname !== "") {
		const nt = new TypeError('File URL host must be "localhost" or empty on darwin');
		throw ((nt.code = "ERR_INVALID_FILE_URL_HOST"), nt);
	}
	const et = _.pathname;
	let tt = -1;
	for (; ++tt < et.length; )
		if (et.charCodeAt(tt) === 37 && et.charCodeAt(tt + 1) === 50) {
			const nt = et.charCodeAt(tt + 2);
			if (nt === 70 || nt === 102) {
				const rt = new TypeError("File URL path must not include encoded / characters");
				throw ((rt.code = "ERR_INVALID_FILE_URL_PATH"), rt);
			}
		}
	return decodeURIComponent(et);
}
const order = ["history", "path", "basename", "stem", "extname", "dirname"];
class VFile {
	constructor(et) {
		let tt;
		et
			? typeof et == "string" || isBuffer(et)
				? (tt = { value: et })
				: isUrl(et)
				? (tt = { path: et })
				: (tt = et)
			: (tt = {}),
			(this.data = {}),
			(this.messages = []),
			(this.history = []),
			(this.cwd = proc.cwd()),
			this.value,
			this.stored,
			this.result,
			this.map;
		let nt = -1;
		for (; ++nt < order.length; ) {
			const it = order[nt];
			it in tt && tt[it] !== void 0 && (this[it] = it === "history" ? [...tt[it]] : tt[it]);
		}
		let rt;
		for (rt in tt) order.includes(rt) || (this[rt] = tt[rt]);
	}
	get path() {
		return this.history[this.history.length - 1];
	}
	set path(et) {
		isUrl(et) && (et = urlToPath(et)), assertNonEmpty(et, "path"), this.path !== et && this.history.push(et);
	}
	get dirname() {
		return typeof this.path == "string" ? path.dirname(this.path) : void 0;
	}
	set dirname(et) {
		assertPath(this.basename, "dirname"), (this.path = path.join(et || "", this.basename));
	}
	get basename() {
		return typeof this.path == "string" ? path.basename(this.path) : void 0;
	}
	set basename(et) {
		assertNonEmpty(et, "basename"), assertPart(et, "basename"), (this.path = path.join(this.dirname || "", et));
	}
	get extname() {
		return typeof this.path == "string" ? path.extname(this.path) : void 0;
	}
	set extname(et) {
		if ((assertPart(et, "extname"), assertPath(this.dirname, "extname"), et)) {
			if (et.charCodeAt(0) !== 46) throw new Error("`extname` must start with `.`");
			if (et.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots");
		}
		this.path = path.join(this.dirname, this.stem + (et || ""));
	}
	get stem() {
		return typeof this.path == "string" ? path.basename(this.path, this.extname) : void 0;
	}
	set stem(et) {
		assertNonEmpty(et, "stem"),
			assertPart(et, "stem"),
			(this.path = path.join(this.dirname || "", et + (this.extname || "")));
	}
	toString(et) {
		return (this.value || "").toString(et);
	}
	message(et, tt, nt) {
		const rt = new VFileMessage(et, tt, nt);
		return (
			this.path && ((rt.name = this.path + ":" + rt.name), (rt.file = this.path)),
			(rt.fatal = !1),
			this.messages.push(rt),
			rt
		);
	}
	info(et, tt, nt) {
		const rt = this.message(et, tt, nt);
		return (rt.fatal = null), rt;
	}
	fail(et, tt, nt) {
		const rt = this.message(et, tt, nt);
		throw ((rt.fatal = !0), rt);
	}
}
function assertPart(_, et) {
	if (_ && _.includes(path.sep)) throw new Error("`" + et + "` cannot be a path: did not expect `" + path.sep + "`");
}
function assertNonEmpty(_, et) {
	if (!_) throw new Error("`" + et + "` cannot be empty");
}
function assertPath(_, et) {
	if (!_) throw new Error("Setting `" + et + "` requires `path` to be set too");
}
function bail(_) {
	if (_) throw _;
}
var hasOwn = Object.prototype.hasOwnProperty,
	toStr = Object.prototype.toString,
	defineProperty = Object.defineProperty,
	gOPD = Object.getOwnPropertyDescriptor,
	isArray = function _(et) {
		return typeof Array.isArray == "function" ? Array.isArray(et) : toStr.call(et) === "[object Array]";
	},
	isPlainObject$1 = function _(et) {
		if (!et || toStr.call(et) !== "[object Object]") return !1;
		var tt = hasOwn.call(et, "constructor"),
			nt = et.constructor && et.constructor.prototype && hasOwn.call(et.constructor.prototype, "isPrototypeOf");
		if (et.constructor && !tt && !nt) return !1;
		var rt;
		for (rt in et);
		return typeof rt > "u" || hasOwn.call(et, rt);
	},
	setProperty = function _(et, tt) {
		defineProperty && tt.name === "__proto__"
			? defineProperty(et, tt.name, { enumerable: !0, configurable: !0, value: tt.newValue, writable: !0 })
			: (et[tt.name] = tt.newValue);
	},
	getProperty = function _(et, tt) {
		if (tt === "__proto__")
			if (hasOwn.call(et, tt)) {
				if (gOPD) return gOPD(et, tt).value;
			} else return;
		return et[tt];
	},
	extend = function _() {
		var et,
			tt,
			nt,
			rt,
			it,
			ot,
			at = arguments[0],
			st = 1,
			lt = arguments.length,
			ut = !1;
		for (
			typeof at == "boolean" && ((ut = at), (at = arguments[1] || {}), (st = 2)),
				(at == null || (typeof at != "object" && typeof at != "function")) && (at = {});
			st < lt;
			++st
		)
			if (((et = arguments[st]), et != null))
				for (tt in et)
					(nt = getProperty(at, tt)),
						(rt = getProperty(et, tt)),
						at !== rt &&
							(ut && rt && (isPlainObject$1(rt) || (it = isArray(rt)))
								? (it ? ((it = !1), (ot = nt && isArray(nt) ? nt : [])) : (ot = nt && isPlainObject$1(nt) ? nt : {}),
								  setProperty(at, { name: tt, newValue: _(ut, ot, rt) }))
								: typeof rt < "u" && setProperty(at, { name: tt, newValue: rt }));
		return at;
	};
function isPlainObject(_) {
	if (typeof _ != "object" || _ === null) return !1;
	const et = Object.getPrototypeOf(_);
	return (
		(et === null || et === Object.prototype || Object.getPrototypeOf(et) === null) &&
		!(Symbol.toStringTag in _) &&
		!(Symbol.iterator in _)
	);
}
function trough() {
	const _ = [],
		et = { run: tt, use: nt };
	return et;
	function tt(...rt) {
		let it = -1;
		const ot = rt.pop();
		if (typeof ot != "function") throw new TypeError("Expected function as last argument, not " + ot);
		at(null, ...rt);
		function at(st, ...lt) {
			const ut = _[++it];
			let dt = -1;
			if (st) {
				ot(st);
				return;
			}
			for (; ++dt < rt.length; ) (lt[dt] === null || lt[dt] === void 0) && (lt[dt] = rt[dt]);
			(rt = lt), ut ? wrap$1(ut, at)(...lt) : ot(null, ...lt);
		}
	}
	function nt(rt) {
		if (typeof rt != "function") throw new TypeError("Expected `middelware` to be a function, not " + rt);
		return _.push(rt), et;
	}
}
function wrap$1(_, et) {
	let tt;
	return nt;
	function nt(...ot) {
		const at = _.length > ot.length;
		let st;
		at && ot.push(rt);
		try {
			st = _.apply(this, ot);
		} catch (lt) {
			const ut = lt;
			if (at && tt) throw ut;
			return rt(ut);
		}
		at || (st instanceof Promise ? st.then(it, rt) : st instanceof Error ? rt(st) : it(st));
	}
	function rt(ot, ...at) {
		tt || ((tt = !0), et(ot, ...at));
	}
	function it(ot) {
		rt(null, ot);
	}
}
const unified = base().freeze(),
	own$7 = {}.hasOwnProperty;
function base() {
	const _ = trough(),
		et = [];
	let tt = {},
		nt,
		rt = -1;
	return (
		(it.data = ot),
		(it.Parser = void 0),
		(it.Compiler = void 0),
		(it.freeze = at),
		(it.attachers = et),
		(it.use = st),
		(it.parse = lt),
		(it.stringify = ut),
		(it.run = dt),
		(it.runSync = ct),
		(it.process = ft),
		(it.processSync = mt),
		it
	);
	function it() {
		const pt = base();
		let vt = -1;
		for (; ++vt < et.length; ) pt.use(...et[vt]);
		return pt.data(extend(!0, {}, tt)), pt;
	}
	function ot(pt, vt) {
		return typeof pt == "string"
			? arguments.length === 2
				? (assertUnfrozen("data", nt), (tt[pt] = vt), it)
				: (own$7.call(tt, pt) && tt[pt]) || null
			: pt
			? (assertUnfrozen("data", nt), (tt = pt), it)
			: tt;
	}
	function at() {
		if (nt) return it;
		for (; ++rt < et.length; ) {
			const [pt, ...vt] = et[rt];
			if (vt[0] === !1) continue;
			vt[0] === !0 && (vt[0] = void 0);
			const ht = pt.call(it, ...vt);
			typeof ht == "function" && _.use(ht);
		}
		return (nt = !0), (rt = Number.POSITIVE_INFINITY), it;
	}
	function st(pt, ...vt) {
		let ht;
		if ((assertUnfrozen("use", nt), pt != null))
			if (typeof pt == "function") St(pt, ...vt);
			else if (typeof pt == "object") Array.isArray(pt) ? xt(pt) : yt(pt);
			else throw new TypeError("Expected usable value, not `" + pt + "`");
		return ht && (tt.settings = Object.assign(tt.settings || {}, ht)), it;
		function gt(wt) {
			if (typeof wt == "function") St(wt);
			else if (typeof wt == "object")
				if (Array.isArray(wt)) {
					const [Ct, ...Et] = wt;
					St(Ct, ...Et);
				} else yt(wt);
			else throw new TypeError("Expected usable value, not `" + wt + "`");
		}
		function yt(wt) {
			xt(wt.plugins), wt.settings && (ht = Object.assign(ht || {}, wt.settings));
		}
		function xt(wt) {
			let Ct = -1;
			if (wt != null)
				if (Array.isArray(wt))
					for (; ++Ct < wt.length; ) {
						const Et = wt[Ct];
						gt(Et);
					}
				else throw new TypeError("Expected a list of plugins, not `" + wt + "`");
		}
		function St(wt, Ct) {
			let Et = -1,
				_t;
			for (; ++Et < et.length; )
				if (et[Et][0] === wt) {
					_t = et[Et];
					break;
				}
			_t
				? (isPlainObject(_t[1]) && isPlainObject(Ct) && (Ct = extend(!0, _t[1], Ct)), (_t[1] = Ct))
				: et.push([...arguments]);
		}
	}
	function lt(pt) {
		it.freeze();
		const vt = vfile(pt),
			ht = it.Parser;
		return assertParser("parse", ht), newable(ht, "parse") ? new ht(String(vt), vt).parse() : ht(String(vt), vt);
	}
	function ut(pt, vt) {
		it.freeze();
		const ht = vfile(vt),
			gt = it.Compiler;
		return (
			assertCompiler("stringify", gt), assertNode(pt), newable(gt, "compile") ? new gt(pt, ht).compile() : gt(pt, ht)
		);
	}
	function dt(pt, vt, ht) {
		if ((assertNode(pt), it.freeze(), !ht && typeof vt == "function" && ((ht = vt), (vt = void 0)), !ht))
			return new Promise(gt);
		gt(null, ht);
		function gt(yt, xt) {
			_.run(pt, vfile(vt), St);
			function St(wt, Ct, Et) {
				(Ct = Ct || pt), wt ? xt(wt) : yt ? yt(Ct) : ht(null, Ct, Et);
			}
		}
	}
	function ct(pt, vt) {
		let ht, gt;
		return it.run(pt, vt, yt), assertDone("runSync", "run", gt), ht;
		function yt(xt, St) {
			bail(xt), (ht = St), (gt = !0);
		}
	}
	function ft(pt, vt) {
		if ((it.freeze(), assertParser("process", it.Parser), assertCompiler("process", it.Compiler), !vt))
			return new Promise(ht);
		ht(null, vt);
		function ht(gt, yt) {
			const xt = vfile(pt);
			it.run(it.parse(xt), xt, (wt, Ct, Et) => {
				if (wt || !Ct || !Et) St(wt);
				else {
					const _t = it.stringify(Ct, Et);
					_t == null || (looksLikeAVFileValue(_t) ? (Et.value = _t) : (Et.result = _t)), St(wt, Et);
				}
			});
			function St(wt, Ct) {
				wt || !Ct ? yt(wt) : gt ? gt(Ct) : vt(null, Ct);
			}
		}
	}
	function mt(pt) {
		let vt;
		it.freeze(), assertParser("processSync", it.Parser), assertCompiler("processSync", it.Compiler);
		const ht = vfile(pt);
		return it.process(ht, gt), assertDone("processSync", "process", vt), ht;
		function gt(yt) {
			(vt = !0), bail(yt);
		}
	}
}
function newable(_, et) {
	return typeof _ == "function" && _.prototype && (keys(_.prototype) || et in _.prototype);
}
function keys(_) {
	let et;
	for (et in _) if (own$7.call(_, et)) return !0;
	return !1;
}
function assertParser(_, et) {
	if (typeof et != "function") throw new TypeError("Cannot `" + _ + "` without `Parser`");
}
function assertCompiler(_, et) {
	if (typeof et != "function") throw new TypeError("Cannot `" + _ + "` without `Compiler`");
}
function assertUnfrozen(_, et) {
	if (et)
		throw new Error(
			"Cannot call `" +
				_ +
				"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
		);
}
function assertNode(_) {
	if (!isPlainObject(_) || typeof _.type != "string") throw new TypeError("Expected node, got `" + _ + "`");
}
function assertDone(_, et, tt) {
	if (!tt) throw new Error("`" + _ + "` finished async. Use `" + et + "` instead");
}
function vfile(_) {
	return looksLikeAVFile(_) ? _ : new VFile(_);
}
function looksLikeAVFile(_) {
	return Boolean(_ && typeof _ == "object" && "message" in _ && "messages" in _);
}
function looksLikeAVFileValue(_) {
	return typeof _ == "string" || isBuffer(_);
}
function toString(_, et) {
	var { includeImageAlt: tt = !0 } = et || {};
	return one$1(_, tt);
}
function one$1(_, et) {
	return (
		(_ &&
			typeof _ == "object" &&
			(_.value ||
				(et ? _.alt : "") ||
				("children" in _ && all$1(_.children, et)) ||
				(Array.isArray(_) && all$1(_, et)))) ||
		""
	);
}
function all$1(_, et) {
	for (var tt = [], nt = -1; ++nt < _.length; ) tt[nt] = one$1(_[nt], et);
	return tt.join("");
}
function splice(_, et, tt, nt) {
	const rt = _.length;
	let it = 0,
		ot;
	if ((et < 0 ? (et = -et > rt ? 0 : rt + et) : (et = et > rt ? rt : et), (tt = tt > 0 ? tt : 0), nt.length < 1e4))
		(ot = Array.from(nt)), ot.unshift(et, tt), [].splice.apply(_, ot);
	else
		for (tt && [].splice.apply(_, [et, tt]); it < nt.length; )
			(ot = nt.slice(it, it + 1e4)), ot.unshift(et, 0), [].splice.apply(_, ot), (it += 1e4), (et += 1e4);
}
function push(_, et) {
	return _.length > 0 ? (splice(_, _.length, 0, et), _) : et;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(_) {
	const et = {};
	let tt = -1;
	for (; ++tt < _.length; ) syntaxExtension(et, _[tt]);
	return et;
}
function syntaxExtension(_, et) {
	let tt;
	for (tt in et) {
		const rt = (hasOwnProperty.call(_, tt) ? _[tt] : void 0) || (_[tt] = {}),
			it = et[tt];
		let ot;
		for (ot in it) {
			hasOwnProperty.call(rt, ot) || (rt[ot] = []);
			const at = it[ot];
			constructs(rt[ot], Array.isArray(at) ? at : at ? [at] : []);
		}
	}
}
function constructs(_, et) {
	let tt = -1;
	const nt = [];
	for (; ++tt < et.length; ) (et[tt].add === "after" ? _ : nt).push(et[tt]);
	splice(_, 0, 0, nt);
}
const unicodePunctuationRegex =
		/[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/,
	asciiAlpha = regexCheck(/[A-Za-z]/),
	asciiDigit = regexCheck(/\d/),
	asciiHexDigit = regexCheck(/[\dA-Fa-f]/),
	asciiAlphanumeric = regexCheck(/[\dA-Za-z]/),
	asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/),
	asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(_) {
	return _ !== null && (_ < 32 || _ === 127);
}
function markdownLineEndingOrSpace(_) {
	return _ !== null && (_ < 0 || _ === 32);
}
function markdownLineEnding(_) {
	return _ !== null && _ < -2;
}
function markdownSpace(_) {
	return _ === -2 || _ === -1 || _ === 32;
}
const unicodeWhitespace = regexCheck(/\s/),
	unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(_) {
	return et;
	function et(tt) {
		return tt !== null && _.test(String.fromCharCode(tt));
	}
}
function factorySpace(_, et, tt, nt) {
	const rt = nt ? nt - 1 : Number.POSITIVE_INFINITY;
	let it = 0;
	return ot;
	function ot(st) {
		return markdownSpace(st) ? (_.enter(tt), at(st)) : et(st);
	}
	function at(st) {
		return markdownSpace(st) && it++ < rt ? (_.consume(st), at) : (_.exit(tt), et(st));
	}
}
const content$1 = { tokenize: initializeContent };
function initializeContent(_) {
	const et = _.attempt(this.parser.constructs.contentInitial, nt, rt);
	let tt;
	return et;
	function nt(at) {
		if (at === null) {
			_.consume(at);
			return;
		}
		return _.enter("lineEnding"), _.consume(at), _.exit("lineEnding"), factorySpace(_, et, "linePrefix");
	}
	function rt(at) {
		return _.enter("paragraph"), it(at);
	}
	function it(at) {
		const st = _.enter("chunkText", { contentType: "text", previous: tt });
		return tt && (tt.next = st), (tt = st), ot(at);
	}
	function ot(at) {
		if (at === null) {
			_.exit("chunkText"), _.exit("paragraph"), _.consume(at);
			return;
		}
		return markdownLineEnding(at) ? (_.consume(at), _.exit("chunkText"), it) : (_.consume(at), ot);
	}
}
const document$2 = { tokenize: initializeDocument },
	containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(_) {
	const et = this,
		tt = [];
	let nt = 0,
		rt,
		it,
		ot;
	return at;
	function at(yt) {
		if (nt < tt.length) {
			const xt = tt[nt];
			return (et.containerState = xt[1]), _.attempt(xt[0].continuation, st, lt)(yt);
		}
		return lt(yt);
	}
	function st(yt) {
		if ((nt++, et.containerState._closeFlow)) {
			(et.containerState._closeFlow = void 0), rt && gt();
			const xt = et.events.length;
			let St = xt,
				wt;
			for (; St--; )
				if (et.events[St][0] === "exit" && et.events[St][1].type === "chunkFlow") {
					wt = et.events[St][1].end;
					break;
				}
			ht(nt);
			let Ct = xt;
			for (; Ct < et.events.length; ) (et.events[Ct][1].end = Object.assign({}, wt)), Ct++;
			return splice(et.events, St + 1, 0, et.events.slice(xt)), (et.events.length = Ct), lt(yt);
		}
		return at(yt);
	}
	function lt(yt) {
		if (nt === tt.length) {
			if (!rt) return ct(yt);
			if (rt.currentConstruct && rt.currentConstruct.concrete) return mt(yt);
			et.interrupt = Boolean(rt.currentConstruct && !rt._gfmTableDynamicInterruptHack);
		}
		return (et.containerState = {}), _.check(containerConstruct, ut, dt)(yt);
	}
	function ut(yt) {
		return rt && gt(), ht(nt), ct(yt);
	}
	function dt(yt) {
		return (et.parser.lazy[et.now().line] = nt !== tt.length), (ot = et.now().offset), mt(yt);
	}
	function ct(yt) {
		return (et.containerState = {}), _.attempt(containerConstruct, ft, mt)(yt);
	}
	function ft(yt) {
		return nt++, tt.push([et.currentConstruct, et.containerState]), ct(yt);
	}
	function mt(yt) {
		if (yt === null) {
			rt && gt(), ht(0), _.consume(yt);
			return;
		}
		return (
			(rt = rt || et.parser.flow(et.now())),
			_.enter("chunkFlow", { contentType: "flow", previous: it, _tokenizer: rt }),
			pt(yt)
		);
	}
	function pt(yt) {
		if (yt === null) {
			vt(_.exit("chunkFlow"), !0), ht(0), _.consume(yt);
			return;
		}
		return markdownLineEnding(yt)
			? (_.consume(yt), vt(_.exit("chunkFlow")), (nt = 0), (et.interrupt = void 0), at)
			: (_.consume(yt), pt);
	}
	function vt(yt, xt) {
		const St = et.sliceStream(yt);
		if (
			(xt && St.push(null),
			(yt.previous = it),
			it && (it.next = yt),
			(it = yt),
			rt.defineSkip(yt.start),
			rt.write(St),
			et.parser.lazy[yt.start.line])
		) {
			let wt = rt.events.length;
			for (; wt--; )
				if (rt.events[wt][1].start.offset < ot && (!rt.events[wt][1].end || rt.events[wt][1].end.offset > ot)) return;
			const Ct = et.events.length;
			let Et = Ct,
				_t,
				$t;
			for (; Et--; )
				if (et.events[Et][0] === "exit" && et.events[Et][1].type === "chunkFlow") {
					if (_t) {
						$t = et.events[Et][1].end;
						break;
					}
					_t = !0;
				}
			for (ht(nt), wt = Ct; wt < et.events.length; ) (et.events[wt][1].end = Object.assign({}, $t)), wt++;
			splice(et.events, Et + 1, 0, et.events.slice(Ct)), (et.events.length = wt);
		}
	}
	function ht(yt) {
		let xt = tt.length;
		for (; xt-- > yt; ) {
			const St = tt[xt];
			(et.containerState = St[1]), St[0].exit.call(et, _);
		}
		tt.length = yt;
	}
	function gt() {
		rt.write([null]), (it = void 0), (rt = void 0), (et.containerState._closeFlow = void 0);
	}
}
function tokenizeContainer(_, et, tt) {
	return factorySpace(
		_,
		_.attempt(this.parser.constructs.document, et, tt),
		"linePrefix",
		this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
	);
}
function classifyCharacter(_) {
	if (_ === null || markdownLineEndingOrSpace(_) || unicodeWhitespace(_)) return 1;
	if (unicodePunctuation(_)) return 2;
}
function resolveAll(_, et, tt) {
	const nt = [];
	let rt = -1;
	for (; ++rt < _.length; ) {
		const it = _[rt].resolveAll;
		it && !nt.includes(it) && ((et = it(et, tt)), nt.push(it));
	}
	return et;
}
const attention = { name: "attention", tokenize: tokenizeAttention, resolveAll: resolveAllAttention };
function resolveAllAttention(_, et) {
	let tt = -1,
		nt,
		rt,
		it,
		ot,
		at,
		st,
		lt,
		ut;
	for (; ++tt < _.length; )
		if (_[tt][0] === "enter" && _[tt][1].type === "attentionSequence" && _[tt][1]._close) {
			for (nt = tt; nt--; )
				if (
					_[nt][0] === "exit" &&
					_[nt][1].type === "attentionSequence" &&
					_[nt][1]._open &&
					et.sliceSerialize(_[nt][1]).charCodeAt(0) === et.sliceSerialize(_[tt][1]).charCodeAt(0)
				) {
					if (
						(_[nt][1]._close || _[tt][1]._open) &&
						(_[tt][1].end.offset - _[tt][1].start.offset) % 3 &&
						!((_[nt][1].end.offset - _[nt][1].start.offset + _[tt][1].end.offset - _[tt][1].start.offset) % 3)
					)
						continue;
					st =
						_[nt][1].end.offset - _[nt][1].start.offset > 1 && _[tt][1].end.offset - _[tt][1].start.offset > 1 ? 2 : 1;
					const dt = Object.assign({}, _[nt][1].end),
						ct = Object.assign({}, _[tt][1].start);
					movePoint(dt, -st),
						movePoint(ct, st),
						(ot = {
							type: st > 1 ? "strongSequence" : "emphasisSequence",
							start: dt,
							end: Object.assign({}, _[nt][1].end),
						}),
						(at = {
							type: st > 1 ? "strongSequence" : "emphasisSequence",
							start: Object.assign({}, _[tt][1].start),
							end: ct,
						}),
						(it = {
							type: st > 1 ? "strongText" : "emphasisText",
							start: Object.assign({}, _[nt][1].end),
							end: Object.assign({}, _[tt][1].start),
						}),
						(rt = {
							type: st > 1 ? "strong" : "emphasis",
							start: Object.assign({}, ot.start),
							end: Object.assign({}, at.end),
						}),
						(_[nt][1].end = Object.assign({}, ot.start)),
						(_[tt][1].start = Object.assign({}, at.end)),
						(lt = []),
						_[nt][1].end.offset - _[nt][1].start.offset &&
							(lt = push(lt, [
								["enter", _[nt][1], et],
								["exit", _[nt][1], et],
							])),
						(lt = push(lt, [
							["enter", rt, et],
							["enter", ot, et],
							["exit", ot, et],
							["enter", it, et],
						])),
						(lt = push(lt, resolveAll(et.parser.constructs.insideSpan.null, _.slice(nt + 1, tt), et))),
						(lt = push(lt, [
							["exit", it, et],
							["enter", at, et],
							["exit", at, et],
							["exit", rt, et],
						])),
						_[tt][1].end.offset - _[tt][1].start.offset
							? ((ut = 2),
							  (lt = push(lt, [
									["enter", _[tt][1], et],
									["exit", _[tt][1], et],
							  ])))
							: (ut = 0),
						splice(_, nt - 1, tt - nt + 3, lt),
						(tt = nt + lt.length - ut - 2);
					break;
				}
		}
	for (tt = -1; ++tt < _.length; ) _[tt][1].type === "attentionSequence" && (_[tt][1].type = "data");
	return _;
}
function tokenizeAttention(_, et) {
	const tt = this.parser.constructs.attentionMarkers.null,
		nt = this.previous,
		rt = classifyCharacter(nt);
	let it;
	return ot;
	function ot(st) {
		return _.enter("attentionSequence"), (it = st), at(st);
	}
	function at(st) {
		if (st === it) return _.consume(st), at;
		const lt = _.exit("attentionSequence"),
			ut = classifyCharacter(st),
			dt = !ut || (ut === 2 && rt) || tt.includes(st),
			ct = !rt || (rt === 2 && ut) || tt.includes(nt);
		return (
			(lt._open = Boolean(it === 42 ? dt : dt && (rt || !ct))),
			(lt._close = Boolean(it === 42 ? ct : ct && (ut || !dt))),
			et(st)
		);
	}
}
function movePoint(_, et) {
	(_.column += et), (_.offset += et), (_._bufferIndex += et);
}
const autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(_, et, tt) {
	let nt = 1;
	return rt;
	function rt(mt) {
		return (
			_.enter("autolink"),
			_.enter("autolinkMarker"),
			_.consume(mt),
			_.exit("autolinkMarker"),
			_.enter("autolinkProtocol"),
			it
		);
	}
	function it(mt) {
		return asciiAlpha(mt) ? (_.consume(mt), ot) : asciiAtext(mt) ? lt(mt) : tt(mt);
	}
	function ot(mt) {
		return mt === 43 || mt === 45 || mt === 46 || asciiAlphanumeric(mt) ? at(mt) : lt(mt);
	}
	function at(mt) {
		return mt === 58
			? (_.consume(mt), st)
			: (mt === 43 || mt === 45 || mt === 46 || asciiAlphanumeric(mt)) && nt++ < 32
			? (_.consume(mt), at)
			: lt(mt);
	}
	function st(mt) {
		return mt === 62
			? (_.exit("autolinkProtocol"), ft(mt))
			: mt === null || mt === 32 || mt === 60 || asciiControl(mt)
			? tt(mt)
			: (_.consume(mt), st);
	}
	function lt(mt) {
		return mt === 64 ? (_.consume(mt), (nt = 0), ut) : asciiAtext(mt) ? (_.consume(mt), lt) : tt(mt);
	}
	function ut(mt) {
		return asciiAlphanumeric(mt) ? dt(mt) : tt(mt);
	}
	function dt(mt) {
		return mt === 46
			? (_.consume(mt), (nt = 0), ut)
			: mt === 62
			? ((_.exit("autolinkProtocol").type = "autolinkEmail"), ft(mt))
			: ct(mt);
	}
	function ct(mt) {
		return (mt === 45 || asciiAlphanumeric(mt)) && nt++ < 63 ? (_.consume(mt), mt === 45 ? ct : dt) : tt(mt);
	}
	function ft(mt) {
		return _.enter("autolinkMarker"), _.consume(mt), _.exit("autolinkMarker"), _.exit("autolink"), et;
	}
}
const blankLine = { tokenize: tokenizeBlankLine, partial: !0 };
function tokenizeBlankLine(_, et, tt) {
	return factorySpace(_, nt, "linePrefix");
	function nt(rt) {
		return rt === null || markdownLineEnding(rt) ? et(rt) : tt(rt);
	}
}
const blockQuote = {
	name: "blockQuote",
	tokenize: tokenizeBlockQuoteStart,
	continuation: { tokenize: tokenizeBlockQuoteContinuation },
	exit,
};
function tokenizeBlockQuoteStart(_, et, tt) {
	const nt = this;
	return rt;
	function rt(ot) {
		if (ot === 62) {
			const at = nt.containerState;
			return (
				at.open || (_.enter("blockQuote", { _container: !0 }), (at.open = !0)),
				_.enter("blockQuotePrefix"),
				_.enter("blockQuoteMarker"),
				_.consume(ot),
				_.exit("blockQuoteMarker"),
				it
			);
		}
		return tt(ot);
	}
	function it(ot) {
		return markdownSpace(ot)
			? (_.enter("blockQuotePrefixWhitespace"),
			  _.consume(ot),
			  _.exit("blockQuotePrefixWhitespace"),
			  _.exit("blockQuotePrefix"),
			  et)
			: (_.exit("blockQuotePrefix"), et(ot));
	}
}
function tokenizeBlockQuoteContinuation(_, et, tt) {
	return factorySpace(
		_,
		_.attempt(blockQuote, et, tt),
		"linePrefix",
		this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
	);
}
function exit(_) {
	_.exit("blockQuote");
}
const characterEscape = { name: "characterEscape", tokenize: tokenizeCharacterEscape };
function tokenizeCharacterEscape(_, et, tt) {
	return nt;
	function nt(it) {
		return _.enter("characterEscape"), _.enter("escapeMarker"), _.consume(it), _.exit("escapeMarker"), rt;
	}
	function rt(it) {
		return asciiPunctuation(it)
			? (_.enter("characterEscapeValue"), _.consume(it), _.exit("characterEscapeValue"), _.exit("characterEscape"), et)
			: tt(it);
	}
}
const element = document.createElement("i");
function decodeNamedCharacterReference(_) {
	const et = "&" + _ + ";";
	element.innerHTML = et;
	const tt = element.textContent;
	return (tt.charCodeAt(tt.length - 1) === 59 && _ !== "semi") || tt === et ? !1 : tt;
}
const characterReference = { name: "characterReference", tokenize: tokenizeCharacterReference };
function tokenizeCharacterReference(_, et, tt) {
	const nt = this;
	let rt = 0,
		it,
		ot;
	return at;
	function at(dt) {
		return (
			_.enter("characterReference"),
			_.enter("characterReferenceMarker"),
			_.consume(dt),
			_.exit("characterReferenceMarker"),
			st
		);
	}
	function st(dt) {
		return dt === 35
			? (_.enter("characterReferenceMarkerNumeric"), _.consume(dt), _.exit("characterReferenceMarkerNumeric"), lt)
			: (_.enter("characterReferenceValue"), (it = 31), (ot = asciiAlphanumeric), ut(dt));
	}
	function lt(dt) {
		return dt === 88 || dt === 120
			? (_.enter("characterReferenceMarkerHexadecimal"),
			  _.consume(dt),
			  _.exit("characterReferenceMarkerHexadecimal"),
			  _.enter("characterReferenceValue"),
			  (it = 6),
			  (ot = asciiHexDigit),
			  ut)
			: (_.enter("characterReferenceValue"), (it = 7), (ot = asciiDigit), ut(dt));
	}
	function ut(dt) {
		let ct;
		return dt === 59 && rt
			? ((ct = _.exit("characterReferenceValue")),
			  ot === asciiAlphanumeric && !decodeNamedCharacterReference(nt.sliceSerialize(ct))
					? tt(dt)
					: (_.enter("characterReferenceMarker"),
					  _.consume(dt),
					  _.exit("characterReferenceMarker"),
					  _.exit("characterReference"),
					  et))
			: ot(dt) && rt++ < it
			? (_.consume(dt), ut)
			: tt(dt);
	}
}
const codeFenced = { name: "codeFenced", tokenize: tokenizeCodeFenced, concrete: !0 };
function tokenizeCodeFenced(_, et, tt) {
	const nt = this,
		rt = { tokenize: St, partial: !0 },
		it = { tokenize: xt, partial: !0 },
		ot = this.events[this.events.length - 1],
		at = ot && ot[1].type === "linePrefix" ? ot[2].sliceSerialize(ot[1], !0).length : 0;
	let st = 0,
		lt;
	return ut;
	function ut(wt) {
		return _.enter("codeFenced"), _.enter("codeFencedFence"), _.enter("codeFencedFenceSequence"), (lt = wt), dt(wt);
	}
	function dt(wt) {
		return wt === lt
			? (_.consume(wt), st++, dt)
			: (_.exit("codeFencedFenceSequence"), st < 3 ? tt(wt) : factorySpace(_, ct, "whitespace")(wt));
	}
	function ct(wt) {
		return wt === null || markdownLineEnding(wt)
			? vt(wt)
			: (_.enter("codeFencedFenceInfo"), _.enter("chunkString", { contentType: "string" }), ft(wt));
	}
	function ft(wt) {
		return wt === null || markdownLineEndingOrSpace(wt)
			? (_.exit("chunkString"), _.exit("codeFencedFenceInfo"), factorySpace(_, mt, "whitespace")(wt))
			: wt === 96 && wt === lt
			? tt(wt)
			: (_.consume(wt), ft);
	}
	function mt(wt) {
		return wt === null || markdownLineEnding(wt)
			? vt(wt)
			: (_.enter("codeFencedFenceMeta"), _.enter("chunkString", { contentType: "string" }), pt(wt));
	}
	function pt(wt) {
		return wt === null || markdownLineEnding(wt)
			? (_.exit("chunkString"), _.exit("codeFencedFenceMeta"), vt(wt))
			: wt === 96 && wt === lt
			? tt(wt)
			: (_.consume(wt), pt);
	}
	function vt(wt) {
		return _.exit("codeFencedFence"), nt.interrupt ? et(wt) : ht(wt);
	}
	function ht(wt) {
		return wt === null
			? yt(wt)
			: markdownLineEnding(wt)
			? _.attempt(it, _.attempt(rt, yt, at ? factorySpace(_, ht, "linePrefix", at + 1) : ht), yt)(wt)
			: (_.enter("codeFlowValue"), gt(wt));
	}
	function gt(wt) {
		return wt === null || markdownLineEnding(wt) ? (_.exit("codeFlowValue"), ht(wt)) : (_.consume(wt), gt);
	}
	function yt(wt) {
		return _.exit("codeFenced"), et(wt);
	}
	function xt(wt, Ct, Et) {
		const _t = this;
		return $t;
		function $t(Lt) {
			return wt.enter("lineEnding"), wt.consume(Lt), wt.exit("lineEnding"), At;
		}
		function At(Lt) {
			return _t.parser.lazy[_t.now().line] ? Et(Lt) : Ct(Lt);
		}
	}
	function St(wt, Ct, Et) {
		let _t = 0;
		return factorySpace(
			wt,
			$t,
			"linePrefix",
			this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
		);
		function $t(Nt) {
			return wt.enter("codeFencedFence"), wt.enter("codeFencedFenceSequence"), At(Nt);
		}
		function At(Nt) {
			return Nt === lt
				? (wt.consume(Nt), _t++, At)
				: _t < st
				? Et(Nt)
				: (wt.exit("codeFencedFenceSequence"), factorySpace(wt, Lt, "whitespace")(Nt));
		}
		function Lt(Nt) {
			return Nt === null || markdownLineEnding(Nt) ? (wt.exit("codeFencedFence"), Ct(Nt)) : Et(Nt);
		}
	}
}
const codeIndented = { name: "codeIndented", tokenize: tokenizeCodeIndented },
	indentedContent = { tokenize: tokenizeIndentedContent, partial: !0 };
function tokenizeCodeIndented(_, et, tt) {
	const nt = this;
	return rt;
	function rt(lt) {
		return _.enter("codeIndented"), factorySpace(_, it, "linePrefix", 4 + 1)(lt);
	}
	function it(lt) {
		const ut = nt.events[nt.events.length - 1];
		return ut && ut[1].type === "linePrefix" && ut[2].sliceSerialize(ut[1], !0).length >= 4 ? ot(lt) : tt(lt);
	}
	function ot(lt) {
		return lt === null
			? st(lt)
			: markdownLineEnding(lt)
			? _.attempt(indentedContent, ot, st)(lt)
			: (_.enter("codeFlowValue"), at(lt));
	}
	function at(lt) {
		return lt === null || markdownLineEnding(lt) ? (_.exit("codeFlowValue"), ot(lt)) : (_.consume(lt), at);
	}
	function st(lt) {
		return _.exit("codeIndented"), et(lt);
	}
}
function tokenizeIndentedContent(_, et, tt) {
	const nt = this;
	return rt;
	function rt(ot) {
		return nt.parser.lazy[nt.now().line]
			? tt(ot)
			: markdownLineEnding(ot)
			? (_.enter("lineEnding"), _.consume(ot), _.exit("lineEnding"), rt)
			: factorySpace(_, it, "linePrefix", 4 + 1)(ot);
	}
	function it(ot) {
		const at = nt.events[nt.events.length - 1];
		return at && at[1].type === "linePrefix" && at[2].sliceSerialize(at[1], !0).length >= 4
			? et(ot)
			: markdownLineEnding(ot)
			? rt(ot)
			: tt(ot);
	}
}
const codeText = { name: "codeText", tokenize: tokenizeCodeText, resolve: resolveCodeText, previous };
function resolveCodeText(_) {
	let et = _.length - 4,
		tt = 3,
		nt,
		rt;
	if (
		(_[tt][1].type === "lineEnding" || _[tt][1].type === "space") &&
		(_[et][1].type === "lineEnding" || _[et][1].type === "space")
	) {
		for (nt = tt; ++nt < et; )
			if (_[nt][1].type === "codeTextData") {
				(_[tt][1].type = "codeTextPadding"), (_[et][1].type = "codeTextPadding"), (tt += 2), (et -= 2);
				break;
			}
	}
	for (nt = tt - 1, et++; ++nt <= et; )
		rt === void 0
			? nt !== et && _[nt][1].type !== "lineEnding" && (rt = nt)
			: (nt === et || _[nt][1].type === "lineEnding") &&
			  ((_[rt][1].type = "codeTextData"),
			  nt !== rt + 2 &&
					((_[rt][1].end = _[nt - 1][1].end), _.splice(rt + 2, nt - rt - 2), (et -= nt - rt - 2), (nt = rt + 2)),
			  (rt = void 0));
	return _;
}
function previous(_) {
	return _ !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(_, et, tt) {
	let nt = 0,
		rt,
		it;
	return ot;
	function ot(dt) {
		return _.enter("codeText"), _.enter("codeTextSequence"), at(dt);
	}
	function at(dt) {
		return dt === 96 ? (_.consume(dt), nt++, at) : (_.exit("codeTextSequence"), st(dt));
	}
	function st(dt) {
		return dt === null
			? tt(dt)
			: dt === 96
			? ((it = _.enter("codeTextSequence")), (rt = 0), ut(dt))
			: dt === 32
			? (_.enter("space"), _.consume(dt), _.exit("space"), st)
			: markdownLineEnding(dt)
			? (_.enter("lineEnding"), _.consume(dt), _.exit("lineEnding"), st)
			: (_.enter("codeTextData"), lt(dt));
	}
	function lt(dt) {
		return dt === null || dt === 32 || dt === 96 || markdownLineEnding(dt)
			? (_.exit("codeTextData"), st(dt))
			: (_.consume(dt), lt);
	}
	function ut(dt) {
		return dt === 96
			? (_.consume(dt), rt++, ut)
			: rt === nt
			? (_.exit("codeTextSequence"), _.exit("codeText"), et(dt))
			: ((it.type = "codeTextData"), lt(dt));
	}
}
function subtokenize(_) {
	const et = {};
	let tt = -1,
		nt,
		rt,
		it,
		ot,
		at,
		st,
		lt;
	for (; ++tt < _.length; ) {
		for (; tt in et; ) tt = et[tt];
		if (
			((nt = _[tt]),
			tt &&
				nt[1].type === "chunkFlow" &&
				_[tt - 1][1].type === "listItemPrefix" &&
				((st = nt[1]._tokenizer.events),
				(it = 0),
				it < st.length && st[it][1].type === "lineEndingBlank" && (it += 2),
				it < st.length && st[it][1].type === "content"))
		)
			for (; ++it < st.length && st[it][1].type !== "content"; )
				st[it][1].type === "chunkText" && ((st[it][1]._isInFirstContentOfListItem = !0), it++);
		if (nt[0] === "enter") nt[1].contentType && (Object.assign(et, subcontent(_, tt)), (tt = et[tt]), (lt = !0));
		else if (nt[1]._container) {
			for (
				it = tt, rt = void 0;
				it-- && ((ot = _[it]), ot[1].type === "lineEnding" || ot[1].type === "lineEndingBlank");

			)
				ot[0] === "enter" && (rt && (_[rt][1].type = "lineEndingBlank"), (ot[1].type = "lineEnding"), (rt = it));
			rt &&
				((nt[1].end = Object.assign({}, _[rt][1].start)),
				(at = _.slice(rt, tt)),
				at.unshift(nt),
				splice(_, rt, tt - rt + 1, at));
		}
	}
	return !lt;
}
function subcontent(_, et) {
	const tt = _[et][1],
		nt = _[et][2];
	let rt = et - 1;
	const it = [],
		ot = tt._tokenizer || nt.parser[tt.contentType](tt.start),
		at = ot.events,
		st = [],
		lt = {};
	let ut,
		dt,
		ct = -1,
		ft = tt,
		mt = 0,
		pt = 0;
	const vt = [pt];
	for (; ft; ) {
		for (; _[++rt][1] !== ft; );
		it.push(rt),
			ft._tokenizer ||
				((ut = nt.sliceStream(ft)),
				ft.next || ut.push(null),
				dt && ot.defineSkip(ft.start),
				ft._isInFirstContentOfListItem && (ot._gfmTasklistFirstContentOfListItem = !0),
				ot.write(ut),
				ft._isInFirstContentOfListItem && (ot._gfmTasklistFirstContentOfListItem = void 0)),
			(dt = ft),
			(ft = ft.next);
	}
	for (ft = tt; ++ct < at.length; )
		at[ct][0] === "exit" &&
			at[ct - 1][0] === "enter" &&
			at[ct][1].type === at[ct - 1][1].type &&
			at[ct][1].start.line !== at[ct][1].end.line &&
			((pt = ct + 1), vt.push(pt), (ft._tokenizer = void 0), (ft.previous = void 0), (ft = ft.next));
	for (ot.events = [], ft ? ((ft._tokenizer = void 0), (ft.previous = void 0)) : vt.pop(), ct = vt.length; ct--; ) {
		const ht = at.slice(vt[ct], vt[ct + 1]),
			gt = it.pop();
		st.unshift([gt, gt + ht.length - 1]), splice(_, gt, 2, ht);
	}
	for (ct = -1; ++ct < st.length; ) (lt[mt + st[ct][0]] = mt + st[ct][1]), (mt += st[ct][1] - st[ct][0] - 1);
	return lt;
}
const content = { tokenize: tokenizeContent, resolve: resolveContent },
	continuationConstruct = { tokenize: tokenizeContinuation, partial: !0 };
function resolveContent(_) {
	return subtokenize(_), _;
}
function tokenizeContent(_, et) {
	let tt;
	return nt;
	function nt(at) {
		return _.enter("content"), (tt = _.enter("chunkContent", { contentType: "content" })), rt(at);
	}
	function rt(at) {
		return at === null
			? it(at)
			: markdownLineEnding(at)
			? _.check(continuationConstruct, ot, it)(at)
			: (_.consume(at), rt);
	}
	function it(at) {
		return _.exit("chunkContent"), _.exit("content"), et(at);
	}
	function ot(at) {
		return (
			_.consume(at),
			_.exit("chunkContent"),
			(tt.next = _.enter("chunkContent", { contentType: "content", previous: tt })),
			(tt = tt.next),
			rt
		);
	}
}
function tokenizeContinuation(_, et, tt) {
	const nt = this;
	return rt;
	function rt(ot) {
		return (
			_.exit("chunkContent"),
			_.enter("lineEnding"),
			_.consume(ot),
			_.exit("lineEnding"),
			factorySpace(_, it, "linePrefix")
		);
	}
	function it(ot) {
		if (ot === null || markdownLineEnding(ot)) return tt(ot);
		const at = nt.events[nt.events.length - 1];
		return !nt.parser.constructs.disable.null.includes("codeIndented") &&
			at &&
			at[1].type === "linePrefix" &&
			at[2].sliceSerialize(at[1], !0).length >= 4
			? et(ot)
			: _.interrupt(nt.parser.constructs.flow, tt, et)(ot);
	}
}
function factoryDestination(_, et, tt, nt, rt, it, ot, at, st) {
	const lt = st || Number.POSITIVE_INFINITY;
	let ut = 0;
	return dt;
	function dt(ht) {
		return ht === 60
			? (_.enter(nt), _.enter(rt), _.enter(it), _.consume(ht), _.exit(it), ct)
			: ht === null || ht === 41 || asciiControl(ht)
			? tt(ht)
			: (_.enter(nt), _.enter(ot), _.enter(at), _.enter("chunkString", { contentType: "string" }), pt(ht));
	}
	function ct(ht) {
		return ht === 62
			? (_.enter(it), _.consume(ht), _.exit(it), _.exit(rt), _.exit(nt), et)
			: (_.enter(at), _.enter("chunkString", { contentType: "string" }), ft(ht));
	}
	function ft(ht) {
		return ht === 62
			? (_.exit("chunkString"), _.exit(at), ct(ht))
			: ht === null || ht === 60 || markdownLineEnding(ht)
			? tt(ht)
			: (_.consume(ht), ht === 92 ? mt : ft);
	}
	function mt(ht) {
		return ht === 60 || ht === 62 || ht === 92 ? (_.consume(ht), ft) : ft(ht);
	}
	function pt(ht) {
		return ht === 40
			? ++ut > lt
				? tt(ht)
				: (_.consume(ht), pt)
			: ht === 41
			? ut--
				? (_.consume(ht), pt)
				: (_.exit("chunkString"), _.exit(at), _.exit(ot), _.exit(nt), et(ht))
			: ht === null || markdownLineEndingOrSpace(ht)
			? ut
				? tt(ht)
				: (_.exit("chunkString"), _.exit(at), _.exit(ot), _.exit(nt), et(ht))
			: asciiControl(ht)
			? tt(ht)
			: (_.consume(ht), ht === 92 ? vt : pt);
	}
	function vt(ht) {
		return ht === 40 || ht === 41 || ht === 92 ? (_.consume(ht), pt) : pt(ht);
	}
}
function factoryLabel(_, et, tt, nt, rt, it) {
	const ot = this;
	let at = 0,
		st;
	return lt;
	function lt(ft) {
		return _.enter(nt), _.enter(rt), _.consume(ft), _.exit(rt), _.enter(it), ut;
	}
	function ut(ft) {
		return ft === null ||
			ft === 91 ||
			(ft === 93 && !st) ||
			(ft === 94 && !at && "_hiddenFootnoteSupport" in ot.parser.constructs) ||
			at > 999
			? tt(ft)
			: ft === 93
			? (_.exit(it), _.enter(rt), _.consume(ft), _.exit(rt), _.exit(nt), et)
			: markdownLineEnding(ft)
			? (_.enter("lineEnding"), _.consume(ft), _.exit("lineEnding"), ut)
			: (_.enter("chunkString", { contentType: "string" }), dt(ft));
	}
	function dt(ft) {
		return ft === null || ft === 91 || ft === 93 || markdownLineEnding(ft) || at++ > 999
			? (_.exit("chunkString"), ut(ft))
			: (_.consume(ft), (st = st || !markdownSpace(ft)), ft === 92 ? ct : dt);
	}
	function ct(ft) {
		return ft === 91 || ft === 92 || ft === 93 ? (_.consume(ft), at++, dt) : dt(ft);
	}
}
function factoryTitle(_, et, tt, nt, rt, it) {
	let ot;
	return at;
	function at(ct) {
		return _.enter(nt), _.enter(rt), _.consume(ct), _.exit(rt), (ot = ct === 40 ? 41 : ct), st;
	}
	function st(ct) {
		return ct === ot ? (_.enter(rt), _.consume(ct), _.exit(rt), _.exit(nt), et) : (_.enter(it), lt(ct));
	}
	function lt(ct) {
		return ct === ot
			? (_.exit(it), st(ot))
			: ct === null
			? tt(ct)
			: markdownLineEnding(ct)
			? (_.enter("lineEnding"), _.consume(ct), _.exit("lineEnding"), factorySpace(_, lt, "linePrefix"))
			: (_.enter("chunkString", { contentType: "string" }), ut(ct));
	}
	function ut(ct) {
		return ct === ot || ct === null || markdownLineEnding(ct)
			? (_.exit("chunkString"), lt(ct))
			: (_.consume(ct), ct === 92 ? dt : ut);
	}
	function dt(ct) {
		return ct === ot || ct === 92 ? (_.consume(ct), ut) : ut(ct);
	}
}
function factoryWhitespace(_, et) {
	let tt;
	return nt;
	function nt(rt) {
		return markdownLineEnding(rt)
			? (_.enter("lineEnding"), _.consume(rt), _.exit("lineEnding"), (tt = !0), nt)
			: markdownSpace(rt)
			? factorySpace(_, nt, tt ? "linePrefix" : "lineSuffix")(rt)
			: et(rt);
	}
}
function normalizeIdentifier(_) {
	return _.replace(/[\t\n\r ]+/g, " ")
		.replace(/^ | $/g, "")
		.toLowerCase()
		.toUpperCase();
}
const definition = { name: "definition", tokenize: tokenizeDefinition },
	titleConstruct = { tokenize: tokenizeTitle, partial: !0 };
function tokenizeDefinition(_, et, tt) {
	const nt = this;
	let rt;
	return it;
	function it(st) {
		return (
			_.enter("definition"),
			factoryLabel.call(nt, _, ot, tt, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(st)
		);
	}
	function ot(st) {
		return (
			(rt = normalizeIdentifier(nt.sliceSerialize(nt.events[nt.events.length - 1][1]).slice(1, -1))),
			st === 58
				? (_.enter("definitionMarker"),
				  _.consume(st),
				  _.exit("definitionMarker"),
				  factoryWhitespace(
						_,
						factoryDestination(
							_,
							_.attempt(titleConstruct, factorySpace(_, at, "whitespace"), factorySpace(_, at, "whitespace")),
							tt,
							"definitionDestination",
							"definitionDestinationLiteral",
							"definitionDestinationLiteralMarker",
							"definitionDestinationRaw",
							"definitionDestinationString"
						)
				  ))
				: tt(st)
		);
	}
	function at(st) {
		return st === null || markdownLineEnding(st)
			? (_.exit("definition"), nt.parser.defined.includes(rt) || nt.parser.defined.push(rt), et(st))
			: tt(st);
	}
}
function tokenizeTitle(_, et, tt) {
	return nt;
	function nt(ot) {
		return markdownLineEndingOrSpace(ot) ? factoryWhitespace(_, rt)(ot) : tt(ot);
	}
	function rt(ot) {
		return ot === 34 || ot === 39 || ot === 40
			? factoryTitle(
					_,
					factorySpace(_, it, "whitespace"),
					tt,
					"definitionTitle",
					"definitionTitleMarker",
					"definitionTitleString"
			  )(ot)
			: tt(ot);
	}
	function it(ot) {
		return ot === null || markdownLineEnding(ot) ? et(ot) : tt(ot);
	}
}
const hardBreakEscape = { name: "hardBreakEscape", tokenize: tokenizeHardBreakEscape };
function tokenizeHardBreakEscape(_, et, tt) {
	return nt;
	function nt(it) {
		return _.enter("hardBreakEscape"), _.enter("escapeMarker"), _.consume(it), rt;
	}
	function rt(it) {
		return markdownLineEnding(it) ? (_.exit("escapeMarker"), _.exit("hardBreakEscape"), et(it)) : tt(it);
	}
}
const headingAtx = { name: "headingAtx", tokenize: tokenizeHeadingAtx, resolve: resolveHeadingAtx };
function resolveHeadingAtx(_, et) {
	let tt = _.length - 2,
		nt = 3,
		rt,
		it;
	return (
		_[nt][1].type === "whitespace" && (nt += 2),
		tt - 2 > nt && _[tt][1].type === "whitespace" && (tt -= 2),
		_[tt][1].type === "atxHeadingSequence" &&
			(nt === tt - 1 || (tt - 4 > nt && _[tt - 2][1].type === "whitespace")) &&
			(tt -= nt + 1 === tt ? 2 : 4),
		tt > nt &&
			((rt = { type: "atxHeadingText", start: _[nt][1].start, end: _[tt][1].end }),
			(it = { type: "chunkText", start: _[nt][1].start, end: _[tt][1].end, contentType: "text" }),
			splice(_, nt, tt - nt + 1, [
				["enter", rt, et],
				["enter", it, et],
				["exit", it, et],
				["exit", rt, et],
			])),
		_
	);
}
function tokenizeHeadingAtx(_, et, tt) {
	const nt = this;
	let rt = 0;
	return it;
	function it(ut) {
		return _.enter("atxHeading"), _.enter("atxHeadingSequence"), ot(ut);
	}
	function ot(ut) {
		return ut === 35 && rt++ < 6
			? (_.consume(ut), ot)
			: ut === null || markdownLineEndingOrSpace(ut)
			? (_.exit("atxHeadingSequence"), nt.interrupt ? et(ut) : at(ut))
			: tt(ut);
	}
	function at(ut) {
		return ut === 35
			? (_.enter("atxHeadingSequence"), st(ut))
			: ut === null || markdownLineEnding(ut)
			? (_.exit("atxHeading"), et(ut))
			: markdownSpace(ut)
			? factorySpace(_, at, "whitespace")(ut)
			: (_.enter("atxHeadingText"), lt(ut));
	}
	function st(ut) {
		return ut === 35 ? (_.consume(ut), st) : (_.exit("atxHeadingSequence"), at(ut));
	}
	function lt(ut) {
		return ut === null || ut === 35 || markdownLineEndingOrSpace(ut)
			? (_.exit("atxHeadingText"), at(ut))
			: (_.consume(ut), lt);
	}
}
const htmlBlockNames = [
		"address",
		"article",
		"aside",
		"base",
		"basefont",
		"blockquote",
		"body",
		"caption",
		"center",
		"col",
		"colgroup",
		"dd",
		"details",
		"dialog",
		"dir",
		"div",
		"dl",
		"dt",
		"fieldset",
		"figcaption",
		"figure",
		"footer",
		"form",
		"frame",
		"frameset",
		"h1",
		"h2",
		"h3",
		"h4",
		"h5",
		"h6",
		"head",
		"header",
		"hr",
		"html",
		"iframe",
		"legend",
		"li",
		"link",
		"main",
		"menu",
		"menuitem",
		"nav",
		"noframes",
		"ol",
		"optgroup",
		"option",
		"p",
		"param",
		"section",
		"summary",
		"table",
		"tbody",
		"td",
		"tfoot",
		"th",
		"thead",
		"title",
		"tr",
		"track",
		"ul",
	],
	htmlRawNames = ["pre", "script", "style", "textarea"],
	htmlFlow = { name: "htmlFlow", tokenize: tokenizeHtmlFlow, resolveTo: resolveToHtmlFlow, concrete: !0 },
	nextBlankConstruct = { tokenize: tokenizeNextBlank, partial: !0 };
function resolveToHtmlFlow(_) {
	let et = _.length;
	for (; et-- && !(_[et][0] === "enter" && _[et][1].type === "htmlFlow"); );
	return (
		et > 1 &&
			_[et - 2][1].type === "linePrefix" &&
			((_[et][1].start = _[et - 2][1].start), (_[et + 1][1].start = _[et - 2][1].start), _.splice(et - 2, 2)),
		_
	);
}
function tokenizeHtmlFlow(_, et, tt) {
	const nt = this;
	let rt, it, ot, at, st;
	return lt;
	function lt(kt) {
		return _.enter("htmlFlow"), _.enter("htmlFlowData"), _.consume(kt), ut;
	}
	function ut(kt) {
		return kt === 33
			? (_.consume(kt), dt)
			: kt === 47
			? (_.consume(kt), mt)
			: kt === 63
			? (_.consume(kt), (rt = 3), nt.interrupt ? et : Dt)
			: asciiAlpha(kt)
			? (_.consume(kt), (ot = String.fromCharCode(kt)), (it = !0), pt)
			: tt(kt);
	}
	function dt(kt) {
		return kt === 45
			? (_.consume(kt), (rt = 2), ct)
			: kt === 91
			? (_.consume(kt), (rt = 5), (ot = "CDATA["), (at = 0), ft)
			: asciiAlpha(kt)
			? (_.consume(kt), (rt = 4), nt.interrupt ? et : Dt)
			: tt(kt);
	}
	function ct(kt) {
		return kt === 45 ? (_.consume(kt), nt.interrupt ? et : Dt) : tt(kt);
	}
	function ft(kt) {
		return kt === ot.charCodeAt(at++) ? (_.consume(kt), at === ot.length ? (nt.interrupt ? et : At) : ft) : tt(kt);
	}
	function mt(kt) {
		return asciiAlpha(kt) ? (_.consume(kt), (ot = String.fromCharCode(kt)), pt) : tt(kt);
	}
	function pt(kt) {
		return kt === null || kt === 47 || kt === 62 || markdownLineEndingOrSpace(kt)
			? kt !== 47 && it && htmlRawNames.includes(ot.toLowerCase())
				? ((rt = 1), nt.interrupt ? et(kt) : At(kt))
				: htmlBlockNames.includes(ot.toLowerCase())
				? ((rt = 6), kt === 47 ? (_.consume(kt), vt) : nt.interrupt ? et(kt) : At(kt))
				: ((rt = 7), nt.interrupt && !nt.parser.lazy[nt.now().line] ? tt(kt) : it ? gt(kt) : ht(kt))
			: kt === 45 || asciiAlphanumeric(kt)
			? (_.consume(kt), (ot += String.fromCharCode(kt)), pt)
			: tt(kt);
	}
	function vt(kt) {
		return kt === 62 ? (_.consume(kt), nt.interrupt ? et : At) : tt(kt);
	}
	function ht(kt) {
		return markdownSpace(kt) ? (_.consume(kt), ht) : _t(kt);
	}
	function gt(kt) {
		return kt === 47
			? (_.consume(kt), _t)
			: kt === 58 || kt === 95 || asciiAlpha(kt)
			? (_.consume(kt), yt)
			: markdownSpace(kt)
			? (_.consume(kt), gt)
			: _t(kt);
	}
	function yt(kt) {
		return kt === 45 || kt === 46 || kt === 58 || kt === 95 || asciiAlphanumeric(kt) ? (_.consume(kt), yt) : xt(kt);
	}
	function xt(kt) {
		return kt === 61 ? (_.consume(kt), St) : markdownSpace(kt) ? (_.consume(kt), xt) : gt(kt);
	}
	function St(kt) {
		return kt === null || kt === 60 || kt === 61 || kt === 62 || kt === 96
			? tt(kt)
			: kt === 34 || kt === 39
			? (_.consume(kt), (st = kt), wt)
			: markdownSpace(kt)
			? (_.consume(kt), St)
			: ((st = null), Ct(kt));
	}
	function wt(kt) {
		return kt === null || markdownLineEnding(kt) ? tt(kt) : kt === st ? (_.consume(kt), Et) : (_.consume(kt), wt);
	}
	function Ct(kt) {
		return kt === null ||
			kt === 34 ||
			kt === 39 ||
			kt === 60 ||
			kt === 61 ||
			kt === 62 ||
			kt === 96 ||
			markdownLineEndingOrSpace(kt)
			? xt(kt)
			: (_.consume(kt), Ct);
	}
	function Et(kt) {
		return kt === 47 || kt === 62 || markdownSpace(kt) ? gt(kt) : tt(kt);
	}
	function _t(kt) {
		return kt === 62 ? (_.consume(kt), $t) : tt(kt);
	}
	function $t(kt) {
		return markdownSpace(kt) ? (_.consume(kt), $t) : kt === null || markdownLineEnding(kt) ? At(kt) : tt(kt);
	}
	function At(kt) {
		return kt === 45 && rt === 2
			? (_.consume(kt), Gt)
			: kt === 60 && rt === 1
			? (_.consume(kt), Bt)
			: kt === 62 && rt === 4
			? (_.consume(kt), Rt)
			: kt === 63 && rt === 3
			? (_.consume(kt), Dt)
			: kt === 93 && rt === 5
			? (_.consume(kt), It)
			: markdownLineEnding(kt) && (rt === 6 || rt === 7)
			? _.check(nextBlankConstruct, Rt, Lt)(kt)
			: kt === null || markdownLineEnding(kt)
			? Lt(kt)
			: (_.consume(kt), At);
	}
	function Lt(kt) {
		return _.exit("htmlFlowData"), Nt(kt);
	}
	function Nt(kt) {
		return kt === null
			? bt(kt)
			: markdownLineEnding(kt)
			? _.attempt({ tokenize: Ft, partial: !0 }, Nt, bt)(kt)
			: (_.enter("htmlFlowData"), At(kt));
	}
	function Ft(kt, zt, Vt) {
		return Yt;
		function Yt(qt) {
			return kt.enter("lineEnding"), kt.consume(qt), kt.exit("lineEnding"), Ut;
		}
		function Ut(qt) {
			return nt.parser.lazy[nt.now().line] ? Vt(qt) : zt(qt);
		}
	}
	function Gt(kt) {
		return kt === 45 ? (_.consume(kt), Dt) : At(kt);
	}
	function Bt(kt) {
		return kt === 47 ? (_.consume(kt), (ot = ""), jt) : At(kt);
	}
	function jt(kt) {
		return kt === 62 && htmlRawNames.includes(ot.toLowerCase())
			? (_.consume(kt), Rt)
			: asciiAlpha(kt) && ot.length < 8
			? (_.consume(kt), (ot += String.fromCharCode(kt)), jt)
			: At(kt);
	}
	function It(kt) {
		return kt === 93 ? (_.consume(kt), Dt) : At(kt);
	}
	function Dt(kt) {
		return kt === 62 ? (_.consume(kt), Rt) : kt === 45 && rt === 2 ? (_.consume(kt), Dt) : At(kt);
	}
	function Rt(kt) {
		return kt === null || markdownLineEnding(kt) ? (_.exit("htmlFlowData"), bt(kt)) : (_.consume(kt), Rt);
	}
	function bt(kt) {
		return _.exit("htmlFlow"), et(kt);
	}
}
function tokenizeNextBlank(_, et, tt) {
	return nt;
	function nt(rt) {
		return (
			_.exit("htmlFlowData"),
			_.enter("lineEndingBlank"),
			_.consume(rt),
			_.exit("lineEndingBlank"),
			_.attempt(blankLine, et, tt)
		);
	}
}
const htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(_, et, tt) {
	const nt = this;
	let rt, it, ot, at;
	return st;
	function st(bt) {
		return _.enter("htmlText"), _.enter("htmlTextData"), _.consume(bt), lt;
	}
	function lt(bt) {
		return bt === 33
			? (_.consume(bt), ut)
			: bt === 47
			? (_.consume(bt), Ct)
			: bt === 63
			? (_.consume(bt), St)
			: asciiAlpha(bt)
			? (_.consume(bt), $t)
			: tt(bt);
	}
	function ut(bt) {
		return bt === 45
			? (_.consume(bt), dt)
			: bt === 91
			? (_.consume(bt), (it = "CDATA["), (ot = 0), vt)
			: asciiAlpha(bt)
			? (_.consume(bt), xt)
			: tt(bt);
	}
	function dt(bt) {
		return bt === 45 ? (_.consume(bt), ct) : tt(bt);
	}
	function ct(bt) {
		return bt === null || bt === 62 ? tt(bt) : bt === 45 ? (_.consume(bt), ft) : mt(bt);
	}
	function ft(bt) {
		return bt === null || bt === 62 ? tt(bt) : mt(bt);
	}
	function mt(bt) {
		return bt === null
			? tt(bt)
			: bt === 45
			? (_.consume(bt), pt)
			: markdownLineEnding(bt)
			? ((at = mt), It(bt))
			: (_.consume(bt), mt);
	}
	function pt(bt) {
		return bt === 45 ? (_.consume(bt), Rt) : mt(bt);
	}
	function vt(bt) {
		return bt === it.charCodeAt(ot++) ? (_.consume(bt), ot === it.length ? ht : vt) : tt(bt);
	}
	function ht(bt) {
		return bt === null
			? tt(bt)
			: bt === 93
			? (_.consume(bt), gt)
			: markdownLineEnding(bt)
			? ((at = ht), It(bt))
			: (_.consume(bt), ht);
	}
	function gt(bt) {
		return bt === 93 ? (_.consume(bt), yt) : ht(bt);
	}
	function yt(bt) {
		return bt === 62 ? Rt(bt) : bt === 93 ? (_.consume(bt), yt) : ht(bt);
	}
	function xt(bt) {
		return bt === null || bt === 62 ? Rt(bt) : markdownLineEnding(bt) ? ((at = xt), It(bt)) : (_.consume(bt), xt);
	}
	function St(bt) {
		return bt === null
			? tt(bt)
			: bt === 63
			? (_.consume(bt), wt)
			: markdownLineEnding(bt)
			? ((at = St), It(bt))
			: (_.consume(bt), St);
	}
	function wt(bt) {
		return bt === 62 ? Rt(bt) : St(bt);
	}
	function Ct(bt) {
		return asciiAlpha(bt) ? (_.consume(bt), Et) : tt(bt);
	}
	function Et(bt) {
		return bt === 45 || asciiAlphanumeric(bt) ? (_.consume(bt), Et) : _t(bt);
	}
	function _t(bt) {
		return markdownLineEnding(bt) ? ((at = _t), It(bt)) : markdownSpace(bt) ? (_.consume(bt), _t) : Rt(bt);
	}
	function $t(bt) {
		return bt === 45 || asciiAlphanumeric(bt)
			? (_.consume(bt), $t)
			: bt === 47 || bt === 62 || markdownLineEndingOrSpace(bt)
			? At(bt)
			: tt(bt);
	}
	function At(bt) {
		return bt === 47
			? (_.consume(bt), Rt)
			: bt === 58 || bt === 95 || asciiAlpha(bt)
			? (_.consume(bt), Lt)
			: markdownLineEnding(bt)
			? ((at = At), It(bt))
			: markdownSpace(bt)
			? (_.consume(bt), At)
			: Rt(bt);
	}
	function Lt(bt) {
		return bt === 45 || bt === 46 || bt === 58 || bt === 95 || asciiAlphanumeric(bt) ? (_.consume(bt), Lt) : Nt(bt);
	}
	function Nt(bt) {
		return bt === 61
			? (_.consume(bt), Ft)
			: markdownLineEnding(bt)
			? ((at = Nt), It(bt))
			: markdownSpace(bt)
			? (_.consume(bt), Nt)
			: At(bt);
	}
	function Ft(bt) {
		return bt === null || bt === 60 || bt === 61 || bt === 62 || bt === 96
			? tt(bt)
			: bt === 34 || bt === 39
			? (_.consume(bt), (rt = bt), Gt)
			: markdownLineEnding(bt)
			? ((at = Ft), It(bt))
			: markdownSpace(bt)
			? (_.consume(bt), Ft)
			: (_.consume(bt), (rt = void 0), jt);
	}
	function Gt(bt) {
		return bt === rt
			? (_.consume(bt), Bt)
			: bt === null
			? tt(bt)
			: markdownLineEnding(bt)
			? ((at = Gt), It(bt))
			: (_.consume(bt), Gt);
	}
	function Bt(bt) {
		return bt === 62 || bt === 47 || markdownLineEndingOrSpace(bt) ? At(bt) : tt(bt);
	}
	function jt(bt) {
		return bt === null || bt === 34 || bt === 39 || bt === 60 || bt === 61 || bt === 96
			? tt(bt)
			: bt === 62 || markdownLineEndingOrSpace(bt)
			? At(bt)
			: (_.consume(bt), jt);
	}
	function It(bt) {
		return (
			_.exit("htmlTextData"),
			_.enter("lineEnding"),
			_.consume(bt),
			_.exit("lineEnding"),
			factorySpace(_, Dt, "linePrefix", nt.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)
		);
	}
	function Dt(bt) {
		return _.enter("htmlTextData"), at(bt);
	}
	function Rt(bt) {
		return bt === 62 ? (_.consume(bt), _.exit("htmlTextData"), _.exit("htmlText"), et) : tt(bt);
	}
}
const labelEnd = {
		name: "labelEnd",
		tokenize: tokenizeLabelEnd,
		resolveTo: resolveToLabelEnd,
		resolveAll: resolveAllLabelEnd,
	},
	resourceConstruct = { tokenize: tokenizeResource },
	fullReferenceConstruct = { tokenize: tokenizeFullReference },
	collapsedReferenceConstruct = { tokenize: tokenizeCollapsedReference };
function resolveAllLabelEnd(_) {
	let et = -1,
		tt;
	for (; ++et < _.length; )
		(tt = _[et][1]),
			(tt.type === "labelImage" || tt.type === "labelLink" || tt.type === "labelEnd") &&
				(_.splice(et + 1, tt.type === "labelImage" ? 4 : 2), (tt.type = "data"), et++);
	return _;
}
function resolveToLabelEnd(_, et) {
	let tt = _.length,
		nt = 0,
		rt,
		it,
		ot,
		at;
	for (; tt--; )
		if (((rt = _[tt][1]), it)) {
			if (rt.type === "link" || (rt.type === "labelLink" && rt._inactive)) break;
			_[tt][0] === "enter" && rt.type === "labelLink" && (rt._inactive = !0);
		} else if (ot) {
			if (
				_[tt][0] === "enter" &&
				(rt.type === "labelImage" || rt.type === "labelLink") &&
				!rt._balanced &&
				((it = tt), rt.type !== "labelLink")
			) {
				nt = 2;
				break;
			}
		} else rt.type === "labelEnd" && (ot = tt);
	const st = {
			type: _[it][1].type === "labelLink" ? "link" : "image",
			start: Object.assign({}, _[it][1].start),
			end: Object.assign({}, _[_.length - 1][1].end),
		},
		lt = { type: "label", start: Object.assign({}, _[it][1].start), end: Object.assign({}, _[ot][1].end) },
		ut = {
			type: "labelText",
			start: Object.assign({}, _[it + nt + 2][1].end),
			end: Object.assign({}, _[ot - 2][1].start),
		};
	return (
		(at = [
			["enter", st, et],
			["enter", lt, et],
		]),
		(at = push(at, _.slice(it + 1, it + nt + 3))),
		(at = push(at, [["enter", ut, et]])),
		(at = push(at, resolveAll(et.parser.constructs.insideSpan.null, _.slice(it + nt + 4, ot - 3), et))),
		(at = push(at, [["exit", ut, et], _[ot - 2], _[ot - 1], ["exit", lt, et]])),
		(at = push(at, _.slice(ot + 1))),
		(at = push(at, [["exit", st, et]])),
		splice(_, it, _.length, at),
		_
	);
}
function tokenizeLabelEnd(_, et, tt) {
	const nt = this;
	let rt = nt.events.length,
		it,
		ot;
	for (; rt--; )
		if (
			(nt.events[rt][1].type === "labelImage" || nt.events[rt][1].type === "labelLink") &&
			!nt.events[rt][1]._balanced
		) {
			it = nt.events[rt][1];
			break;
		}
	return at;
	function at(ut) {
		return it
			? it._inactive
				? lt(ut)
				: ((ot = nt.parser.defined.includes(normalizeIdentifier(nt.sliceSerialize({ start: it.end, end: nt.now() })))),
				  _.enter("labelEnd"),
				  _.enter("labelMarker"),
				  _.consume(ut),
				  _.exit("labelMarker"),
				  _.exit("labelEnd"),
				  st)
			: tt(ut);
	}
	function st(ut) {
		return ut === 40
			? _.attempt(resourceConstruct, et, ot ? et : lt)(ut)
			: ut === 91
			? _.attempt(fullReferenceConstruct, et, ot ? _.attempt(collapsedReferenceConstruct, et, lt) : lt)(ut)
			: ot
			? et(ut)
			: lt(ut);
	}
	function lt(ut) {
		return (it._balanced = !0), tt(ut);
	}
}
function tokenizeResource(_, et, tt) {
	return nt;
	function nt(st) {
		return (
			_.enter("resource"), _.enter("resourceMarker"), _.consume(st), _.exit("resourceMarker"), factoryWhitespace(_, rt)
		);
	}
	function rt(st) {
		return st === 41
			? at(st)
			: factoryDestination(
					_,
					it,
					tt,
					"resourceDestination",
					"resourceDestinationLiteral",
					"resourceDestinationLiteralMarker",
					"resourceDestinationRaw",
					"resourceDestinationString",
					32
			  )(st);
	}
	function it(st) {
		return markdownLineEndingOrSpace(st) ? factoryWhitespace(_, ot)(st) : at(st);
	}
	function ot(st) {
		return st === 34 || st === 39 || st === 40
			? factoryTitle(_, factoryWhitespace(_, at), tt, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(st)
			: at(st);
	}
	function at(st) {
		return st === 41
			? (_.enter("resourceMarker"), _.consume(st), _.exit("resourceMarker"), _.exit("resource"), et)
			: tt(st);
	}
}
function tokenizeFullReference(_, et, tt) {
	const nt = this;
	return rt;
	function rt(ot) {
		return factoryLabel.call(nt, _, it, tt, "reference", "referenceMarker", "referenceString")(ot);
	}
	function it(ot) {
		return nt.parser.defined.includes(
			normalizeIdentifier(nt.sliceSerialize(nt.events[nt.events.length - 1][1]).slice(1, -1))
		)
			? et(ot)
			: tt(ot);
	}
}
function tokenizeCollapsedReference(_, et, tt) {
	return nt;
	function nt(it) {
		return _.enter("reference"), _.enter("referenceMarker"), _.consume(it), _.exit("referenceMarker"), rt;
	}
	function rt(it) {
		return it === 93
			? (_.enter("referenceMarker"), _.consume(it), _.exit("referenceMarker"), _.exit("reference"), et)
			: tt(it);
	}
}
const labelStartImage = { name: "labelStartImage", tokenize: tokenizeLabelStartImage, resolveAll: labelEnd.resolveAll };
function tokenizeLabelStartImage(_, et, tt) {
	const nt = this;
	return rt;
	function rt(at) {
		return _.enter("labelImage"), _.enter("labelImageMarker"), _.consume(at), _.exit("labelImageMarker"), it;
	}
	function it(at) {
		return at === 91
			? (_.enter("labelMarker"), _.consume(at), _.exit("labelMarker"), _.exit("labelImage"), ot)
			: tt(at);
	}
	function ot(at) {
		return at === 94 && "_hiddenFootnoteSupport" in nt.parser.constructs ? tt(at) : et(at);
	}
}
const labelStartLink = { name: "labelStartLink", tokenize: tokenizeLabelStartLink, resolveAll: labelEnd.resolveAll };
function tokenizeLabelStartLink(_, et, tt) {
	const nt = this;
	return rt;
	function rt(ot) {
		return _.enter("labelLink"), _.enter("labelMarker"), _.consume(ot), _.exit("labelMarker"), _.exit("labelLink"), it;
	}
	function it(ot) {
		return ot === 94 && "_hiddenFootnoteSupport" in nt.parser.constructs ? tt(ot) : et(ot);
	}
}
const lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(_, et) {
	return tt;
	function tt(nt) {
		return _.enter("lineEnding"), _.consume(nt), _.exit("lineEnding"), factorySpace(_, et, "linePrefix");
	}
}
const thematicBreak$1 = { name: "thematicBreak", tokenize: tokenizeThematicBreak };
function tokenizeThematicBreak(_, et, tt) {
	let nt = 0,
		rt;
	return it;
	function it(st) {
		return _.enter("thematicBreak"), (rt = st), ot(st);
	}
	function ot(st) {
		return st === rt
			? (_.enter("thematicBreakSequence"), at(st))
			: markdownSpace(st)
			? factorySpace(_, ot, "whitespace")(st)
			: nt < 3 || (st !== null && !markdownLineEnding(st))
			? tt(st)
			: (_.exit("thematicBreak"), et(st));
	}
	function at(st) {
		return st === rt ? (_.consume(st), nt++, at) : (_.exit("thematicBreakSequence"), ot(st));
	}
}
const list$1 = {
		name: "list",
		tokenize: tokenizeListStart,
		continuation: { tokenize: tokenizeListContinuation },
		exit: tokenizeListEnd,
	},
	listItemPrefixWhitespaceConstruct = { tokenize: tokenizeListItemPrefixWhitespace, partial: !0 },
	indentConstruct = { tokenize: tokenizeIndent, partial: !0 };
function tokenizeListStart(_, et, tt) {
	const nt = this,
		rt = nt.events[nt.events.length - 1];
	let it = rt && rt[1].type === "linePrefix" ? rt[2].sliceSerialize(rt[1], !0).length : 0,
		ot = 0;
	return at;
	function at(ft) {
		const mt = nt.containerState.type || (ft === 42 || ft === 43 || ft === 45 ? "listUnordered" : "listOrdered");
		if (mt === "listUnordered" ? !nt.containerState.marker || ft === nt.containerState.marker : asciiDigit(ft)) {
			if (
				(nt.containerState.type || ((nt.containerState.type = mt), _.enter(mt, { _container: !0 })),
				mt === "listUnordered")
			)
				return _.enter("listItemPrefix"), ft === 42 || ft === 45 ? _.check(thematicBreak$1, tt, lt)(ft) : lt(ft);
			if (!nt.interrupt || ft === 49) return _.enter("listItemPrefix"), _.enter("listItemValue"), st(ft);
		}
		return tt(ft);
	}
	function st(ft) {
		return asciiDigit(ft) && ++ot < 10
			? (_.consume(ft), st)
			: (!nt.interrupt || ot < 2) &&
			  (nt.containerState.marker ? ft === nt.containerState.marker : ft === 41 || ft === 46)
			? (_.exit("listItemValue"), lt(ft))
			: tt(ft);
	}
	function lt(ft) {
		return (
			_.enter("listItemMarker"),
			_.consume(ft),
			_.exit("listItemMarker"),
			(nt.containerState.marker = nt.containerState.marker || ft),
			_.check(blankLine, nt.interrupt ? tt : ut, _.attempt(listItemPrefixWhitespaceConstruct, ct, dt))
		);
	}
	function ut(ft) {
		return (nt.containerState.initialBlankLine = !0), it++, ct(ft);
	}
	function dt(ft) {
		return markdownSpace(ft)
			? (_.enter("listItemPrefixWhitespace"), _.consume(ft), _.exit("listItemPrefixWhitespace"), ct)
			: tt(ft);
	}
	function ct(ft) {
		return (nt.containerState.size = it + nt.sliceSerialize(_.exit("listItemPrefix"), !0).length), et(ft);
	}
}
function tokenizeListContinuation(_, et, tt) {
	const nt = this;
	return (nt.containerState._closeFlow = void 0), _.check(blankLine, rt, it);
	function rt(at) {
		return (
			(nt.containerState.furtherBlankLines = nt.containerState.furtherBlankLines || nt.containerState.initialBlankLine),
			factorySpace(_, et, "listItemIndent", nt.containerState.size + 1)(at)
		);
	}
	function it(at) {
		return nt.containerState.furtherBlankLines || !markdownSpace(at)
			? ((nt.containerState.furtherBlankLines = void 0), (nt.containerState.initialBlankLine = void 0), ot(at))
			: ((nt.containerState.furtherBlankLines = void 0),
			  (nt.containerState.initialBlankLine = void 0),
			  _.attempt(indentConstruct, et, ot)(at));
	}
	function ot(at) {
		return (
			(nt.containerState._closeFlow = !0),
			(nt.interrupt = void 0),
			factorySpace(
				_,
				_.attempt(list$1, et, tt),
				"linePrefix",
				nt.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
			)(at)
		);
	}
}
function tokenizeIndent(_, et, tt) {
	const nt = this;
	return factorySpace(_, rt, "listItemIndent", nt.containerState.size + 1);
	function rt(it) {
		const ot = nt.events[nt.events.length - 1];
		return ot && ot[1].type === "listItemIndent" && ot[2].sliceSerialize(ot[1], !0).length === nt.containerState.size
			? et(it)
			: tt(it);
	}
}
function tokenizeListEnd(_) {
	_.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(_, et, tt) {
	const nt = this;
	return factorySpace(
		_,
		rt,
		"listItemPrefixWhitespace",
		nt.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
	);
	function rt(it) {
		const ot = nt.events[nt.events.length - 1];
		return !markdownSpace(it) && ot && ot[1].type === "listItemPrefixWhitespace" ? et(it) : tt(it);
	}
}
const setextUnderline = {
	name: "setextUnderline",
	tokenize: tokenizeSetextUnderline,
	resolveTo: resolveToSetextUnderline,
};
function resolveToSetextUnderline(_, et) {
	let tt = _.length,
		nt,
		rt,
		it;
	for (; tt--; )
		if (_[tt][0] === "enter") {
			if (_[tt][1].type === "content") {
				nt = tt;
				break;
			}
			_[tt][1].type === "paragraph" && (rt = tt);
		} else _[tt][1].type === "content" && _.splice(tt, 1), !it && _[tt][1].type === "definition" && (it = tt);
	const ot = {
		type: "setextHeading",
		start: Object.assign({}, _[rt][1].start),
		end: Object.assign({}, _[_.length - 1][1].end),
	};
	return (
		(_[rt][1].type = "setextHeadingText"),
		it
			? (_.splice(rt, 0, ["enter", ot, et]),
			  _.splice(it + 1, 0, ["exit", _[nt][1], et]),
			  (_[nt][1].end = Object.assign({}, _[it][1].end)))
			: (_[nt][1] = ot),
		_.push(["exit", ot, et]),
		_
	);
}
function tokenizeSetextUnderline(_, et, tt) {
	const nt = this;
	let rt = nt.events.length,
		it,
		ot;
	for (; rt--; )
		if (
			nt.events[rt][1].type !== "lineEnding" &&
			nt.events[rt][1].type !== "linePrefix" &&
			nt.events[rt][1].type !== "content"
		) {
			ot = nt.events[rt][1].type === "paragraph";
			break;
		}
	return at;
	function at(ut) {
		return !nt.parser.lazy[nt.now().line] && (nt.interrupt || ot)
			? (_.enter("setextHeadingLine"), _.enter("setextHeadingLineSequence"), (it = ut), st(ut))
			: tt(ut);
	}
	function st(ut) {
		return ut === it
			? (_.consume(ut), st)
			: (_.exit("setextHeadingLineSequence"), factorySpace(_, lt, "lineSuffix")(ut));
	}
	function lt(ut) {
		return ut === null || markdownLineEnding(ut) ? (_.exit("setextHeadingLine"), et(ut)) : tt(ut);
	}
}
const flow$1 = { tokenize: initializeFlow };
function initializeFlow(_) {
	const et = this,
		tt = _.attempt(
			blankLine,
			nt,
			_.attempt(
				this.parser.constructs.flowInitial,
				rt,
				factorySpace(_, _.attempt(this.parser.constructs.flow, rt, _.attempt(content, rt)), "linePrefix")
			)
		);
	return tt;
	function nt(it) {
		if (it === null) {
			_.consume(it);
			return;
		}
		return _.enter("lineEndingBlank"), _.consume(it), _.exit("lineEndingBlank"), (et.currentConstruct = void 0), tt;
	}
	function rt(it) {
		if (it === null) {
			_.consume(it);
			return;
		}
		return _.enter("lineEnding"), _.consume(it), _.exit("lineEnding"), (et.currentConstruct = void 0), tt;
	}
}
const resolver = { resolveAll: createResolver() },
	string$1 = initializeFactory("string"),
	text$2 = initializeFactory("text");
function initializeFactory(_) {
	return { tokenize: et, resolveAll: createResolver(_ === "text" ? resolveAllLineSuffixes : void 0) };
	function et(tt) {
		const nt = this,
			rt = this.parser.constructs[_],
			it = tt.attempt(rt, ot, at);
		return ot;
		function ot(ut) {
			return lt(ut) ? it(ut) : at(ut);
		}
		function at(ut) {
			if (ut === null) {
				tt.consume(ut);
				return;
			}
			return tt.enter("data"), tt.consume(ut), st;
		}
		function st(ut) {
			return lt(ut) ? (tt.exit("data"), it(ut)) : (tt.consume(ut), st);
		}
		function lt(ut) {
			if (ut === null) return !0;
			const dt = rt[ut];
			let ct = -1;
			if (dt)
				for (; ++ct < dt.length; ) {
					const ft = dt[ct];
					if (!ft.previous || ft.previous.call(nt, nt.previous)) return !0;
				}
			return !1;
		}
	}
}
function createResolver(_) {
	return et;
	function et(tt, nt) {
		let rt = -1,
			it;
		for (; ++rt <= tt.length; )
			it === void 0
				? tt[rt] && tt[rt][1].type === "data" && ((it = rt), rt++)
				: (!tt[rt] || tt[rt][1].type !== "data") &&
				  (rt !== it + 2 && ((tt[it][1].end = tt[rt - 1][1].end), tt.splice(it + 2, rt - it - 2), (rt = it + 2)),
				  (it = void 0));
		return _ ? _(tt, nt) : tt;
	}
}
function resolveAllLineSuffixes(_, et) {
	let tt = 0;
	for (; ++tt <= _.length; )
		if ((tt === _.length || _[tt][1].type === "lineEnding") && _[tt - 1][1].type === "data") {
			const nt = _[tt - 1][1],
				rt = et.sliceStream(nt);
			let it = rt.length,
				ot = -1,
				at = 0,
				st;
			for (; it--; ) {
				const lt = rt[it];
				if (typeof lt == "string") {
					for (ot = lt.length; lt.charCodeAt(ot - 1) === 32; ) at++, ot--;
					if (ot) break;
					ot = -1;
				} else if (lt === -2) (st = !0), at++;
				else if (lt !== -1) {
					it++;
					break;
				}
			}
			if (at) {
				const lt = {
					type: tt === _.length || st || at < 2 ? "lineSuffix" : "hardBreakTrailing",
					start: {
						line: nt.end.line,
						column: nt.end.column - at,
						offset: nt.end.offset - at,
						_index: nt.start._index + it,
						_bufferIndex: it ? ot : nt.start._bufferIndex + ot,
					},
					end: Object.assign({}, nt.end),
				};
				(nt.end = Object.assign({}, lt.start)),
					nt.start.offset === nt.end.offset
						? Object.assign(nt, lt)
						: (_.splice(tt, 0, ["enter", lt, et], ["exit", lt, et]), (tt += 2));
			}
			tt++;
		}
	return _;
}
function createTokenizer(_, et, tt) {
	let nt = Object.assign(tt ? Object.assign({}, tt) : { line: 1, column: 1, offset: 0 }, {
		_index: 0,
		_bufferIndex: -1,
	});
	const rt = {},
		it = [];
	let ot = [],
		at = [];
	const st = { consume: gt, enter: yt, exit: xt, attempt: Ct(St), check: Ct(wt), interrupt: Ct(wt, { interrupt: !0 }) },
		lt = {
			previous: null,
			code: null,
			containerState: {},
			events: [],
			parser: _,
			sliceStream: ft,
			sliceSerialize: ct,
			now: mt,
			defineSkip: pt,
			write: dt,
		};
	let ut = et.tokenize.call(lt, st);
	return et.resolveAll && it.push(et), lt;
	function dt(At) {
		return (
			(ot = push(ot, At)),
			vt(),
			ot[ot.length - 1] !== null ? [] : (Et(et, 0), (lt.events = resolveAll(it, lt.events, lt)), lt.events)
		);
	}
	function ct(At, Lt) {
		return serializeChunks(ft(At), Lt);
	}
	function ft(At) {
		return sliceChunks(ot, At);
	}
	function mt() {
		return Object.assign({}, nt);
	}
	function pt(At) {
		(rt[At.line] = At.column), $t();
	}
	function vt() {
		let At;
		for (; nt._index < ot.length; ) {
			const Lt = ot[nt._index];
			if (typeof Lt == "string")
				for (
					At = nt._index, nt._bufferIndex < 0 && (nt._bufferIndex = 0);
					nt._index === At && nt._bufferIndex < Lt.length;

				)
					ht(Lt.charCodeAt(nt._bufferIndex));
			else ht(Lt);
		}
	}
	function ht(At) {
		ut = ut(At);
	}
	function gt(At) {
		markdownLineEnding(At)
			? (nt.line++, (nt.column = 1), (nt.offset += At === -3 ? 2 : 1), $t())
			: At !== -1 && (nt.column++, nt.offset++),
			nt._bufferIndex < 0
				? nt._index++
				: (nt._bufferIndex++, nt._bufferIndex === ot[nt._index].length && ((nt._bufferIndex = -1), nt._index++)),
			(lt.previous = At);
	}
	function yt(At, Lt) {
		const Nt = Lt || {};
		return (Nt.type = At), (Nt.start = mt()), lt.events.push(["enter", Nt, lt]), at.push(Nt), Nt;
	}
	function xt(At) {
		const Lt = at.pop();
		return (Lt.end = mt()), lt.events.push(["exit", Lt, lt]), Lt;
	}
	function St(At, Lt) {
		Et(At, Lt.from);
	}
	function wt(At, Lt) {
		Lt.restore();
	}
	function Ct(At, Lt) {
		return Nt;
		function Nt(Ft, Gt, Bt) {
			let jt, It, Dt, Rt;
			return Array.isArray(Ft) ? kt(Ft) : "tokenize" in Ft ? kt([Ft]) : bt(Ft);
			function bt(Ut) {
				return qt;
				function qt(Wt) {
					const Xt = Wt !== null && Ut[Wt],
						Zt = Wt !== null && Ut.null,
						pn = [...(Array.isArray(Xt) ? Xt : Xt ? [Xt] : []), ...(Array.isArray(Zt) ? Zt : Zt ? [Zt] : [])];
					return kt(pn)(Wt);
				}
			}
			function kt(Ut) {
				return (jt = Ut), (It = 0), Ut.length === 0 ? Bt : zt(Ut[It]);
			}
			function zt(Ut) {
				return qt;
				function qt(Wt) {
					return (
						(Rt = _t()),
						(Dt = Ut),
						Ut.partial || (lt.currentConstruct = Ut),
						Ut.name && lt.parser.constructs.disable.null.includes(Ut.name)
							? Yt()
							: Ut.tokenize.call(Lt ? Object.assign(Object.create(lt), Lt) : lt, st, Vt, Yt)(Wt)
					);
				}
			}
			function Vt(Ut) {
				return At(Dt, Rt), Gt;
			}
			function Yt(Ut) {
				return Rt.restore(), ++It < jt.length ? zt(jt[It]) : Bt;
			}
		}
	}
	function Et(At, Lt) {
		At.resolveAll && !it.includes(At) && it.push(At),
			At.resolve && splice(lt.events, Lt, lt.events.length - Lt, At.resolve(lt.events.slice(Lt), lt)),
			At.resolveTo && (lt.events = At.resolveTo(lt.events, lt));
	}
	function _t() {
		const At = mt(),
			Lt = lt.previous,
			Nt = lt.currentConstruct,
			Ft = lt.events.length,
			Gt = Array.from(at);
		return { restore: Bt, from: Ft };
		function Bt() {
			(nt = At), (lt.previous = Lt), (lt.currentConstruct = Nt), (lt.events.length = Ft), (at = Gt), $t();
		}
	}
	function $t() {
		nt.line in rt && nt.column < 2 && ((nt.column = rt[nt.line]), (nt.offset += rt[nt.line] - 1));
	}
}
function sliceChunks(_, et) {
	const tt = et.start._index,
		nt = et.start._bufferIndex,
		rt = et.end._index,
		it = et.end._bufferIndex;
	let ot;
	return (
		tt === rt
			? (ot = [_[tt].slice(nt, it)])
			: ((ot = _.slice(tt, rt)), nt > -1 && (ot[0] = ot[0].slice(nt)), it > 0 && ot.push(_[rt].slice(0, it))),
		ot
	);
}
function serializeChunks(_, et) {
	let tt = -1;
	const nt = [];
	let rt;
	for (; ++tt < _.length; ) {
		const it = _[tt];
		let ot;
		if (typeof it == "string") ot = it;
		else
			switch (it) {
				case -5: {
					ot = "\r";
					break;
				}
				case -4: {
					ot = `
`;
					break;
				}
				case -3: {
					ot = `\r
`;
					break;
				}
				case -2: {
					ot = et ? " " : "	";
					break;
				}
				case -1: {
					if (!et && rt) continue;
					ot = " ";
					break;
				}
				default:
					ot = String.fromCharCode(it);
			}
		(rt = it === -2), nt.push(ot);
	}
	return nt.join("");
}
const document$1 = {
		[42]: list$1,
		[43]: list$1,
		[45]: list$1,
		[48]: list$1,
		[49]: list$1,
		[50]: list$1,
		[51]: list$1,
		[52]: list$1,
		[53]: list$1,
		[54]: list$1,
		[55]: list$1,
		[56]: list$1,
		[57]: list$1,
		[62]: blockQuote,
	},
	contentInitial = { [91]: definition },
	flowInitial = { [-2]: codeIndented, [-1]: codeIndented, [32]: codeIndented },
	flow = {
		[35]: headingAtx,
		[42]: thematicBreak$1,
		[45]: [setextUnderline, thematicBreak$1],
		[60]: htmlFlow,
		[61]: setextUnderline,
		[95]: thematicBreak$1,
		[96]: codeFenced,
		[126]: codeFenced,
	},
	string = { [38]: characterReference, [92]: characterEscape },
	text$1 = {
		[-5]: lineEnding,
		[-4]: lineEnding,
		[-3]: lineEnding,
		[33]: labelStartImage,
		[38]: characterReference,
		[42]: attention,
		[60]: [autolink, htmlText],
		[91]: labelStartLink,
		[92]: [hardBreakEscape, characterEscape],
		[93]: labelEnd,
		[95]: attention,
		[96]: codeText,
	},
	insideSpan = { null: [attention, resolver] },
	attentionMarkers = { null: [42, 95] },
	disable = { null: [] },
	defaultConstructs = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				document: document$1,
				contentInitial,
				flowInitial,
				flow,
				string,
				text: text$1,
				insideSpan,
				attentionMarkers,
				disable,
			},
			Symbol.toStringTag,
			{ value: "Module" }
		)
	);
function parse$1(_ = {}) {
	const et = combineExtensions([defaultConstructs].concat(_.extensions || [])),
		tt = {
			defined: [],
			lazy: {},
			constructs: et,
			content: nt(content$1),
			document: nt(document$2),
			flow: nt(flow$1),
			string: nt(string$1),
			text: nt(text$2),
		};
	return tt;
	function nt(rt) {
		return it;
		function it(ot) {
			return createTokenizer(tt, rt, ot);
		}
	}
}
const search = /[\0\t\n\r]/g;
function preprocess() {
	let _ = 1,
		et = "",
		tt = !0,
		nt;
	return rt;
	function rt(it, ot, at) {
		const st = [];
		let lt, ut, dt, ct, ft;
		for (
			it = et + it.toString(ot), dt = 0, et = "", tt && (it.charCodeAt(0) === 65279 && dt++, (tt = void 0));
			dt < it.length;

		) {
			if (
				((search.lastIndex = dt),
				(lt = search.exec(it)),
				(ct = lt && lt.index !== void 0 ? lt.index : it.length),
				(ft = it.charCodeAt(ct)),
				!lt)
			) {
				et = it.slice(dt);
				break;
			}
			if (ft === 10 && dt === ct && nt) st.push(-3), (nt = void 0);
			else
				switch ((nt && (st.push(-5), (nt = void 0)), dt < ct && (st.push(it.slice(dt, ct)), (_ += ct - dt)), ft)) {
					case 0: {
						st.push(65533), _++;
						break;
					}
					case 9: {
						for (ut = Math.ceil(_ / 4) * 4, st.push(-2); _++ < ut; ) st.push(-1);
						break;
					}
					case 10: {
						st.push(-4), (_ = 1);
						break;
					}
					default:
						(nt = !0), (_ = 1);
				}
			dt = ct + 1;
		}
		return at && (nt && st.push(-5), et && st.push(et), st.push(null)), st;
	}
}
function postprocess(_) {
	for (; !subtokenize(_); );
	return _;
}
function decodeNumericCharacterReference(_, et) {
	const tt = Number.parseInt(_, et);
	return tt < 9 ||
		tt === 11 ||
		(tt > 13 && tt < 32) ||
		(tt > 126 && tt < 160) ||
		(tt > 55295 && tt < 57344) ||
		(tt > 64975 && tt < 65008) ||
		(tt & 65535) === 65535 ||
		(tt & 65535) === 65534 ||
		tt > 1114111
		? "\uFFFD"
		: String.fromCharCode(tt);
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(_) {
	return _.replace(characterEscapeOrReference, decode);
}
function decode(_, et, tt) {
	if (et) return et;
	if (tt.charCodeAt(0) === 35) {
		const rt = tt.charCodeAt(1),
			it = rt === 120 || rt === 88;
		return decodeNumericCharacterReference(tt.slice(it ? 2 : 1), it ? 16 : 10);
	}
	return decodeNamedCharacterReference(tt) || _;
}
const own$6 = {}.hasOwnProperty,
	fromMarkdown = function (_, et, tt) {
		return (
			typeof et != "string" && ((tt = et), (et = void 0)),
			compiler(tt)(postprocess(parse$1(tt).document().write(preprocess()(_, et, !0))))
		);
	};
function compiler(_ = {}) {
	const et = configure(
			{
				transforms: [],
				canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
				enter: {
					autolink: st(vn),
					autolinkProtocol: Lt,
					autolinkEmail: Lt,
					atxHeading: st(an),
					blockQuote: st(Sn),
					characterEscape: Lt,
					characterReference: Lt,
					codeFenced: st(yn),
					codeFencedFenceInfo: lt,
					codeFencedFenceMeta: lt,
					codeIndented: st(yn, lt),
					codeText: st(Qt, lt),
					codeTextData: Lt,
					data: Lt,
					codeFlowValue: Lt,
					definition: st(Jt),
					definitionDestinationString: lt,
					definitionLabelString: lt,
					definitionTitleString: lt,
					emphasis: st(tn),
					hardBreakEscape: st(mn),
					hardBreakTrailing: st(mn),
					htmlFlow: st(xn, lt),
					htmlFlowData: Lt,
					htmlText: st(xn, lt),
					htmlTextData: Lt,
					image: st(gn),
					label: lt,
					link: st(vn),
					listItem: st(Cn),
					listItemValue: pt,
					listOrdered: st(kn, mt),
					listUnordered: st(kn),
					paragraph: st(Rn),
					reference: Ut,
					referenceString: lt,
					resourceDestinationString: lt,
					resourceTitleString: lt,
					setextHeading: st(an),
					strong: st(Mn),
					thematicBreak: st(Dn),
				},
				exit: {
					atxHeading: dt(),
					atxHeadingSequence: Et,
					autolink: dt(),
					autolinkEmail: pn,
					autolinkProtocol: Zt,
					blockQuote: dt(),
					characterEscapeValue: Nt,
					characterReferenceMarkerHexadecimal: Wt,
					characterReferenceMarkerNumeric: Wt,
					characterReferenceValue: Xt,
					codeFenced: dt(yt),
					codeFencedFence: gt,
					codeFencedFenceInfo: vt,
					codeFencedFenceMeta: ht,
					codeFlowValue: Nt,
					codeIndented: dt(xt),
					codeText: dt(It),
					codeTextData: Nt,
					data: Nt,
					definition: dt(),
					definitionDestinationString: Ct,
					definitionLabelString: St,
					definitionTitleString: wt,
					emphasis: dt(),
					hardBreakEscape: dt(Gt),
					hardBreakTrailing: dt(Gt),
					htmlFlow: dt(Bt),
					htmlFlowData: Nt,
					htmlText: dt(jt),
					htmlTextData: Nt,
					image: dt(Rt),
					label: kt,
					labelText: bt,
					lineEnding: Ft,
					link: dt(Dt),
					listItem: dt(),
					listOrdered: dt(),
					listUnordered: dt(),
					paragraph: dt(),
					referenceString: qt,
					resourceDestinationString: zt,
					resourceTitleString: Vt,
					resource: Yt,
					setextHeading: dt(At),
					setextHeadingLineSequence: $t,
					setextHeadingText: _t,
					strong: dt(),
					thematicBreak: dt(),
				},
			},
			_.mdastExtensions || []
		),
		tt = {};
	return nt;
	function nt(Ot) {
		let Ht = { type: "root", children: [] };
		const en = [Ht],
			sn = [],
			wn = [],
			In = {
				stack: en,
				tokenStack: sn,
				config: et,
				enter: ut,
				exit: ct,
				buffer: lt,
				resume: ft,
				setData: it,
				getData: ot,
			};
		let ln = -1;
		for (; ++ln < Ot.length; )
			if (Ot[ln][1].type === "listOrdered" || Ot[ln][1].type === "listUnordered")
				if (Ot[ln][0] === "enter") wn.push(ln);
				else {
					const bn = wn.pop();
					ln = rt(Ot, bn, ln);
				}
		for (ln = -1; ++ln < Ot.length; ) {
			const bn = et[Ot[ln][0]];
			own$6.call(bn, Ot[ln][1].type) &&
				bn[Ot[ln][1].type].call(Object.assign({ sliceSerialize: Ot[ln][2].sliceSerialize }, In), Ot[ln][1]);
		}
		if (sn.length > 0) {
			const bn = sn[sn.length - 1];
			(bn[1] || defaultOnError).call(In, void 0, bn[0]);
		}
		for (
			Ht.position = {
				start: at(Ot.length > 0 ? Ot[0][1].start : { line: 1, column: 1, offset: 0 }),
				end: at(Ot.length > 0 ? Ot[Ot.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
			},
				ln = -1;
			++ln < et.transforms.length;

		)
			Ht = et.transforms[ln](Ht) || Ht;
		return Ht;
	}
	function rt(Ot, Ht, en) {
		let sn = Ht - 1,
			wn = -1,
			In = !1,
			ln,
			bn,
			Tn,
			_n;
		for (; ++sn <= en; ) {
			const hn = Ot[sn];
			if (
				(hn[1].type === "listUnordered" || hn[1].type === "listOrdered" || hn[1].type === "blockQuote"
					? (hn[0] === "enter" ? wn++ : wn--, (_n = void 0))
					: hn[1].type === "lineEndingBlank"
					? hn[0] === "enter" && (ln && !_n && !wn && !Tn && (Tn = sn), (_n = void 0))
					: hn[1].type === "linePrefix" ||
					  hn[1].type === "listItemValue" ||
					  hn[1].type === "listItemMarker" ||
					  hn[1].type === "listItemPrefix" ||
					  hn[1].type === "listItemPrefixWhitespace" ||
					  (_n = void 0),
				(!wn && hn[0] === "enter" && hn[1].type === "listItemPrefix") ||
					(wn === -1 && hn[0] === "exit" && (hn[1].type === "listUnordered" || hn[1].type === "listOrdered")))
			) {
				if (ln) {
					let jn = sn;
					for (bn = void 0; jn--; ) {
						const Pn = Ot[jn];
						if (Pn[1].type === "lineEnding" || Pn[1].type === "lineEndingBlank") {
							if (Pn[0] === "exit") continue;
							bn && ((Ot[bn][1].type = "lineEndingBlank"), (In = !0)), (Pn[1].type = "lineEnding"), (bn = jn);
						} else if (
							!(
								Pn[1].type === "linePrefix" ||
								Pn[1].type === "blockQuotePrefix" ||
								Pn[1].type === "blockQuotePrefixWhitespace" ||
								Pn[1].type === "blockQuoteMarker" ||
								Pn[1].type === "listItemIndent"
							)
						)
							break;
					}
					Tn && (!bn || Tn < bn) && (ln._spread = !0),
						(ln.end = Object.assign({}, bn ? Ot[bn][1].start : hn[1].end)),
						Ot.splice(bn || sn, 0, ["exit", ln, hn[2]]),
						sn++,
						en++;
				}
				hn[1].type === "listItemPrefix" &&
					((ln = { type: "listItem", _spread: !1, start: Object.assign({}, hn[1].start) }),
					Ot.splice(sn, 0, ["enter", ln, hn[2]]),
					sn++,
					en++,
					(Tn = void 0),
					(_n = !0));
			}
		}
		return (Ot[Ht][1]._spread = In), en;
	}
	function it(Ot, Ht) {
		tt[Ot] = Ht;
	}
	function ot(Ot) {
		return tt[Ot];
	}
	function at(Ot) {
		return { line: Ot.line, column: Ot.column, offset: Ot.offset };
	}
	function st(Ot, Ht) {
		return en;
		function en(sn) {
			ut.call(this, Ot(sn), sn), Ht && Ht.call(this, sn);
		}
	}
	function lt() {
		this.stack.push({ type: "fragment", children: [] });
	}
	function ut(Ot, Ht, en) {
		return (
			this.stack[this.stack.length - 1].children.push(Ot),
			this.stack.push(Ot),
			this.tokenStack.push([Ht, en]),
			(Ot.position = { start: at(Ht.start) }),
			Ot
		);
	}
	function dt(Ot) {
		return Ht;
		function Ht(en) {
			Ot && Ot.call(this, en), ct.call(this, en);
		}
	}
	function ct(Ot, Ht) {
		const en = this.stack.pop(),
			sn = this.tokenStack.pop();
		if (sn) sn[0].type !== Ot.type && (Ht ? Ht.call(this, Ot, sn[0]) : (sn[1] || defaultOnError).call(this, Ot, sn[0]));
		else
			throw new Error(
				"Cannot close `" +
					Ot.type +
					"` (" +
					stringifyPosition({ start: Ot.start, end: Ot.end }) +
					"): it\u2019s not open"
			);
		return (en.position.end = at(Ot.end)), en;
	}
	function ft() {
		return toString(this.stack.pop());
	}
	function mt() {
		it("expectingFirstListItemValue", !0);
	}
	function pt(Ot) {
		if (ot("expectingFirstListItemValue")) {
			const Ht = this.stack[this.stack.length - 2];
			(Ht.start = Number.parseInt(this.sliceSerialize(Ot), 10)), it("expectingFirstListItemValue");
		}
	}
	function vt() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.lang = Ot;
	}
	function ht() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.meta = Ot;
	}
	function gt() {
		ot("flowCodeInside") || (this.buffer(), it("flowCodeInside", !0));
	}
	function yt() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		(Ht.value = Ot.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")), it("flowCodeInside");
	}
	function xt() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.value = Ot.replace(/(\r?\n|\r)$/g, "");
	}
	function St(Ot) {
		const Ht = this.resume(),
			en = this.stack[this.stack.length - 1];
		(en.label = Ht), (en.identifier = normalizeIdentifier(this.sliceSerialize(Ot)).toLowerCase());
	}
	function wt() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.title = Ot;
	}
	function Ct() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.url = Ot;
	}
	function Et(Ot) {
		const Ht = this.stack[this.stack.length - 1];
		if (!Ht.depth) {
			const en = this.sliceSerialize(Ot).length;
			Ht.depth = en;
		}
	}
	function _t() {
		it("setextHeadingSlurpLineEnding", !0);
	}
	function $t(Ot) {
		const Ht = this.stack[this.stack.length - 1];
		Ht.depth = this.sliceSerialize(Ot).charCodeAt(0) === 61 ? 1 : 2;
	}
	function At() {
		it("setextHeadingSlurpLineEnding");
	}
	function Lt(Ot) {
		const Ht = this.stack[this.stack.length - 1];
		let en = Ht.children[Ht.children.length - 1];
		(!en || en.type !== "text") && ((en = Nn()), (en.position = { start: at(Ot.start) }), Ht.children.push(en)),
			this.stack.push(en);
	}
	function Nt(Ot) {
		const Ht = this.stack.pop();
		(Ht.value += this.sliceSerialize(Ot)), (Ht.position.end = at(Ot.end));
	}
	function Ft(Ot) {
		const Ht = this.stack[this.stack.length - 1];
		if (ot("atHardBreak")) {
			const en = Ht.children[Ht.children.length - 1];
			(en.position.end = at(Ot.end)), it("atHardBreak");
			return;
		}
		!ot("setextHeadingSlurpLineEnding") &&
			et.canContainEols.includes(Ht.type) &&
			(Lt.call(this, Ot), Nt.call(this, Ot));
	}
	function Gt() {
		it("atHardBreak", !0);
	}
	function Bt() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.value = Ot;
	}
	function jt() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.value = Ot;
	}
	function It() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.value = Ot;
	}
	function Dt() {
		const Ot = this.stack[this.stack.length - 1];
		ot("inReference")
			? ((Ot.type += "Reference"),
			  (Ot.referenceType = ot("referenceType") || "shortcut"),
			  delete Ot.url,
			  delete Ot.title)
			: (delete Ot.identifier, delete Ot.label),
			it("referenceType");
	}
	function Rt() {
		const Ot = this.stack[this.stack.length - 1];
		ot("inReference")
			? ((Ot.type += "Reference"),
			  (Ot.referenceType = ot("referenceType") || "shortcut"),
			  delete Ot.url,
			  delete Ot.title)
			: (delete Ot.identifier, delete Ot.label),
			it("referenceType");
	}
	function bt(Ot) {
		const Ht = this.stack[this.stack.length - 2],
			en = this.sliceSerialize(Ot);
		(Ht.label = decodeString(en)), (Ht.identifier = normalizeIdentifier(en).toLowerCase());
	}
	function kt() {
		const Ot = this.stack[this.stack.length - 1],
			Ht = this.resume(),
			en = this.stack[this.stack.length - 1];
		it("inReference", !0), en.type === "link" ? (en.children = Ot.children) : (en.alt = Ht);
	}
	function zt() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.url = Ot;
	}
	function Vt() {
		const Ot = this.resume(),
			Ht = this.stack[this.stack.length - 1];
		Ht.title = Ot;
	}
	function Yt() {
		it("inReference");
	}
	function Ut() {
		it("referenceType", "collapsed");
	}
	function qt(Ot) {
		const Ht = this.resume(),
			en = this.stack[this.stack.length - 1];
		(en.label = Ht),
			(en.identifier = normalizeIdentifier(this.sliceSerialize(Ot)).toLowerCase()),
			it("referenceType", "full");
	}
	function Wt(Ot) {
		it("characterReferenceType", Ot.type);
	}
	function Xt(Ot) {
		const Ht = this.sliceSerialize(Ot),
			en = ot("characterReferenceType");
		let sn;
		en
			? ((sn = decodeNumericCharacterReference(Ht, en === "characterReferenceMarkerNumeric" ? 10 : 16)),
			  it("characterReferenceType"))
			: (sn = decodeNamedCharacterReference(Ht));
		const wn = this.stack.pop();
		(wn.value += sn), (wn.position.end = at(Ot.end));
	}
	function Zt(Ot) {
		Nt.call(this, Ot);
		const Ht = this.stack[this.stack.length - 1];
		Ht.url = this.sliceSerialize(Ot);
	}
	function pn(Ot) {
		Nt.call(this, Ot);
		const Ht = this.stack[this.stack.length - 1];
		Ht.url = "mailto:" + this.sliceSerialize(Ot);
	}
	function Sn() {
		return { type: "blockquote", children: [] };
	}
	function yn() {
		return { type: "code", lang: null, meta: null, value: "" };
	}
	function Qt() {
		return { type: "inlineCode", value: "" };
	}
	function Jt() {
		return { type: "definition", identifier: "", label: null, title: null, url: "" };
	}
	function tn() {
		return { type: "emphasis", children: [] };
	}
	function an() {
		return { type: "heading", depth: void 0, children: [] };
	}
	function mn() {
		return { type: "break" };
	}
	function xn() {
		return { type: "html", value: "" };
	}
	function gn() {
		return { type: "image", title: null, url: "", alt: null };
	}
	function vn() {
		return { type: "link", title: null, url: "", children: [] };
	}
	function kn(Ot) {
		return { type: "list", ordered: Ot.type === "listOrdered", start: null, spread: Ot._spread, children: [] };
	}
	function Cn(Ot) {
		return { type: "listItem", spread: Ot._spread, checked: null, children: [] };
	}
	function Rn() {
		return { type: "paragraph", children: [] };
	}
	function Mn() {
		return { type: "strong", children: [] };
	}
	function Nn() {
		return { type: "text", value: "" };
	}
	function Dn() {
		return { type: "thematicBreak" };
	}
}
function configure(_, et) {
	let tt = -1;
	for (; ++tt < et.length; ) {
		const nt = et[tt];
		Array.isArray(nt) ? configure(_, nt) : extension(_, nt);
	}
	return _;
}
function extension(_, et) {
	let tt;
	for (tt in et)
		if (own$6.call(et, tt)) {
			const nt = tt === "canContainEols" || tt === "transforms",
				it = (own$6.call(_, tt) ? _[tt] : void 0) || (_[tt] = nt ? [] : {}),
				ot = et[tt];
			ot && (nt ? (_[tt] = [...it, ...ot]) : Object.assign(it, ot));
		}
}
function defaultOnError(_, et) {
	throw _
		? new Error(
				"Cannot close `" +
					_.type +
					"` (" +
					stringifyPosition({ start: _.start, end: _.end }) +
					"): a different token (`" +
					et.type +
					"`, " +
					stringifyPosition({ start: et.start, end: et.end }) +
					") is open"
		  )
		: new Error(
				"Cannot close document, a token (`" +
					et.type +
					"`, " +
					stringifyPosition({ start: et.start, end: et.end }) +
					") is still open"
		  );
}
function remarkParse(_) {
	Object.assign(this, {
		Parser: (tt) => {
			const nt = this.data("settings");
			return fromMarkdown(
				tt,
				Object.assign({}, nt, _, {
					extensions: this.data("micromarkExtensions") || [],
					mdastExtensions: this.data("fromMarkdownExtensions") || [],
				})
			);
		},
	});
}
var u$1 = function (_, et, tt) {
	var nt = { type: String(_) };
	return (
		tt == null && (typeof et == "string" || Array.isArray(et)) ? (tt = et) : Object.assign(nt, et),
		Array.isArray(tt) ? (nt.children = tt) : tt != null && (nt.value = String(tt)),
		nt
	);
};
const own$5 = {}.hasOwnProperty;
function unknown(_, et) {
	const tt = et.data || {};
	return "value" in et && !(own$5.call(tt, "hName") || own$5.call(tt, "hProperties") || own$5.call(tt, "hChildren"))
		? _.augment(et, u$1("text", et.value))
		: _(et, "div", all(_, et));
}
function one(_, et, tt) {
	const nt = et && et.type;
	let rt;
	if (!nt) throw new Error("Expected node, got `" + et + "`");
	return (
		own$5.call(_.handlers, nt)
			? (rt = _.handlers[nt])
			: _.passThrough && _.passThrough.includes(nt)
			? (rt = returnNode)
			: (rt = _.unknownHandler),
		(typeof rt == "function" ? rt : unknown)(_, et, tt)
	);
}
function returnNode(_, et) {
	return "children" in et ? { ...et, children: all(_, et) } : et;
}
function all(_, et) {
	const tt = [];
	if ("children" in et) {
		const nt = et.children;
		let rt = -1;
		for (; ++rt < nt.length; ) {
			const it = one(_, nt[rt], et);
			if (it) {
				if (
					rt &&
					nt[rt - 1].type === "break" &&
					(!Array.isArray(it) && it.type === "text" && (it.value = it.value.replace(/^\s+/, "")),
					!Array.isArray(it) && it.type === "element")
				) {
					const ot = it.children[0];
					ot && ot.type === "text" && (ot.value = ot.value.replace(/^\s+/, ""));
				}
				Array.isArray(it) ? tt.push(...it) : tt.push(it);
			}
		}
	}
	return tt;
}
const convert = function (_) {
	if (_ == null) return ok;
	if (typeof _ == "string") return typeFactory(_);
	if (typeof _ == "object") return Array.isArray(_) ? anyFactory(_) : propsFactory(_);
	if (typeof _ == "function") return castFactory(_);
	throw new Error("Expected function, string, or object as test");
};
function anyFactory(_) {
	const et = [];
	let tt = -1;
	for (; ++tt < _.length; ) et[tt] = convert(_[tt]);
	return castFactory(nt);
	function nt(...rt) {
		let it = -1;
		for (; ++it < et.length; ) if (et[it].call(this, ...rt)) return !0;
		return !1;
	}
}
function propsFactory(_) {
	return castFactory(et);
	function et(tt) {
		let nt;
		for (nt in _) if (tt[nt] !== _[nt]) return !1;
		return !0;
	}
}
function typeFactory(_) {
	return castFactory(et);
	function et(tt) {
		return tt && tt.type === _;
	}
}
function castFactory(_) {
	return et;
	function et(...tt) {
		return Boolean(_.call(this, ...tt));
	}
}
function ok() {
	return !0;
}
function color(_) {
	return _;
}
const CONTINUE = !0,
	SKIP = "skip",
	EXIT = !1,
	visitParents = function (_, et, tt, nt) {
		typeof et == "function" && typeof tt != "function" && ((nt = tt), (tt = et), (et = null));
		const rt = convert(et),
			it = nt ? -1 : 1;
		ot(_, null, [])();
		function ot(at, st, lt) {
			const ut = typeof at == "object" && at !== null ? at : {};
			let dt;
			return (
				typeof ut.type == "string" &&
					((dt = typeof ut.tagName == "string" ? ut.tagName : typeof ut.name == "string" ? ut.name : void 0),
					Object.defineProperty(ct, "name", { value: "node (" + (ut.type + (dt ? "<" + dt + ">" : "")) + ")" })),
				ct
			);
			function ct() {
				let ft = [],
					mt,
					pt,
					vt;
				if ((!et || rt(at, st, lt[lt.length - 1] || null)) && ((ft = toResult(tt(at, lt))), ft[0] === EXIT)) return ft;
				if (at.children && ft[0] !== SKIP)
					for (pt = (nt ? at.children.length : -1) + it, vt = lt.concat(at); pt > -1 && pt < at.children.length; ) {
						if (((mt = ot(at.children[pt], pt, vt)()), mt[0] === EXIT)) return mt;
						pt = typeof mt[1] == "number" ? mt[1] : pt + it;
					}
				return ft;
			}
		}
	};
function toResult(_) {
	return Array.isArray(_) ? _ : typeof _ == "number" ? [CONTINUE, _] : [_];
}
const visit = function (_, et, tt, nt) {
		typeof et == "function" && typeof tt != "function" && ((nt = tt), (tt = et), (et = null)),
			visitParents(_, et, rt, nt);
		function rt(it, ot) {
			const at = ot[ot.length - 1];
			return tt(it, at ? at.children.indexOf(it) : null, at);
		}
	},
	pointStart = point("start"),
	pointEnd = point("end");
function point(_) {
	return et;
	function et(tt) {
		const nt = (tt && tt.position && tt.position[_]) || {};
		return { line: nt.line || null, column: nt.column || null, offset: nt.offset > -1 ? nt.offset : null };
	}
}
function generated(_) {
	return (
		!_ ||
		!_.position ||
		!_.position.start ||
		!_.position.start.line ||
		!_.position.start.column ||
		!_.position.end ||
		!_.position.end.line ||
		!_.position.end.column
	);
}
const own$4 = {}.hasOwnProperty;
function definitions(_) {
	const et = Object.create(null);
	if (!_ || !_.type) throw new Error("mdast-util-definitions expected node");
	return (
		visit(_, "definition", (nt) => {
			const rt = clean(nt.identifier);
			rt && !own$4.call(et, rt) && (et[rt] = nt);
		}),
		tt
	);
	function tt(nt) {
		const rt = clean(nt);
		return rt && own$4.call(et, rt) ? et[rt] : null;
	}
}
function clean(_) {
	return String(_ || "").toUpperCase();
}
function normalizeUri(_) {
	const et = [];
	let tt = -1,
		nt = 0,
		rt = 0;
	for (; ++tt < _.length; ) {
		const it = _.charCodeAt(tt);
		let ot = "";
		if (it === 37 && asciiAlphanumeric(_.charCodeAt(tt + 1)) && asciiAlphanumeric(_.charCodeAt(tt + 2))) rt = 2;
		else if (it < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(it)) || (ot = String.fromCharCode(it));
		else if (it > 55295 && it < 57344) {
			const at = _.charCodeAt(tt + 1);
			it < 56320 && at > 56319 && at < 57344 ? ((ot = String.fromCharCode(it, at)), (rt = 1)) : (ot = "\uFFFD");
		} else ot = String.fromCharCode(it);
		ot && (et.push(_.slice(nt, tt), encodeURIComponent(ot)), (nt = tt + rt + 1), (ot = "")),
			rt && ((tt += rt), (rt = 0));
	}
	return et.join("") + _.slice(nt);
}
function wrap(_, et) {
	const tt = [];
	let nt = -1;
	for (
		et &&
		tt.push(
			u$1(
				"text",
				`
`
			)
		);
		++nt < _.length;

	)
		nt &&
			tt.push(
				u$1(
					"text",
					`
`
				)
			),
			tt.push(_[nt]);
	return (
		et &&
			_.length > 0 &&
			tt.push(
				u$1(
					"text",
					`
`
				)
			),
		tt
	);
}
function footer(_) {
	let et = -1;
	const tt = [];
	for (; ++et < _.footnoteOrder.length; ) {
		const nt = _.footnoteById[_.footnoteOrder[et].toUpperCase()];
		if (!nt) continue;
		const rt = all(_, nt),
			it = String(nt.identifier),
			ot = normalizeUri(it.toLowerCase());
		let at = 0;
		const st = [];
		for (; ++at <= _.footnoteCounts[it]; ) {
			const dt = {
				type: "element",
				tagName: "a",
				properties: {
					href: "#" + _.clobberPrefix + "fnref-" + ot + (at > 1 ? "-" + at : ""),
					dataFootnoteBackref: !0,
					className: ["data-footnote-backref"],
					ariaLabel: _.footnoteBackLabel,
				},
				children: [{ type: "text", value: "\u21A9" }],
			};
			at > 1 && dt.children.push({ type: "element", tagName: "sup", children: [{ type: "text", value: String(at) }] }),
				st.length > 0 && st.push({ type: "text", value: " " }),
				st.push(dt);
		}
		const lt = rt[rt.length - 1];
		if (lt && lt.type === "element" && lt.tagName === "p") {
			const dt = lt.children[lt.children.length - 1];
			dt && dt.type === "text" ? (dt.value += " ") : lt.children.push({ type: "text", value: " " }),
				lt.children.push(...st);
		} else rt.push(...st);
		const ut = {
			type: "element",
			tagName: "li",
			properties: { id: _.clobberPrefix + "fn-" + ot },
			children: wrap(rt, !0),
		};
		nt.position && (ut.position = nt.position), tt.push(ut);
	}
	return tt.length === 0
		? null
		: {
				type: "element",
				tagName: "section",
				properties: { dataFootnotes: !0, className: ["footnotes"] },
				children: [
					{
						type: "element",
						tagName: _.footnoteLabelTagName,
						properties: { ...JSON.parse(JSON.stringify(_.footnoteLabelProperties)), id: "footnote-label" },
						children: [u$1("text", _.footnoteLabel)],
					},
					{
						type: "text",
						value: `
`,
					},
					{ type: "element", tagName: "ol", properties: {}, children: wrap(tt, !0) },
					{
						type: "text",
						value: `
`,
					},
				],
		  };
}
function blockquote(_, et) {
	return _(et, "blockquote", wrap(all(_, et), !0));
}
function hardBreak(_, et) {
	return [
		_(et, "br"),
		u$1(
			"text",
			`
`
		),
	];
}
function code(_, et) {
	const tt = et.value
			? et.value +
			  `
`
			: "",
		nt = et.lang && et.lang.match(/^[^ \t]+(?=[ \t]|$)/),
		rt = {};
	nt && (rt.className = ["language-" + nt]);
	const it = _(et, "code", rt, [u$1("text", tt)]);
	return et.meta && (it.data = { meta: et.meta }), _(et.position, "pre", [it]);
}
function strikethrough(_, et) {
	return _(et, "del", all(_, et));
}
function emphasis(_, et) {
	return _(et, "em", all(_, et));
}
function footnoteReference(_, et) {
	const tt = String(et.identifier),
		nt = normalizeUri(tt.toLowerCase()),
		rt = _.footnoteOrder.indexOf(tt);
	let it;
	rt === -1
		? (_.footnoteOrder.push(tt), (_.footnoteCounts[tt] = 1), (it = _.footnoteOrder.length))
		: (_.footnoteCounts[tt]++, (it = rt + 1));
	const ot = _.footnoteCounts[tt];
	return _(et, "sup", [
		_(
			et.position,
			"a",
			{
				href: "#" + _.clobberPrefix + "fn-" + nt,
				id: _.clobberPrefix + "fnref-" + nt + (ot > 1 ? "-" + ot : ""),
				dataFootnoteRef: !0,
				ariaDescribedBy: "footnote-label",
			},
			[u$1("text", String(it))]
		),
	]);
}
function footnote(_, et) {
	const tt = _.footnoteById;
	let nt = 1;
	for (; nt in tt; ) nt++;
	const rt = String(nt);
	return (
		(tt[rt] = {
			type: "footnoteDefinition",
			identifier: rt,
			children: [{ type: "paragraph", children: et.children }],
			position: et.position,
		}),
		footnoteReference(_, { type: "footnoteReference", identifier: rt, position: et.position })
	);
}
function heading(_, et) {
	return _(et, "h" + et.depth, all(_, et));
}
function html$2(_, et) {
	return _.dangerous ? _.augment(et, u$1("raw", et.value)) : null;
}
function revert(_, et) {
	const tt = et.referenceType;
	let nt = "]";
	if (
		(tt === "collapsed" ? (nt += "[]") : tt === "full" && (nt += "[" + (et.label || et.identifier) + "]"),
		et.type === "imageReference")
	)
		return u$1("text", "![" + et.alt + nt);
	const rt = all(_, et),
		it = rt[0];
	it && it.type === "text" ? (it.value = "[" + it.value) : rt.unshift(u$1("text", "["));
	const ot = rt[rt.length - 1];
	return ot && ot.type === "text" ? (ot.value += nt) : rt.push(u$1("text", nt)), rt;
}
function imageReference(_, et) {
	const tt = _.definition(et.identifier);
	if (!tt) return revert(_, et);
	const nt = { src: normalizeUri(tt.url || ""), alt: et.alt };
	return tt.title !== null && tt.title !== void 0 && (nt.title = tt.title), _(et, "img", nt);
}
function image(_, et) {
	const tt = { src: normalizeUri(et.url), alt: et.alt };
	return et.title !== null && et.title !== void 0 && (tt.title = et.title), _(et, "img", tt);
}
function inlineCode(_, et) {
	return _(et, "code", [u$1("text", et.value.replace(/\r?\n|\r/g, " "))]);
}
function linkReference(_, et) {
	const tt = _.definition(et.identifier);
	if (!tt) return revert(_, et);
	const nt = { href: normalizeUri(tt.url || "") };
	return tt.title !== null && tt.title !== void 0 && (nt.title = tt.title), _(et, "a", nt, all(_, et));
}
function link(_, et) {
	const tt = { href: normalizeUri(et.url) };
	return et.title !== null && et.title !== void 0 && (tt.title = et.title), _(et, "a", tt, all(_, et));
}
function listItem(_, et, tt) {
	const nt = all(_, et),
		rt = tt ? listLoose(tt) : listItemLoose(et),
		it = {},
		ot = [];
	if (typeof et.checked == "boolean") {
		let lt;
		nt[0] && nt[0].type === "element" && nt[0].tagName === "p"
			? (lt = nt[0])
			: ((lt = _(null, "p", [])), nt.unshift(lt)),
			lt.children.length > 0 && lt.children.unshift(u$1("text", " ")),
			lt.children.unshift(_(null, "input", { type: "checkbox", checked: et.checked, disabled: !0 })),
			(it.className = ["task-list-item"]);
	}
	let at = -1;
	for (; ++at < nt.length; ) {
		const lt = nt[at];
		(rt || at !== 0 || lt.type !== "element" || lt.tagName !== "p") &&
			ot.push(
				u$1(
					"text",
					`
`
				)
			),
			lt.type === "element" && lt.tagName === "p" && !rt ? ot.push(...lt.children) : ot.push(lt);
	}
	const st = nt[nt.length - 1];
	return (
		st &&
			(rt || !("tagName" in st) || st.tagName !== "p") &&
			ot.push(
				u$1(
					"text",
					`
`
				)
			),
		_(et, "li", it, ot)
	);
}
function listLoose(_) {
	let et = _.spread;
	const tt = _.children;
	let nt = -1;
	for (; !et && ++nt < tt.length; ) et = listItemLoose(tt[nt]);
	return Boolean(et);
}
function listItemLoose(_) {
	const et = _.spread;
	return et == null ? _.children.length > 1 : et;
}
function list(_, et) {
	const tt = {},
		nt = et.ordered ? "ol" : "ul",
		rt = all(_, et);
	let it = -1;
	for (typeof et.start == "number" && et.start !== 1 && (tt.start = et.start); ++it < rt.length; ) {
		const ot = rt[it];
		if (
			ot.type === "element" &&
			ot.tagName === "li" &&
			ot.properties &&
			Array.isArray(ot.properties.className) &&
			ot.properties.className.includes("task-list-item")
		) {
			tt.className = ["contains-task-list"];
			break;
		}
	}
	return _(et, nt, tt, wrap(rt, !0));
}
function paragraph(_, et) {
	return _(et, "p", all(_, et));
}
function root(_, et) {
	return _.augment(et, u$1("root", wrap(all(_, et))));
}
function strong(_, et) {
	return _(et, "strong", all(_, et));
}
function table(_, et) {
	const tt = et.children;
	let nt = -1;
	const rt = et.align || [],
		it = [];
	for (; ++nt < tt.length; ) {
		const ot = tt[nt].children,
			at = nt === 0 ? "th" : "td",
			st = [];
		let lt = -1;
		const ut = et.align ? rt.length : ot.length;
		for (; ++lt < ut; ) {
			const dt = ot[lt];
			st.push(_(dt, at, { align: rt[lt] }, dt ? all(_, dt) : []));
		}
		it[nt] = _(tt[nt], "tr", wrap(st, !0));
	}
	return _(
		et,
		"table",
		wrap(
			[_(it[0].position, "thead", wrap([it[0]], !0))].concat(
				it[1] ? _({ start: pointStart(it[1]), end: pointEnd(it[it.length - 1]) }, "tbody", wrap(it.slice(1), !0)) : []
			),
			!0
		)
	);
}
const tab = 9,
	space = 32;
function trimLines(_) {
	const et = String(_),
		tt = /\r?\n|\r/g;
	let nt = tt.exec(et),
		rt = 0;
	const it = [];
	for (; nt; )
		it.push(trimLine(et.slice(rt, nt.index), rt > 0, !0), nt[0]), (rt = nt.index + nt[0].length), (nt = tt.exec(et));
	return it.push(trimLine(et.slice(rt), rt > 0, !1)), it.join("");
}
function trimLine(_, et, tt) {
	let nt = 0,
		rt = _.length;
	if (et) {
		let it = _.codePointAt(nt);
		for (; it === tab || it === space; ) nt++, (it = _.codePointAt(nt));
	}
	if (tt) {
		let it = _.codePointAt(rt - 1);
		for (; it === tab || it === space; ) rt--, (it = _.codePointAt(rt - 1));
	}
	return rt > nt ? _.slice(nt, rt) : "";
}
function text(_, et) {
	return _.augment(et, u$1("text", trimLines(String(et.value))));
}
function thematicBreak(_, et) {
	return _(et, "hr");
}
const handlers = {
	blockquote,
	break: hardBreak,
	code,
	delete: strikethrough,
	emphasis,
	footnoteReference,
	footnote,
	heading,
	html: html$2,
	imageReference,
	image,
	inlineCode,
	linkReference,
	link,
	listItem,
	list,
	paragraph,
	root,
	strong,
	table,
	text,
	thematicBreak,
	toml: ignore,
	yaml: ignore,
	definition: ignore,
	footnoteDefinition: ignore,
};
function ignore() {
	return null;
}
const own$3 = {}.hasOwnProperty;
function factory(_, et) {
	const tt = et || {},
		nt = tt.allowDangerousHtml || !1,
		rt = {};
	return (
		(ot.dangerous = nt),
		(ot.clobberPrefix = tt.clobberPrefix === void 0 || tt.clobberPrefix === null ? "user-content-" : tt.clobberPrefix),
		(ot.footnoteLabel = tt.footnoteLabel || "Footnotes"),
		(ot.footnoteLabelTagName = tt.footnoteLabelTagName || "h2"),
		(ot.footnoteLabelProperties = tt.footnoteLabelProperties || { className: ["sr-only"] }),
		(ot.footnoteBackLabel = tt.footnoteBackLabel || "Back to content"),
		(ot.definition = definitions(_)),
		(ot.footnoteById = rt),
		(ot.footnoteOrder = []),
		(ot.footnoteCounts = {}),
		(ot.augment = it),
		(ot.handlers = { ...handlers, ...tt.handlers }),
		(ot.unknownHandler = tt.unknownHandler),
		(ot.passThrough = tt.passThrough),
		visit(_, "footnoteDefinition", (at) => {
			const st = String(at.identifier).toUpperCase();
			own$3.call(rt, st) || (rt[st] = at);
		}),
		ot
	);
	function it(at, st) {
		if (at && "data" in at && at.data) {
			const lt = at.data;
			lt.hName &&
				(st.type !== "element" && (st = { type: "element", tagName: "", properties: {}, children: [] }),
				(st.tagName = lt.hName)),
				st.type === "element" && lt.hProperties && (st.properties = { ...st.properties, ...lt.hProperties }),
				"children" in st && st.children && lt.hChildren && (st.children = lt.hChildren);
		}
		if (at) {
			const lt = "type" in at ? at : { position: at };
			generated(lt) || (st.position = { start: pointStart(lt), end: pointEnd(lt) });
		}
		return st;
	}
	function ot(at, st, lt, ut) {
		return (
			Array.isArray(lt) && ((ut = lt), (lt = {})),
			it(at, { type: "element", tagName: st, properties: lt || {}, children: ut || [] })
		);
	}
}
function toHast(_, et) {
	const tt = factory(_, et),
		nt = one(tt, _, null),
		rt = footer(tt);
	return (
		rt &&
			nt.children.push(
				u$1(
					"text",
					`
`
				),
				rt
			),
		Array.isArray(nt) ? { type: "root", children: nt } : nt
	);
}
const remarkRehype = function (_, et) {
		return _ && "run" in _ ? bridge(_, et) : mutate(_ || et);
	},
	remarkRehype$1 = remarkRehype;
function bridge(_, et) {
	return (tt, nt, rt) => {
		_.run(toHast(tt, et), nt, (it) => {
			rt(it);
		});
	};
}
function mutate(_) {
	return (et) => toHast(et, _);
}
class Schema {
	constructor(et, tt, nt) {
		(this.property = et), (this.normal = tt), nt && (this.space = nt);
	}
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(_, et) {
	const tt = {},
		nt = {};
	let rt = -1;
	for (; ++rt < _.length; ) Object.assign(tt, _[rt].property), Object.assign(nt, _[rt].normal);
	return new Schema(tt, nt, et);
}
function normalize(_) {
	return _.toLowerCase();
}
class Info {
	constructor(et, tt) {
		(this.property = et), (this.attribute = tt);
	}
}
Info.prototype.space = null;
Info.prototype.boolean = !1;
Info.prototype.booleanish = !1;
Info.prototype.overloadedBoolean = !1;
Info.prototype.number = !1;
Info.prototype.commaSeparated = !1;
Info.prototype.spaceSeparated = !1;
Info.prototype.commaOrSpaceSeparated = !1;
Info.prototype.mustUseProperty = !1;
Info.prototype.defined = !1;
let powers = 0;
const boolean = increment(),
	booleanish = increment(),
	overloadedBoolean = increment(),
	number = increment(),
	spaceSeparated = increment(),
	commaSeparated = increment(),
	commaOrSpaceSeparated = increment();
function increment() {
	return 2 ** ++powers;
}
const types = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				boolean,
				booleanish,
				overloadedBoolean,
				number,
				spaceSeparated,
				commaSeparated,
				commaOrSpaceSeparated,
			},
			Symbol.toStringTag,
			{ value: "Module" }
		)
	),
	checks = Object.keys(types);
class DefinedInfo extends Info {
	constructor(et, tt, nt, rt) {
		let it = -1;
		if ((super(et, tt), mark(this, "space", rt), typeof nt == "number"))
			for (; ++it < checks.length; ) {
				const ot = checks[it];
				mark(this, checks[it], (nt & types[ot]) === types[ot]);
			}
	}
}
DefinedInfo.prototype.defined = !0;
function mark(_, et, tt) {
	tt && (_[et] = tt);
}
const own$2 = {}.hasOwnProperty;
function create(_) {
	const et = {},
		tt = {};
	let nt;
	for (nt in _.properties)
		if (own$2.call(_.properties, nt)) {
			const rt = _.properties[nt],
				it = new DefinedInfo(nt, _.transform(_.attributes || {}, nt), rt, _.space);
			_.mustUseProperty && _.mustUseProperty.includes(nt) && (it.mustUseProperty = !0),
				(et[nt] = it),
				(tt[normalize(nt)] = nt),
				(tt[normalize(it.attribute)] = nt);
		}
	return new Schema(et, tt, _.space);
}
const xlink = create({
		space: "xlink",
		transform(_, et) {
			return "xlink:" + et.slice(5).toLowerCase();
		},
		properties: {
			xLinkActuate: null,
			xLinkArcRole: null,
			xLinkHref: null,
			xLinkRole: null,
			xLinkShow: null,
			xLinkTitle: null,
			xLinkType: null,
		},
	}),
	xml = create({
		space: "xml",
		transform(_, et) {
			return "xml:" + et.slice(3).toLowerCase();
		},
		properties: { xmlLang: null, xmlBase: null, xmlSpace: null },
	});
function caseSensitiveTransform(_, et) {
	return et in _ ? _[et] : et;
}
function caseInsensitiveTransform(_, et) {
	return caseSensitiveTransform(_, et.toLowerCase());
}
const xmlns = create({
		space: "xmlns",
		attributes: { xmlnsxlink: "xmlns:xlink" },
		transform: caseInsensitiveTransform,
		properties: { xmlns: null, xmlnsXLink: null },
	}),
	aria = create({
		transform(_, et) {
			return et === "role" ? et : "aria-" + et.slice(4).toLowerCase();
		},
		properties: {
			ariaActiveDescendant: null,
			ariaAtomic: booleanish,
			ariaAutoComplete: null,
			ariaBusy: booleanish,
			ariaChecked: booleanish,
			ariaColCount: number,
			ariaColIndex: number,
			ariaColSpan: number,
			ariaControls: spaceSeparated,
			ariaCurrent: null,
			ariaDescribedBy: spaceSeparated,
			ariaDetails: null,
			ariaDisabled: booleanish,
			ariaDropEffect: spaceSeparated,
			ariaErrorMessage: null,
			ariaExpanded: booleanish,
			ariaFlowTo: spaceSeparated,
			ariaGrabbed: booleanish,
			ariaHasPopup: null,
			ariaHidden: booleanish,
			ariaInvalid: null,
			ariaKeyShortcuts: null,
			ariaLabel: null,
			ariaLabelledBy: spaceSeparated,
			ariaLevel: number,
			ariaLive: null,
			ariaModal: booleanish,
			ariaMultiLine: booleanish,
			ariaMultiSelectable: booleanish,
			ariaOrientation: null,
			ariaOwns: spaceSeparated,
			ariaPlaceholder: null,
			ariaPosInSet: number,
			ariaPressed: booleanish,
			ariaReadOnly: booleanish,
			ariaRelevant: null,
			ariaRequired: booleanish,
			ariaRoleDescription: spaceSeparated,
			ariaRowCount: number,
			ariaRowIndex: number,
			ariaRowSpan: number,
			ariaSelected: booleanish,
			ariaSetSize: number,
			ariaSort: null,
			ariaValueMax: number,
			ariaValueMin: number,
			ariaValueNow: number,
			ariaValueText: null,
			role: null,
		},
	}),
	html$1 = create({
		space: "html",
		attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" },
		transform: caseInsensitiveTransform,
		mustUseProperty: ["checked", "multiple", "muted", "selected"],
		properties: {
			abbr: null,
			accept: commaSeparated,
			acceptCharset: spaceSeparated,
			accessKey: spaceSeparated,
			action: null,
			allow: null,
			allowFullScreen: boolean,
			allowPaymentRequest: boolean,
			allowUserMedia: boolean,
			alt: null,
			as: null,
			async: boolean,
			autoCapitalize: null,
			autoComplete: spaceSeparated,
			autoFocus: boolean,
			autoPlay: boolean,
			capture: boolean,
			charSet: null,
			checked: boolean,
			cite: null,
			className: spaceSeparated,
			cols: number,
			colSpan: null,
			content: null,
			contentEditable: booleanish,
			controls: boolean,
			controlsList: spaceSeparated,
			coords: number | commaSeparated,
			crossOrigin: null,
			data: null,
			dateTime: null,
			decoding: null,
			default: boolean,
			defer: boolean,
			dir: null,
			dirName: null,
			disabled: boolean,
			download: overloadedBoolean,
			draggable: booleanish,
			encType: null,
			enterKeyHint: null,
			form: null,
			formAction: null,
			formEncType: null,
			formMethod: null,
			formNoValidate: boolean,
			formTarget: null,
			headers: spaceSeparated,
			height: number,
			hidden: boolean,
			high: number,
			href: null,
			hrefLang: null,
			htmlFor: spaceSeparated,
			httpEquiv: spaceSeparated,
			id: null,
			imageSizes: null,
			imageSrcSet: null,
			inputMode: null,
			integrity: null,
			is: null,
			isMap: boolean,
			itemId: null,
			itemProp: spaceSeparated,
			itemRef: spaceSeparated,
			itemScope: boolean,
			itemType: spaceSeparated,
			kind: null,
			label: null,
			lang: null,
			language: null,
			list: null,
			loading: null,
			loop: boolean,
			low: number,
			manifest: null,
			max: null,
			maxLength: number,
			media: null,
			method: null,
			min: null,
			minLength: number,
			multiple: boolean,
			muted: boolean,
			name: null,
			nonce: null,
			noModule: boolean,
			noValidate: boolean,
			onAbort: null,
			onAfterPrint: null,
			onAuxClick: null,
			onBeforePrint: null,
			onBeforeUnload: null,
			onBlur: null,
			onCancel: null,
			onCanPlay: null,
			onCanPlayThrough: null,
			onChange: null,
			onClick: null,
			onClose: null,
			onContextLost: null,
			onContextMenu: null,
			onContextRestored: null,
			onCopy: null,
			onCueChange: null,
			onCut: null,
			onDblClick: null,
			onDrag: null,
			onDragEnd: null,
			onDragEnter: null,
			onDragExit: null,
			onDragLeave: null,
			onDragOver: null,
			onDragStart: null,
			onDrop: null,
			onDurationChange: null,
			onEmptied: null,
			onEnded: null,
			onError: null,
			onFocus: null,
			onFormData: null,
			onHashChange: null,
			onInput: null,
			onInvalid: null,
			onKeyDown: null,
			onKeyPress: null,
			onKeyUp: null,
			onLanguageChange: null,
			onLoad: null,
			onLoadedData: null,
			onLoadedMetadata: null,
			onLoadEnd: null,
			onLoadStart: null,
			onMessage: null,
			onMessageError: null,
			onMouseDown: null,
			onMouseEnter: null,
			onMouseLeave: null,
			onMouseMove: null,
			onMouseOut: null,
			onMouseOver: null,
			onMouseUp: null,
			onOffline: null,
			onOnline: null,
			onPageHide: null,
			onPageShow: null,
			onPaste: null,
			onPause: null,
			onPlay: null,
			onPlaying: null,
			onPopState: null,
			onProgress: null,
			onRateChange: null,
			onRejectionHandled: null,
			onReset: null,
			onResize: null,
			onScroll: null,
			onSecurityPolicyViolation: null,
			onSeeked: null,
			onSeeking: null,
			onSelect: null,
			onSlotChange: null,
			onStalled: null,
			onStorage: null,
			onSubmit: null,
			onSuspend: null,
			onTimeUpdate: null,
			onToggle: null,
			onUnhandledRejection: null,
			onUnload: null,
			onVolumeChange: null,
			onWaiting: null,
			onWheel: null,
			open: boolean,
			optimum: number,
			pattern: null,
			ping: spaceSeparated,
			placeholder: null,
			playsInline: boolean,
			poster: null,
			preload: null,
			readOnly: boolean,
			referrerPolicy: null,
			rel: spaceSeparated,
			required: boolean,
			reversed: boolean,
			rows: number,
			rowSpan: number,
			sandbox: spaceSeparated,
			scope: null,
			scoped: boolean,
			seamless: boolean,
			selected: boolean,
			shape: null,
			size: number,
			sizes: null,
			slot: null,
			span: number,
			spellCheck: booleanish,
			src: null,
			srcDoc: null,
			srcLang: null,
			srcSet: null,
			start: number,
			step: null,
			style: null,
			tabIndex: number,
			target: null,
			title: null,
			translate: null,
			type: null,
			typeMustMatch: boolean,
			useMap: null,
			value: booleanish,
			width: number,
			wrap: null,
			align: null,
			aLink: null,
			archive: spaceSeparated,
			axis: null,
			background: null,
			bgColor: null,
			border: number,
			borderColor: null,
			bottomMargin: number,
			cellPadding: null,
			cellSpacing: null,
			char: null,
			charOff: null,
			classId: null,
			clear: null,
			code: null,
			codeBase: null,
			codeType: null,
			color: null,
			compact: boolean,
			declare: boolean,
			event: null,
			face: null,
			frame: null,
			frameBorder: null,
			hSpace: number,
			leftMargin: number,
			link: null,
			longDesc: null,
			lowSrc: null,
			marginHeight: number,
			marginWidth: number,
			noResize: boolean,
			noHref: boolean,
			noShade: boolean,
			noWrap: boolean,
			object: null,
			profile: null,
			prompt: null,
			rev: null,
			rightMargin: number,
			rules: null,
			scheme: null,
			scrolling: booleanish,
			standby: null,
			summary: null,
			text: null,
			topMargin: number,
			valueType: null,
			version: null,
			vAlign: null,
			vLink: null,
			vSpace: number,
			allowTransparency: null,
			autoCorrect: null,
			autoSave: null,
			disablePictureInPicture: boolean,
			disableRemotePlayback: boolean,
			prefix: null,
			property: null,
			results: number,
			security: null,
			unselectable: null,
		},
	}),
	svg$1 = create({
		space: "svg",
		attributes: {
			accentHeight: "accent-height",
			alignmentBaseline: "alignment-baseline",
			arabicForm: "arabic-form",
			baselineShift: "baseline-shift",
			capHeight: "cap-height",
			className: "class",
			clipPath: "clip-path",
			clipRule: "clip-rule",
			colorInterpolation: "color-interpolation",
			colorInterpolationFilters: "color-interpolation-filters",
			colorProfile: "color-profile",
			colorRendering: "color-rendering",
			crossOrigin: "crossorigin",
			dataType: "datatype",
			dominantBaseline: "dominant-baseline",
			enableBackground: "enable-background",
			fillOpacity: "fill-opacity",
			fillRule: "fill-rule",
			floodColor: "flood-color",
			floodOpacity: "flood-opacity",
			fontFamily: "font-family",
			fontSize: "font-size",
			fontSizeAdjust: "font-size-adjust",
			fontStretch: "font-stretch",
			fontStyle: "font-style",
			fontVariant: "font-variant",
			fontWeight: "font-weight",
			glyphName: "glyph-name",
			glyphOrientationHorizontal: "glyph-orientation-horizontal",
			glyphOrientationVertical: "glyph-orientation-vertical",
			hrefLang: "hreflang",
			horizAdvX: "horiz-adv-x",
			horizOriginX: "horiz-origin-x",
			horizOriginY: "horiz-origin-y",
			imageRendering: "image-rendering",
			letterSpacing: "letter-spacing",
			lightingColor: "lighting-color",
			markerEnd: "marker-end",
			markerMid: "marker-mid",
			markerStart: "marker-start",
			navDown: "nav-down",
			navDownLeft: "nav-down-left",
			navDownRight: "nav-down-right",
			navLeft: "nav-left",
			navNext: "nav-next",
			navPrev: "nav-prev",
			navRight: "nav-right",
			navUp: "nav-up",
			navUpLeft: "nav-up-left",
			navUpRight: "nav-up-right",
			onAbort: "onabort",
			onActivate: "onactivate",
			onAfterPrint: "onafterprint",
			onBeforePrint: "onbeforeprint",
			onBegin: "onbegin",
			onCancel: "oncancel",
			onCanPlay: "oncanplay",
			onCanPlayThrough: "oncanplaythrough",
			onChange: "onchange",
			onClick: "onclick",
			onClose: "onclose",
			onCopy: "oncopy",
			onCueChange: "oncuechange",
			onCut: "oncut",
			onDblClick: "ondblclick",
			onDrag: "ondrag",
			onDragEnd: "ondragend",
			onDragEnter: "ondragenter",
			onDragExit: "ondragexit",
			onDragLeave: "ondragleave",
			onDragOver: "ondragover",
			onDragStart: "ondragstart",
			onDrop: "ondrop",
			onDurationChange: "ondurationchange",
			onEmptied: "onemptied",
			onEnd: "onend",
			onEnded: "onended",
			onError: "onerror",
			onFocus: "onfocus",
			onFocusIn: "onfocusin",
			onFocusOut: "onfocusout",
			onHashChange: "onhashchange",
			onInput: "oninput",
			onInvalid: "oninvalid",
			onKeyDown: "onkeydown",
			onKeyPress: "onkeypress",
			onKeyUp: "onkeyup",
			onLoad: "onload",
			onLoadedData: "onloadeddata",
			onLoadedMetadata: "onloadedmetadata",
			onLoadStart: "onloadstart",
			onMessage: "onmessage",
			onMouseDown: "onmousedown",
			onMouseEnter: "onmouseenter",
			onMouseLeave: "onmouseleave",
			onMouseMove: "onmousemove",
			onMouseOut: "onmouseout",
			onMouseOver: "onmouseover",
			onMouseUp: "onmouseup",
			onMouseWheel: "onmousewheel",
			onOffline: "onoffline",
			onOnline: "ononline",
			onPageHide: "onpagehide",
			onPageShow: "onpageshow",
			onPaste: "onpaste",
			onPause: "onpause",
			onPlay: "onplay",
			onPlaying: "onplaying",
			onPopState: "onpopstate",
			onProgress: "onprogress",
			onRateChange: "onratechange",
			onRepeat: "onrepeat",
			onReset: "onreset",
			onResize: "onresize",
			onScroll: "onscroll",
			onSeeked: "onseeked",
			onSeeking: "onseeking",
			onSelect: "onselect",
			onShow: "onshow",
			onStalled: "onstalled",
			onStorage: "onstorage",
			onSubmit: "onsubmit",
			onSuspend: "onsuspend",
			onTimeUpdate: "ontimeupdate",
			onToggle: "ontoggle",
			onUnload: "onunload",
			onVolumeChange: "onvolumechange",
			onWaiting: "onwaiting",
			onZoom: "onzoom",
			overlinePosition: "overline-position",
			overlineThickness: "overline-thickness",
			paintOrder: "paint-order",
			panose1: "panose-1",
			pointerEvents: "pointer-events",
			referrerPolicy: "referrerpolicy",
			renderingIntent: "rendering-intent",
			shapeRendering: "shape-rendering",
			stopColor: "stop-color",
			stopOpacity: "stop-opacity",
			strikethroughPosition: "strikethrough-position",
			strikethroughThickness: "strikethrough-thickness",
			strokeDashArray: "stroke-dasharray",
			strokeDashOffset: "stroke-dashoffset",
			strokeLineCap: "stroke-linecap",
			strokeLineJoin: "stroke-linejoin",
			strokeMiterLimit: "stroke-miterlimit",
			strokeOpacity: "stroke-opacity",
			strokeWidth: "stroke-width",
			tabIndex: "tabindex",
			textAnchor: "text-anchor",
			textDecoration: "text-decoration",
			textRendering: "text-rendering",
			typeOf: "typeof",
			underlinePosition: "underline-position",
			underlineThickness: "underline-thickness",
			unicodeBidi: "unicode-bidi",
			unicodeRange: "unicode-range",
			unitsPerEm: "units-per-em",
			vAlphabetic: "v-alphabetic",
			vHanging: "v-hanging",
			vIdeographic: "v-ideographic",
			vMathematical: "v-mathematical",
			vectorEffect: "vector-effect",
			vertAdvY: "vert-adv-y",
			vertOriginX: "vert-origin-x",
			vertOriginY: "vert-origin-y",
			wordSpacing: "word-spacing",
			writingMode: "writing-mode",
			xHeight: "x-height",
			playbackOrder: "playbackorder",
			timelineBegin: "timelinebegin",
		},
		transform: caseSensitiveTransform,
		properties: {
			about: commaOrSpaceSeparated,
			accentHeight: number,
			accumulate: null,
			additive: null,
			alignmentBaseline: null,
			alphabetic: number,
			amplitude: number,
			arabicForm: null,
			ascent: number,
			attributeName: null,
			attributeType: null,
			azimuth: number,
			bandwidth: null,
			baselineShift: null,
			baseFrequency: null,
			baseProfile: null,
			bbox: null,
			begin: null,
			bias: number,
			by: null,
			calcMode: null,
			capHeight: number,
			className: spaceSeparated,
			clip: null,
			clipPath: null,
			clipPathUnits: null,
			clipRule: null,
			color: null,
			colorInterpolation: null,
			colorInterpolationFilters: null,
			colorProfile: null,
			colorRendering: null,
			content: null,
			contentScriptType: null,
			contentStyleType: null,
			crossOrigin: null,
			cursor: null,
			cx: null,
			cy: null,
			d: null,
			dataType: null,
			defaultAction: null,
			descent: number,
			diffuseConstant: number,
			direction: null,
			display: null,
			dur: null,
			divisor: number,
			dominantBaseline: null,
			download: boolean,
			dx: null,
			dy: null,
			edgeMode: null,
			editable: null,
			elevation: number,
			enableBackground: null,
			end: null,
			event: null,
			exponent: number,
			externalResourcesRequired: null,
			fill: null,
			fillOpacity: number,
			fillRule: null,
			filter: null,
			filterRes: null,
			filterUnits: null,
			floodColor: null,
			floodOpacity: null,
			focusable: null,
			focusHighlight: null,
			fontFamily: null,
			fontSize: null,
			fontSizeAdjust: null,
			fontStretch: null,
			fontStyle: null,
			fontVariant: null,
			fontWeight: null,
			format: null,
			fr: null,
			from: null,
			fx: null,
			fy: null,
			g1: commaSeparated,
			g2: commaSeparated,
			glyphName: commaSeparated,
			glyphOrientationHorizontal: null,
			glyphOrientationVertical: null,
			glyphRef: null,
			gradientTransform: null,
			gradientUnits: null,
			handler: null,
			hanging: number,
			hatchContentUnits: null,
			hatchUnits: null,
			height: null,
			href: null,
			hrefLang: null,
			horizAdvX: number,
			horizOriginX: number,
			horizOriginY: number,
			id: null,
			ideographic: number,
			imageRendering: null,
			initialVisibility: null,
			in: null,
			in2: null,
			intercept: number,
			k: number,
			k1: number,
			k2: number,
			k3: number,
			k4: number,
			kernelMatrix: commaOrSpaceSeparated,
			kernelUnitLength: null,
			keyPoints: null,
			keySplines: null,
			keyTimes: null,
			kerning: null,
			lang: null,
			lengthAdjust: null,
			letterSpacing: null,
			lightingColor: null,
			limitingConeAngle: number,
			local: null,
			markerEnd: null,
			markerMid: null,
			markerStart: null,
			markerHeight: null,
			markerUnits: null,
			markerWidth: null,
			mask: null,
			maskContentUnits: null,
			maskUnits: null,
			mathematical: null,
			max: null,
			media: null,
			mediaCharacterEncoding: null,
			mediaContentEncodings: null,
			mediaSize: number,
			mediaTime: null,
			method: null,
			min: null,
			mode: null,
			name: null,
			navDown: null,
			navDownLeft: null,
			navDownRight: null,
			navLeft: null,
			navNext: null,
			navPrev: null,
			navRight: null,
			navUp: null,
			navUpLeft: null,
			navUpRight: null,
			numOctaves: null,
			observer: null,
			offset: null,
			onAbort: null,
			onActivate: null,
			onAfterPrint: null,
			onBeforePrint: null,
			onBegin: null,
			onCancel: null,
			onCanPlay: null,
			onCanPlayThrough: null,
			onChange: null,
			onClick: null,
			onClose: null,
			onCopy: null,
			onCueChange: null,
			onCut: null,
			onDblClick: null,
			onDrag: null,
			onDragEnd: null,
			onDragEnter: null,
			onDragExit: null,
			onDragLeave: null,
			onDragOver: null,
			onDragStart: null,
			onDrop: null,
			onDurationChange: null,
			onEmptied: null,
			onEnd: null,
			onEnded: null,
			onError: null,
			onFocus: null,
			onFocusIn: null,
			onFocusOut: null,
			onHashChange: null,
			onInput: null,
			onInvalid: null,
			onKeyDown: null,
			onKeyPress: null,
			onKeyUp: null,
			onLoad: null,
			onLoadedData: null,
			onLoadedMetadata: null,
			onLoadStart: null,
			onMessage: null,
			onMouseDown: null,
			onMouseEnter: null,
			onMouseLeave: null,
			onMouseMove: null,
			onMouseOut: null,
			onMouseOver: null,
			onMouseUp: null,
			onMouseWheel: null,
			onOffline: null,
			onOnline: null,
			onPageHide: null,
			onPageShow: null,
			onPaste: null,
			onPause: null,
			onPlay: null,
			onPlaying: null,
			onPopState: null,
			onProgress: null,
			onRateChange: null,
			onRepeat: null,
			onReset: null,
			onResize: null,
			onScroll: null,
			onSeeked: null,
			onSeeking: null,
			onSelect: null,
			onShow: null,
			onStalled: null,
			onStorage: null,
			onSubmit: null,
			onSuspend: null,
			onTimeUpdate: null,
			onToggle: null,
			onUnload: null,
			onVolumeChange: null,
			onWaiting: null,
			onZoom: null,
			opacity: null,
			operator: null,
			order: null,
			orient: null,
			orientation: null,
			origin: null,
			overflow: null,
			overlay: null,
			overlinePosition: number,
			overlineThickness: number,
			paintOrder: null,
			panose1: null,
			path: null,
			pathLength: number,
			patternContentUnits: null,
			patternTransform: null,
			patternUnits: null,
			phase: null,
			ping: spaceSeparated,
			pitch: null,
			playbackOrder: null,
			pointerEvents: null,
			points: null,
			pointsAtX: number,
			pointsAtY: number,
			pointsAtZ: number,
			preserveAlpha: null,
			preserveAspectRatio: null,
			primitiveUnits: null,
			propagate: null,
			property: commaOrSpaceSeparated,
			r: null,
			radius: null,
			referrerPolicy: null,
			refX: null,
			refY: null,
			rel: commaOrSpaceSeparated,
			rev: commaOrSpaceSeparated,
			renderingIntent: null,
			repeatCount: null,
			repeatDur: null,
			requiredExtensions: commaOrSpaceSeparated,
			requiredFeatures: commaOrSpaceSeparated,
			requiredFonts: commaOrSpaceSeparated,
			requiredFormats: commaOrSpaceSeparated,
			resource: null,
			restart: null,
			result: null,
			rotate: null,
			rx: null,
			ry: null,
			scale: null,
			seed: null,
			shapeRendering: null,
			side: null,
			slope: null,
			snapshotTime: null,
			specularConstant: number,
			specularExponent: number,
			spreadMethod: null,
			spacing: null,
			startOffset: null,
			stdDeviation: null,
			stemh: null,
			stemv: null,
			stitchTiles: null,
			stopColor: null,
			stopOpacity: null,
			strikethroughPosition: number,
			strikethroughThickness: number,
			string: null,
			stroke: null,
			strokeDashArray: commaOrSpaceSeparated,
			strokeDashOffset: null,
			strokeLineCap: null,
			strokeLineJoin: null,
			strokeMiterLimit: number,
			strokeOpacity: number,
			strokeWidth: null,
			style: null,
			surfaceScale: number,
			syncBehavior: null,
			syncBehaviorDefault: null,
			syncMaster: null,
			syncTolerance: null,
			syncToleranceDefault: null,
			systemLanguage: commaOrSpaceSeparated,
			tabIndex: number,
			tableValues: null,
			target: null,
			targetX: number,
			targetY: number,
			textAnchor: null,
			textDecoration: null,
			textRendering: null,
			textLength: null,
			timelineBegin: null,
			title: null,
			transformBehavior: null,
			type: null,
			typeOf: commaOrSpaceSeparated,
			to: null,
			transform: null,
			u1: null,
			u2: null,
			underlinePosition: number,
			underlineThickness: number,
			unicode: null,
			unicodeBidi: null,
			unicodeRange: null,
			unitsPerEm: number,
			values: null,
			vAlphabetic: number,
			vMathematical: number,
			vectorEffect: null,
			vHanging: number,
			vIdeographic: number,
			version: null,
			vertAdvY: number,
			vertOriginX: number,
			vertOriginY: number,
			viewBox: null,
			viewTarget: null,
			visibility: null,
			width: null,
			widths: null,
			wordSpacing: null,
			writingMode: null,
			x: null,
			x1: null,
			x2: null,
			xChannelSelector: null,
			xHeight: number,
			y: null,
			y1: null,
			y2: null,
			yChannelSelector: null,
			z: null,
			zoomAndPan: null,
		},
	}),
	valid = /^data[-\w.:]+$/i,
	dash = /-[a-z]/g,
	cap = /[A-Z]/g;
function find(_, et) {
	const tt = normalize(et);
	let nt = et,
		rt = Info;
	if (tt in _.normal) return _.property[_.normal[tt]];
	if (tt.length > 4 && tt.slice(0, 4) === "data" && valid.test(et)) {
		if (et.charAt(4) === "-") {
			const it = et.slice(5).replace(dash, camelcase);
			nt = "data" + it.charAt(0).toUpperCase() + it.slice(1);
		} else {
			const it = et.slice(4);
			if (!dash.test(it)) {
				let ot = it.replace(cap, kebab);
				ot.charAt(0) !== "-" && (ot = "-" + ot), (et = "data" + ot);
			}
		}
		rt = DefinedInfo;
	}
	return new rt(nt, et);
}
function kebab(_) {
	return "-" + _.toLowerCase();
}
function camelcase(_) {
	return _.charAt(1).toUpperCase();
}
const hastToReact = {
		classId: "classID",
		dataType: "datatype",
		itemId: "itemID",
		strokeDashArray: "strokeDasharray",
		strokeDashOffset: "strokeDashoffset",
		strokeLineCap: "strokeLinecap",
		strokeLineJoin: "strokeLinejoin",
		strokeMiterLimit: "strokeMiterlimit",
		typeOf: "typeof",
		xLinkActuate: "xlinkActuate",
		xLinkArcRole: "xlinkArcrole",
		xLinkHref: "xlinkHref",
		xLinkRole: "xlinkRole",
		xLinkShow: "xlinkShow",
		xLinkTitle: "xlinkTitle",
		xLinkType: "xlinkType",
		xmlnsXLink: "xmlnsXlink",
	},
	html = merge([xml, xlink, xmlns, aria, html$1], "html"),
	svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
function rehypeFilter(_) {
	if (_.allowedElements && _.disallowedElements)
		throw new TypeError("Only one of `allowedElements` and `disallowedElements` should be defined");
	if (_.allowedElements || _.disallowedElements || _.allowElement)
		return (et) => {
			visit(et, "element", (tt, nt, rt) => {
				const it = rt;
				let ot;
				if (
					(_.allowedElements
						? (ot = !_.allowedElements.includes(tt.tagName))
						: _.disallowedElements && (ot = _.disallowedElements.includes(tt.tagName)),
					!ot && _.allowElement && typeof nt == "number" && (ot = !_.allowElement(tt, nt, it)),
					ot && typeof nt == "number")
				)
					return (
						_.unwrapDisallowed && tt.children ? it.children.splice(nt, 1, ...tt.children) : it.children.splice(nt, 1),
						nt
					);
			});
		};
}
var reactIs = { exports: {} },
	reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b = Symbol.for("react.element"),
	c = Symbol.for("react.portal"),
	d = Symbol.for("react.fragment"),
	e = Symbol.for("react.strict_mode"),
	f = Symbol.for("react.profiler"),
	g = Symbol.for("react.provider"),
	h = Symbol.for("react.context"),
	k = Symbol.for("react.server_context"),
	l = Symbol.for("react.forward_ref"),
	m = Symbol.for("react.suspense"),
	n = Symbol.for("react.suspense_list"),
	p = Symbol.for("react.memo"),
	q = Symbol.for("react.lazy"),
	t = Symbol.for("react.offscreen"),
	u;
u = Symbol.for("react.module.reference");
function v(_) {
	if (typeof _ == "object" && _ !== null) {
		var et = _.$$typeof;
		switch (et) {
			case b:
				switch (((_ = _.type), _)) {
					case d:
					case f:
					case e:
					case m:
					case n:
						return _;
					default:
						switch (((_ = _ && _.$$typeof), _)) {
							case k:
							case h:
							case l:
							case q:
							case p:
							case g:
								return _;
							default:
								return et;
						}
				}
			case c:
				return et;
		}
	}
}
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p;
reactIs_production_min.Portal = c;
reactIs_production_min.Profiler = f;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m;
reactIs_production_min.SuspenseList = n;
reactIs_production_min.isAsyncMode = function () {
	return !1;
};
reactIs_production_min.isConcurrentMode = function () {
	return !1;
};
reactIs_production_min.isContextConsumer = function (_) {
	return v(_) === h;
};
reactIs_production_min.isContextProvider = function (_) {
	return v(_) === g;
};
reactIs_production_min.isElement = function (_) {
	return typeof _ == "object" && _ !== null && _.$$typeof === b;
};
reactIs_production_min.isForwardRef = function (_) {
	return v(_) === l;
};
reactIs_production_min.isFragment = function (_) {
	return v(_) === d;
};
reactIs_production_min.isLazy = function (_) {
	return v(_) === q;
};
reactIs_production_min.isMemo = function (_) {
	return v(_) === p;
};
reactIs_production_min.isPortal = function (_) {
	return v(_) === c;
};
reactIs_production_min.isProfiler = function (_) {
	return v(_) === f;
};
reactIs_production_min.isStrictMode = function (_) {
	return v(_) === e;
};
reactIs_production_min.isSuspense = function (_) {
	return v(_) === m;
};
reactIs_production_min.isSuspenseList = function (_) {
	return v(_) === n;
};
reactIs_production_min.isValidElementType = function (_) {
	return (
		typeof _ == "string" ||
		typeof _ == "function" ||
		_ === d ||
		_ === f ||
		_ === e ||
		_ === m ||
		_ === n ||
		_ === t ||
		(typeof _ == "object" &&
			_ !== null &&
			(_.$$typeof === q ||
				_.$$typeof === p ||
				_.$$typeof === g ||
				_.$$typeof === h ||
				_.$$typeof === l ||
				_.$$typeof === u ||
				_.getModuleId !== void 0))
	);
};
reactIs_production_min.typeOf = v;
(function (_) {
	_.exports = reactIs_production_min;
})(reactIs);
const ReactIs = getDefaultExportFromCjs(reactIs.exports);
function whitespace(_) {
	var et = _ && typeof _ == "object" && _.type === "text" ? _.value || "" : _;
	return typeof et == "string" && et.replace(/[ \t\n\f\r]/g, "") === "";
}
function stringify$1(_) {
	return _.join(" ").trim();
}
function stringify(_, et) {
	const tt = et || {};
	return (_[_.length - 1] === "" ? [..._, ""] : _)
		.join((tt.padRight ? " " : "") + "," + (tt.padLeft === !1 ? "" : " "))
		.trim();
}
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
	NEWLINE_REGEX = /\n/g,
	WHITESPACE_REGEX = /^\s*/,
	PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
	COLON_REGEX = /^:\s*/,
	VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
	SEMICOLON_REGEX = /^[;\s]*/,
	TRIM_REGEX = /^\s+|\s+$/g,
	NEWLINE = `
`,
	FORWARD_SLASH = "/",
	ASTERISK = "*",
	EMPTY_STRING = "",
	TYPE_COMMENT = "comment",
	TYPE_DECLARATION = "declaration",
	inlineStyleParser = function (_, et) {
		if (typeof _ != "string") throw new TypeError("First argument must be a string");
		if (!_) return [];
		et = et || {};
		var tt = 1,
			nt = 1;
		function rt(mt) {
			var pt = mt.match(NEWLINE_REGEX);
			pt && (tt += pt.length);
			var vt = mt.lastIndexOf(NEWLINE);
			nt = ~vt ? mt.length - vt : nt + mt.length;
		}
		function it() {
			var mt = { line: tt, column: nt };
			return function (pt) {
				return (pt.position = new ot(mt)), lt(), pt;
			};
		}
		function ot(mt) {
			(this.start = mt), (this.end = { line: tt, column: nt }), (this.source = et.source);
		}
		ot.prototype.content = _;
		function at(mt) {
			var pt = new Error(et.source + ":" + tt + ":" + nt + ": " + mt);
			if (((pt.reason = mt), (pt.filename = et.source), (pt.line = tt), (pt.column = nt), (pt.source = _), !et.silent))
				throw pt;
		}
		function st(mt) {
			var pt = mt.exec(_);
			if (!!pt) {
				var vt = pt[0];
				return rt(vt), (_ = _.slice(vt.length)), pt;
			}
		}
		function lt() {
			st(WHITESPACE_REGEX);
		}
		function ut(mt) {
			var pt;
			for (mt = mt || []; (pt = dt()); ) pt !== !1 && mt.push(pt);
			return mt;
		}
		function dt() {
			var mt = it();
			if (!(FORWARD_SLASH != _.charAt(0) || ASTERISK != _.charAt(1))) {
				for (
					var pt = 2;
					EMPTY_STRING != _.charAt(pt) && (ASTERISK != _.charAt(pt) || FORWARD_SLASH != _.charAt(pt + 1));

				)
					++pt;
				if (((pt += 2), EMPTY_STRING === _.charAt(pt - 1))) return at("End of comment missing");
				var vt = _.slice(2, pt - 2);
				return (nt += 2), rt(vt), (_ = _.slice(pt)), (nt += 2), mt({ type: TYPE_COMMENT, comment: vt });
			}
		}
		function ct() {
			var mt = it(),
				pt = st(PROPERTY_REGEX);
			if (!!pt) {
				if ((dt(), !st(COLON_REGEX))) return at("property missing ':'");
				var vt = st(VALUE_REGEX),
					ht = mt({
						type: TYPE_DECLARATION,
						property: trim(pt[0].replace(COMMENT_REGEX, EMPTY_STRING)),
						value: vt ? trim(vt[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING,
					});
				return st(SEMICOLON_REGEX), ht;
			}
		}
		function ft() {
			var mt = [];
			ut(mt);
			for (var pt; (pt = ct()); ) pt !== !1 && (mt.push(pt), ut(mt));
			return mt;
		}
		return lt(), ft();
	};
function trim(_) {
	return _ ? _.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var parse = inlineStyleParser;
function StyleToObject(_, et) {
	var tt = null;
	if (!_ || typeof _ != "string") return tt;
	for (var nt, rt = parse(_), it = typeof et == "function", ot, at, st = 0, lt = rt.length; st < lt; st++)
		(nt = rt[st]), (ot = nt.property), (at = nt.value), it ? et(ot, at, nt) : at && (tt || (tt = {}), (tt[ot] = at));
	return tt;
}
var styleToObject = StyleToObject;
const own$1 = {}.hasOwnProperty,
	tableElements = new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function childrenToReact(_, et) {
	const tt = [];
	let nt = -1,
		rt;
	for (; ++nt < et.children.length; )
		(rt = et.children[nt]),
			rt.type === "element"
				? tt.push(toReact(_, rt, nt, et))
				: rt.type === "text"
				? (et.type !== "element" || !tableElements.has(et.tagName) || !whitespace(rt)) && tt.push(rt.value)
				: rt.type === "raw" && !_.options.skipHtml && tt.push(rt.value);
	return tt;
}
function toReact(_, et, tt, nt) {
	const rt = _.options,
		it = _.schema,
		ot = et.tagName,
		at = {};
	let st = it,
		lt;
	if ((it.space === "html" && ot === "svg" && ((st = svg), (_.schema = st)), et.properties))
		for (lt in et.properties) own$1.call(et.properties, lt) && addProperty(at, lt, et.properties[lt], _);
	(ot === "ol" || ot === "ul") && _.listDepth++;
	const ut = childrenToReact(_, et);
	(ot === "ol" || ot === "ul") && _.listDepth--, (_.schema = it);
	const dt = et.position || {
			start: { line: null, column: null, offset: null },
			end: { line: null, column: null, offset: null },
		},
		ct = rt.components && own$1.call(rt.components, ot) ? rt.components[ot] : ot,
		ft = typeof ct == "string" || ct === React$1.Fragment;
	if (!ReactIs.isValidElementType(ct))
		throw new TypeError(`Component for name \`${ot}\` not defined or is not renderable`);
	if (
		((at.key = [ot, dt.start.line, dt.start.column, tt].join("-")),
		ot === "a" &&
			rt.linkTarget &&
			(at.target =
				typeof rt.linkTarget == "function"
					? rt.linkTarget(String(at.href || ""), et.children, typeof at.title == "string" ? at.title : null)
					: rt.linkTarget),
		ot === "a" &&
			rt.transformLinkUri &&
			(at.href = rt.transformLinkUri(
				String(at.href || ""),
				et.children,
				typeof at.title == "string" ? at.title : null
			)),
		!ft && ot === "code" && nt.type === "element" && nt.tagName !== "pre" && (at.inline = !0),
		!ft &&
			(ot === "h1" || ot === "h2" || ot === "h3" || ot === "h4" || ot === "h5" || ot === "h6") &&
			(at.level = Number.parseInt(ot.charAt(1), 10)),
		ot === "img" &&
			rt.transformImageUri &&
			(at.src = rt.transformImageUri(
				String(at.src || ""),
				String(at.alt || ""),
				typeof at.title == "string" ? at.title : null
			)),
		!ft && ot === "li" && nt.type === "element")
	) {
		const mt = getInputElement(et);
		(at.checked = mt && mt.properties ? Boolean(mt.properties.checked) : null),
			(at.index = getElementsBeforeCount(nt, et)),
			(at.ordered = nt.tagName === "ol");
	}
	return (
		!ft && (ot === "ol" || ot === "ul") && ((at.ordered = ot === "ol"), (at.depth = _.listDepth)),
		(ot === "td" || ot === "th") &&
			(at.align && (at.style || (at.style = {}), (at.style.textAlign = at.align), delete at.align),
			ft || (at.isHeader = ot === "th")),
		!ft && ot === "tr" && nt.type === "element" && (at.isHeader = Boolean(nt.tagName === "thead")),
		rt.sourcePos && (at["data-sourcepos"] = flattenPosition(dt)),
		!ft && rt.rawSourcePos && (at.sourcePosition = et.position),
		!ft &&
			rt.includeElementIndex &&
			((at.index = getElementsBeforeCount(nt, et)), (at.siblingCount = getElementsBeforeCount(nt))),
		ft || (at.node = et),
		ut.length > 0 ? React$1.createElement(ct, at, ut) : React$1.createElement(ct, at)
	);
}
function getInputElement(_) {
	let et = -1;
	for (; ++et < _.children.length; ) {
		const tt = _.children[et];
		if (tt.type === "element" && tt.tagName === "input") return tt;
	}
	return null;
}
function getElementsBeforeCount(_, et) {
	let tt = -1,
		nt = 0;
	for (; ++tt < _.children.length && _.children[tt] !== et; ) _.children[tt].type === "element" && nt++;
	return nt;
}
function addProperty(_, et, tt, nt) {
	const rt = find(nt.schema, et);
	let it = tt;
	it == null ||
		it !== it ||
		(Array.isArray(it) && (it = rt.commaSeparated ? stringify(it) : stringify$1(it)),
		rt.property === "style" && typeof it == "string" && (it = parseStyle(it)),
		rt.space && rt.property
			? (_[own$1.call(hastToReact, rt.property) ? hastToReact[rt.property] : rt.property] = it)
			: rt.attribute && (_[rt.attribute] = it));
}
function parseStyle(_) {
	const et = {};
	try {
		styleToObject(_, tt);
	} catch {}
	return et;
	function tt(nt, rt) {
		const it = nt.slice(0, 4) === "-ms-" ? `ms-${nt.slice(4)}` : nt;
		et[it.replace(/-([a-z])/g, styleReplacer)] = rt;
	}
}
function styleReplacer(_, et) {
	return et.toUpperCase();
}
function flattenPosition(_) {
	return [_.start.line, ":", _.start.column, "-", _.end.line, ":", _.end.column].map((et) => String(et)).join("");
}
const own = {}.hasOwnProperty,
	changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md",
	deprecated = {
		plugins: { to: "plugins", id: "change-plugins-to-remarkplugins" },
		renderers: { to: "components", id: "change-renderers-to-components" },
		astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
		allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
		escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
		source: { to: "children", id: "change-source-to-children" },
		allowNode: { to: "allowElement", id: "replace-allownode-allowedtypes-and-disallowedtypes" },
		allowedTypes: { to: "allowedElements", id: "replace-allownode-allowedtypes-and-disallowedtypes" },
		disallowedTypes: { to: "disallowedElements", id: "replace-allownode-allowedtypes-and-disallowedtypes" },
		includeNodeIndex: { to: "includeElementIndex", id: "change-includenodeindex-to-includeelementindex" },
	};
function ReactMarkdown(_) {
	for (const it in deprecated)
		if (own.call(deprecated, it) && own.call(_, it)) {
			const ot = deprecated[it];
			console.warn(
				`[react-markdown] Warning: please ${
					ot.to ? `use \`${ot.to}\` instead of` : "remove"
				} \`${it}\` (see <${changelog}#${ot.id}> for more info)`
			),
				delete deprecated[it];
		}
	const et = unified()
			.use(remarkParse)
			.use(_.remarkPlugins || [])
			.use(remarkRehype$1, { ..._.remarkRehypeOptions, allowDangerousHtml: !0 })
			.use(_.rehypePlugins || [])
			.use(rehypeFilter, _),
		tt = new VFile();
	typeof _.children == "string"
		? (tt.value = _.children)
		: _.children !== void 0 &&
		  _.children !== null &&
		  console.warn(`[react-markdown] Warning: please pass a string as \`children\` (not: \`${_.children}\`)`);
	const nt = et.runSync(et.parse(tt), tt);
	if (nt.type !== "root") throw new TypeError("Expected a `root` node");
	let rt = jsx(Fragment, { children: childrenToReact({ options: _, schema: html, listDepth: 0 }, nt) });
	return _.className && (rt = jsx("div", { className: _.className, children: rt })), rt;
}
ReactMarkdown.defaultProps = { transformLinkUri: uriTransformer };
ReactMarkdown.propTypes = {
	children: propTypes.exports.string,
	className: propTypes.exports.string,
	allowElement: propTypes.exports.func,
	allowedElements: propTypes.exports.arrayOf(propTypes.exports.string),
	disallowedElements: propTypes.exports.arrayOf(propTypes.exports.string),
	unwrapDisallowed: propTypes.exports.bool,
	remarkPlugins: propTypes.exports.arrayOf(
		propTypes.exports.oneOfType([
			propTypes.exports.object,
			propTypes.exports.func,
			propTypes.exports.arrayOf(
				propTypes.exports.oneOfType([
					propTypes.exports.bool,
					propTypes.exports.string,
					propTypes.exports.object,
					propTypes.exports.func,
					propTypes.exports.arrayOf(propTypes.exports.any),
				])
			),
		])
	),
	rehypePlugins: propTypes.exports.arrayOf(
		propTypes.exports.oneOfType([
			propTypes.exports.object,
			propTypes.exports.func,
			propTypes.exports.arrayOf(
				propTypes.exports.oneOfType([
					propTypes.exports.bool,
					propTypes.exports.string,
					propTypes.exports.object,
					propTypes.exports.func,
					propTypes.exports.arrayOf(propTypes.exports.any),
				])
			),
		])
	),
	sourcePos: propTypes.exports.bool,
	rawSourcePos: propTypes.exports.bool,
	skipHtml: propTypes.exports.bool,
	includeElementIndex: propTypes.exports.bool,
	transformLinkUri: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.bool]),
	linkTarget: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.string]),
	transformImageUri: propTypes.exports.func,
	components: propTypes.exports.object,
};
const FirstTimeModal = ({ startWalkThrough: _ }) => {
		const { isOpen: et, onOpen: tt, onClose: nt } = useDisclosure$1(),
			rt = react.exports.useRef(null),
			it = () => {
				var at;
				localStorage.setItem(
					"walkThroughPrompt",
					JSON.stringify(((at = rt.current) == null ? void 0 : at.checked) || !1)
				),
					nt(),
					_(!0);
			},
			ot = () => {
				var at;
				localStorage.setItem(
					"walkThroughPrompt",
					JSON.stringify(((at = rt.current) == null ? void 0 : at.checked) || !1)
				),
					nt();
			};
		return (
			react.exports.useEffect(() => {
				localStorage.getItem("walkThroughPrompt") !== "true" && tt();
			}, []),
			jsx(DarkMode, {
				children: jsxs(Modal, {
					onClose: nt,
					isOpen: et,
					isCentered: !0,
					children: [
						jsx(ModalOverlay, {}),
						jsxs(ModalContent, {
							color: "white",
							children: [
								jsx(ModalHeader, { children: "Welcome to the Tutorial" }),
								jsx(ModalCloseButton, {}),
								jsxs(ModalBody, {
									children: [
										jsx(Text$2, { children: "Want to take the tour of the layout?" }),
										jsxs("div", {
											className: "flex items-start mt-5",
											children: [
												jsx("div", {
													className: "flex h-5 items-center",
													children: jsx("input", {
														id: "comments",
														name: "comments",
														type: "checkbox",
														ref: rt,
														className: "h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500",
													}),
												}),
												jsx("div", {
													className: "ml-3 text-sm",
													children: jsx("label", {
														htmlFor: "comments",
														className: "font-medium text-gray-300",
														children: "Don't ask again (You can still access it in Settings)",
													}),
												}),
											],
										}),
									],
								}),
								jsxs(ModalFooter, {
									children: [
										jsx(Button, { onClick: ot, mx: 2, variant: "ghost", children: "No thanks" }),
										jsx(Button, { onClick: it, colorScheme: "green", children: "Yes, let's do it" }),
									],
								}),
							],
						}),
					],
				}),
			})
		);
	},
	SettingsButton = ({ ide: _, info: et, gui: tt, setGui: nt, startWalkThrough: rt }) => {
		useColorMode();
		const it = () => {
				rt(!0);
			},
			ot = () => {
				localStorage.removeItem("walkThroughPrompt");
			};
		return jsx(DarkMode, {
			children: jsxs(Menu, {
				closeOnSelect: !1,
				children: [
					jsx(MenuButton, {
						leftIcon: jsx(FaCog, {}),
						rightIcon: jsx(ChevronDownIcon, {}),
						as: Button,
						className: " sixth-step",
						size: "sm",
						color: "white",
						children: "Settings",
					}),
					jsxs(MenuList, {
						minWidth: "240px",
						fontSize: "sm",
						color: "white",
						borderColor: "gray.600",
						children: [
							jsxs(MenuOptionGroup, {
								title: "Tutorial",
								type: "checkbox",
								children: [
									jsx(MenuItemOption, {
										value: "toggleSplitScreen",
										onClick: () => nt({ ...tt, toggleWidth: !tt.toggleWidth }),
										children: "Toggle Split Screen View",
									}),
									jsx(MenuItemOption, { value: "triggerLayoutTour", onClick: it, children: "Start Layout Tour" }),
								],
							}),
							!(et != null && et.legacy) &&
								jsxs(Fragment, {
									children: [
										jsx(MenuDivider, {}),
										jsxs(MenuOptionGroup, {
											title: "CSnap",
											type: "checkbox",
											children: [
												jsx(MenuItemOption, {
													value: "singlePalette",
													onClick: () => _.toggleSinglePalette(),
													children: "Toggle Single Palette",
												}),
												jsx(MenuItemOption, {
													value: "corralBar",
													onClick: () => _.toggleCorralBar(),
													children: "Toggle Corral Bar",
												}),
												jsx(MenuItemOption, { value: "tabs", onClick: () => _.toggleTabs(), children: "Toggle Tabs" }),
												jsx(MenuItemOption, {
													value: "spriteBar",
													onClick: () => _.toggleSpriteBar(),
													children: "Toggle Sprite Bar",
												}),
											],
										}),
									],
								}),
							jsx(MenuDivider, {}),
							jsx(MenuGroup, {
								title: "Misc",
								children: jsx(MenuItem, {
									value: "resetLayoutTour",
									onClick: ot,
									closeOnSelect: !0,
									children: "Reset Layout Tour Prompt",
								}),
							}),
						],
					}),
				],
			}),
		});
	},
	StepSelectionDrawer = ({ title: _, steps: et, current: tt, handleOnClick: nt }) => {
		const { isOpen: rt, onOpen: it, onClose: ot } = useDisclosure$1(),
			at = react.exports.useRef(null);
		return jsxs(DarkMode, {
			children: [
				jsx("button", {
					className:
						"text-white seventh-step ml-2 text-sm border border-gray-500  px-3 h-8 rounded-md leading-4 font-semibold hover:bg-gray-500 hover:bg-opacity-20 transition ease-linear duration-150",
					"aria-label": "Tutorial Step Selection",
					ref: at,
					onClick: it,
					children: jsx(FaBars, {}),
				}),
				jsxs(Drawer, {
					isOpen: rt,
					placement: "right",
					onClose: ot,
					finalFocusRef: at,
					children: [
						jsx(ModalOverlay, {}),
						jsxs(DrawerContent, {
							children: [
								jsx(ModalCloseButton, {}),
								jsxs("header", {
									className: "text-2xl py-4 px-6 flex-0 font-semibold leading-9 overflow-auto text-white mr-4",
									children: [_, " Steps"],
								}),
								jsx("div", {
									className: "flex-1 overflow-auto py-2 px-6",
									children:
										et &&
										et.map((st) =>
											jsx(
												"div",
												{
													className:
														"flex text-center px-4 pl-4 py-3 cursor-pointer text-gray-400 hover:bg-gray-900 hover:text-gray-300 font-semibold transition ease-linear duration-150",
													onClick: () => {
														nt(st), ot();
													},
													children: jsx("span", {
														className: `${tt === st.id && "text-blue-300"}`,
														children: st.title,
													}),
												},
												st.title
											)
										),
								}),
								jsx("footer", {
									className: "py-4 px-6",
									children: jsx("button", {
										className:
											"w-full border border-gray-600 py-2 rounded-md font-medium hover:bg-gray-500 hover:bg-opacity-50 transition ease-linear text-white",
										onClick: ot,
										children: "Close",
									}),
								}),
							],
						}),
					],
				}),
			],
		});
	},
	CodeImage = ({ source: _ }) => jsx("img", { src: _, alt: "The step's blocks", className: "px-2 mx-auto py-5 w-2/3" }),
	OutcomeImage = ({ source: _ }) => jsx("img", { src: _, alt: "The result when you finish the tutorial" }),
	StepVideo = ({ source: _ }) =>
		jsxs(Fragment, {
			children: [
				jsx("div", {
					className: "w-full aspect-video",
					children: jsx(Plyr, {
						options: {
							controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "settings", "fullscreen"],
						},
						source: { type: "video", sources: [{ src: _ != null ? _ : "", type: "video/mp4" }] },
					}),
				}),
				" ",
			],
		});
function ChevronUpIcon({ title: _, titleId: et, ...tt }, nt) {
	return jsxs("svg", {
		...Object.assign(
			{
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20",
				fill: "currentColor",
				"aria-hidden": "true",
				ref: nt,
				"aria-labelledby": et,
			},
			tt
		),
		children: [
			_ ? jsx("title", { id: et, children: _ }) : null,
			jsx("path", {
				fillRule: "evenodd",
				d: "M14.77 12.79a.75.75 0 01-1.06-.02L10 8.832 6.29 12.77a.75.75 0 11-1.08-1.04l4.25-4.5a.75.75 0 011.08 0l4.25 4.5a.75.75 0 01-.02 1.06z",
				clipRule: "evenodd",
			}),
		],
	});
}
const ForwardRef = react.exports.forwardRef(ChevronUpIcon),
	ChevronUpIcon$1 = ForwardRef,
	VideoDescription = ({ tagline: _, source: et }) => {
		const [tt, nt] = react.exports.useState("");
		return (
			react.exports.useEffect(() => {
				et
					? fetch(et)
							.then((rt) => rt.text())
							.then((rt) => nt(rt))
							.catch((rt) => console.error(rt))
					: nt("");
			}, [et]),
			jsx("div", {
				className: "w-full  pt-4",
				children: jsx("div", {
					className: "mx-auto w-full max-w-md rounded-2xl bg-gray-400 bg-opacity-10  p-2",
					children: jsx(Oe, {
						children: ({ open: rt }) =>
							jsxs(Fragment, {
								children: [
									jsxs(Oe.Button, {
										className:
											" flex w-full justify-between rounded-lg bg-gray-700 px-4 py-2 text-left text-sm font-medium text-slate-400 hover:bg-gray-600 focus:outline-none focus-visible:ring focus-visible:ring-purple-500 focus-visible:ring-opacity-75",
										children: [
											jsx("span", { children: _ }),
											jsx(ChevronUpIcon$1, {
												className: `${
													rt ? "rotate-180 transform" : ""
												} h-5 w-5 text-slate-500 transition duration-100 ease-linear`,
											}),
										],
									}),
									jsx(Oe.Panel, {
										className: "px-4 pt-4 pb-2 text-gray-500 text-base max-h-96 overflow-y-auto my-2",
										children: jsx(ReactMarkdown, { components: q$1(), children: tt, skipHtml: !0 }),
									}),
								],
							}),
					}),
				}),
			})
		);
	},
	SidebarContainer = ({ toggleWidth: _, children: et }) =>
		jsx("nav", {
			className: `second-step z-auto bg-gray-800 fixed hidden md:flex md:flex-col ${
				_ ? "w-2/6" : "w-96"
			}  top-0 left-0 h-full px-8 pt-5 pb-10 overflow-x-hidden overflow-y-auto border-r-black border-opacity-30  ease-linear duration-200 transition-all`,
			children: et,
		});
function Sidebar(_) {
	const { info: et, step: tt, setStep: nt, available: rt, isCodeShown: it, toggleWidth: ot } = _,
		[at, st] = react.exports.useState(0),
		lt = "assets/" + (et == null ? void 0 : et.prefix),
		ut = lt + (tt == null ? void 0 : tt.code),
		dt = lt + (tt == null ? void 0 : tt.video),
		ct = lt + (tt == null ? void 0 : tt.outcome),
		ft = lt + (tt == null ? void 0 : tt.explanation);
	return jsxs(SidebarContainer, {
		toggleWidth: ot,
		children: [
			jsx("header", {
				className: "font-semibold text-xl pt-5 text-gray-50",
				children: et == null ? void 0 : et.tutorial_title,
			}),
			rt &&
				rt.length > 0 &&
				jsx(StepProgressBar, {
					current: {
						get: () => at,
						set: (mt) => {
							st(mt.id), nt(mt);
						},
					},
					available: rt,
				}),
			jsx("section", {
				className: "flex flex-col justify-between",
				children: jsxs("div", {
					className: "flex flex-col text-sm",
					"aria-label": "Main Navigation",
					children: [
						jsx("p", { className: "text-lg text-slate-600", children: "Instructions" }),
						(tt == null ? void 0 : tt.video) && jsx(StepVideo, { source: dt }),
						(tt == null ? void 0 : tt.explanation) &&
							(tt == null ? void 0 : tt.tagline) &&
							jsx(VideoDescription, { source: ft, tagline: tt == null ? void 0 : tt.tagline }),
						(tt == null ? void 0 : tt.outcome) && jsx(OutcomeImage, { source: ct }),
						(tt == null ? void 0 : tt.code) && it && jsx(CodeImage, { source: ut }),
					],
				}),
			}),
			rt &&
				rt.length > 0 &&
				jsx(StepNavigation, {
					current: {
						get: () => at,
						set: (mt) => {
							st(mt), nt(rt[mt]);
						},
					},
					available: rt,
				}),
		],
	});
}
function Tutorial({ name: _ }) {
	const et = useDisclosure$1(),
		{ isOpen: tt, onOpen: nt, onClose: rt } = useDisclosure$1(),
		{ info: it, data: ot, isLoading: at } = FetchService.selectSet(_),
		[st, lt] = react.exports.useState(null),
		[ut, dt] = react.exports.useState(null),
		[ct, ft] = react.exports.useState(null),
		[mt, pt] = react.exports.useState(null);
	react.exports.useEffect(() => {
		if (ot) {
			let yt = ot.slice(1).map((xt, St) => ({ ...xt, id: St }));
			lt(yt), dt(yt[0]), ft(it.prefix + it.base);
		}
	}, [ot]);
	const { setIsOpen: vt } = useTour();
	react.exports.useEffect(() => {
		(ut == null ? void 0 : ut.id) == (st == null ? void 0 : st.length) - 1 && nt(),
			ut != null && ut.explanation
				? fetch(`assets/${it == null ? void 0 : it.prefix}${ut == null ? void 0 : ut.explanation}`)
						.then((yt) => yt.text())
						.then((yt) => gt({ ...ht, longDescription: yt }))
						.catch((yt) => console.error(yt))
				: gt({ ...ht, longDescription: "text" });
	}, [ut]);
	const [ht, gt] = react.exports.useState({
		toggleWidth: !1,
		isCodeShown: !1,
		isLongDescriptionShown: !1,
		longDescription: "",
	});
	return jsxs(Fragment, {
		children: [
			jsx(FirstTimeModal, { startWalkThrough: vt }),
			(ut == null ? void 0 : ut.id) == (st == null ? void 0 : st.length) - 1 &&
				jsx(FinalModal, { isOpen: tt, onOpen: nt, onClose: rt, ...ut }),
			jsxs("section", {
				className: "bg-gray-700 min-h-screen first-step final-step",
				children: [
					jsx(Sidebar, {
						info: it,
						step: ut,
						setStep: dt,
						available: st,
						isCodeShown: ht.isCodeShown,
						toggleWidth: ht.toggleWidth,
					}),
					jsxs(Drawer, {
						isOpen: et.isOpen,
						onClose: et.onClose,
						placement: "left",
						zIndex: "auto",
						children: [
							jsx(ModalOverlay, {}),
							jsxs(DrawerContent, {
								children: [
									jsx(ModalCloseButton, { zIndex: 1 }),
									jsx(SidebarContent, {
										display: { base: "flex" },
										flexDirection: "column",
										w: "full",
										borderRight: "none",
										info: it,
										step: ut,
										setStep: dt,
										available: st,
										isCodeShown: ht.isCodeShown,
									}),
								],
							}),
						],
					}),
					jsxs("section", {
						className: `${ht.toggleWidth && "w-2/3 md:ml-auto "} ${
							!ht.toggleWidth && "md:ml-96 w-full"
						}transition-all duration-300 ease-linear flex flex-col flex-grow min-h-screen `,
						children: [
							jsx(Navigation, {}),
							jsxs("main", {
								className: "p-4 h-full transition-all duration-300 ease-in-out w-full",
								children: [
									jsxs("section", {
										className: "flex justify-between my-2 py-2 items-center",
										children: [
											jsx("header", {
												className: "font-bold text-3xl text-gray-50",
												children: ut == null ? void 0 : ut.title,
											}),
											jsxs("div", {
												className: "flex",
												children: [
													jsx(SettingsButton, { ide: mt, info: it, gui: ht, setGui: gt, startWalkThrough: vt }),
													jsx(StepSelectionDrawer, {
														title: it == null ? void 0 : it.tutorial_title,
														steps: st,
														current: ut == null ? void 0 : ut.id,
														handleOnClick: dt,
													}),
													jsx(Button, {
														colorScheme: "teal",
														onClick: et.onOpen,
														display: { base: "block", md: "none" },
														children: "Open",
													}),
												],
											}),
										],
									}),
									(ut == null ? void 0 : ut.id) < (st == null ? void 0 : st.length) &&
										ct &&
										jsx("div", {
											className: `${ht.isLongDescriptionShown && "h-csnap-text overflow-y-scroll"} ${
												!ht.isLongDescriptionShown && "h-csnap-normal overflow-y-scroll md:h-csnap-normal-md"
											} transition-all ease-out duration-500`,
											children: jsx(CSnap, {
												base: ct,
												coreList: it == null ? void 0 : it.core,
												whitelist: ut == null ? void 0 : ut.whitelist,
												modifiers: ut == null ? void 0 : ut.modifiers,
												globalModifiers: it == null ? void 0 : it.globalModifiers,
												ide: mt,
												setIde: pt,
												legacy: it == null ? void 0 : it.legacy,
											}),
										}),
									ht.isLongDescriptionShown &&
										jsxs(SlideFade, {
											in: ht.isLongDescriptionShown,
											offsetY: "20px",
											children: [
												jsxs(Box, {
													py: "30px",
													px: "40px",
													color: "white",
													mt: "4",
													bg: "gray.800",
													rounded: "md",
													shadow: "md",
													maxH: { base: "35vh", md: "25vh" },
													children: [
														jsx(Heading, { size: { base: "lg", md: "md" }, mb: 3, children: "Step Description" }),
														jsx(Box, {
															maxH: { base: "20vh", md: "15vh" },
															overflowY: "scroll",
															children: jsx(ReactMarkdown, {
																components: q$1(),
																children: ht.longDescription,
																skipHtml: !0,
															}),
														}),
													],
												}),
												" ",
											],
										}),
								],
							}),
							jsx(Footer, { tool: it == null ? void 0 : it.tool }),
						],
					}),
				],
			}),
		],
	});
}
function App() {
	const [_, et] = useSearchParams(),
		{ info: tt, data: nt, isLoading: rt } = FetchService.selectSet(_.get("name")),
		[it, ot] = react.exports.useState(null),
		[at, st] = react.exports.useState(null),
		[lt, ut] = react.exports.useState(null);
	return (
		react.exports.useEffect(() => {
			if (nt) {
				let dt = nt.slice(1).map((ct, ft) => ({ ...ct, id: ft }));
				ot(dt), st(dt[0]), ut(tt.prefix + tt.base);
			}
		}, [nt]),
		jsx(Fragment, { children: _.get("name") ? jsx(Tutorial, { name: _.get("name") }) : jsx(Homepage, {}) })
	);
}
const index = "",
	config = { initialColorMode: "dark", useSystemColorMode: !1 };
extendTheme({ config });
const steps = [
	{
		content: () =>
			jsx(Box, {
				children: jsx(Text$2, {
					color: "gray.800",
					children: "Welcome to the tutorial! Let's get familiar with the interface.",
				}),
			}),
	},
	{
		selector: ".second-step",
		content: () =>
			jsx(Box, {
				children: jsx(Text$2, {
					color: "gray.800",
					children: "This sidebar holds all the available information for the current step.",
				}),
			}),
	},
	{
		selector: ".third-step",
		content: () =>
			jsx(Box, {
				children: jsx(Text$2, {
					color: "gray.800",
					children: "You can advance to the next step, or go back to the previous step.",
				}),
			}),
	},
	{
		selector: ".fourth-step",
		content: () =>
			jsx(Box, {
				children: jsx(Text$2, {
					color: "gray.800",
					children: "You can also click on a specific step here, as well as track your progress.",
				}),
			}),
	},
	{
		selector: ".fifth-step",
		content: () =>
			jsx(Box, {
				children: jsx(Text$2, {
					color: "gray.800",
					children:
						"This is CSnap. You create your scripts here. Once finished, you click on the green flag to run your code.",
				}),
			}),
	},
	{
		selector: ".sixth-step",
		content: () =>
			jsx(Box, {
				children: jsx(Text$2, {
					color: "gray.800",
					children:
						"You can adjust the current tutorial with modifiers, found here. Or adjust the layout to make doing the tutorial easier.",
				}),
			}),
	},
	{
		selector: ".seventh-step",
		content: () =>
			jsx(Box, { children: jsx(Text$2, { color: "gray.800", children: "You can jump to a specific step here." }) }),
	},
	{
		selector: ".help-step",
		content: () =>
			jsx(Box, {
				children: jsx(Text$2, {
					color: "gray.800",
					children:
						"If you find yourself struggling with using CSnap, check out our help section here for more information.",
				}),
			}),
	},
	{
		content: ({ setIsOpen: _ }) =>
			jsxs(Box, {
				children: [
					jsx(Text$2, { color: "gray.800", children: "Finally, you are ready to begin." }),
					jsx(Button, { onClick: () => _((et) => !1), w: "100%", mt: 4, colorScheme: "blue", children: "End Tour" }),
				],
			}),
	},
];
client.createRoot(document.getElementById("root")).render(
	jsx(React$1.StrictMode, {
		children: jsx(BrowserRouter, {
			children: jsx(ChakraProvider, { children: jsx(TourProvider, { steps, children: jsx(App, {}) }) }),
		}),
	})
);
